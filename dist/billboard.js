(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-transition", "d3-brush", "d3-axis", "d3-scale", "d3-dsv", "d3-drag", "d3-zoom", "d3-ease", "d3-color", "d3-shape", "d3-interpolate"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__37__, __WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__42__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(32);
module.exports = __webpack_require__(49);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var _require = __webpack_require__(11),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(12),
  Html4Entities: __webpack_require__(13),
  Html5Entities: __webpack_require__(14),
  AllHtmlEntities: __webpack_require__(14)
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(33);
            var content = __webpack_require__(34);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(35);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused, .bb-circles.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step, .bb-circles.bb-focused path.bb-line, .bb-circles.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused, .bb-circles.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping, .bb-circles.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__36__;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__37__;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__42__;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(36);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(37);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(38);

// CONCATENATED MODULE: ./src/config/classes.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartCircles: "bb-chart-circles",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./src/config/Store.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var Store_state = function () {
  return {
    width: 0,
    width2: 0,
    height: 0,
    height2: 0,
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin2: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin3: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    arcWidth: 0,
    arcHeight: 0,
    currentWidth: 0,
    currentHeight: 0,
    // legend
    isLegendRight: !1,
    isLegendInset: !1,
    isLegendTop: !1,
    isLegendLeft: !1,
    legendStep: 0,
    legendItemWidth: 0,
    legendItemHeight: 0,
    legendHasRendered: !1,
    currentMaxTickWidths: {
      x: {
        size: 0,
        domain: ""
      },
      y: {
        size: 0,
        domain: ""
      },
      y2: {
        size: 0,
        domain: ""
      }
    },
    rotatedPadding: {
      left: 30,
      right: 0,
      top: 5
    },
    withoutFadeIn: {},
    inputType: "",
    datetimeId: "",
    // clip id string
    clip: {
      id: "",
      idXAxis: "",
      idYAxis: "",
      idGrid: "",
      idSubchart: "",
      // clipIdForSubchart
      path: "",
      pathXAxis: "",
      pathYAxis: "",
      pathGrid: ""
    },
    // status
    dragStart: null,
    dragging: !1,
    flowing: !1,
    cancelClick: !1,
    mouseover: !1,
    rendered: !1,
    transiting: !1,
    hasNegativeValue: !1,
    hasPositiveValue: !0,
    orgAreaOpacity: "0.2",
    // ID strings
    hiddenTargetIds: [],
    hiddenLegendIds: [],
    focusedTargetIds: [],
    defocusedTargetIds: [],
    // value for Arc
    radius: 0,
    innerRadius: 0,
    innerRadiusRatio: 0,
    gaugeArcWidth: 0,
    radiusExpanded: 0,
    // xgrid attribute
    xgridAttr: {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }
  };
};


// CONCATENATED MODULE: ./src/config/Options/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data config options
 */
/* harmony default export */ var data_data = ({
  /**
   * Converts data id value
   * @name dataidConverter
   * @memberof Options
   * @type {Function}
   * @default function(id) { return id; }
   * @example
   * data: {
   *    idConverter: function(id) {
   *       // when id is 'data1', converts to be 'data2'
   *       // 'data2' should be given as the initial data value
   *       if (id === "data1") {
   *          return "data2";
   *       } else {
   *          return id;
   *       }
   *    }
   * }
   */
  data_idConverter: function data_idConverter(id) {
    return id;
  },

  /**
   * Set custom data name.
   * @name datanames
   * @memberof Options
   * @type {Object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
   * @example
   * data: {
   *   names: {
   *     data1: "Data Name 1",
   *     data2: "Data Name 2"
   *   }
   * }
   */
  data_names: {},

  /**
   * Set custom data class.<br><br>
   * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
   * @name dataclasses
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   classes: {
   *     data1: "additional-data1-class",
   *     data2: "additional-data2-class"
   *   }
   * }
   */
  data_classes: {},

  /**
   * Set chart type at once.<br><br>
   * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
   * **Available Values:**
   * - area
   * - area-line-range
   * - area-spline
   * - area-spline-range
   * - area-step
   * - bar
   * - bubble
   * - donut
   * - gauge
   * - line
   * - pie
   * - radar
   * - scatter
   * - spline
   * - step
   * @name datatype
   * @memberof Options
   * @type {String}
   * @default line
   * @example
   * data: {
   *    type: "bar"
   * }
   */
  data_type: undefined,

  /**
   * Set chart type for each data.<br>
   * This setting overwrites data.type setting.
   * - **NOTE:** `radar` type can't be combined with other types.
   * @name datatypes
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   types: {
   *     data1: "bar",
   *     data2: "spline"
   *   }
   * }
   */
  data_types: {},

  /**
   *  This option changes the order of stacking data and pieces of pie/donut.
   *  - If `null` specified, it will be the order the data loaded.
   *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
   *
   *  **Available Values:**
   *  - `desc`: In descending order
   *  - `asc`: In ascending order
   *  - `null`: It keeps the data load order
   *  - `function(data1, data2) { ... }`: Array.sort compareFunction
   * @name dataorder
   * @memberof Options
   * @type {String|Function|null}
   * @default desc
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
   * @example
   * data: {
   *   // in descending order (default)
   *   order: "desc"
   *
   *   // in ascending order
   *   order: "asc"
   *
   *   // keeps data input order
   *   order: null
   *
   *   // specifying sort function
   *   order: function(a, b) {
   *       // param data passed format
   *       {
   *          id: "data1", id_org: "data1", values: [
   *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
   *              ...
   *          ]
   *       }
   *   }
   * }
   */
  data_order: "desc",

  /**
   * Set color converter function.<br><br>
   * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
   * @name datacolor
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
   * @example
   * data: {
   *   color: function(color, d) { ... }
   * }
   */
  data_color: undefined,

  /**
   * Set color for each data.
   * @name datacolors
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   colors: {
   *     data1: "#ff0000",
   *     data2: function(d) {
   *        return "#000";
   *     }
   *     ...
   *   }
   * }
   */
  data_colors: {},

  /**
   * Hide each data when the chart appears.<br><br>
   * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
   * @name datahide
   * @memberof Options
   * @type {Boolean|Array}
   * @default false
   * @example
   * data: {
   *   // all of data will be hidden
   *   hide: true
   *
   *   // specified data will be hidden
   *   hide: ["data1", ...]
   * }
   */
  data_hide: !1,

  /**
   * Filter values to be shown
   * The data value is the same as the returned by `.data()`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   * @name datafilter
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * data: {
   *   // filter for id value
   *   filter: function(v) {
   *      // v: [{id: "data1", id_org: "data1", values: [
   *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
   *      //    }, ...]
   *      return v.id !== "data1";
   *   }
   */
  data_filter: undefined,

  /**
   * Set a callback for click event on each data point.<br><br>
   * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
   * - `d` is the data clicked and element is the element clicked.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name dataonclick
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onclick: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onclick: function data_onclick() {},

  /**
   * Set a callback for mouse/touch over event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
   * - `d` is the data where mouse cursor moves onto.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name dataonover
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onover: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onover: function data_onover() {},

  /**
   * Set a callback for mouse/touch out event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
   * - `d` is the data where mouse cursor moves out.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name dataonout
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onout: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onout: function data_onout() {},

  /**
  * Set a callback for minimum data
  * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
  * @name dataonmin
  * @memberof Options
  * @type {Function}
  * @default undefined
  * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
  * @example
  *  onmin: function(data) {
  *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
  *    ...
  *  }
  */
  data_onmin: undefined,

  /**
   * Set a callback for maximum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name dataonmax
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmax: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmax: undefined,

  /**
   * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
   * @name dataurl
   * @memberof Options
   * @type {String}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
   * @example
   * data: {
   *     url: "/data/test.csv"
   * }
   */
  data_url: undefined,

  /**
   * XHR header value
   * - **NOTE:** Should be used with `data.url` option
   * @name dataheaders
   * @memberof Options
   * @type {String}
   * @default undefined
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
   * @example
   * data: {
   *     url: "/data/test.csv",
   *     headers: {
   *        "Content-Type": "text/xml",
   *        ...
   *     }
   * }
   */
  data_headers: undefined,

  /**
   * Parse a JSON object for data. See also data.keys.
   * @name datajson
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [datakeys](#.data%25E2%2580%25A4keys)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_json: undefined,

  /**
   * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
   * @name datarows
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
   * @example
   * data: {
   *   rows: [
   *     ["A", "B", "C"],
   *     [90, 120, 300],
   *     [40, 160, 240],
   *     [50, 200, 290],
   *     [120, 160, 230],
   *     [80, 130, 300],
   *     [90, 220, 320]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {high:150, mid: 140, low: 110}, 120
   *        [150, 140, 110], 120
   *      ],
   *      [[155, 130, 115], 55],
   *      [[160, 135, 120], 60]
   *   ],
   *   types: {
   *       data1: "area-line-range",
   *       data2: "line"
   *   }
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {y:10, z: 140}, 120
   *        [10, 140], 120
   *      ],
   *      [[100, 30], 55],
   *      [[50, 100], 60]
   *   ],
   *   types: {
   *       data1: "bubble",
   *       data2: "line"
   *   }
   * }
   */
  data_rows: undefined,

  /**
   * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
   * @name datacolumns
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
   * @example
   * data: {
   *   columns: [
   *      ["data1", 30, 20, 50, 40, 60, 50],
   *      ["data2", 200, 130, 90, 240, 130, 220],
   *      ["data3", 300, 200, 160, 400, 250, 250]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   columns: [
   *      ["data1",
   *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
   *          [150, 140, 110],
   *          [150, 140, 110]
   *      ]
   *   ],
   *   type: "area-line-range"
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   columns: [
   *      ["data1",
   *          [10, 140],  // or {y:10, z: 140}
   *          [100, 30],
   *          [50, 100]
   *      ]
   *   ],
   *   type: "bubble"
   * }
   */
  data_columns: undefined,

  /**
   * Used if loading JSON via data.url.
   * - **Available Values:**
   *   - json
   *   - csv
   *   - tsv
   * @name datamimeType
   * @memberof Options
   * @type {String}
   * @default csv
   * @example
   * data: {
   *     mimeType: "json"
   * }
   */
  data_mimeType: "csv",

  /**
   * Choose which JSON object keys correspond to desired data.
   * - **NOTE:** Only for JSON object given as array.
   * @name datakeys
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_keys: undefined,

  /**
   * Set text label to be displayed when there's no data to show.
   * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
   * @name dataemptylabeltext
   * @memberof Options
   * @type {String}
   * @default ""
   * @example
   * data: {
   *   empty: {
   *     label: {
   *       text: "No Data"
   *     }
   *   }
   * }
   */
  data_empty_label_text: ""
});
// CONCATENATED MODULE: ./src/config/Options/common/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * color config options
 */
/* harmony default export */ var common_color = ({
  /**
   * Set color of the data values
   * @name color
   * @memberof Options
   * @type {Object}
   * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
   * @property {Array} [color.pattern=[]] custom color pattern
   * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
   *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
   *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
   *    - `bb-colorize-pattern-red`
   *    - `bb-colorize-pattern-fff`
   * @property {Object} [color.threshold] color threshold for gauge and tooltip color
   * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
   * @property {Array} [color.threshold.values] Threshold values for each steps
   * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
   * @example
   *  color: {
   *      pattern: ["#1f77b4", "#aec7e8", ...],
   *
   *      // Set colors' patterns
   *      // it should return an array of SVGPatternElement
   *      tiles: function() {
   *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
   *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
   *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
   *
   *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
   *         pattern.setAttribute("width", "32");
   *         pattern.setAttribute("height", "32");
   *
   *         g.style.fill = "#000";
   *         g.style.opacity = "0.2";
   *
   *         circle1.setAttribute("cx", "3");
   *         circle1.setAttribute("cy", "3");
   *         circle1.setAttribute("r", "3");
   *
   *         g.appendChild(circle1);
   *         pattern.appendChild(g);
   *
   *         return [pattern];
   *      },
   *
   *      // for threshold usage, pattern values should be set for each steps
   *      pattern: ["grey", "green", "yellow", "orange", "red"],
   *      threshold: {
   *          unit: "value",
   *
   *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
   *          values: [10, 20, 30, 40, 50],
   *
   *          // the equation for max:
   *          // - unit == 'value': max => 30
   *          // - unit != 'value': max => value*100/30
   *          max: 30
   *      },
   *
   *      // set all data to 'red'
   *      onover: "red",
   *
   *      // set different color for data
   *      onover: {
   *          data1: "red",
   *          data2: "yellow"
   *      },
   *
   *      // will pass data object to the callback
   *      onover: function(d) {
   *          return d.id === "data1" ? "red" : "green";
   *      }
   *  }
   */
  color_pattern: [],
  color_tiles: undefined,
  color_threshold: {},
  color_onover: undefined
});
// CONCATENATED MODULE: ./src/config/Options/common/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * interaction config options
 */
/* harmony default export */ var interaction = ({
  /**
   * Interaction options
   * @name interaction
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
   *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
   * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
   * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
   * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
   * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
   * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
   * @example
   * interaction: {
   *    enabled: false,
   *    brighten: false,
   *    inputType: {
   *        mouse: true,
   *        touch: false
   *
   *        // or declare preventDefault explicitly.
   *        // In this case touch inputType is enabled by default
   *        touch: {
   *            preventDefault: true
   *
   *            // or threshold pixel value (pixel moved from touchstart to touchmove)
   *            preventDefault: 5
   *        }
   *    }
   * }
   */
  interaction_enabled: !0,
  interaction_brighten: !0,
  interaction_inputType_mouse: !0,
  interaction_inputType_touch: {}
});
// CONCATENATED MODULE: ./src/config/Options/common/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * legend config options
 */
/* harmony default export */ var common_legend = ({
  /**
   * Legend options
   * @name legend
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [legend.show=true] Show or hide legend.
   * @property {Boolean} [legend.hide=false] Hide legend
   *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
   * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
   * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
   *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
   *    - {=COLOR}: data color value
   *    - {=TITLE}: data title value
   *  - If set `function` value, will pass following arguments to the given function:
   *   - title {String}: data's id value
   *   - color {String}: color string
   *   - data {Array}: data array
   * @property {String} [legend.position=bottom] Change the position of legend.<br>
   *  Available values are: `bottom`, `right` and `inset` are supported.
   * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
   *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
   *  - **anchor** decides the position of the legend:
   *   - top-left
   *   - top-right
   *   - bottom-left
   *   - bottom-right
   *  - **x** and **y**:
   *   - set the position of the legend based on the anchor.
   *  - **step**:
   *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
   * @property {Boolean} [legend.equally=false] Set to all items have same width size.
   * @property {Boolean} [legend.padding=0] Set padding value
   * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
   * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
   * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
   * @property {Number} [legend.item.tile.width=10] Set width of item tile element
   * @property {Number} [legend.item.tile.height=10] Set height of item tile element
   * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
   * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
   * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
   * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
   * @example
   *  legend: {
   *      show: true,
   *      hide: true,
   *      //or hide: "data1"
   *      //or hide: ["data1", "data2"]
   *      contents: {
   *          bindto: "#legend",   // <ul id='legend'></ul>
   *
   *          // will be as: <li style='background-color:#1f77b4'>data1</li>
   *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
   *
   *          // or using function
   *          template: function(id, color, data) {
   *               // if you want omit some legend, return falsy value
   *               if (id !== "data1") {
   *                    return "<li style='background-color:"+ color +">"+ id +"</li>";
   *               }
   *          }
   *      },
   *      position: "bottom",  // bottom, right, inset
   *      inset: {
   *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
   *          x: 20,
   *          y: 10,
   *          step: 2
   *      },
   *      equally: false,
   *      padding: 10,
   *      item: {
   *          onclick: function(id) { ... },
   *          onover: function(id) { ... },
   *          onout: function(id) { ... },
   *
   *          // set tile's size
   *          tile: {
   *              width: 20,
   *              height: 15
   *          }
   *      },
   *      usePoint: true
   *  }
   */
  legend_show: !0,
  legend_hide: !1,
  legend_contents_bindto: undefined,
  legend_contents_template: undefined,
  legend_position: "bottom",
  legend_inset_anchor: "top-left",
  legend_inset_x: 10,
  legend_inset_y: 0,
  legend_inset_step: undefined,
  legend_item_onclick: undefined,
  legend_item_onover: undefined,
  legend_item_onout: undefined,
  legend_equally: !1,
  legend_padding: 0,
  legend_item_tile_width: 10,
  legend_item_tile_height: 10,
  legend_usePoint: !1
});
// CONCATENATED MODULE: ./src/config/Options/common/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * title config options
 */
/* harmony default export */ var common_title = ({
  /**
   * Set title options
   * @name title
   * @memberof Options
   * @type {Object}
   * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
   * @property {Number} [title.padding.top=0] Top padding value.
   * @property {Number} [title.padding.right=0] Right padding value.
   * @property {Number} [title.padding.bottom=0] Bottom padding value.
   * @property {Number} [title.padding.left=0] Left padding value.
   * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
   * @example
   *  title: {
   *      text: "Title Text",
   *
   *      // or Multiline title text
   *      text: "Main title text\nSub title text",
   *
   *      padding: {
   *          top: 10,
   *          right: 10,
   *          bottom: 10,
   *          left: 10
   *      },
   *      position: "center"
   *  }
   */
  title_text: undefined,
  title_padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  title_position: "center"
});
// CONCATENATED MODULE: ./src/config/Options/common/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * tooltip config options
 */
/* harmony default export */ var common_tooltip = ({
  /**
   * Tooltip options
   * @name tooltip
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
   * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
   * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
   *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
   * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
   * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
   * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
   *  Specified function receives x of the data point to show.
   * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   *  If undefined returned, the row of that value will be skipped.
   * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>
   *  This option can be used to modify the tooltip position by returning object that has top and left.
   * @property {String} [tooltip.position.unit="px"] Set tooltip's position unit.
   *  - **NOTE:** This option can't be used along with `tooltip.position` custom function. If want to specify unit in custom function, return value with desired unit.
   * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
   *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
   * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
   *  - **NOTE:** When is specified, will not be updating tooltip's position.
   * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
   *  Within template, below syntax will be replaced using template-like syntax string:
   *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
   *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
   *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
   *    - **{=TITLE}**: title value.
   *    - **{=COLOR}**: data color.
   *    - **{=VALUE}**: data value.
   * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
   *  - **NOTE:** It should contain `{ key: Array, ... }` value
   *    - 'key' name is used as substitution within template as '{=KEY}'
   *    - The value array length should match with the data length
   * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
   * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
   * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
   * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
   * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
   * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
   * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
   * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
   *  **Available Values:**
   *  - `desc`: In descending data value order
   *  - `asc`: In ascending data value order
   *  - `null`: It keeps the data display order<br>
   *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
   *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
   *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
   * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
   * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
   * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
   * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
   * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
   * @example
   *  tooltip: {
   *      show: true,
   *      doNotHide: true,
   *      grouped: false,
   *      format: {
   *          title: function(x) { return "Data " + x; },
   *          name: function(name, ratio, id, index) { return name; },
   *          value: function(value, ratio, id, index) { return ratio; }
   *      },
   *      position: function(data, width, height, element) {
   *          return {top: 0, left: 0}
   *      },
   *
   *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
   *          return ... // formatted html as you want
   *      },
   *
   *       // specify tooltip contents using template
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
   *      		'}}</ul>'
   *      }
   *
   *       // with additional text value
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	text: {
   *      		// a) 'key' name is used as substitution within template as '{=KEY}'
   *      		// b) the length should match with the data length
   *      		VAR1: ["text1", "text2"],
   *      		VAR2: ["comment1", "comment2"],
   *      	},
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
   *      		'}}</ul>'
   *      }
   *
   *      // sort tooltip data value display in ascending order
   *      order: "asc",
   *
   *      // specifying sort function
   *      order: function(a, b) {
   *         // param data passed format
   *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
   *           ...
   *      },
   *
   *      // show at the initialization
   *      init: {
   *          show: true,
   *          x: 2,
   *          position: {
   *              top: "150px",
   *              left: "250px"
   *          }
   *      },
   *
   *      // fires prior tooltip is shown
   *      onshow: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires prior tooltip is hidden
   *      onhide: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is shown
   *      onshown: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is hidden
   *      onhidden: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
   *      // Useful for timeseries correlation
   *      linked: true,
   *
   *      // Specify name to interact those with the same name only.
   *      linked: {
   *          name: "some-group"
   *      }
   *  }
   */
  tooltip_show: !0,
  tooltip_doNotHide: !1,
  tooltip_grouped: !0,
  tooltip_format_title: undefined,
  tooltip_format_name: undefined,
  tooltip_format_value: undefined,
  tooltip_position: undefined,
  tooltip_contents: {},
  tooltip_init_show: !1,
  tooltip_init_x: 0,
  tooltip_init_position: {
    top: "0px",
    left: "50px"
  },
  tooltip_linked: !1,
  tooltip_linked_name: "",
  tooltip_onshow: function tooltip_onshow() {},
  tooltip_onhide: function tooltip_onhide() {},
  tooltip_onshown: function tooltip_onshown() {},
  tooltip_onhidden: function tooltip_onhidden() {},
  tooltip_order: null
});
// CONCATENATED MODULE: ./src/config/Options/data/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Axis based chart data config options
 */
/* harmony default export */ var data_axis = ({
  /**
   * Specify the key of x values in the data.<br><br>
   * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
   * @name datax
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * data: {
   *   x: "date"
   * }
   */
  data_x: undefined,

  /**
   * Specify the keys of the x values for each data.<br><br>
   * This option can be used if we want to show the data that has different x values.
   * @name dataxs
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   xs: {
   *      data1: "x1",
   *      data2: "x2"
   *   }
   * }
   */
  data_xs: {},

  /**
   * Set a format specifier to parse string specifed as x.
   * @name dataxFormat
   * @memberof Options
   * @type {String}
   * @default %Y-%m-%d
   * @example
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "01012019", "02012019", "03012019"],
   *        ["data1", 30, 200, 100]
   *    ],
   *    // Format specifier to parse as datetime for given 'x' string value
   *    xFormat: "%m%d%Y"
   * },
   * axis: {
   *    x: {
   *        type: "timeseries"
   *    }
   * }
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   */
  data_xFormat: "%Y-%m-%d",

  /**
   * Set localtime format to parse x axis.
   * @name dataxLocaltime
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *   xLocaltime: false
   * }
   */
  data_xLocaltime: !0,

  /**
   * Sort on x axis.
   * @name dataxSort
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *   xSort: false
   * }
   */
  data_xSort: !0,

  /**
   * Set groups for the data for stacking.
   * @name datagroups
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * data: {
   *   groups: [
   *     ["data1", "data2"],
   *     ["data3"]
   *   ]
   * }
   */
  data_groups: [],

  /**
   * Set y axis the data related to. y and y2 can be used.
  * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @name dataaxes
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   axes: {
   *     data1: "y",
   *     data2: "y2"
   *   }
   * }
   */
  data_axes: {},

  /**
   * Set labels options
   * @name datalabels
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [data.labels=false] Show or hide labels on each data points
   * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
   * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
   * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
   *  - `v` is the value of the data point where the label is shown.
   *  - `id` is the id of the data where the label is shown.
   *  - `i` is the index of the data point where the label is shown.
   *  - `j` is the sub index of the data point where the label is shown.<br><br>
   * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
   * @property {String|Object} [data.labels.colors] Set label text colors.
   * @property {Object} [data.labels.position] Set each dataset position, relative the original.
   * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
   * @property {Number} [data.labels.position.y=0] y coordinate position, relative the original.
   * @memberof Options
   * @type {Object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
   * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
   * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
   * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
   * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
   * @example
   * data: {
   *   labels: true,
   *
   *   // or set specific options
   *   labels: {
   *     format: function(v, id, i, j) { ... },
   *
   *     // it's possible to set for each data
   *     format: {
   *         data1: function(v, id, i, j) { ... },
   *         ...
   *     },
   *
   *     // align text to center of the 'bar' shape (works only for 'bar' type)
   *     centered: true,
   *
   *     // apply for all label texts
   *     colors: "red",
   *
   *     // or set different colors per dataset
   *     // for not specified dataset, will have the default color value
   *     colors: {
   *        data1: "yellow",
   *        data3: "green"
   *     },
   *
   *     // set x, y coordinate position
   *     position: {
   *        x: -10,
   *        y: 10
   *     },
   *
   *     // or set x, y coordinate position by each dataset
   *     position: {
   *        data1: {x: 5, y: 5},
   *        data2: {x: 10, y: -20}
   *     }
   *   }
   * }
   */
  data_labels: {},
  data_labels_colors: undefined,
  data_labels_position: {},

  /**
   * Define regions for each data.<br>
   * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
   * - The object type should be as:
   *   - start {Number}: Start data point number. If not set, the start will be the first data point.
   *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
   *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
   * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
   * @name dataregions
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   regions: {
   *     data1: [{
   *         start: 1,
   *         end: 2,
   *         style: {
   *             dasharray: "5 2"
   *         }
   *     }, {
   *         start: 3
   *     }],
   *     ...
   *   }
   * }
   */
  data_regions: {},

  /**
   * Set the stacking to be normalized
   * - **NOTE:**
   *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
   *   - y Axis will be set in percentage value (0 ~ 100%)
   *   - Must have postive values
   * @name datastacknormalize
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
   * @example
   * data: {
   *   stack: {
   *      normalize: true
   *   }
   * }
   */
  data_stack_normalize: !1
});
// CONCATENATED MODULE: ./src/config/Options/data/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data.selection config options
 */
/* harmony default export */ var data_selection = ({
  /**
   * Set data selection enabled<br><br>
   * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
   * @name dataselectionenabled
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
   * @example
   * data: {
   *    selection: {
   *       enabled: true
   *    }
   * }
   */
  data_selection_enabled: !1,

  /**
   * Set grouped selection enabled.<br><br>
   * If this option set true, multiple data points that have same x value will be selected by one selection.
   * @name dataselectiongrouped
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       grouped: true
   *    }
   * }
   */
  data_selection_grouped: !1,

  /**
   * Set a callback for each data point to determine if it's selectable or not.<br><br>
   * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
   * @name dataselectionisselectable
   * @memberof Options
   * @type {Function}
   * @default function() { return true; }
   * @example
   * data: {
   *    selection: {
   *       isselectable: function(d) { ... }
   *    }
   * }
   */
  data_selection_isselectable: function data_selection_isselectable() {
    return !0;
  },

  /**
   * Set multiple data points selection enabled.<br><br>
   * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
   * @name dataselectionmultiple
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *    selection: {
   *       multiple: false
   *    }
   * }
   */
  data_selection_multiple: !0,

  /**
   * Enable to select data points by dragging.
   * If this option set true, data points can be selected by dragging.
   * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
   * @name dataselectiondraggable
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       draggable: true
   *   }
   * }
   */
  data_selection_draggable: !1,

  /**
   * Set a callback for on data selection.
   * @name dataonselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onselected: function data_onselected() {},

  /**
   * Set a callback for on data un-selection.
   * @name dataonunselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onunselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onunselected: function data_onunselected() {}
});
// CONCATENATED MODULE: ./src/config/Options/axis/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var axis_x = ({
  /**
   * Set clip-path attribute for x axis element
   * @name axisxclipPath
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo]()
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_x_clipPath: !0,

  /**
   * Show or hide x axis.
   * @name axisxshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     show: false
   *   }
   * }
   */
  axis_x_show: !0,

  /**
   * Set type of x axis.<br><br>
   * **Available Values:**
   * - timeseries
   * - category
   * - indexed
   * @name axisxtype
   * @memberof Options
   * @type {String}
   * @default indexed
   * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
   * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
   * @example
   * axis: {
   *   x: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_x_type: "indexed",

  /**
   * Set how to treat the timezone of x values.<br>
   * If true, treat x value as localtime. If false, convert to UTC internally.
   * @name axisxlocaltime
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     localtime: false
   *   }
   * }
   */
  axis_x_localtime: !0,

  /**
   * Set category names on category axis.
   * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @name axisxcategories
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * axis: {
   *   x: {
   *     categories: ["Category 1", "Category 2", ...]
   *   }
   * }
   */
  axis_x_categories: [],

  /**
   * centerize ticks on category axis.
   * @name axisxtickcentered
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       centered: true
   *     }
   *   }
   * }
   */
  axis_x_tick_centered: !1,

  /**
   * A function to format tick value. Format string is also available for timeseries data.
   * @name axisxtickformat
   * @memberof Options
   * @type {Function|String}
   * @default undefined
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *        // for timeseries, a 'datetime' object is given as parameter
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *
   *       // for category, index(Number) and categoryName(String) are given as parameter
   *       format: function(index, categoryName) {
   *           return categoryName.substr(0, 10);
   *       },
   *
   *        // for timeseries format specifier
   *        format: "%Y-%m-%d %H:%M:%S"
   *     }
   *   }
   * }
   */
  axis_x_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.x.tick.culling.max.
   * @name axisxtickculling
   * @memberof Options
   * @type {Boolean}
   * @default
   * - true for indexed axis and timeseries axis
   * - false for category axis
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_x_tick_culling: {},

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axisxtickcullingmax
   * @memberof Options
   * @type {Number}
   * @default 10
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_culling_max: 10,

  /**
   * The number of x axis ticks to show.<br><br>
   * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
   * @name axisxtickcount
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_x_tick_count: undefined,

  /**
   * Show or hide x axis tick line.
   * @name axisxtickshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_x_tick_show: !0,

  /**
   * Show or hide x axis tick text.
   * @name axisxticktextshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_show: !0,

  /**
   * Set the x Axis tick text's position relatively its original position
   * @name axisxticktextposition
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Fit x axis ticks.
   * - **true**: ticks will be positioned nicely to have same intervals.
   * - **false**: ticks will be positioned according to x value of the data points.
   * @name axisxtickfit
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
   * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       fit: false
   *     }
   *   }
   * }
   */
  axis_x_tick_fit: !0,

  /**
   * Set the x values of ticks manually.<br><br>
   * If this option is provided, the position of the ticks will be determined based on those values.<br>
   * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
   * @name axisxtickvalues
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       values: [1, 2, 4, 8, 16, 32, ...],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_values: null,

  /**
   * Rotate x axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
   * @name axisxtickrotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_x_tick_rotate: 0,

  /**
   * Show x axis outer tick.
   * @name axisxtickouter
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_x_tick_outer: !0,

  /**
   * Set tick text to be multiline
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
   * @name axisxtickmultiline
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       multiline: false
   *     }
   *   }
   * }
   * @example
   * // example of line break with '\n'
   * // In this case, 'axis.x.tick.width' is ignored
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "long\ntext", "Another\nLong\nText"],
   *        ...
   *    ],
   * }
   */
  axis_x_tick_multiline: !0,

  /**
   * Set tick width
   * - **NOTE:**
   *  > When x tick text contains `\n`, this option is ignored.
   * @name axisxtickwidth
   * @memberof Options
   * @type {Number}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       width: 50
   *     }
   *   }
   * }
   */
  axis_x_tick_width: null,

  /**
   * Set to display system tooltip(via 'title' attribute) for tick text
   * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
   * @name axisxticktooltip
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       tooltip: true
   *     }
   *   }
   * }
   */
  axis_x_tick_tooltip: !1,

  /**
   * Set max value of x axis range.
   * @name axisxmax
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     max: 100
   *   }
   * }
   */
  axis_x_max: undefined,

  /**
   * Set min value of x axis range.
   * @name axisxmin
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     min: -100
   *   }
   * }
   */
  axis_x_min: undefined,

  /**
   * Set padding for x axis.<br><br>
   * If this option is set, the range of x axis will increase/decrease according to the values.
   * If no padding is needed in the rage of x axis, 0 should be set.
   * - **NOTE:**
   *   The padding values aren't based on pixels. It differs according axis types<br>
   *   - **category:** The unit of tick value
   *     ex. the given value `1`, is same as the width of 1 tick width
   *   - **timeseries:** Numeric time value
   *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
   * @name axisxpadding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   x: {
   *     padding: {
   *       // when axis type is 'category'
   *       left: 1,  // set left padding width of equivalent value of a tick's width
   *       right: 0.5  // set right padding width as half of equivalent value of tick's width
   *
   *       // when axis type is 'timeseries'
   *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
   *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_x_padding: {},

  /**
   * Set height of x axis.<br><br>
   * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
   * @name axisxheight
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     height: 20
   *   }
   * }
   */
  axis_x_height: undefined,

  /**
   * Set default extent for subchart and zoom. This can be an array or function that returns an array.
   * @name axisxextent
   * @memberof Options
   * @type {Array|Function}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     // extent range as a pixel value
   *     extent: [0, 200],
   *
   *     // when axis is 'timeseries', parsable datetime string
   *     extent: ["2019-03-01", "2019-03-05"],
   *
   *     // return extent value
   *     extent: function(domain, scale) {
   *    	 var extent = domain.map(function(v) {
   *     	    return scale(v);
   *     	 });
   *
   *   	 // it should return a format of array
   *   	 // ex) [0, 584]
   *     	 return extent;
   *     }
   *   }
   * }
   */
  axis_x_extent: undefined,

  /**
   * Set label on x axis.<br><br>
   * You can set x axis label and change its position by this option.
   * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
   * Available position differs according to the axis direction (vertical or horizontal).
   * If string set, the position will be the default.
   *
   *  - **If it's horizontal axis:**
   *    - inner-right [default]
   *    - inner-center
   *    - inner-left
   *    - outer-right
   *    - outer-center
   *    - outer-left
   *  - **If it's vertical axis:**
   *    - inner-top [default]
   *    - inner-middle
   *    - inner-bottom
   *    - outer-top
   *    - outer-middle
   *    - outer-bottom
   * @name axisxlabel
   * @memberof Options
   * @type {String|Object}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     label: "Your X Axis"
   *   }
   * }
   *
   * axis: {
   *   x: {
   *     label: {
   *        text: "Your X Axis",
   *        position: "outer-center"
   *     }
   *   }
   * }
   */
  axis_x_label: {},

  /**
   * Set additional axes for x Axis.
   * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axisxaxes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * x: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main x Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_x_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y Axis  config options
 */
/* harmony default export */ var axis_y = ({
  /**
   * Set clip-path attribute for y axis element
   * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
   * @name axisyclipPath
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_y_clipPath: !0,

  /**
   * Show or hide y axis.
   * @name axisyshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     show: false
   *   }
   * }
   */
  axis_y_show: !0,

  /**
   * Set type of y axis.<br><br>
   * **Available Values:**
   *   - timeseries
   *   - category
   *   - indexed
   * @name axisytype
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_y_type: undefined,

  /**
   * Set max value of y axis.
   * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axisymax
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     max: 1000
   *   }
   * }
   */
  axis_y_max: undefined,

  /**
   * Set min value of y axis.
   * - **NOTE:**
   *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axisymin
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     min: 1000
   *   }
   * }
   */
  axis_y_min: undefined,

  /**
   * Change the direction of y axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axisyinverted
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inverted: true
   *   }
   * }
   */
  axis_y_inverted: !1,

  /**
   * Set center value of y axis.
   * @name axisycenter
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     center: 0
   *   }
   * }
   */
  axis_y_center: undefined,

  /**
   * Show y axis inside of the chart.
   * @name axisyinner
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inner: true
   *   }
   * }
   */
  axis_y_inner: !1,

  /**
   * Set label on y axis.<br><br>
   * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axisylabel
   * @memberof Options
   * @type {String|Object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y: {
   *     label: "Your Y Axis"
   *   }
   * }
   *
   * axis: {
   *   y: {
   *     label: {
   *        text: "Your Y Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y_label: {},

  /**
   * Set formatter for y axis tick text.<br><br>
   * This option accepts d3.format object as well as a function you define.
   * @name axisytickformat
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axisytickculling
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axisytickcullingmax
   * @memberof Options
   * @type {Number}
   * @default 5
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_culling_max: 5,

  /**
   * Show y axis outer tick.
   * @name axisytickouter
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y_tick_outer: !0,

  /**
   * Set y axis tick values manually.
   * @name axisytickvalues
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_values: null,

  /**
   * Rotate y axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axisytickrotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y_tick_rotate: 0,

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axisytickcount
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y_tick_count: undefined,

  /**
   * Show or hide y axis tick line.
   * @name axisytickshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
   * @name axisytickstepSize
   * @memberof Options
   * @type {Number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y_tick_stepSize: null,

  /**
  * Show or hide y axis tick text.
  * @name axisyticktextshow
  * @memberof Options
  * @type {Boolean}
  * @default true
  * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
  * @example
  * axis: {
  *   y: {
  *     tick: {
  *       text: {
  *           show: false
  *       }
  *     }
  *   }
  * }
  */
  axis_y_tick_text_show: !0,

  /**
   * Set the y Axis tick text's position relatively its original position
   * @name axisyticktextposition
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axisyticktime
   * @memberof Options
   * @private
   * @type {Object}
   * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       time: {
   *          // ticks at 15-minute intervals
   *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
   *          value: d3.timeMinute.every(15)
   *       }
   *     }
   *   }
   * }
   */
  // @TODO: not fully implemented yet
  axis_y_tick_time_value: undefined,

  /**
   * Set padding for y axis.<br><br>
   * You can set padding for y axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axisypadding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   y: {
   *     padding: {
   *       top: 0,
   *       bottom: 0
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_y_padding: {},

  /**
   * Set default range of y axis.<br><br>
   * This option set the default value for y axis when there is no data on init.
   * @name axisydefault
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y_default: undefined,

  /**
   * Set additional axes for y Axis.
   * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axisyaxes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y2.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y2 Axis  config options
 */
/* harmony default export */ var axis_y2 = ({
  /**
   * Show or hide y2 axis.
   * - **NOTE**:
   *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
   *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
   * @name axisy2show
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     show: true
   *   }
   * }
   */
  axis_y2_show: !1,

  /**
   * Set max value of y2 axis.
   * @name axisy2max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     max: 1000
   *   }
   * }
   */
  axis_y2_max: undefined,

  /**
   * Set min value of y2 axis.
   * @name axisy2min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     min: -1000
   *   }
   * }
   */
  axis_y2_min: undefined,

  /**
   * Change the direction of y2 axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axisy2inverted
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inverted: true
   *   }
   * }
   */
  axis_y2_inverted: !1,

  /**
   * Set center value of y2 axis.
   * @name axisy2center
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     center: 0
   *   }
   * }
   */
  axis_y2_center: undefined,

  /**
   * Show y2 axis inside of the chart.
   * @name axisy2inner
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inner: true
   *   }
   * }
   */
  axis_y2_inner: !1,

  /**
   * Set label on y2 axis.<br><br>
   * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axisy2label
   * @memberof Options
   * @type {String|Object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y2: {
   *     label: "Your Y2 Axis"
   *   }
   * }
   *
   * axis: {
   *   y2: {
   *     label: {
   *        text: "Your Y2 Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y2_label: {},

  /**
   * Set formatter for y2 axis tick text.<br><br>
   * This option works in the same way as axis.y.format.
   * @name axisy2tickformat
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       format: d3.format("$,")
   *       //or format: function(d) { return "$" + d; }
   *     }
   *   }
   * }
   */
  axis_y2_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axisy2tickculling
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axisy2tickcullingmax
   * @memberof Options
   * @type {Number}
   * @default 5
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling_max: 5,

  /**
   * Show or hide y2 axis outer tick.
   * @name axisy2tickouter
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_outer: !0,

  /**
   * Set y2 axis tick values manually.
   * @name axisy2tickvalues
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_values: null,

  /**
   * Rotate y2 axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axisy2tickrotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y2_tick_rotate: 0,

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axisy2tickcount
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y2_tick_count: undefined,

  /**
   * Show or hide y2 axis tick line.
   * @name axisy2tickshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
   * @name axisy2tickstepSize
   * @memberof Options
   * @type {Number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y2_tick_stepSize: null,

  /**
   * Show or hide y2 axis tick text.
   * @name axisy2ticktextshow
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_show: !0,

  /**
   * Set the y2 Axis tick text's position relatively its original position
   * @name axisy2ticktextposition
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axisy2padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   y2: {
   *     padding: {
   *       top: 100,
   *       bottom: 100
   *     }
   *
   *     // or set both values at once.
   *     padding: 10
   * }
   */
  axis_y2_padding: {},

  /**
   * Set default range of y2 axis.<br><br>
   * This option set the default value for y2 axis when there is no data on init.
   * @name axisy2default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y2_default: undefined,

  /**
   * Set additional axes for y2 Axis.
   * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axisy2axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y2: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y2 Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y2_axes: []
});
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(39);

// CONCATENATED MODULE: ./src/module/browser.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */


var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */
// CONCATENATED MODULE: ./src/module/util.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */






var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof v === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return Array.isArray(arr);
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
};

function getOption(options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
}

function util_hasValue(dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
}
/**
 * Call function with arguments
 * @param {Function} fn Function to be called
 * @param {*} args Arguments
 * @return {Boolean} true: fn is function, false: fn is not function
 * @private
 */


function callFn(fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
}
/**
 * Replace tag sign to html entity
 * @param {String} str
 * @return {String}
 * @private
 */


function sanitise(str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
}
/**
 * Set text value. If there's multiline add nodes.
 * @param {d3Selection} node Text node
 * @param {String} text Text value string
 * @param {Array} dy dy value for multilined text
 * @param {Boolean} toMiddle To be alingned vertically middle
 * @private
 */


function setTextValue(node, text, dy, toMiddle) {
  if (dy === void 0 && (dy = [-1, 1]), toMiddle === void 0 && (toMiddle = !1), node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", (i === 0 ? dy[0] * len : dy[1]) + "em").text(v);
      });
    }
  }
} // substitution of SVGPathSeg API polyfill


function getRectSegList(path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
}

function getPathBox(path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
} // return brush selection array


function getBrushSelection(_ref) {
  var selection,
      $el = _ref.$el,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = $el.subchart.main || $el.main;
  return event && event.type === "brush" ? selection = event.selection : main && (selection = main.select("." + config_classes.brush).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
} // Get boundingClientRect. cache the evaluated value once it was called.


var getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
}; // retrun random number


function getRandom(asStr) {
  asStr === void 0 && (asStr = !0);
  var rand = Math.random();
  return asStr ? rand + "" : rand;
}

function brushEmpty(ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
}

function extend(target, source) {
  // exclude name with only numbers
  for (var p in target === void 0 && (target = {}), isArray(source) && source.forEach(function (v) {
    return extend(target, v);
  }), source) /^\d+$/.test(p) || (target[p] = source[p]);

  return target;
}
/**
 * Return first letter capitalized
 * @param {String} str
 * @return {String} capitalized string
 * @private
 */


var capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
};
/**
 * Convert to array
 * @param {Object} v
 * @returns {Array}
 * @private
 */


/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
function getCssRules(styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
    }
  }), rules;
}
/**
 * Gets the SVGMatrix of an SVGElement
 * @param {SVGElement} element
 * @return {SVGMatrix} matrix
 * @private
 */


function getTranslation(node) {
  var transform = node ? node.transform : null,
      baseVal = transform ? transform.baseVal : [];
  return baseVal.length ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
}
/**
 * Get unique value from array
 * @param {Array} data
 * @return {Array} Unique array value
 * @private
 */


function getUnique(data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
}
/**
 * Merge array
 * @param {Array} arr
 * @return {Array}
 * @private
 */


function mergeArray(arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
}
/**
 * Merge object returning new object
 * @param {Object} target
 * @param {Object} objectN
 * @returns {Object} merged target object
 * @private
 */


function mergeObj(target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}
/**
 * Sort value
 * @param {Array} data value to be sorted
 * @param {Boolean} isAsc true: asc, false: desc
 * @return {Number|String|Date} sorted date
 * @private
 */


function util_sortValue(data, isAsc) {
  isAsc === void 0 && (isAsc = !0);
  var fn;
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
}
/**
 * Get min/max value
 * @param {String} type 'min' or 'max'
 * @param {Array} data Array data value
 * @retun {Number|Date|undefined}
 * @private
 */


function getMinMax(type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, res) : res[0] instanceof Date && (res = util_sortValue(res, type === "min")[0]) : res = undefined, res;
}
/**
 * Get range
 * @param {Number} start Start number
 * @param {Number} end End number
 * @return {Array}
 * @private
 */


function getRange(start, end) {
  var res = [];

  for (var i = start; i < end; i++) res.push(i);

  return res;
} // emulate event


var emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType, params) {
        params === void 0 && (params = getParams()), el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType, params) {
        params === void 0 && (params = getParams());
        var mouseEvent = browser_doc.createEvent("MouseEvent"); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
};
/**
 * Process the template  & return bound string
 * @param {String} tpl Template string
 * @param {Object} data Data value to be replaced
 * @return {String}
 * @private
 */

function tplProcess(tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=" + x + "}", "g"), data[x]);

  return res;
}
/**
 * Get parsed date value
 * (It must be called in 'ChartInternal' context)
 * @param {Date|String|Number} date Value of date to be parsed
 * @return {Date}
 * @private
 */


function parseDate(date) {
  var parsedDate;
  if (date instanceof Date) parsedDate = date;else if (isString(date)) {
    var config = this.config,
        format = this.format;
    parsedDate = format.dataTime(config.data_xFormat)(date);
  } else isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date));
  return (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
}
/**
 * Return if the current doc is visible or not
 * @return {boolean}
 * @private
 */


function isTabVisible() {
  return !browser_doc.hidden;
}
/**
 * Get the current input type
 * @return {String} "mouse" | "touch" | null
 * @private
 */


function convertInputType(mouse, touch) {
  var isMobile = !1; // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop

  if (/Mobi/.test(win.navigator.userAgent) && touch) {
    // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
    var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
        hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
    // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

    isMobile = hasTouchPoints || hasTouch;
  }

  var hasMouse = !(!mouse || isMobile) && "onmouseover" in win;
  return hasMouse && "mouse" || isMobile && "touch" || null;
}
// CONCATENATED MODULE: ./src/config/Options/axis/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
* y Axis  config options
*/

/* harmony default export */ var axis_axis = (mergeObj({
  /**
   * Switch x and y axis position.
   * @name axisrotated
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   rotated: true
   * }
   */
  axis_rotated: !1
}, axis_x, axis_y, axis_y2));
// CONCATENATED MODULE: ./src/config/Options/common/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * grid config options
 */
/* harmony default export */ var common_grid = ({
  /**
   * Set related options
   * @name grid
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
   * @property {Boolean} [x.show=false] Show grids along x axis.
   * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
   *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
   *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
   * @property {Boolean} [y.show=false] Show grids along x axis.
   * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
   *  This option accepts array including object that has value, text, position and class.
   * @property {Number} [y.ticks=10] Number of y grids to be shown.
   * @property {Boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {Boolean} [focus.show=true] Show grid line when focus.
   * @property {Boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
   * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
   * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
   * @example
   * grid: {
   *   x: {
   *     show: true,
   *     lines: [
   *       {value: 2, text: "Label on 2"},
   *       {value: 5, text: "Label on 5", class: "label-5"},
   *       {value: 6, text: "Label on 6", position: "start"}
   *     ]
   *   },
   *   y: {
   *     show: true,
   *     lines: [
   *       {value: 100, text: "Label on 100"},
   *       {value: 200, text: "Label on 200", class: "label-200"},
   *       {value: 300, text: "Label on 300", position: 'middle'}
   *     ],
   *     ticks: 5
   *   },
   *   front: true,
   *   focus: {
   *      show: false,
   *
   *      // Below options are available when 'tooltip.grouped=false' option is set
   *      edge: true,
   *      y: true
   *   },
   *   lines: {
   *      front: false
   *   }
   * }
   */
  grid_x_show: !1,
  grid_x_type: "tick",
  grid_x_lines: [],
  grid_y_show: !1,
  grid_y_lines: [],
  grid_y_ticks: 10,
  grid_focus_edge: !1,
  grid_focus_show: !0,
  grid_focus_y: !1,
  grid_front: !1,
  grid_lines_front: !0
});
// CONCATENATED MODULE: ./src/config/Options/common/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * point config options
 */
/* harmony default export */ var common_point = ({
  /**
   * Set point options
   * @name point
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [point.show=true] Whether to show each point in line.
   * @property {Number|Function} [point.r=2.5] The radius size of each point.
   *  - **NOTE:** Disabled for 'bubble' type
   * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
   * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
   *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
   * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
   * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
   * @property {String} [point.type="circle"] The type of point to be drawn
   * - **NOTE:**
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
   * - **NOTE:**
   *   - This is an `experimental` feature and can have some unexpected behaviors.
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   *   - svg shape tag interpreted as string<br>
   *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
   * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
   * @example
   *  point: {
   *      show: false,
   *      r: 5,
   *
   *      // or customize the radius
   *      r: function(d) {
   *          ...
   *          return r;
   *      },
   *
   *      focus: {
   *          expand: {
   *              enabled: true,
   *              r: 1
   *          }
   *      },
   *      select: {
   *          r: 3
   *      },
   *
   *      // having lower value, means how closer to be for interaction
   *      sensitivity: 3,
   *
   *      // valid values are "circle" or "rectangle"
   *      type: "rectangle",
   *
   *      // or indicate as pattern
   *      pattern: [
   *        "circle",
   *        "rectangle",
   *        "<polygon points='0 6 4 0 -4 0'></polygon>"
   *     ],
   *  }
   */
  point_show: !0,
  point_r: 2.5,
  point_sensitivity: 10,
  point_focus_expand_enabled: !0,
  point_focus_expand_r: undefined,
  point_pattern: [],
  point_select_r: undefined,
  point_type: "circle"
});
// CONCATENATED MODULE: ./src/config/Options/common/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var common_subchart = ({
  /**
   * Set subchart options
   * @name subchart
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
   * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
   * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
   * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
   * @property {Number} [subchart.size.height] Change the height of the subchart.
   * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
   *  Specified function receives the current zoomed x domain.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
   * @example
   *  subchart: {
   *      axis: {
   *      	x: {
   *      	  show: true,
   *      	    tick: {
   *      	      show: true,
   *      	      text: {
   *      	        show: false
   *      	      }
   *      	    }
   *      	}
   *      },
   *      show: true,
   *      size: {
   *          height: 20
   *      },
   *      onbrush: function(domain) { ... }
   *  }
   */
  subchart_show: !1,
  subchart_size_height: 60,
  subchart_axis_x_show: !0,
  subchart_axis_x_tick_show: !0,
  subchart_axis_x_tick_text_show: !0,
  subchart_onbrush: function subchart_onbrush() {}
});
// CONCATENATED MODULE: ./src/config/Options/common/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * zoom config options
 */
/* harmony default export */ var common_zoom = ({
  /**
   * Set zoom options
   * @name zoom
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [zoom.enabled=false] Enable zooming.
   * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
   *  - **Available types:**
   *    - wheel
   *    - drag
   * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
   *  If true set, y domain will be updated according to the zoomed region.
   * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
   * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
   * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
   * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
   *  Specified function receives the zoom event.
   * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
   *  Specified function receives the zoomed domain.
   * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
   *  Specified function receives the zoomed domain.
   * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
   * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
   * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
   * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
   * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
   * @example
   *  zoom: {
   *      enabled: {
   *          type: "drag"
   *      },
   *      rescale: true,
   *      extent: [1, 100]  // enable more zooming
   *      x: {
   *          min: -1,  // set min range
   *          max: 10  // set max range
   *      },
   *      onzoomstart: function(event) { ... },
   *      onzoom: function(domain) { ... },
   *      onzoomend: function(domain) { ... },
   *
   *      // show reset button when is zoomed-in
   *      resetButton: true,
   *
   *      resetButton: {
   *          // onclick callback when reset button is clicked
   *          onclick: function(button) {
   *            button; // Reset button element reference
   *            ...
   *          },
   *
   *          // customized text value for reset zoom button
   *          text: "Unzoom"
   *      }
   *  }
   */
  zoom_enabled: undefined,
  zoom_extent: undefined,
  zoom_privileged: !1,
  zoom_rescale: !1,
  zoom_onzoom: undefined,
  zoom_onzoomstart: undefined,
  zoom_onzoomend: undefined,
  zoom_resetButton: !0,
  zoom_x_min: undefined,
  zoom_x_max: undefined
});
// CONCATENATED MODULE: ./src/config/Options/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * area config options
 */
/* harmony default export */ var shape_area = ({
  /**
   * Set area options
   * @name area
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
   * @property {Boolean} [area.above=false] Set background area above the data chart line.
   * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
   * Or customize by giving below object value:
   *  - x {Array}: `x1`, `x2` value
   *  - y {Array}: `y1`, `y2` value
   *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
   * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
   * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
   * @example
   *  area: {
   *      zerobased: false,
   *      above: true,
   *
   *      // will generate follwing linearGradient:
   *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
   *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
   *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
   *      // </linearGradient>
   *      linearGradient: true,
   *
   *      // Or customized gradient
   *      linearGradient: {
   *      	x: [0, 0],  // x1, x2 attributes
   *      	y: [0, 0],  // y1, y2 attributes
   *      	stops: [
   *      	  // offset, stop-color, stop-opacity
   *      	  [0, "#7cb5ec", 1],
   *
   *      	  // setting 'null' for stop-color, will set its original data color
   *      	  [0.5, null, 0],
   *
   *      	  // setting 'function' for stop-color, will pass data id as argument.
   *      	  // It should return color string or null value
   *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
   *      	]
   *      }
   *  }
   */
  area_zerobased: !0,
  area_above: !1,
  area_linearGradient: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bar config options
 */
/* harmony default export */ var shape_bar = ({
  /**
   * Set bar options
   * @name bar
   * @memberof Options
   * @type {Object}
   * @property {Number} [bar.padding=0] The padding pixel value between each bar.
   * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
   * - **NOTE:** Works only for non-stacked bar
   * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
   * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
   * @property {Number} [bar.width] Change the width of bar chart.
   * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
   * @property {Number} [bar.width.max] The maximum width value for ratio.
   * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
   * - **NOTE:**
   *   - Works only for non-stacked bar
   *   - Bars are centered accoding its total width value
   * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
   * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
   * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
   * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
   * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
   * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
   * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
   * @example
   *  bar: {
   *      padding: 1,
   *
   *      // the 'radius' option can be used only for non-stacking bars
   *      radius: 10,
   *      // or
   *      radius: {
   *          ratio: 0.5
   *      }
   *
   *      // will not have offset between each bar elements for interaction
   *      sensitivity: 0,
   *
   *      width: 10,
   *
   *      // or
   *      width: {
   *          ratio: 0.2,
   *          max: 20
   *      },
   *
   *      // or specify width per dataset
   *      width: {
   *          data1: 20,
   *          data2: {
   *              ratio: 0.2,
   *              max: 20
   *          }
   *      },
   *
   *      zerobased: false
   *  }
   */
  bar_padding: 0,
  bar_radius: undefined,
  bar_radius_ratio: undefined,
  bar_sensitivity: 2,
  bar_width: undefined,
  bar_width_ratio: .6,
  bar_width_max: undefined,
  bar_zerobased: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bubble config options
 */
/* harmony default export */ var bubble = ({
  /**
   * Set bubble options
   * @name bubble
   * @memberof Options
   * @type {Object}
   * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
   * @property {Boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
   * @example
   *  bubble: {
   *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
   *      // And the lesser will have radius relatively from tha max value.
   *      maxR: 50,
   *
   *      // or set radius callback
   *      maxR: function(d) {
   *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
   *          ...
   *          return Math.sqrt(d.value * 2);
   *      },
   *      zerobased: false
   *  }
   */
  bubble_maxR: 35,
  bubble_zerobased: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * line config options
 */
/* harmony default export */ var shape_line = ({
  /**
   * Set line options
   * @name line
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
   *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
   * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
   * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
   * **Available values:**
   * - step
   * - step-before
   * - step-after
   * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
   * @property {Boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
   * @example
   *  line: {
   *      connectNull: true,
   *      classes: [
   *          "line-class1",
   *          "line-class2"
   *      ],
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  line_connectNull: !1,
  line_step_type: "step",
  line_zerobased: !1,
  line_classes: undefined,
  line_point: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/spline.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var spline = ({
  /**
   * Set spline options
   * - **Available interpolation type values:**
   *  - basis (d3.curveBasis)
   *  - basis-closed (d3.curveBasisClosed)
   *  - basis-open (d3.curveBasisOpen)
   *  - bundle (d3.curveBundle)
   *  - cardinal (d3.curveCardinal)
   *  - cardinal-closed (d3.curveCardinalClosed)
   *  - cardinal-open (d3.curveCardinalOpen)
   *  - catmull-rom (d3.curveCatmullRom)
   *  - catmull-rom-closed (d3.curveCatmullRomClosed)
   *  - catmull-rom-open (d3.curveCatmullRomOpen)
   *  - monotone-x (d3.curveMonotoneX)
   *  - monotone-y (d3.curveMonotoneY)
   *  - natural (d3.curveNatural)
   *  - linear-closed (d3.curveLinearClosed)
   *  - linear (d3.curveLinear)
   *  - step (d3.curveStep)
   *  - step-after (d3.curveStepAfter)
   *  - step-before (d3.curveStepBefore)
   * @name spline
   * @memberof Options
   * @type {Object}
   * @property {String} [spline.interpolation.type="cardinal"]
   * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
   * @example
   *  spline: {
   *      interpolation: {
   *          type: "cardinal"
   *      }
   *  }
   */
  spline_interpolation_type: "cardinal"
});
// CONCATENATED MODULE: ./src/config/Options/shape/donut.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * donut config options
 */
/* harmony default export */ var donut = ({
  /**
   * Set donut options
   * @name donut
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
   * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
   * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
   * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
   * @property {Number} [donut.expand.rate=0.98] Set expand rate.
   * @property {Number} [donut.expand.duration=50] Set expand transition time in ms.
   * @property {Number} [donut.width] Set width of donut chart.
   * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
   * @property {Number} [donut.padAngle=0] Set padding between data.
   * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  donut: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *          	...
   *          	return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      width: 10,
   *      padAngle: 0.2,
   *      startingAngle: 1,
   *      title: "Donut Title"
   *
   *      // title with line break
   *      title: "Title1\nTitle2"
   *  }
   */
  donut_label_show: !0,
  donut_label_format: undefined,
  donut_label_threshold: .05,
  donut_label_ratio: undefined,
  donut_width: undefined,
  donut_title: "",
  donut_expand: {},
  donut_expand_rate: .98,
  donut_expand_duration: 50,
  donut_padAngle: 0,
  donut_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/gauge.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * gauge config options
 */
/* harmony default export */ var gauge = ({
  /**
   * Set gauge options
   * @name gauge
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
   * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
   * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
   * @property {Function} [gauge.label.extents] Set customized min/max label text.
   * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
   * @property {Number} [gauge.expand.rate=0.98] Set expand rate.
   * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
   * @property {Number} [gauge.min=0] Set min value of the gauge.
   * @property {Number} [gauge.max=100] Set max value of the gauge.
   * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
   * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
   * @property {String} [gauge.units] Set units of the gauge.
   * @property {Number} [gauge.width] Set width of gauge chart.
   * @property {String} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
   * **Available Values:**
   * - single
   * - multi
   * @property {String} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
   * @example
   *  gauge: {
   *      fullCircle: false,
   *      label: {
   *          show: false,
   *          format: function(value, ratio) {
   *              return value;
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          extents: function(value, isMax) {
   *              return (isMax ? "Max:" : "Min:") + value;
   *          }
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      min: -100,
   *      max: 200,
   *      type: "single"  // or 'multi'
   *      title: "Title Text",
   *      units: "%",
   *      width: 10,
   *      arcs: {
   *          minWidth: 5
   *      }
   *  }
   */
  gauge_fullCircle: !1,
  gauge_label_show: !0,
  gauge_label_format: undefined,
  gauge_label_extents: undefined,
  gauge_min: 0,
  gauge_max: 100,
  gauge_type: "single",
  gauge_startingAngle: -1 * Math.PI / 2,
  gauge_title: "",
  gauge_units: undefined,
  gauge_width: undefined,
  gauge_arcs_minWidth: 5,
  gauge_expand: {},
  gauge_expand_rate: .98,
  gauge_expand_duration: 50
});
// CONCATENATED MODULE: ./src/config/Options/shape/pie.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var pie = ({
  /**
   * Set pie options
   * @name pie
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
   * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
   * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
   * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
   * @property {Number} [pie.expand.rate=0.98] Set expand rate.
   * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
   * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
   * @property {Number} [pie.padAngle=0] Set padding between data.
   * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
   * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  pie: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *              ...
   *              return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      innerRadius: 0,
   *
   *      // set different innerRadius for each data
   *      innerRadius: {
   *      	data1: 10,
   *      	data2: 0
   *      }
   *
   *      padAngle: 0.1,
   *      padding: 0,
   *      startingAngle: 1
   *  }
   */
  pie_label_show: !0,
  pie_label_format: undefined,
  pie_label_threshold: .05,
  pie_label_ratio: undefined,
  pie_expand: {},
  pie_expand_rate: .98,
  pie_expand_duration: 50,
  pie_innerRadius: 0,
  pie_padAngle: 0,
  pie_padding: 0,
  pie_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var radar = ({
  /**
   * Set radar options
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break.
   * @name radar
   * @memberof Options
   * @type {Object}
   * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
   * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
   * @property {Number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
   * @property {NUmber} [radar.axis.text.position.y=0] y coordinate position, relative the original.
   * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
   * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
   * @property {Number} [radar.level.depth=3] Set the level depth.
   * @property {Boolean} [radar.level.show=true] Show or hide level.
   * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
   * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
   * @property {Number} [radar.size.ratio=0.87] Set size ratio.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
   * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
   * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
   * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
   * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
   * @example
   *  radar: {
   *      axis: {
   *          max: 50,
   *          line: {
   *              show: false
   *          },
   *          text: {
   *              position: {
   *              	x: 0,
   *              	y: 0
   *              },
   *              show: false
   *          }
   *      },
   *      direction: {
   *          clockwise: true
   *      },
   *      level: {
   *          show: false,
   *          text: {
   *              format: function(x) {
   *                  return x + "%";
   *              },
   *              show: true
   *          }
   *      },
   *      size: {
   *          ratio: 0.7
   *      }
   *  }
   */
  radar_axis_max: undefined,
  radar_axis_line_show: !0,
  radar_axis_text_show: !0,
  radar_axis_text_position: {},
  radar_level_depth: 3,
  radar_level_show: !0,
  radar_level_text_format: function radar_level_text_format(x) {
    return x % 1 === 0 ? x : x.toFixed(2);
  },
  radar_level_text_show: !0,
  radar_size_ratio: .87,
  radar_direction_clockwise: !1
});
// CONCATENATED MODULE: ./src/config/Options/Options.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// common





 // Axis based












 // Non-Axis based






/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */

var Options = function () {
  var config = [data_data, common_color, interaction, common_legend, common_title, common_tooltip].concat([donut, gauge, pie, radar], [data_axis, data_selection, axis_axis, common_grid, common_point, common_subchart, common_zoom], [shape_area, shape_bar, bubble, shape_line, spline]);
  return mergeObj.apply(void 0, [{
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set chart background.
     * @name background
     * @memberof Options
     * @property {String} background.class Specify the class name for background element.
     * @property {String} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
     * @property {String} background.imgUrl Specify the image url string for background.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
     * @example
     * background: {
     *    class: "myClass",
     *    color: "red",
     *
     *    // Set image url for background.
     *    // If specified, 'color' option will be ignored.
     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
     * }
     */
    background: {},

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * Set a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Set scatter options
     * @name scatter
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
     * @example
     *  scatter: {
     *      connectNull: true,
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ],
     *
     *      zerobased: false
     *  }
     */
    scatter_zerobased: !1,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {Boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class.
     * The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end.
     * If not specified, the edge values will be used.
     * If timeseries x axis, date string, Date object and unixtime integer can be used.
     * If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: []
  }].concat(config));
};


// CONCATENATED MODULE: ./src/module/Cache.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


var Cache_Cache =
/*#__PURE__*/
function () {
  function Cache() {
    _defineProperty(this, "cache", {});
  }

  var _proto = Cache.prototype;
  return _proto.add =
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  function add(key, value, isDataType) {
    return isDataType === void 0 && (isDataType = !1), this.cache[key] = isDataType ? this.cloneTarget(value) : value, this.cache[key];
  }
  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  , _proto.remove = function remove(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  }
  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  , _proto.get = function get(key, isDataType) {
    if (isDataType === void 0 && (isDataType = !1), isDataType) {
      for (var id, targets = [], i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  }
  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  , _proto.reset = function reset(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }, _proto.cloneTarget = function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  }, Cache;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(40);

// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRendererHelper.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper =
/*#__PURE__*/
function () {
  function AxisRendererHelper(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "scale", void 0);
    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  AxisRendererHelper.getSizeFor1Char = function getSizeFor1Char(node) {
    // default size for one character
    var size = {
      w: 5.5,
      h: 11.5
    };
    return node.empty() || node.select("text").text("0").call(function (el) {
      try {
        var _el$node$getBBox = el.node().getBBox(),
            width = _el$node$getBBox.width,
            height = _el$node$getBBox.height;

        width && height && (size.w = width, size.h = height), el.text("");
      } catch (e) {}
    }), this.getSizeFor1Char = function () {
      return size;
    }, size;
  };

  var _proto = AxisRendererHelper.prototype;
  return _proto.axisX = function axisX(selection, x) {
    var _this = this;

    selection.attr("transform", function (d) {
      return "translate(" + Math.ceil(x(d) + _this.config.tickOffset) + ",0)";
    });
  }, _proto.axisY = function axisY(selection, y) {
    selection.attr("transform", function (d) {
      return "translate(0," + Math.ceil(y(d)) + ")";
    });
  }, _proto.scaleExtent = function scaleExtent(domain) {
    var start = domain[0],
        stop = domain[domain.length - 1];
    return start < stop ? [start, stop] : [stop, start];
  }, _proto.generateTicks = function generateTicks(scale, isYAxes) {
    var tickStepSize = this.owner.params.tickStepSize,
        ticks = [];
    // When 'axis[y|y2].tick.stepSize' option is set
    if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), start = _scale$domain[0], end = _scale$domain[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, this.config.tickArguments || []).map(function (v) {
      return (// round the tick value if is number
        isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
      );
    });else {
      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
    }
    return ticks;
  }, _proto.copyScale = function copyScale() {
    var newScale = this.scale.copy();
    return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
  }, _proto.textFormatted = function textFormatted(v) {
    var tickFormat = this.config.tickFormat,
        value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
        formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
    // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

    return isDefined(formatted) ? formatted : "";
  }, _proto.transitionise = function transitionise(selection) {
    var config = this.config;
    return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
  }, AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRenderer.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer =
/*#__PURE__*/
function () {
  function AxisRenderer(params) {
    params === void 0 && (params = {}), _defineProperty(this, "helper", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "params", void 0), _defineProperty(this, "g", void 0);
    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  var _proto = AxisRenderer.prototype;
  return _proto.create = function create(g) {
    var ctx = this,
        config = this.config,
        params = this.params,
        helperInst = this.helper,
        scale = helperInst.scale,
        orient = config.orient,
        splitTickText = this.splitTickText.bind(this),
        isLeftRight = /^(left|right)$/.test(orient),
        isTopBottom = /^(top|bottom)$/.test(orient),
        tickTransform = helperInst[isTopBottom ? "axisX" : "axisY"],
        axisPx = tickTransform === helperInst.axisX ? "y" : "x",
        sign = /^(top|left)$/.test(orient) ? -1 : 1,
        rotate = params.tickTextRotate;
    this.config.range = scale.rangeExtent ? scale.rangeExtent() : helperInst.scaleExtent((params.orgXScale || scale).range());
    var $g,
        _config = config,
        innerTickSize = _config.innerTickSize,
        tickLength = _config.tickLength,
        range = _config.range,
        name = params.name,
        tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_" + name + "_tick_text_position"] : {
      x: 0,
      y: 0
    },
        prefix = name === "subX" ? "subchart_axis_x" : "axis_" + name,
        axisShow = params.config[prefix + "_show"],
        tickShow = {
      tick: !!axisShow && params.config[prefix + "_tick_show"],
      text: !!axisShow && params.config[prefix + "_tick_text_show"]
    }; // // get the axis' tick position configuration

    g.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          scale0 = this.__chart__ || scale,
          scale1 = helperInst.copyScale();
      $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
      // update selection - data join
      var path = g.selectAll(".domain").data([0]); // enter + update selection

      if (path.enter().append("path").attr("class", "domain").merge(helperInst.transitionise(path)).attr("d", function () {
        var outerTickSized = config.outerTickSize * sign;
        return isTopBottom ? "M" + range[0] + "," + outerTickSized + "V0H" + range[1] + "V" + outerTickSized : "M" + outerTickSized + "," + range[0] + "H0V" + range[1] + "H" + outerTickSized;
      }), tickShow.tick || tickShow.text) {
        // count of tick data in array
        var ticks = config.tickValues || helperInst.generateTicks(scale1, isLeftRight),
            tick = g.selectAll(".tick").data(ticks, scale1),
            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
            tickExit = tick.exit().remove(); // update selection

        tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
        var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
            counts = [],
            tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
          var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helperInst.textFormatted(d)) ? helperInst.textFormatted(d).concat() : [helperInst.textFormatted(d)];
          return counts[index] = split.length, split.map(function (splitted) {
            return {
              index: index,
              splitted: splitted
            };
          });
        });
        tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
          return d.splitted;
        }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
          var dx = 0;
          return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
        }()).attr("dy", function (d, i) {
          var dy = 0;
          return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
        });
        var lineUpdate = tick.select("line"),
            textUpdate = tick.select("text");

        if (tickEnter.select("line").attr(axisPx + "2", innerTickSize * sign), tickEnter.select("text").attr("" + axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
          Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).text(params.tickTitle[index]);
        }), scale1.bandwidth) {
          var x = scale1,
              dx = x.bandwidth() / 2;
          scale0 = function (d) {
            return x(d) + dx;
          }, scale1 = scale0;
        } else scale0.bandwidth ? scale0 = scale1 : tickTransform.call(helperInst, tickExit, scale1);

        tickTransform.call(helperInst, tickEnter, scale0), tickTransform.call(helperInst, helperInst.transitionise(tick).style("opacity", "1"), scale1);
      }
    }), this.g = $g;
  }
  /**
   * Get tick x/y coordinate
   * @return {{x: number, y: number}}
   * @private
   */
  , _proto.getTickXY = function getTickXY() {
    var config = this.config,
        pos = {
      x: 0,
      y: 0
    };
    return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
  }
  /**
   * Get tick size
   * @param d
   * @return {number}
   * @private
   */
  , _proto.getTickSize = function getTickSize(d) {
    var scale = this.helper.scale,
        config = this.config,
        _config2 = config,
        innerTickSize = _config2.innerTickSize,
        range = _config2.range,
        tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
    return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
  }
  /**
   * Set tick's line & text position
   * @param lineUpdate
   * @param textUpdate
   * @param scale
   * @private
   */
  , _proto.setTickLineTextPosition = function setTickLineTextPosition(lineUpdate, textUpdate) {
    var tickPos = this.getTickXY(),
        _this$config = this.config,
        innerTickSize = _this$config.innerTickSize,
        orient = _this$config.orient,
        tickLength = _this$config.tickLength,
        tickOffset = _this$config.tickOffset,
        rotate = this.params.tickTextRotate,
        textAnchorForText = function (r) {
      var value = ["start", "end"];
      return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
    },
        textTransform = function (r) {
      return r ? "rotate(" + r + ")" : null;
    },
        yForText = function (r) {
      var r2 = r / (orient === "bottom" ? 15 : 23);
      return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
    };

    orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
  } // this should be called only when category axis
  , _proto.splitTickText = function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
    function split(splitted, text) {
      for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
      if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

      return splitted.concat(text);
    }

    var params = this.params,
        tickText = this.helper.textFormatted(d),
        splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
    if (splitted.length) return splitted;
    if (isArray(tickText)) return tickText;
    var tickWidth = params.tickWidth;
    return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
  }, _proto.scale = function scale(x) {
    return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
  }, _proto.orient = function orient(x) {
    return arguments.length ? (this.config.orient = x in {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    } ? x + "" : "bottom", this) : this.config.orient;
  }, _proto.tickFormat = function tickFormat(format) {
    var config = this.config;
    return arguments.length ? (config.tickFormat = format, this) : config.tickFormat;
  }, _proto.tickCentered = function tickCentered(isCentered) {
    var config = this.config;
    return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
  }
  /**
   * Return tick's offset value.
   * The value will be set for 'category' axis type.
   * @return {number}
   * @private
   */
  , _proto.tickOffset = function tickOffset() {
    return this.config.tickOffset;
  }
  /**
   * Get tick interval count
   * @private
   * @param {Number} size Total data size
   * @return {number}
   */
  , _proto.tickInterval = function tickInterval(size) {
    var interval;
    if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
      var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
      interval = length / (size || this.g.selectAll("line").size());
    }
    return interval === Infinity ? 0 : interval;
  }, _proto.ticks = function ticks() {
    for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
  }, _proto.tickCulling = function tickCulling(culling) {
    var config = this.config;
    return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
  }, _proto.tickValues = function tickValues(x) {
    var _this = this,
        config = this.config;

    if (isFunction(x)) config.tickValues = function () {
      return x(_this.helper.scale.domain());
    };else {
      if (!arguments.length) return config.tickValues;
      config.tickValues = x;
    }
    return this;
  }, _proto.setTransition = function setTransition(t) {
    return this.config.transition = t, this;
  }, AxisRenderer;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/Axis.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var Axis_Axis =
/*#__PURE__*/
function () {
  function Axis(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "axesList", {}), _defineProperty(this, "tick", {
      x: null,
      y: null,
      y2: null
    }), _defineProperty(this, "xs", []), _defineProperty(this, "orient", {
      x: "bottom",
      y: "left",
      y2: "right",
      subX: "bottom"
    }), this.owner = owner, this.setOrient();
  }

  var _proto = Axis.prototype;
  return _proto.getAxisClassName = function getAxisClassName(id) {
    return config_classes.axis + " " + config_classes["axis" + capitalize(id)];
  }, _proto.isHorizontal = function isHorizontal($$, forHorizontal) {
    var isRotated = $$.config.axis_rotated;
    return forHorizontal ? isRotated : !isRotated;
  }, _proto.init = function init() {
    var _this = this,
        $$ = this.owner,
        config = $$.config,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        axis = _$$$$el.axis,
        clip = $$.state.clip,
        isRotated = config.axis_rotated,
        target = ["x", "y"];

    config.axis_y2_show && target.push("y2"), target.forEach(function (v) {
      var classAxis = _this.getAxisClassName(v),
          axisId = v.toUpperCase(),
          classLabel = config_classes["axis" + axisId + "Label"];

      axis[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
        var res = null;
        return v === "x" ? res = clip.pathXAxis : v === "y" && config.axis_y_inner && (res = clip.pathYAxis), res;
      }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_" + v + "_show"] ? "visible" : "hidden"), axis[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", _this["textAnchorFor" + axisId + "AxisLabel"].bind(_this)), _this.generateAxes(v);
    });
  }
  /**
   * Set axis orient according option value
   * @private
   */
  , _proto.setOrient = function setOrient() {
    var $$ = this.owner,
        _$$$config = $$.config,
        isRotated = _$$$config.axis_rotated,
        yInner = _$$$config.axis_y_inner,
        y2Inner = _$$$config.axis_y2_inner;
    this.orient = {
      x: isRotated ? "left" : "bottom",
      y: isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left",
      y2: isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right",
      subX: isRotated ? "left" : "bottom"
    };
  }
  /**
   * Generate axes
   * It's used when axis' axes option is set
   * @param {String} id Axis id
   * @private
   */
  , _proto.generateAxes = function generateAxes(id) {
    var d3Axis,
        $$ = this.owner,
        config = $$.config,
        axes = [],
        axesConfig = config["axis_" + id + "_axes"],
        isRotated = config.axis_rotated;
    id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
      var tick = v.tick || {},
          scale = $$.scale[id].copy();
      v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(isFunction(tick.format) ? tick.format.bind($$.api) : function (x) {
        return x;
      }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
    }), this.axesList[id] = axes;
  }
  /**
   * Update axes nodes
   * @private
   */
  , _proto.updateAxes = function updateAxes() {
    var _this2 = this,
        $$ = this.owner,
        config = $$.config,
        main = $$.$el.main;

    Object.keys(this.axesList).forEach(function (id) {
      var axesConfig = config["axis_" + id + "_axes"],
          scale = $$.scale[id].copy(),
          range = scale.range();

      _this2.axesList[id].forEach(function (v, i) {
        var axisRange = v.scale().range(); // adjust range value with the current
        // https://github.com/naver/billboard.js/issues/859

        range.every(function (v, i) {
          return v === axisRange[i];
        }) || v.scale().range(range);
        var className = _this2.getAxisClassName(id) + "-" + (i + 1),
            g = main.select("." + className.replace(/\s/, "."));
        g.empty() ? g = main.append("g").attr("class", className).style("visibility", config["axis_" + id + "_show"] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), $$.axis.x.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
      });
    });
  } // called from : updateScales() & getMaxTickWidth()
  , _proto.getAxis = function getAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
    var tickFormat,
        $$ = this.owner,
        config = $$.config,
        isX = /^(x|subX)$/.test(name),
        type = isX ? "x" : name,
        isCategory = isX && $$.isCategorized(),
        orient = this.orient[name];
    if (isX) tickFormat = $$.format.xAxisTick;else {
      var fn = config["axis_" + name + "_tick_format"];
      isFunction(fn) && (tickFormat = fn.bind($$.api));
    }
    var tickValues = $$.axis.tick[type],
        axisParams = mergeObj({
      outerTick: outerTick,
      noTransition: noTransition,
      config: config,
      name: name,
      tickTextRotate: noTickTextRotate ? 0 : config["axis_" + type + "_tick_rotate"]
    }, isX && {
      isCategory: isCategory,
      tickMultiline: config.axis_x_tick_multiline,
      tickWidth: config.axis_x_tick_width,
      tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
      orgXScale: $$.scale.x
    });
    isX || (axisParams.tickStepSize = config["axis_" + type + "_tick_stepSize"]);
    var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.scale.zoom || scale).orient(orient);

    if (isX && $$.isTimeSeries() && tickValues && !isFunction(tickValues)) {
      var _fn = parseDate.bind($$);

      tickValues = tickValues.map(function (v) {
        return _fn(v);
      });
    } else !isX && $$.isTimeSeriesY() && ( // https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time
    axis.ticks(config.axis_y_tick_time_value), tickValues = null);

    return tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
      return x + "%";
    }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), config["axis_" + type + "_tick_count"] && axis.ticks(config["axis_" + type + "_tick_count"]), axis;
  }, _proto.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
    var values,
        $$ = this.owner,
        config = $$.config,
        fit = config.axis_x_tick_fit,
        count = config.axis_x_tick_count;
    return (fit || count && fit) && (values = this.generateTickValues($$.mapTargetsToUniqueXs(targets), count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.axis.x && ($$.axis.x.tickValues(values), $$.axis.subX && $$.axis.subX.tickValues(values)), values;
  }, _proto.getId = function getId(id) {
    var _this$owner = this.owner,
        config = _this$owner.config,
        scale = _this$owner.scale,
        axis = config.data_axes[id];
    return axis && scale[axis] || (axis = "y"), axis;
  }, _proto.getXAxisTickFormat = function getXAxisTickFormat() {
    var currFormat,
        $$ = this.owner,
        config = $$.config,
        format = $$.format,
        tickFormat = config.axis_x_tick_format,
        isTimeSeries = $$.isTimeSeries(),
        isCategorized = $$.isCategorized();
    return tickFormat ? isFunction(tickFormat) ? currFormat = tickFormat.bind($$.api) : isTimeSeries && (currFormat = function (date) {
      return date ? format.axisTime(tickFormat)(date) : "";
    }) : currFormat = isTimeSeries ? format.defaultAxisTime : isCategorized ? $$.categoryName : function (v) {
      return v < 0 ? v.toFixed(0) : v;
    }, isFunction(currFormat) ? function (v) {
      return currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
    } : currFormat;
  }, _proto.getTickValues = function getTickValues(id) {
    var $$ = this.owner,
        tickValues = $$.config["axis_" + id + "_tick_values"],
        axis = $$[id + "Axis"];
    return (isFunction(tickValues) ? tickValues.call($$.api) : tickValues) || (axis ? axis.tickValues() : undefined);
  }, _proto.getLabelOptionByAxisId = function getLabelOptionByAxisId(id) {
    return this.owner.config["axis_" + id + "_label"];
  }, _proto.getLabelText = function getLabelText(id) {
    var option = this.getLabelOptionByAxisId(id);
    return isString(option) ? option : option ? option.text : null;
  }, _proto.setLabelText = function setLabelText(id, text) {
    var $$ = this.owner,
        config = $$.config,
        option = this.getLabelOptionByAxisId(id);
    isString(option) ? config["axis_" + id + "_label"] = text : option && (option.text = text);
  }, _proto.getLabelPosition = function getLabelPosition(id, defaultPosition) {
    var isRotated = this.owner.config.axis_rotated,
        option = this.getLabelOptionByAxisId(id),
        position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
        has = function (v) {
      return !!~position.indexOf(v);
    };

    return {
      isInner: has("inner"),
      isOuter: has("outer"),
      isLeft: has("left"),
      isCenter: has("center"),
      isRight: has("right"),
      isTop: has("top"),
      isMiddle: has("middle"),
      isBottom: has("bottom")
    };
  }, _proto.getXAxisLabelPosition = function getXAxisLabelPosition() {
    return this.getLabelPosition("x", ["inner-top", "inner-right"]);
  }, _proto.getYAxisLabelPosition = function getYAxisLabelPosition() {
    return this.getLabelPosition("y", ["inner-right", "inner-top"]);
  }, _proto.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
    return this.getLabelPosition("y2", ["inner-right", "inner-top"]);
  }, _proto.getLabelPositionById = function getLabelPositionById(id) {
    return this["get" + id.toUpperCase() + "AxisLabelPosition"]();
  }, _proto.textForXAxisLabel = function textForXAxisLabel() {
    return this.getLabelText("x");
  }, _proto.textForYAxisLabel = function textForYAxisLabel() {
    return this.getLabelText("y");
  }, _proto.textForY2AxisLabel = function textForY2AxisLabel() {
    return this.getLabelText("y2");
  }, _proto.xForAxisLabel = function xForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        x = position.isMiddle ? -height / 2 : 0;
    return this.isHorizontal($$, forHorizontal) ? x = position.isLeft ? 0 : position.isCenter ? width / 2 : width : position.isBottom && (x = -$$.state.height), x;
  }, _proto.dxForAxisLabel = function dxForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        dx = position.isBottom ? "0.5em" : "0";
    return this.isHorizontal($$, forHorizontal) ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
  }, _proto.textAnchorForAxisLabel = function textAnchorForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        anchor = position.isMiddle ? "middle" : "end";
    return this.isHorizontal($$, forHorizontal) ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
  }, _proto.xForXAxisLabel = function xForXAxisLabel() {
    return this.xForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.xForYAxisLabel = function xForYAxisLabel() {
    return this.xForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.xForY2AxisLabel = function xForY2AxisLabel() {
    return this.xForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.dxForXAxisLabel = function dxForXAxisLabel() {
    return this.dxForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.dxForYAxisLabel = function dxForYAxisLabel() {
    return this.dxForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.dxForY2AxisLabel = function dxForY2AxisLabel() {
    return this.dxForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.dyForXAxisLabel = function dyForXAxisLabel() {
    var $$ = this.owner,
        config = $$.config,
        isInner = this.getXAxisLabelPosition().isInner,
        xHeight = config.axis_x_height;
    return config.axis_rotated ? isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : isInner ? "-0.5em" : xHeight ? xHeight - 10 : "3em";
  }, _proto.dyForYAxisLabel = function dyForYAxisLabel() {
    var $$ = this.owner,
        isInner = this.getYAxisLabelPosition().isInner;
    return $$.config.axis_rotated ? isInner ? "-0.5em" : "3em" : isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
  }, _proto.dyForY2AxisLabel = function dyForY2AxisLabel() {
    var $$ = this.owner,
        isInner = this.getY2AxisLabelPosition().isInner;
    return $$.config.axis_rotated ? isInner ? "1.2em" : "-2.2em" : isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
  }, _proto.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
    return this.textAnchorForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
    return this.textAnchorForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
    return this.textAnchorForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
    var $$ = this.owner,
        config = $$.config,
        _$$$$el2 = $$.$el,
        svg = _$$$$el2.svg,
        chart = _$$$$el2.chart,
        currentTickMax = $$.state.currentMaxTickWidths[id],
        maxWidth = 0;
    if (withoutRecompute || !config["axis_" + id + "_show"]) return currentTickMax.size;

    if (svg) {
      var isYAxis = /^y2?$/.test(id),
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          scale = $$.scale[id].copy().domain($$["get" + (isYAxis ? "Y" : "X") + "Domain"](targetsToShow, id)),
          domain = scale.domain();
      // do not compute if domain is same
      if (isArray(currentTickMax.domain) && currentTickMax.domain.every(function (v, i) {
        return v === domain[i];
      })) return currentTickMax.size;
      currentTickMax.domain = domain;
      var axis = this.getAxis(id, scale, !1, !1, !0),
          tickCount = config["axis_" + id + "_tick_count"];
      tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
      var dummy = chart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
      axis.create(dummy), dummy.selectAll("text").each(function () {
        maxWidth = Math.max(maxWidth, this.getBoundingClientRect().width);
      }), dummy.remove();
    }

    return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
  }, _proto.updateLabels = function updateLabels(withTransition) {
    var _this3 = this,
        $$ = this.owner,
        main = $$.$el.main,
        labels = {
      X: main.select("." + config_classes.axisX + " ." + config_classes.axisXLabel),
      Y: main.select("." + config_classes.axisY + " ." + config_classes.axisYLabel),
      Y2: main.select("." + config_classes.axisY2 + " ." + config_classes.axisY2Label)
    };

    Object.keys(labels).filter(function (id) {
      return !labels[id].empty();
    }).forEach(function (v) {
      var node = labels[v],
          axisLabel = v + "AxisLabel";
      (withTransition ? node.transition() : node).attr("x", _this3["xFor" + axisLabel].bind(_this3)).attr("dx", _this3["dxFor" + axisLabel].bind(_this3)).attr("dy", _this3["dyFor" + axisLabel].bind(_this3)).text(_this3["textFor" + axisLabel].bind(_this3));
    });
  }, _proto.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
    var p = isNumber(padding) ? padding : padding[key];
    return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
  }, _proto.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
    var $$ = this.owner,
        config = $$.config,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        length = config.axis_rotated ? width : height;
    return domainLength * (pixels / length);
  }, _proto.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
    var start,
        end,
        count,
        interval,
        i,
        tickValue,
        tickValues = values;

    if (tickCount) {
      var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

      if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
        var isCategorized = this.owner.isCategorized();

        for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

        tickValues.push(end);
      }
    }

    return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
      return a - b;
    })), tickValues;
  }, _proto.generateTransitions = function generateTransitions(duration) {
    var $$ = this.owner,
        axis = $$.$el.axis,
        _map = ["x", "y", "y2", "subX"].map(function (v) {
      var ax = axis[v];
      return ax && duration && (ax = ax.transition().duration(duration)), ax;
    }),
        axisX = _map[0],
        axisY = _map[1],
        axisY2 = _map[2],
        axisSubX = _map[3];

    return {
      axisX: axisX,
      axisY: axisY,
      axisY2: axisY2,
      axisSubX: axisSubX
    };
  }, _proto.redraw = function redraw(transitions, isHidden, isInit) {
    var $$ = this.owner,
        config = $$.config,
        $el = $$.$el,
        opacity = isHidden ? "0" : "1";
    ["x", "y", "y2", "subX"].forEach(function (id) {
      var axis = $$.axis[id],
          $axis = $el.axis[id];
      axis && $axis && (!isInit && (axis.config.withoutTransition = !config.transition_duration), $axis.style("opacity", opacity), axis.create(transitions["axis" + capitalize(id)]));
    }), this.updateAxes();
  }
  /**
   * Redraw axis
   * @param {Object} targetsToShow targets data to be shown
   * @param {Object} wth
   * @param {Ojbect} transitions
   * @param {Object} flow
   * @private
   */
  , _proto.redrawAxis = function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
    var xDomainForZoom,
        _this4 = this,
        $$ = this.owner,
        config = $$.config,
        scale = $$.scale,
        $el = $$.$el,
        hasZoom = !!scale.zoom;

    !hasZoom && $$.isCategorized() && targetsToShow.length === 0 && scale.x.domain([0, $el.axis.x.selectAll(".tick").size()]), scale.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : $$.axis.x && ($$.axis.x.tickValues([]), $$.axis.subX && $$.axis.subX.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = scale.x.orgDomain()), ["y", "y2"].forEach(function (key) {
      var axis = scale[key];

      if (axis) {
        var tickValues = config["axis_" + key + "_tick_values"],
            tickCount = config["axis_" + key + "_tick_count"];

        if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
          var domain = axis.domain();
          $$[key + "Axis"].tickValues(_this4.generateTickValues(domain, domain.every(function (v) {
            return v === 0;
          }) ? 1 : tickCount, $$.isTimeSeriesY()));
        }
      }
    }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && (scale.subY && scale.subY.domain($$.getYDomain(targetsToShow, "y")), scale.subY2 && scale.subY2.domain($$.getYDomain(targetsToShow, "y2")));
  }
  /**
   * Set manual culling
   * @private
   */
  , _proto.setCulling = function setCulling() {
    var $$ = this.owner,
        config = $$.config,
        $el = $$.$el;
    ["subX", "x", "y", "y2"].forEach(function (type) {
      var axis = $el.axis[type],
          id = type === "subX" ? "x" : type,
          toCull = config["axis_" + id + "_tick_culling"]; // subchart x axis should be aligned with x axis culling

      if (axis && toCull) {
        var intervalForCulling,
            tickText = axis.selectAll(".tick text"),
            tickValues = util_sortValue(tickText.data()),
            tickSize = tickValues.length,
            cullingMax = config["axis_" + id + "_tick_culling_max"];

        if (tickSize) {
          for (var _i = 1; _i < tickSize; _i++) if (tickSize / _i < cullingMax) {
            intervalForCulling = _i;
            break;
          }

          tickText.each(function (d) {
            this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
          });
        } else tickText.style("display", "block");
      }
    });
  }, Axis;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(42);

// CONCATENATED MODULE: ./src/ChartInternal/data/data.convert.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Data convert
 * @memberof ChartInternal
 * @private
 */

/* harmony default export */ var data_convert = ({
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_" + v;
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) this.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = this.convertJsonToData(data.json, data.keys);else if (data.rows) data = this.convertRowsToData(data.rows);else if (data.columns) data = this.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {String} url Remote URL
   * @param {String} mimeType MIME type string: json | csv | tsv
   * @param {Object} headers Header object
   * @param {Object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url, mimeType, headers, keys, done) {
    var _this = this;

    mimeType === void 0 && (mimeType = "csv");
    var req = new XMLHttpRequest();
    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert" + capitalize(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error(url + ": Something went wrong loading!");
    }, req.send();
  },

  /**
   * Convert CSV/TSV data
   * @param {Object} parser Parser object
   * @param {Object} xsv Data
   * @private
   * @return {Object}
   */
  convertCsvTsvToData: function convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isTimeSeries = $$.isTimeSeries(),
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter.bind($$.api)(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), state.hasNegativeValue = $$.hasNegativeValueInTargets(targets), state.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.cache.add(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var ChartInternal_data_data = ({
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return !!(config.data_stack_normalize && config.data_groups.length);
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this,
        config = $$.config;
    Object.keys(xs).forEach(function (id) {
      config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this,
        config = $$.config;
    return data && (name = config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;

    if ($$.isTimeSeries()) {
      var fn = parseDate.bind($$);
      x = rawX ? fn(rawX) : fn($$.getXValue(id, index));
    } else $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index));

    return x;
  },
  updateXs: function updateXs(values) {
    values.length && (this.axis.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.axis.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.axis.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && $$.hasAxis && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(value)), max = Math.max.apply(Math, [i ? max : -Infinity].concat(value));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.cache.get(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.cache.add(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.cache.get("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum() {
    var $$ = this,
        cacheKey = "$totalDataSum",
        totalDataSum = $$.cache.get(cacheKey);

    if (!totalDataSum) {
      var total = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.cache.add(cacheKey, totalDataSum = total);
    }

    return totalDataSum;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, this.data.targets.map(function (t) {
      return t.values.length;
    }));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = util_sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.state.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.state.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), util_sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, value) : isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : $$.isBubbleZType(v) ? data.push($$.hasAxis && $$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = [].concat(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();
    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order.bind($$.api)), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.$el.chart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = main.select("." + config_classes.bars + $$.getTargetSelectorSuffix(v.id) + " ." + config_classes.bar + "-" + v.index).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        scale = $$.scale,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = (scale.zoom || scale.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length, value = converted[x - 1].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_" + name];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        api = $$.api,
        ratio = 0;

    if (d && api.data.shown().length) {
      var dataValues = api.data.values.bind(api);
      if (ratio = d.ratio || d.value, type === "arc") {
          // if has padAngle set, calculate rate based on value
          if ($$.pie.padAngle()()) {
            var total = $$.getTotalDataSum();
            state.hiddenTargetIds.length && (total -= dataValues(state.hiddenTargetIds).reduce(function (p, c) {
              return p + c;
            })), ratio = d.value / total;
          } else ratio = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));
      } else if (type === "index") {
        var _total = this.getTotalPerIndex();

        if (state.hiddenTargetIds.length) {
          var hiddenSum = dataValues(state.hiddenTargetIds, !1);
          hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
            return acc.map(function (v, i) {
              return (isNumber(v) ? v : 0) + curr[i];
            });
          }), _total = _total.map(function (v, i) {
            return v - hiddenSum[i];
          }));
        }

        d.ratio = isNumber(d.value) && _total && _total[d.index] > 0 ? d.value / _total[d.index] : 0, ratio = d.ratio;
      } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0) + "") / $$.maxValue * config.radar_size_ratio);
    }

    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var data_load = ({
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done.call($$.api);
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.cache.reset();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        state = $$.state,
        $el = $$.$el,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.cache.reset(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($el.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      state.withoutFadeIn[id] = !1, $el.legend && $el.legend.selectAll("." + config_classes.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(43);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_interaction = ({
  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, main.select("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).node());else if (!config.tooltip_grouped) {
        var callee = $$.setOverOut,
            last = callee.last || [],
            shape = main.selectAll("." + config_classes.shape + "-" + d).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), callee.last = last;
      } else isOver && $$.expandCirclesBars(d, null, !0), $$.isMultipleX() || main.selectAll("." + config_classes.shape + "-" + d).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      // @ts-ignore
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      // @ts-ignore
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = "." + (isMultipleX ? config_classes.eventRect : config_classes.eventRect + "-" + index),
        eventRect = $$.$el.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/class.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_class = ({
  generateClass: function generateClass(prefix, targetId) {
    return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return this.generateClass(config_classes.region, i) + " " + ("class" in d ? d.class : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " " + config_classes.target + "-" + additionalClassSuffix), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " " + (this.state.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " " + (this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    var pfx = prefix || "",
        target = this.getTargetSelectorSuffix(id);
    // select target & circle
    return pfx + "." + (config_classes.target + target) + ", " + pfx + "." + (config_classes.circles + target);
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return "." + (config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


/* harmony default export */ var internals_color = ({
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = browser_doc.body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles.bind($$.api)(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = $$.state.datetimeId + "-pattern-" + color + "-" + index;
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#" + p.id + ")";
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id].bind($$.api)(d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback.bind($$.api)(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restate in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) ? color = function () {
      return onover;
    } : isFunction(onover) && (color = color.bind($$.api)), isObject(d) ? main.selectAll("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).style("fill", color(d)) : main.selectAll("." + config_classes.shape + "-" + d).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/domain.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_domain = ({
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) // use domain of the other axis if target of axisId is none
      return axisId === "y2" ? scale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
      // So, it needs to call to get y2 domain here
      $$.getYDomain(targets, "y2", xDomain);
    var yMin = config["axis_" + axisId + "_min"],
        yMax = config["axis_" + axisId + "_max"],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["axis_" + axisId + "_center"],
        isZeroBased = ["area", "bar", "bubble", "line", "scatter"].some(function (v) {
      return $$.hasType(v, yTargets) && config[v + "_zerobased"];
    }),
        isInverted = config["axis_" + axisId + "_inverted"],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain(scale.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    }

    if (/^y2?$/.test(axisId)) {
      var p = config["axis_" + axisId + "_padding"];
      notEmpty(p) && ["bottom", "top"].forEach(function (v) {
        padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
      });
    } // Bar/Area chart should be 0-based if all positive|negative


    isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        value = $$.config["axis_x_" + type];
    return isDefined(value) ? $$.isTimeSeries() ? parseDate.call($$, value) : value : getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    }));
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        _xDomain = xDomain,
        firstX = _xDomain[0],
        lastX = _xDomain[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        subX = _$$$scale.subX,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && (x.domain(domain || util_sortValue($$.getXDomain(targets))), org.xDomain = x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), subX.domain(x.domain()), $$.brush && $$.brush.scale(subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? org.xDomain : getBrushSelection($$).map(subX.invert);
      x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && x.domain($$.trimXDomain(x.orgDomain())), x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        min = zoomDomain[0],
        max = zoomDomain[1];
    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/format.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


function getFormat($$, typeValue, v) {
  var config = $$.config,
      type = "axis_" + typeValue + "_tick_format",
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
}

/* harmony default export */ var internals_format = ({
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        yFormat = $$.yFormat,
        y2Format = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (yFormat = $$.defaultArcValueFormat, y2Format = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis && $$.axis.getId(id) === "y2" ? y2Format : yFormat;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return (ratio * 100).toFixed(1) + "%";
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format.bind($$.api);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_legend = ({
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.state.legendHasRendered = !1, $el.legend = $$.$el.svg.append("g"), config.legend_show ? ($el.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.$el.legend.style("visibility", "hidden"), $$.state.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        scale = $$.scale,
        $el = $$.$el,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !scale.zoom), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), state.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.bind($$.api)(v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $el.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        isLegendTop = _$$$state.isLegendTop,
        isLegendLeft = _$$$state.isLegendLeft,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.state.margin3 = {
      top: isLegendRight ? 0 : isLegendInset ? insetLegendPosition.top : currentHeight - height,
      right: NaN,
      bottom: 0,
      left: isLegendRight ? currentWidth - width : isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this,
        legend = $$.$el.legend;
    (withTransition ? legend.transition() : legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.state.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.state.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.state.legendItemHeight = h;
  },

  /**
   * Update legend item color
   * @private
   * @param {String} id Corresponding data ID value
   * @param {String} color Color value
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.$el.legend.select("." + config_classes.legendItem + "-" + id + " line").style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        currentWidth = _$$$state2.currentWidth,
        isLegendRight = _$$$state2.isLegendRight,
        isLegendInset = _$$$state2.isLegendInset,
        legendItemWidth = _$$$state2.legendItemWidth,
        legendStep = _$$$state2.legendStep;
    return $$.config.legend_show ? isLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this,
        _$$$state3 = $$.state,
        currentHeight = _$$$state3.currentHeight,
        isLegendRight = _$$$state3.isLegendRight,
        legendItemHeight = _$$$state3.legendItemHeight,
        legendStep = _$$$state3.legendStep;
    return $$.config.legend_show ? isLegendRight ? currentHeight : Math.max(20, legendItemHeight) * (legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.$el.legend.selectAll("." + config_classes.legendItem).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.$el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show || (config.legend_show = !0, legend.style("visibility", "visible"), !$$.state.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Get legend item textbox dimension
   * @param {String} id
   * @param {HTMLElement|d3.selection} textElement
   */
  getLegendItemTextBox: function getLegendItemTextBox(id, textElement) {
    var $$ = this,
        cache = $$.cache,
        cacheKey = "$legendItemTextBox";

    if (id) {
      var data = cache.get(cacheKey);
      return data || (data = {}), data[id] || (data[id] = $$.getTextRect(textElement, config_classes.legendItem), cache.add(cacheKey, data)), data[id];
    }

    cache.remove(cacheKey);
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, api, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? (api.hide(), api.show(id)) : (api.toggle(id), !isTouch && $$.isTargetToShow(id) ? api.focus(id) : api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, "." + config_classes.gaugeValue), !state.transiting && $$.isTargetToShow(id) && api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        state = $$.state,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = state.isLegendRight || state.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = $$.getLegendItemTextBox(id, textElement),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = state.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    state.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), state.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : state.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        legend = $$.$el.legend,
        l = legend.selectAll("." + config_classes.legendItem).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#" + state.datetimeId + "-point-" + data : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = legend.select("." + config_classes.legendBackground + " rect"), state.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = legend.insert("g", "." + config_classes.legendItem).attr("class", config_classes.legendBackground).append("rect"));
    var texts = legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = legend.selectAll("rect." + config_classes.legendItemEvent).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = legend.selectAll("." + config_classes.legendItemPoint).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = legend.selectAll("line." + config_classes.legendItemTile).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache.get(id).values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/scale.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_scale = ({
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.scale.zoom || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.axis.x.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    var _this$scale = this.scale,
        y = _this$scale.y,
        y2 = _this$scale.y2;
    return this.axis.getId(id) === "y2" ? y2 : y;
  },
  getSubYScale: function getSubYScale(id) {
    var _this$scale2 = this.scale,
        subY = _this$scale2.subY,
        subY2 = _this$scale2.subY2;
    return this.axis.getId(id) === "y2" ? subY2 : subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit, updateXDomain) {
    updateXDomain === void 0 && (updateXDomain = !0);
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        format = $$.format,
        org = $$.org,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        width2 = _$$$state.width2,
        height2 = _$$$state.height2;

    if ($$.hasAxis) {
      var isRotated = config.axis_rotated,
          min = {
        x: isRotated ? 1 : 0,
        y: isRotated ? 0 : height,
        subX: isRotated ? 1 : 0,
        subY: isRotated ? 0 : height2
      },
          max = {
        x: isRotated ? height : width,
        y: isRotated ? width : 1,
        subX: isRotated ? height : width,
        subY: isRotated ? width2 : 1
      },
          xDomain = updateXDomain && scale.x && scale.x.orgDomain(),
          xSubDomain = updateXDomain && org.xDomain; // update edges

      // y Axis
      scale.x = $$.getX(min.x, max.x, xDomain, function () {
        return axis.x.tickOffset();
      }), scale.subX = $$.getX(min.x, max.x, xSubDomain, function (d) {
        return d % 1 ? 0 : axis.subX.tickOffset();
      }), format.xAxisTick = axis.getXAxisTickFormat(), axis.tick.x = axis.getTickValues("x"), axis.x = axis.getAxis("x", scale.x, config.axis_x_tick_outer, isInit), config.subchart_show && (axis.subX = axis.getAxis("subX", scale.subX, config.axis_x_tick_outer, isInit)), scale.y = $$.getY(min.y, max.y, scale.y ? scale.y.domain() : config.axis_y_default), scale.subY = $$.getY(min.subY, max.subY, scale.subY ? scale.subY.domain() : config.axis_y_default), axis.tick.y = axis.getTickValues("y"), axis.y = axis.getAxis("y", scale.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && (scale.y2 = $$.getY(min.y, max.y, scale.y2 ? scale.y2.domain() : config.axis_y2_default), scale.subY2 = $$.getY(min.subY, max.subY, scale.subY2 ? scale.subY2.domain() : config.axis_y2_default), axis.tick.y2 = axis.getTickValues("y2"), axis.y2 = axis.getAxis("y2", scale.y2, config.axis_y2_tick_outer, isInit));
    } else // update for arc
    $$.updateArc && $$.updateArc();
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_size = ({
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this,
        state = $$.state;
    state.currentWidth = $$.getCurrentWidth(), state.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $el.title && $el.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_" + axisId + "_axes"].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_" + axisId + "_axes"].length,
        axisWidth = $$.hasAxis ? $$.getAxisWidthByAxisId(axisId, withoutRecompute) : 0;
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        $$ = this,
        config = $$.config,
        legendWidthOnRight = $$.state.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2");
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : $$.axis && config.axis_rotated ? 10 + legendWidthOnRight : $$.axis && (!config.axis_y2_show || config.axis_y2_inner) ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : ceil10(axisWidth) + legendWidthOnRight, padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset" + capitalize(key), parent = this.$el.chart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.$el.chart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $el.main.select("." + leftAxisClass).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $el.chart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this;

    if ($$.axis) {
      var position = $$.axis && $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    }

    return 40;
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        rotatedPadding = _$$$state.rotatedPadding,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || isLegendRight || isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return rotatedPadding.top;
    var rotate = config["axis_" + id + "_tick_rotate"]; // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.axis.x.tickInterval());
  },
  updateDimension: function updateDimension(withoutAxis) {
    var $$ = this,
        config = $$.config,
        axis = $$.$el.axis;
    // pass 'withoutAxis' param to not animate at the init rendering
    $$.hasAxis && !withoutAxis && ($$.axis.x && config.axis_rotated ? ($$.axis.x.create(axis.x), $$.axis.subX && $$.axis.subX.create(axis.subX)) : ($$.axis.y && $$.axis.y.create(axis.y), $$.axis.y2 && $$.axis.y2.create(axis.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
  },
  updateSvgSize: function updateSvgSize() {
    var $$ = this,
        state = $$.state,
        svg = $$.$el.svg;

    if (svg.attr("width", state.currentWidth).attr("height", state.currentHeight), $$.hasAxis) {
      var brush = svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), svg.selectAll(["#" + state.clip.id, "#" + state.clip.idGrid]).select("rect").attr("width", state.width).attr("height", state.height), svg.select("#" + state.clip.idXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), svg.select("#" + state.clip.idYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), state.clip.idSubchart && svg.select("#" + state.clip.idSubchart).select("rect").attr("width", state.width).attr("height", brushSize.height), svg.select("." + config_classes.zoomRect).attr("width", state.width).attr("height", state.height);
    }
  },

  /**
   * Update size values
   * @param {Boolean} isInit If is called at initialization
   * @private
   */
  updateSizes: function updateSizes(isInit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        isRotated = config.axis_rotated,
        hasArc = $$.hasArcType(),
        currLegend = {
      width: legend ? $$.getLegendWidth() : 0,
      height: legend ? $$.getLegendHeight() : 0
    },
        legendHeightForBottom = state.isLegendRight || state.isLegendInset ? 0 : currLegend.height,
        xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
        subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
    // for main
    // for subchart
    // for legend
    // for arc
    isInit || $$.setContainerSize(), state.margin = isRotated ? {
      top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
    } : {
      top: 4 + $$.getCurrentPaddingTop(),
      // for top tick text
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: hasArc ? 0 : $$.getCurrentPaddingLeft()
    }, state.margin2 = isRotated ? {
      top: state.margin.top,
      right: NaN,
      bottom: 20 + legendHeightForBottom,
      left: $$.state.rotatedPadding.left
    } : {
      top: state.currentHeight - subchartHeight - legendHeightForBottom,
      right: NaN,
      bottom: subchartXAxisHeight + legendHeightForBottom,
      left: state.margin.left
    }, state.margin3 = {
      top: 0,
      right: NaN,
      bottom: 0,
      left: 0
    }, $$.updateSizeForLegend && $$.updateSizeForLegend(currLegend), state.width = state.currentWidth - state.margin.left - state.margin.right, state.height = state.currentHeight - state.margin.top - state.margin.bottom, state.width < 0 && (state.width = 0), state.height < 0 && (state.height = 0), state.width2 = isRotated ? state.margin.left - state.rotatedPadding.left - state.rotatedPadding.right : state.width, state.height2 = isRotated ? state.height : state.currentHeight - state.margin2.top - state.margin2.bottom, state.width2 < 0 && (state.width2 = 0), state.height2 < 0 && (state.height2 = 0), state.arcWidth = state.width - (state.isLegendRight ? currLegend.width + 10 : 0), state.arcHeight = state.height - (state.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && (state.arcHeight += state.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), state.isLegendRight && hasArc && (state.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/text.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_text = ({
  opacityForText: function opacityForText() {
    return this.hasDataLabel() ? "1" : "0";
  },

  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $el = this.$el;
    $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartTexts);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.$el.main.select("." + config_classes.chartTexts).selectAll("." + config_classes.chartText).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").style("opacity", "0").attr("class", classChartText).style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $el.text = $el.main.selectAll("." + config_classes.texts).selectAll("." + config_classes.text).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $el.text.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $el.text = $el.text.enter().append("text").merge($$.$el.text).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    return [$$.$el.text.each(function (d, i) {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x.bind(this)(d, i)).attr("y", y.bind(this)(d, i)).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    })];
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$" + text.replace(/\W/g, "_"),
        rect = $$.cache.get(cacheKey);
    return rect || ($$.$el.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.cache.add(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet" + capitalize(v) + "Points"](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {String} id Data id value
   * @param {String} type x | y
   * @return {Number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > state.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = state.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !state.hasPositiveValue && state.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @private
   * @param {number} id
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.$el.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 0);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @private
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.$el.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

function getTextPos(pos, width) {
  pos === void 0 && (pos = "left");
  var position,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
}

/* harmony default export */ var internals_title = ({
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.title_text) {
      $el.title = $el.svg.append("g");
      var text = $el.title.append("text").style("text-anchor", getTextPos(config.title_position)).attr("class", config_classes.title);
      setTextValue(text, config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this,
        config = $$.config,
        currentWidth = $$.state.currentWidth,
        title = $$.$el.title;

    if (title) {
      var y = $$.yForTitle.call($$);
      /g/i.test(title.node().tagName) ? title.attr("transform", "translate(" + getTextPos(config.title_position, currentWidth) + ", " + y + ")") : title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        currentWidth = $$.state.currentWidth,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.$el.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = currentWidth - textRectWidth, position.indexOf("right") >= 0 ? x = currentWidth - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = (currentWidth - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.$el.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_tooltip = ({
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($el.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $el.tooltip.empty() && ($el.tooltip = $el.chart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = parseDate.call($$, config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $el.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $el.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    var $$ = this,
        config = $$.config;
    return isFunction(config.tooltip_contents) ? config.tooltip_contents.bind($$.api).apply(void 0, arguments) : $$.getTooltipContent.apply($$, arguments);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        _map = ["title", "name", "value"].map(function (v) {
      var fn = config["tooltip_format_" + v];
      return isFunction(fn) ? fn.bind(api) : fn;
    }),
        titleFormat = _map[0],
        nameFormat = _map[1],
        valueFormat = _map[2];

    titleFormat = titleFormat || defaultTitleFormat, nameFormat = nameFormat || function (name) {
      return name;
    }, valueFormat = valueFormat || ($$.isStackNormalized() ? function (v, ratio) {
      return (ratio * 100).toFixed(2) + "%";
    } : defaultValueFormat);

    var order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.axis && $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order.bind(api));

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">" + title + "</th></tr>" : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(param))), $$.isAreaRangeType(row)) {
        var _map2 = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(param)));
        }),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> " + value + " <b>High:</b> " + high + " <b>Low:</b> " + low;
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(param))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:" + color + "\" width=\"10\" height=\"10\"></rect></svg>",
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return text + "</table>";
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">" + (this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>") + "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>").replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        isLegendRight = _$$$state.isLegendRight,
        inputType = _$$$state.inputType,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        left = _d3Mouse[0],
        top = _d3Mouse[1],
        chartRight = svgLeft + currentWidth - $$.getCurrentPaddingRight();

    // Determine tooltip position
    if (top += 20, $$.hasArcType()) {
      var raw = inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? height : height / 2, left += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = scale.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + 20, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + $$.getCurrentPaddingLeft(!0) + 20 + (scale.zoom ? left : dataScale));
    }

    var right = left + tWidth;
    return right > chartRight && (left -= right - chartRight + 20), top + tHeight > currentHeight && (top -= hasGauge ? tHeight * 3 : tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        tooltip = $$.$el.tooltip,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = tooltip.datum(),
          dataStr = JSON.stringify(selectedData),
          _ref = datum || {},
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 0 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 0 : _ref$height;

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$.api, selectedData), tooltip.html($$.getTooltipHTML(selectedData, $$.axis && $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum({
          index: index,
          current: dataStr,
          width: width = tooltip.property("offsetWidth"),
          height: height = tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        var unit,
            fn = config.tooltip_position;
        isFunction(fn) ? fn = fn.bind($$.api) : (unit = fn && fn.unit, fn = $$.tooltipPosition.bind($$));
        // Get tooltip dimensions
        var pos = fn(dataToShow, width, height, element);
        ["top", "left"].forEach(function (v) {
          var value = pos[v]; // when value is number

          if (/^\d+(\.\d+)?$/.test(value)) {
            if (unit === "%") {
              var size = state[v === "top" ? "currentHeight" : "currentWidth"];
              value = value / size * 100;
            } else unit = "px";

            value += unit;
          }

          tooltip.style(v, value);
        });
      }
    }
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        config = $$.config,
        tooltip = $$.$el.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, $$.api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, $$.api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this,
        charts = $$.charts,
        config = $$.config;

    if (config.tooltip_linked && charts.length > 1) {
      var linkedName = config.tooltip_linked_name;
      charts.forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.$el.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/transform.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_transform = ({
  getTranslate: function getTranslate(target, index) {
    index === void 0 && (index = 0);
    var x,
        y,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        hasGauge = $$.hasType("gauge"),
        padding = 0;
    if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel(state.margin.left), y = asHalfPixel(state.margin.top);else if (target === "context") x = asHalfPixel(state.margin2.left), y = asHalfPixel(state.margin2.top);else if (target === "legend") x = state.margin3.left, y = state.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : state.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? state.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : state.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subX") x = 0, y = isRotated ? 0 : state.height2;else if (target === "arc") x = state.arcWidth / 2, y = state.arcHeight / 2;else if (target === "radar") {
      var _$$$getRadarSize = $$.getRadarSize(),
          width = _$$$getRadarSize[0];

      x = state.width / 2 - width, y = asHalfPixel(state.margin.top);
    }
    return "translate(" + x + ", " + y + ")";
  },
  transformMain: function transformMain(withTransition, transitions) {
    var xAxis,
        yAxis,
        y2Axis,
        $$ = this,
        main = $$.$el.main;
    transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = main.select("." + config_classes.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = main.select("." + config_classes.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = main.select("." + config_classes.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? main.transition() : main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), main.select("." + config_classes.chartArcs).attr("transform", $$.getTranslate("arc"));
  },
  transformAll: function transformAll(withTransition, transitions) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.transformMain(withTransition, transitions), $$.hasAxis && config.subchart_show && $$.transformContext(withTransition, transitions), $el.legend && $$.transformLegend(withTransition);
  }
});
// CONCATENATED MODULE: ./src/config/const.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// defined chart types as category
var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
// CONCATENATED MODULE: ./src/ChartInternal/internals/type.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_type = ({
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config,
        withoutFadeIn = $$.state.withoutFadeIn;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        config = $$.config,
        types = config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @parma {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets, exclude) {
    var _this = this;

    return exclude === void 0 && (exclude = []), !TYPES[type] // @ts-ignore
    .filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String|Array} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },
  hasPointType: function hasPointType() {
    var $$ = this;
    return $$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter");
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

function setMinMax($$, type, value) {
  var config = $$.config,
      axisY = "axis_y_" + type,
      axisY2 = "axis_y2_" + type;
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config["axis_x_" + type] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
}
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


function axis_getMinMax($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_" + type],
    y: config["axis_y_" + type],
    y2: config["axis_y2_" + type]
  };
}
/**
 * Define axis
 * @ignore
 */


var api_axis_axis = {
  /**
   * Get and set axis labels.
   * @method axislabels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axismin
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return isValue(_min) ? setMinMax($$, "min", _min) : axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axismax
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axisrange
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
};
/* harmony default export */ var api_axis = ({
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/Chart/api/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var category = ({
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_flow = ({
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [datajson](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [datarows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [datacolumns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? parseDate.call($$, args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
});
// CONCATENATED MODULE: ./src/Chart/api/grid.x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

function xgrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
}

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});
/* harmony default export */ var grid_x = ({
  xgrids: xgrids
});
// CONCATENATED MODULE: ./src/Chart/api/grid.y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */

function ygrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  if (!grids) return config.grid_y_lines;
  config.grid_y_lines = grids;

  http: //jindo.com/git/billboard.js/demo/work/chart.html
  $$.redrawWithoutRescale();

  return config.grid_y_lines;
}

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
});
/* harmony default export */ var grid_y = ({
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/Chart/api/group.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var group = ({
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/regions.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

function regions_regions(regions) {
  var $$ = this.internal,
      config = $$.config;
  return regions ? (config.regions = regions, $$.redrawWithoutRescale(), regions) : config.regions;
}

extend(regions_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regionsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regionsremove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.$el.main.select("." + config_classes.regions).selectAll(classes.map(function (c) {
      return "." + c;
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region.class || (region.class.split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
});
/* harmony default export */ var api_regions = ({
  regions: regions_regions
});
// CONCATENATED MODULE: ./src/Chart/api/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var api_selection = ({
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.$el.main.selectAll("." + (config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + config_classes.shape).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable.bind($$.api)(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable.bind($$.api)(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_x = ({
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? this.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? this.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(44);

// CONCATENATED MODULE: ./src/Chart/api/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

function withinRange(domain, range) {
  var min = range[0],
      max = range[1];
  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
}

/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */
var zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      config = $$.config,
      scale = $$.scale,
      domain = domainValue;

  if (config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries) {
      var fn = parseDate.bind($$);
      domain = domain.map(function (x) {
        return fn(x);
      });
    }

    if (config.subchart_show) {
      var xScale = scale.zoom || scale.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else scale.x.domain(domain), scale.zoom = scale.x, $$.axis.x.scale(scale.zoom), resultDomain = scale.zoom.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn(config.zoom_onzoom, $$.api, resultDomain);
  } else resultDomain = scale.zoom ? scale.zoom.domain() : scale.x.orgDomain();

  return resultDomain;
};

extend(zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoomenable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable(enabled) {
    var $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoommax
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [xDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoommin
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [xDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoomrange
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range) {
    var zoom = this.zoom;

    if (isObject(_range)) {
      var min = _range.min,
          max = _range.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
});
/* harmony default export */ var api_zoom = ({
  zoom: zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.scale.zoom) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.$el.main.select("." + config_classes.eventRects);
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/drag.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var interactions_drag = ({
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _state$dragStart = state.dragStart,
            sx = _state$dragStart[0],
            sy = _state$dragStart[1],
            mx = mouse[0],
            my = mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? state.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? state.height : Math.max(sy, my);
        main.select("." + config_classes.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).filter(function (d) {
          return config.data_selection_isselectable.bind($$.api)(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = +shape.attr("cx") * 1,
                y = +shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return; // @ts-ignore


          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (state.dragStart = mouse, main.select("." + config_classes.chart).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (main.select("." + config_classes.dragarea).transition().duration(100).style("opacity", "0").remove(), main.selectAll("." + config_classes.shape).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(45);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_flow = ({
  /**
   * Generate flow
   * @param {Object} args
   * @return {Function}
      * @private
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        data = $$.data,
        state = $$.state,
        $el = $$.$el;
    return function () {
      var flowLength = args.flow.length; // set flag

      state.flowing = !0, data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      }), $$.updateXGrid && $$.updateXGrid(!0);
      // target elements
      var elements = {};
      ["axis.x", "grid.x", "gridLines.x", "region.list", "text", "bar", "line", "area", "circle"].forEach(function (v) {
        var name = v.split("."),
            node = $el[name[0]];
        node && name.length > 1 && (node = node[name[1]]), node && node.size() && (elements[v] = node);
      }), $$.hideGridFocus(), $$.setFlowList(elements, args);
    };
  },

  /**
   * Set flow list
   * @param elements {Object} Target elements
   * @param args {Object}
   * @private
   */
  setFlowList: function setFlowList(elements, args) {
    var $$ = this,
        flow = args.flow,
        targets = args.targets,
        _flow = flow,
        _flow$duration = _flow.duration,
        duration = _flow$duration === void 0 ? args.duration : _flow$duration,
        flowIndex = _flow.index,
        flowLength = _flow.length,
        orgDataCount = _flow.orgDataCount,
        transform = $$.getFlowTransform(targets, orgDataCount, flowIndex, flowLength),
        wait = $$.generateWait(),
        gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(duration);
    wait.add(Object.keys(elements).map(function (v) {
      var n = elements[v];
      return n = v === "axis.x" ? n.transition(gt).call(function (g) {
        return $$.axis.x.setTransition(gt).create(g);
      }) : v === "region.list" ? n.filter($$.isRegionOnX).transition(gt).attr("transform", transform) : n.transition(gt).attr("transform", transform), n;
    })), gt.call(wait, function () {
      $$.cleanUpFlow(elements, args);
    });
  },

  /**
   * Clean up flow
   * @param elements {Object} Target elements
   * @param args {Object}
   * @private
   */
  cleanUpFlow: function cleanUpFlow(elements, args) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        isRotated = config.axis_rotated,
        flow = args.flow,
        shape = args.shape,
        xv = args.xv,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        _flow2 = flow,
        _flow2$done = _flow2.done,
        done = _flow2$done === void 0 ? function () {} : _flow2$done,
        flowLength = _flow2.length;
    // draw again for removing flowed elements and reverting attr
    // callback for end of flow
    flowLength && (["circle", "text", "shape", "eventRect"].forEach(function (v) {
      var target = [];

      for (var i = 0; i < flowLength; i++) target.push("." + config_classes[v] + "-" + i);

      svg.selectAll("." + config_classes[v + "s"]) // circles, shapes, texts, eventRects
      .selectAll(target).remove();
    }), svg.select("." + config_classes.xgrid).remove()), Object.keys(elements).forEach(function (v) {
      var n = elements[v];
      if (v !== "axis.x" && n.attr("transform", null), v === "grid.x") n.attr(state.xgridAttr);else if (v === "gridLines.x") n.attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv);else if (v === "gridLines.x") n.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv), n.select("text").attr("x", isRotated ? state.width : 0).attr("y", xv);else if (/^(area|bar|line)$/.test(v)) n.attr("d", shape.type[v]);else if (v === "text") n.attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$));else if (v !== "circle") v === "region.list" && n.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));else if ($$.isCirclePoint()) n.attr("cx", cx).attr("cy", cy);else {
        var xFunc = function (d) {
          return cx(d) - config.point_r;
        },
            yFunc = function (d) {
          return cy(d) - config.point_r;
        };

        n.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
        .attr("cy", cy);
      }
    }), config.interaction_enabled && $$.redrawEventRect(), done.call($$.api), state.flowing = !1;
  },

  /**
   * Get flow transform value
   * @param targets
   * @param orgDataCount
   * @param flowIndex
   * @param flowLength
   * @return {String}
   * @private
   */
  getFlowTransform: function getFlowTransform(targets, orgDataCount, flowIndex, flowLength) {
    var translateX,
        $$ = this,
        data = $$.data,
        x = $$.scale.x,
        dataValues = data.targets[0].values,
        flowStart = $$.getValueOnIndex(dataValues, flowIndex),
        flowEnd = $$.getValueOnIndex(dataValues, flowIndex + flowLength),
        orgDomain = x.domain(),
        domain = $$.updateXDomain(targets, !0, !0);
    orgDataCount ? orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = x(orgDomain[0]) - x(domain[0]) : translateX = $$.isTimeSeries() ? x(orgDomain[0]) - x(domain[0]) : x(flowStart.x) - x(flowEnd.x) : dataValues.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex(dataValues, 0), flowEnd = $$.getValueOnIndex(dataValues, dataValues.length - 1), translateX = x(flowStart.x) - x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = x(orgDomain[0]) - x(domain[0]);
    var scaleX = diffDomain(orgDomain) / diffDomain(domain);
    return "translate(" + translateX + ",0) scale(" + scaleX + ",1)";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/eventrect.ts
/**
* Copyright (c) 2017 ~ present NAVER Corp.
* billboard.js project is licensed under the MIT license
*/




/* harmony default export */ var eventrect = ({
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.$el.main.select("." + config_classes.eventRects).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll("." + config_classes.eventRect).remove(), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), isMultipleX) eventRectUpdate = $el.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $el.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), eventRectUpdate = $el.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $el.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.state.inputType !== "touch" || $el.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + config_classes.eventRect + "-?|s)", "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if (state.dragging || state.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || state.cancelClick) && state.cancelClick && (state.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        xScale = scale.zoom || scale.x,
        eventRectData = eventRectUpdate || $$.$el.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = state.width, h = state.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? state.height : state.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? state.width : rectW, h = isRotated ? rectW : state.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || main.selectAll("." + config_classes.shape + "-" + index).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable.bind($$.api)(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if (state.mouseover && (!closest || closest.id !== state.mouseover.id) && (config.data_onout.call($$.api, state.mouseover), state.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.$el.svg.select("." + config_classes.eventRect).style("cursor", "pointer"), !state.mouseover && (config.data_onover.call($$.api, closest), state.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.$el.svg.select("." + config_classes.eventRect).style("cursor", null), $$.hideGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return state.inputType === "mouse" && rect.on("mouseover", function (d) {
      state.dragging || state.flowing || $$.hasArcType() || config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!(state.dragging || state.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.$el.svg.select("." + config_classes.eventRect + "-" + index);
        $$.isStepType(d) && config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.scale.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    if ($$.hasArcType() || !$$.toggleShape || state.cancelClick) return void (state.cancelClick && (state.cancelClick = !1));
    var index = d.index;
    main.selectAll("." + config_classes.shape + "-" + index).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.bind($$.api)(d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        inputType = _$$$state.inputType,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.$el.main.selectAll("." + config_classes.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + config_classes.shape + "-" + closest.index).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.bind($$.api)(closest, this));
      });
    } // select if selection enabled

  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_subchart = ({
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        subchart = $$.$el.subchart,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.$el.svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.state.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = scale.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map(scale.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && subchart.main && subchart.main.select("." + config_classes.brush).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return (// @ts-ignore
        subchart.main ? subchart.main.select("." + config_classes.brush) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([])
      );
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this;

    if ($$.hasAxis) {
      var config = $$.config,
          clip = $$.state.clip,
          _$$$$el = $$.$el,
          defs = _$$$$el.defs,
          svg = _$$$$el.svg,
          subchart = _$$$$el.subchart,
          axis = _$$$$el.axis,
          visibility = config.subchart_show ? "visible" : "hidden",
          clipId = clip.id + "-subchart",
          clipPath = $$.getClipPath(clipId);
      clip.idSubchart = clipId, $$.appendClip(defs, clipId), $$.initBrush(), subchart.main = svg.append("g").attr("transform", $$.getTranslate("context"));
      var main = subchart.main;
      main.style("visibility", visibility), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars), main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), axis.subX = main.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subX")).attr("clip-path", config.axis_rotated ? "" : clip.pathXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
    }
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.subchart.main,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var barUpdate = main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", classChartBar),
          barEnter = barUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(barUpdate);
      barEnter.append("g").attr("class", classBars);
      // -- Line --//
      var lineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", classChartLine),
          lineEnter = lineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(lineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      lineEnter.append("g").attr("class", classLines), $$.hasType("area") && lineEnter.append("g").attr("class", classAreas), main.selectAll("." + config_classes.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? state.width2 : state.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.bar = subchart.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data($$.barData.bind($$)), subchart.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.bar = subchart.bar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge(subchart.bar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var bar = this.$el.subchart.bar;
    (withTransition ? bar.transition(getRandom()).duration(duration) : bar).attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.line = subchart.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), subchart.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.line = subchart.line.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge(subchart.line).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var line = this.$el.subchart.line;
    (withTransition ? line.transition(getRandom()).duration(duration) : line).attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.area = subchart.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), subchart.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.area = subchart.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge(subchart.area).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var area = this.$el.subchart.area;
    (withTransition ? area.transition(getRandom()).duration(duration) : area).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.state.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.subchart.main;
    main.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw" + name](shape.indices[v], !0);
      $$["update" + name + "ForSubchart"](duration), $$["redraw" + name + "ForSubchart"](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this,
        _$$$config = $$.config,
        subchart_onbrush = _$$$config.subchart_onbrush,
        withY = _$$$config.zoom_rescale,
        scale = $$.scale;
    $$.redraw({
      withTransition: !1,
      withY: withY,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), subchart_onbrush.bind($$.api)(scale.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this,
        main = $$.$el.subchart.main;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = main.select("." + config_classes.axisX), withTransition && (subXAxis = subXAxis.transition())), main.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subX"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        extent = config.axis_x_extent;
    if (extent) if (isFunction(extent)) extent = extent.bind($$.api)($$.getXDomain($$.data.targets), scale.subX);else if ($$.isTimeSeries() && extent.every(isNaN)) {
      var fn = parseDate.bind($$);
      extent = extent.map(function (v) {
        return scale.subX(fn(v));
      });
    }
    return extent;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var interactions_zoom = ({
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.scale.zoom = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent(bind) {
    bind === void 0 && (bind = !0);
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        zoomEnabled = config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = main.select("." + config_classes.eventRects);
    zoomEnabled && bind ? !config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent
    // @ts-ignore
    // @ts-ignore

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    // @ts-ignore
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      org.xScale && org.xScale.range(scale.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"](org.xScale || scale.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, org.xDomain), scale.zoom = $$.getCustomizedScale(newScale), $$.axis.x.scale(scale.zoom), rescale && (!org.xScale && (org.xScale = scale.x.copy()), scale.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        org = $$.org,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && (scale.zoom || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && scale.x.domain().every(function (v, i) {
        return v !== org.xDomain[i];
      }) && scale.x.domain(org.xDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && scale.x.orgDomain()[0] === org.xDomain[0] && scale.x.domain([org.xDomain[0] - 1e-10, scale.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.state.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, scale.zoom.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn(config.zoom_onzoomend, $$.api, scale[scale.zoom ? "zoom" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _org$xDomain = org.xDomain,
        min = _org$xDomain[0],
        max = _org$xDomain[1];
    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this,
        _$$$scale = $$.scale,
        subX = _$$$scale.subX,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom;

    if (zoom) {
      var zoomDomain = zoom.domain(),
          xDomain = subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.axis.x.scale(subX), x.domain(subX.orgDomain()), zoom = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var zoomRect,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      // @ts-ignore
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.$el.main.append("rect").attr("clip-path", state.clip.path).attr("class", config_classes.zoomBrush).attr("width", isRotated ? state.width : 0).attr("height", isRotated ? 0 : state.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      // @ts-ignore
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.scale.zoom || $$.scale.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event3 = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event3 ? [_event3.clientX, _event3.clientY] : [_event3.x, _event3.y],
            x = _ref2[0],
            y = _ref2[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.$el.chart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick.bind($$.api)(this), $$.api.unzoom();
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var internals_category = ({
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var categories = this.config.axis_x_categories;
    return i < categories.length ? categories[i] : i;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/clip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_clip = ({
  initClip: function initClip() {
    var $$ = this,
        clip = $$.state.clip;
    // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
    // Define 'clip-path' attribute values
    clip.id = $$.state.datetimeId + "-clip", clip.idXAxis = clip.id + "-xaxis", clip.idYAxis = clip.id + "-yaxis", clip.idGrid = clip.id + "-grid", clip.path = $$.getClipPath(clip.id), clip.pathXAxis = $$.getClipPath(clip.idXAxis), clip.pathYAxis = $$.getClipPath(clip.idYAxis), clip.pathGrid = $$.getClipPath(clip.idGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(" + (isIE9 ? "" : browser_doc.URL.split("#")[0]) + "#" + id + ")";
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    var margin = this.state.margin,
        left = Math.max(30, margin.left); // axis line width + padding for left

    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    var margin = this.state.margin;
    return forHorizontal ? -20 : -margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        _$$$state = $$.state,
        margin = _$$$state.margin,
        width = _$$$state.width,
        left = Math.max(30, margin.left),
        right = Math.max(30, margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? width + 2 + left + right : margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    var _this$state = this.state,
        margin = _this$state.margin,
        height = _this$state.height; // less than 20 is not enough to show the axis label 'outer' without legend

    return (forHorizontal ? margin.bottom : margin.top + height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
};

function getGridTextX(isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
}

function smoothLines(el, type) {
  type === "grid" && el.each(function () {
    var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
    ["x1", "x2", "y1", "y2"].forEach(function (v) {
      return g.attr(v, Math.ceil(+g.attr(v)));
    });
  });
}

/* harmony default export */ var internals_grid = ({
  initGrid: function initGrid() {
    var $$ = this;
    $$.initGridLines(), $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        _$$$$el = $$.$el,
        gridLines = _$$$$el.gridLines,
        main = _$$$$el.main;
    (config.grid_x_lines.length || config.grid_y_lines.length) && (gridLines.main = main.insert("g", "." + config_classes.chart + (config.grid_lines_front ? " + *" : "")).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid + " " + config_classes.gridLines), gridLines.main.append("g").attr("class", config_classes.xgridLines), gridLines.main.append("g").attr("class", config_classes.ygridLines), gridLines.x = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        _$$$$el2 = $$.$el,
        main = _$$$$el2.main,
        grid = _$$$$el2.grid,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, scale.x),
        tickOffset = $$.isCategorized() ? $$.axis.x.tickOffset() : 0,
        pos = function (d) {
      return ((scale.zoom || scale.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    state.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": state.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": state.height
    }, grid.x = main.select("." + config_classes.xgrids).selectAll("." + config_classes.xgrid).data(xgridData), grid.x.exit().remove(), grid.x = grid.x.enter().append("line").attr("class", config_classes.xgrid).merge(grid.x), withoutUpdate || grid.x.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys(state.xgridAttr).forEach(function (id) {
        grid.attr(id, state.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? state.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el3 = $$.$el,
        grid = _$$$$el3.grid,
        main = _$$$$el3.main,
        isRotated = config.axis_rotated,
        gridValues = $$.axis.y.tickValues() || $$.scale.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.scale.y(d));
    };

    grid.y = main.select("." + config_classes.ygrids).selectAll("." + config_classes.ygrid).data(gridValues), grid.y.exit().remove(), grid.y = grid.y.enter().append("line").attr("class", config_classes.ygrid).merge(grid.y), grid.y.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : state.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? state.height : pos), smoothLines(grid.y, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this,
        _$$$$el4 = $$.$el,
        grid = _$$$$el4.grid,
        gridLines = _$$$$el4.gridLines;
    // hide if arc type
    gridLines.main || $$.initGridLines(), grid.main.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$$el5 = $$.$el,
        gridLines = _$$$$el5.gridLines,
        main = _$$$$el5.main,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid();
    var xLines = main.select("." + config_classes.xgridLines).selectAll("." + config_classes.xgridLine).data(config.grid_x_lines); // exit

    xLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = xLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), xLines = xgridLine.merge(xLines), xLines.attr("class", function (d) {
      return (config_classes.xgridLine + " " + (d.class || "")).trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), gridLines.x = xLines;
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid();
    var ygridLines = $el.main.select("." + config_classes.ygridLines).selectAll("." + config_classes.ygridLine).data(config.grid_y_lines); // exit

    ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), ygridLines = ygridLine.merge(ygridLines);
    // update
    var yv = $$.yv.bind($$);
    ygridLines.attr("class", function (d) {
      return (config_classes.ygridLine + " " + (d.class || "")).trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? height : yv).transition().style("opacity", "1"), ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, width, height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.gridLines.y = ygridLines;
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        gridLines = $$.$el.gridLines,
        xv = $$.xv.bind($$),
        lines = gridLines.x.select("line"),
        texts = gridLines.x.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, width, height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        isFront = config.grid_front,
        className = "." + config_classes[isFront && $el.grid.main ? "gridLines" : "chart"] + (isFront ? " + *" : ""),
        grid = $el.grid.main = $el.main.insert("g", className).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid);
    config.grid_x_show && grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && (grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} selectedData
   * @private
   */
  showGridFocus: function showGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        _$$$state3 = $$.state,
        width = _$$$state3.width,
        height = _$$$state3.height,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var focusEl = $$.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus),
          isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScale(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), smoothLines(focusEl, "grid");
    }
  },
  hideGridFocus: function hideGridFocus() {
    this.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus).style("visibility", "hidden");
  },
  updategridFocus: function updategridFocus() {
    var $$ = this,
        _$$$state4 = $$.state,
        width = _$$$state4.width,
        height = _$$$state4.height,
        isRotated = $$.config.axis_rotated;
    $$.$el.main.select("line." + config_classes.xgridFocus).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : height);
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.$el.main.select("." + config_classes.axisX).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.$el.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/region.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection



/* harmony default export */ var region = ({
  initRegion: function initRegion() {
    var $$ = this,
        $el = $$.$el;
    $el.region.main = $el.main.append("g").attr("clip-path", $$.state.clip.path).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $el.region.main.style("visibility", $$.hasArcType() ? "hidden" : "visible");
    // select <g> element
    var list = $el.main.select("." + config_classes.regions).selectAll("." + config_classes.region).data(config.regions);
    list.exit().transition().duration(duration).style("opacity", "0").remove(), list = list.enter().append("g").merge(list).attr("class", $$.classRegion.bind($$)), list.append("rect").style("fill-opacity", "0"), $el.region.list = list;
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.$el.region.list.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], pos = currScale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, pos = currScale($$.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = state[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], end = currScale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, end = currScale($$.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/ChartInternal/internals/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_selection = ({
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    // remove selected-circle from low layer g
    callFn(config.data_onunselected, $$.api, d, target.node()), $el.main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = (selected ? "" : "un") + "selectPoint";
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this[(selected ? "" : "un") + "selectPath"](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable.bind($$.api)(d)) {
      if (!config.data_selection_multiple) {
        var selector = "." + config_classes.shapes;
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), main.selectAll(selector).selectAll("." + config_classes.shape).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_shape_bar = ({
  initBar: function initBar() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.bar || $$.initBar();
    var mainBarUpdate = $$.$el.main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        $el = $$.$el,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $el.bar = $el.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data(barData), $el.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.bar = $el.bar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($el.bar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    var bar = this.$el.bar;
    return [(withTransition ? bar.transition(getRandom()) : bar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = config.data_groups.length,
        tickInterval = (scale.zoom || $$) && !$$.isCategorized() ? $$.xx(scale.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        main = $$.$el.main,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? main.selectAll("." + config_classes.bars + $$.getTargetSelectorSuffix(id)) : main).selectAll("." + config_classes.bar + suffix);
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a" + radius + "," + radius + " " + (isNegative ? "1 0 0" : "0 0 1") + " ";
        pathRadius[+!isRotated] = "" + arc + radius + "," + radius, pathRadius[+isRotated] = "" + arc + [-radius, radius][isRotated ? "sort" : "reverse"](), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H" + (points[1][indexX] - radius) + " " + pathRadius[0] + "V" + (points[2][indexY] - radius) + " " + pathRadius[1] + "H" + points[3][indexX] : "V" + (points[1][indexY] + (isNegative ? -radius : radius)) + " " + pathRadius[0] + "H" + (points[2][indexX] - radius) + " " + pathRadius[1] + "V" + points[3][indexY];
      return "M" + points[0][indexX] + "," + points[0][indexY] + path + "z";
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        axis = isSub ? $$.axis.subX : $$.axis.x,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list = list,
        seg0 = _list[0],
        seg1 = _list[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var shape_bubble = ({
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        axis = $$.$el.axis,
        cacheKey = "$baseLength",
        baseLength = $$.cache.get(cacheKey);
    return baseLength || $$.cache.add(cacheKey, baseLength = getMinMax("min", [axis.x.select("path").node().getTotalLength(), axis.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR.bind($$.api)(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {Object|Array} d data value
   * @param {String} type - y or z
   * @return {Number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {Object|array} d data value
   * @return {Boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/ChartInternal/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_line = ({
  initLine: function initLine() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        $el = $$.$el,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.line || $$.initLine();
    var mainLineUpdate = $el.main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    mainLineEnter.append("g").attr("class", classLines), $$.hasTypeOf("Area") && mainLineEnter.append("g").attr("class", $$.classAreas.bind($$));
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this,
        extraLineClasses = $$.format.extraLineClasses,
        $el = $$.$el;
    $el.line = $el.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $el.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.line = $el.line.enter().append("path").attr("class", function (d) {
      return $$.classLine.bind($$)(d) + " " + (extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($el.line).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    var line = this.$el.line;
    return [(withTransition ? line.transition(getRandom()) : line).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? scale.subX : scale.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? parseDate.call($$, v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M" + points[0][0] + "," + points[0][1] + "L" + points[1][0] + "," + points[1][1];
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "" + (_i && hasPrevData ? "L" : "M") + xValue(data) + "," + yValue(data);else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1].bind($$.api)(d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : 0);
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_point = ({
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  initialOpacityForCircle: function initialOpacityForCircle(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
  },
  opacityForCircle: function opacityForCircle(d) {
    var opacity = this.config.point_show ? "1" : "0";
    return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
  },
  initCircle: function initCircle() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.point = $$.generatePoint(), config.point_show && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartCircles);
  },
  updateTargetForCircle: function updateTargetForCircle(t) {
    var $$ = this,
        config = $$.config,
        data = $$.data,
        $el = $$.$el,
        targets = t || data.targets,
        classCircles = $$.classCircles.bind($$);
    !$el.circle && config.point_show && $$.initCircle();
    var mainCircle = $el.main.select("." + config_classes.chartCircles).style("pointer-events", "none").selectAll("." + config_classes.circles).data(targets).attr("class", classCircles),
        mainCircleEnter = mainCircle.enter();
    // Circles for each data point on lines
    // Update date for selected circles
    config.data_selection_enabled && mainCircleEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainCircleEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }), targets.forEach(function (t) {
      $el.main.selectAll("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + config_classes.selectedCircle).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateCircle: function updateCircle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.point_show) {
      var circles = $el.main.selectAll("." + config_classes.circles).selectAll("." + config_classes.circle).data(function (d) {
        return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
      });
      circles.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      $el.circle = circles.enter().append(fn).merge(circles).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$));
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        rendered = $$.state.rendered,
        _$$$$el = $$.$el,
        circle = _$$$$el.circle,
        main = _$$$$el.main,
        selectedCircles = main.selectAll("." + config_classes.selectedCircle);
    if (!$$.config.point_show) return [];
    var fn = $$.point("update", $$, cx, cy, $$.color, withTransition, flow, selectedCircles),
        posAttr = $$.isCirclePoint() ? "c" : "",
        t = getRandom(),
        opacityStyleFn = $$.opacityForCircle.bind($$),
        mainCircles = [];
    return circle.each(function (d) {
      var result = fn.bind(this)(d);
      result = (withTransition || !rendered ? result.transition(t) : result).style("opacity", opacityStyleFn), mainCircles.push(result);
    }), [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && zoom ? hasValue ? zoom(d.x) : null : hasValue ? x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? $$.$el.main.selectAll("." + config_classes.circles + $$.getTargetSelectorSuffix(id)) : $$.$el.main).selectAll("." + config_classes.circle + suffix);
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(" + x + " " + y + ") scale(" + scale + ")");
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(" + r(circles) / $$.config.point_r + ")");
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR.bind($$.api)(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr(prefix + "x"),
        cy = +element.attr(prefix + "y");

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _getBoundingRect = getBoundingRect(node),
          x = _getBoundingRect.x,
          y = _getBoundingRect.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.$el.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.$el.defs.select("#" + id);
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        circle = $$.$el.circle,
        pointClass = !1;
    return (isObject(d) || circle) && (pointClass = d === !0 ? circle.attr("class", $$.classCircle.bind($$)) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = datetimeId + "-point-" + id,
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#" + id).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/shape.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_shape = ({
  /**
   * Get the shape draw function
   * @return {Object}
   * @private
   */
  getDrawShape: function getDrawShape() {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        hasRadar = $$.hasRadar,
        shape = {
      type: {},
      indices: {},
      pos: {}
    };

    // setup drawer - MEMO: these must be called after axis updated
    if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
      var indices = $$.getShapeIndices($$.isLineType);

      if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
        var _indices = $$.getShapeIndices($$.isAreaType);

        shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
      }
    }

    if ($$.hasType("bar")) {
      var _indices2 = $$.getShapeIndices($$.isBarType);

      shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
    }

    return (!$$.hasArcType() || hasRadar) && (shape.pos = {
      xForText: $$.generateXYForText(shape.indices, !0),
      yForText: $$.generateXYForText(shape.indices, !1),
      // generate circle x/y functions depending on updated params
      cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
      cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
    }), shape;
  },
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {Object} indices Indices object
   * @param {String} id Data id value
   * @return {Object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {Object} indices Indices object
   * @return {Number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        currScale = isSub ? scale.subX : scale.zoom || scale.x,
        barPadding = config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = currScale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(value);
    };
  },

  /**
   * Get Shape's offset data
   * @param {function(Object): boolean} typeFilter
   * @return {{shapeOffsetTargets: ShapeOffsetTarget[], indexMapByTargetId: object}}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values;
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var rowValueMapByXValue = rowValues.reduce(function (out, value) {
        return out[+value.x] = value, out;
      }, {}),
          values = rowValues.map($$.isStackNormalized() ? function (v) {
        return $$.getRatio("index", v, !0);
      } : function (_ref) {
        var value = _ref.value;
        return value;
      });
      return {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref2, index) {
      var id = _ref2.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale(0),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.forEach(function (t) {
        var rowValues = t.rowValues,
            values = t.values;

        if (t.id !== d.id && ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var _rowValue = rowValues[idx]; // check if the x values line up

          _rowValue && +_rowValue.x === dataXAsNumber || (_rowValue = t.rowValueMapByXValue[dataXAsNumber]), _rowValue && _rowValue.value * d.value >= 0 && (offset += scale(values[_rowValue.index]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        config = $$.config,
        type = config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? config.line_step_type : "linear";
  }
});
// CONCATENATED MODULE: ./src/config/resolver/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Axis based chart
 */
// Chart









 // ChartInternal
















/* harmony default export */ var resolver_axis = ({
  api: [api_axis, category, api_flow, grid_x, grid_y, group, api_regions, api_selection, api_x, api_zoom],
  internal: [internals_category, interactions_drag, interactions_flow, interactions_subchart, interactions_zoom, internals_clip, internals_grid, region, internals_selection, eventrect, ChartInternal_shape_bar, shape_bubble, ChartInternal_shape_line, shape_point, shape_shape]
});
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/ChartInternal/shape/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var shape_arc = ({
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config[dataType + "_startingAngle"] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config[dataType + "_padAngle"]) || 0,
        sortValue = $$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues(sortValue).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    state.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), state.radius = state.radiusExpanded * .95, state.innerRadiusRatio = w ? (state.radius - w) / state.radius : .6, state.gaugeArcWidth = w || (gaugeArcWidth <= state.radius - state.innerRadius ? state.radius - state.innerRadius : gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius);
    var innerRadius = radius || (padding ? padding * (state.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    state.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? state.radius * state.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        innerRadius = $$.state.innerRadius;
    return !isNumber(innerRadius) && d && (innerRadius = innerRadius[d.data.id] || 0), innerRadius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data)) {
      var totalSum = $$.getTotalDataSum(); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        state = $$.state,
        ir = $$.getInnerRadius(),
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index : state.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        state = $$.state,
        newRate = rate || 1,
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min(state.radiusExpanded * newRate - state.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index + expandWidth : state.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : state.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        radius = _$$$state.radius,
        radiusExpanded = _$$$state.radiusExpanded,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * (radiusExpanded + 25),
          y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(" + x + "," + y + ")";
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio.bind($$.api)(d, radius, h) : ratio : radius && (h ? (36 / radius > .375 ? 1.175 - 36 / radius : .8) * radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")";
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this;
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          value = updated ? updated.value : d.value,
          ratio = $$.getRatio("arc", updated),
          id = d.data.id,
          hasGauge = $$.hasType("gauge"),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      }
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var $$ = this,
        config = $$.config,
        format = config.gauge_label_extents;
    return isFunction(format) ? format.bind($$.api)(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        $el = $$.$el;

    // MEMO: avoid to cancel transition
    if (transiting) {
      var interval = setInterval(function () {
        transiting || (clearInterval(interval), $el.legend.selectAll("." + config_classes.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $el.svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        svg = $$.$el.svg;

    if (!transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), svg.selectAll("" + config_classes.arc).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {String} id data ID
   * @param {String} key config key: 'duration | rate'
   * @return {Number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config[type + "_expand_" + key] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config[v + "_label_show"];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), isFunction(format) ? format.bind($$.api) : format;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config[type + "_title"] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.$el.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select("." + config_classes.chartArcs).selectAll("." + config_classes.chartArc).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this,
        $el = $$.$el;
    $el.arcs = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.$el.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arc).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      state.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      state.transiting = !1, callFn(config.onrendered, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        arcLabelLines = $el.main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arcLabelLine).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return config_classes.arcLabelLine + " " + config_classes.target + " " + config_classes.target + "-" + d.data.id;
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if (hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = state.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = state.radiusExpanded - state.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        isMouse = state.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), config.data_onclick.bind($$.api)(arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!state.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.$el.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        arcs = _$$$$el.arcs,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll("." + config_classes.chartArc).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? Math.round(state.radius / 5) + "px" : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select("." + config_classes.chartArcsTitle).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "" + Math.round(state.radius / 14));
      var backgroundArc = $$.$el.arcs.select((hasMultiArcGauge ? "g" : "") + "." + config_classes.chartArcsBackground);

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path." + config_classes.chartArcsBackground).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return config_classes.chartArcsBackground + " " + config_classes.chartArcsBackground + "-" + i;
        }).merge(backgroundArc).attr("d", function (d1) {
          if (state.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      arcs.select("." + config_classes.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && (arcs.select("." + config_classes.chartArcsGaugeMin).attr("dx", -1 * (state.innerRadius + (state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && arcs.select("." + config_classes.chartArcsGaugeMax).attr("dx", state.innerRadius + (state.radius - state.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.$el.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
/* harmony default export */ var shape_radar = ({
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        arcWidth = _$$$state.arcWidth,
        arcHeight = _$$$state.arcHeight,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min(arcWidth, arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        width = _$$$getRadarSize[0],
        height = _$$$getRadarSize[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize2 = $$.getRadarSize(),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        points = $$.cache.get(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.cache.add(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(durationForExit) {
    var $$ = this,
        main = $$.$el.main,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), main.selectAll("." + config_classes.circles).attr("transform", translate), main.select("." + config_classes.chartTexts).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var points = this.cache.get(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize3 = $$.getRadarSize(),
        width = _$$$getRadarSize3[0],
        height = _$$$getRadarSize3[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = (config.radar_level_text_format || function () {}).bind($$.api),
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll("." + config_classes.level).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return config_classes.level + " " + config_classes.level + "-" + i;
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(" + (width - levelRatio[d]) + ", " + (height - levelRatio[d]) + ")";
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize4 = $$.getRadarSize(),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return config_classes.axis + "-" + i;
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(" + posX + " " + posY + ")";
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config,
        _$$$state2 = $$.state,
        inputType = _$$$state2.inputType,
        transiting = _$$$state2.transiting,
        svg = $$.$el.svg;

    if (config.interaction_enabled) {
      var isMouse = inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select("." + config_classes.axis).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle(svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.cache.get(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", $$.color).style("stroke", $$.color).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/config/resolver/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Arc based chart
 */
// shape


/* harmony default export */ var resolver_arc = ({
  internal: [shape_arc, shape_radar]
});
// CONCATENATED MODULE: ./src/ChartInternal/ChartInternal.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */








 // for Types

// Axis
 // data



 // interactions

 // internals
















/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */
var ChartInternal_ChartInternal =
/*#__PURE__*/
function () {
  // API interface
  // config object
  // cache instance
  // state variables
  // all Chart instances array within page (equivalent of 'bb.instances')
  // if is Arc type chart
  // data object
  // selections
  // Axis
  // Axis
  // scales
  // original values
  // formatter function
  // format function
  function ChartInternal(api) {
    _defineProperty(this, "api", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "cache", void 0), _defineProperty(this, "state", void 0), _defineProperty(this, "charts", void 0), _defineProperty(this, "isArc", !1), _defineProperty(this, "data", {
      xs: {},
      targets: []
    }), _defineProperty(this, "$el", {
      chart: null,
      main: null,
      svg: null,
      axis: {
        // axes
        x: null,
        y: null,
        y2: null,
        subX: null
      },
      defs: null,
      tooltip: null,
      legend: null,
      title: null,
      subchart: {
        main: null,
        // $$.context
        bar: null,
        // $$.contextBar
        line: null,
        // $$.contextLine
        area: null // $$.contextArea

      },
      arcs: null,
      bar: null,
      //mainBar,
      line: null,
      //mainLine,
      area: null,
      //mainArea,
      circle: null,
      //mainCircle,
      text: null,
      //mainText,
      grid: {
        main: null,
        // grid (also focus)
        x: null,
        // xgrid,
        y: null // ygrid,

      },
      gridLines: {
        main: null,
        // gridLines
        x: null,
        // xgridLines,
        y: null // ygridLines

      },
      region: {
        main: null,
        //region
        list: null // mainRegion

      },
      eventRect: null
    }), _defineProperty(this, "axis", void 0), _defineProperty(this, "scale", {
      x: null,
      y: null,
      y2: null,
      subX: null,
      subY: null,
      subY2: null,
      zoom: null
    }), _defineProperty(this, "org", {
      xScale: null,
      xDomain: null
    }), _defineProperty(this, "color", void 0), _defineProperty(this, "patterns", void 0), _defineProperty(this, "levelColor", void 0), _defineProperty(this, "point", void 0), _defineProperty(this, "brush", void 0), _defineProperty(this, "format", {
      extraLineClasses: null,
      xAxisTick: null,
      dataTime: null,
      // dataTimeFormat
      defaultAxisTime: null,
      // defaultAxisTimeFormat
      axisTime: null // axisTimeFormat

    }), _defineProperty(this, "hasAxis", void 0), _defineProperty(this, "hasRadar", void 0);
    var $$ = this;
    $$.api = api, $$.config = new Options(), $$.cache = new Cache_Cache(), $$.state = new Store_state();
  }

  var _proto = ChartInternal.prototype;
  return _proto.beforeInit = function beforeInit() {
    var $$ = this;
    $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$.api);
  }, _proto.afterInit = function afterInit() {
    var $$ = this;
    $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$.api);
  }, _proto.init = function init() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.hasAxis = !$$.hasArcType(), $$.hasRadar = !$$.hasAxis && $$.hasType("radar"), $$.initParams();
    var bindto = {
      element: config.bindto,
      classname: "bb"
    };
    isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $el.chart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $el.chart.empty() && ($el.chart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $el.chart.html("").classed(bindto.classname, !0), $$.initToRender();
  }
  /**
   * Initialize the rendering process
   * @param {Boolean} forced Force to render process
   * @private
   */
  , _proto.initToRender = function initToRender(forced) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        chart = $$.$el.chart,
        isHidden = function () {
      return chart.style("display") === "none" || chart.style("visibility") === "hidden";
    },
        isLazy = config.render.lazy || isHidden(),
        MutationObserver = win.MutationObserver;

    if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
      isHidden() || (observer.disconnect(), !state.rendered && $$.initToRender(!0));
    }).observe(chart.node(), {
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), !isLazy || forced) {
      var convertedData = $$.convertData(config, $$.initWithData);
      convertedData && $$.initWithData(convertedData);
    }
  }, _proto.initParams = function initParams() {
    var $$ = this,
        config = $$.config,
        format = $$.format,
        state = $$.state,
        isRotated = config.axis_rotated;

    if (state.datetimeId = "bb-" + +new Date(), $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.hasPointType() && ($$.point = $$.generatePoint()), $$.hasAxis) {
      $$.initClip(), format.extraLineClasses = $$.generateExtraLineClass(), format.dataTime = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], format.axisTime = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";

      format.defaultAxisTime = function (d) {
        var _$$$scale = $$.scale,
            x = _$$$scale.x,
            zoom = _$$$scale.zoom,
            isZoomed = isDragZoom ? zoom : zoom && x.orgDomain().toString() !== zoom.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return format.axisTime(specifier)(d);
      };
    }

    state.isLegendRight = config.legend_position === "right", state.isLegendInset = config.legend_position === "inset", state.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", state.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", state.rotatedPaddingRight = isRotated && !config.axis_x_show ? 0 : 30, state.inputType = convertInputType(config.interaction_inputType_mouse, config.interaction_inputType_touch);
  }, _proto.initWithData = function initWithData(data) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hasAxis = $$.hasAxis,
        _$$$scale2 = $$.scale,
        x = _$$$scale2.x,
        y = _$$$scale2.y,
        y2 = _$$$scale2.y2,
        subX = _$$$scale2.subX,
        subY = _$$$scale2.subY,
        subY2 = _$$$scale2.subY2,
        org = $$.org;

    if ($$.hasAxis && ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom()), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter.bind($$.api))), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0), x && (x.domain(util_sortValue($$.getXDomain($$.data.targets))), subX.domain(x.domain()), org.xDomain = x.domain()), y && (y.domain($$.getYDomain($$.data.targets, "y")), subY.domain(y.domain())), y2 && (y2.domain($$.getYDomain($$.data.targets, "y2")), subY2 && subY2.domain(y2.domain())), $el.svg = $el.chart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && state.inputType) {
      var isTouch = state.inputType === "touch";
      $el.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
        return callFn(config.onover, $$.api);
      }).on(isTouch ? "touchend" : "mouseleave", function () {
        return callFn(config.onout, $$.api);
      });
    }

    config.svg_classname && $el.svg.attr("class", config.svg_classname);
    // Define defs
    var hasColorPatterns = isFunction(config.color_tiles) && $$.patterns;
    ($$.hasAxis || hasColorPatterns) && ($el.defs = $el.svg.append("defs"), $$.hasAxis && ["id", "idXAxis", "idYAxis", "idGrid"].forEach(function (v) {
      $$.appendClip($el.defs, state.clip[v]);
    }), hasColorPatterns && $$.patterns.forEach(function (p) {
      return $el.defs.append(function () {
        return p.node;
      });
    })), $$.updateSvgSize();
    // Define regions
    var main = $el.svg.append("g").attr("transform", $$.getTranslate("main"));

    // data.onmin/max callback
    if ($el.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", config_classes.text + " " + config_classes.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
    .attr("dominant-baseline", "middle"), $$.hasAxis && ($$.initRegion && $$.initRegion(), !config.clipPath && $$.axis.init()), main.append("g").attr("class", config_classes.chart).attr("clip-path", state.clip.path), $$.callPluginHook("$init"), hasAxis && ($$.initEventRect && $$.initEventRect(), $$.initGrid && $$.initGrid(), config.clipPath && $$.axis && $$.axis.init()), $$.initChartElements(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$.api), $$.setBackground(), $$.redraw({
      withTransition: !1,
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withTransitionForAxis: !1,
      initializing: !0
    }), config.data_onmin || config.data_onmax) {
      var minMax = $$.getMinMaxData();
      callFn(config.data_onmin, $$.api, minMax.min), callFn(config.data_onmax, $$.api, minMax.max);
    } // Bind resize event


    $$.bindResize(), $$.api.element = $el.chart.node(), state.rendered = !0;
  }, _proto.initChartElements = function initChartElements() {
    var $$ = this,
        hasRadar = $$.hasRadar,
        types = [];
    $$.hasTypeOf("Arc") ? (types.push("Arc"), !hasRadar && types.push("Pie"), $$.hasType("gauge") ? types.push("Gauge") : hasRadar && types.push("Radar")) : ($$.hasType("bar") && types.push("Bar"), $$.hasType("bubble") && types.push("Bubble"), $$.hasTypeOf("Line") && types.push("Line")), types.forEach(function (v) {
      $$["init" + v]();
    }), notEmpty($$.config.data_labels) && $$.initText();
  }, _proto.setChartElements = function setChartElements() {
    var $$ = this,
        $el = $$.$el;
    $$.api.$ = {
      chart: $el.chart,
      svg: $el.svg,
      defs: $el.defs,
      main: $el.main,
      tooltip: $el.tooltip,
      legend: $el.legend,
      title: $el.title,
      grid: $el.grid,
      arc: $el.arcs,
      circles: $el.circle,
      bar: {
        bars: $el.bar
      },
      line: {
        lines: $el.line,
        areas: $el.area
      },
      text: {
        texts: $el.text
      }
    };
  }
  /**
   * Set background element/image
   * @private
   */
  , _proto.setBackground = function setBackground() {
    var $$ = this,
        bg = $$.config.background,
        svg = $$.$el.svg;

    if (notEmpty(bg)) {
      var element = svg.select("." + config_classes[$$.hasArcType() ? "chart" : "regions"]).insert(bg.imgUrl ? "image" : "rect", ":first-child");
      bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color), element.attr("class", bg.class || null).attr("width", "100%").attr("height", "100%");
    }
  }
  /**
   * Update targeted element with given data
   * @param {Object} targets Data object formatted as 'target'
   * @private
   */
  , _proto.updateTargets = function updateTargets(targets) {
    var $$ = this,
        hasAxis = $$.hasAxis,
        hasRadar = $$.hasRadar;
    $$.updateTargetsForText(targets), ($$.hasPointType() || hasRadar) && $$.updateTargetForCircle(), hasAxis ? ($$.hasType("bar") && $$.updateTargetsForBar(targets), $$.hasTypeOf("Line") && $$.updateTargetsForLine(targets), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets)) : $$.hasArcType(targets) && (hasRadar ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.showTargets();
  }
  /**
   * Display targeted elements
   * @private
   */
  , _proto.showTargets = function showTargets() {
    var $$ = this,
        config = $$.config,
        svg = $$.$el.svg;
    svg.selectAll("." + config_classes.target).filter(function (d) {
      return $$.isTargetToShow(d.id);
    }).transition().duration(config.transition_duration).style("opacity", "1");
  }, _proto.getWithOption = function getWithOption(options) {
    var withOptions = {
      Y: !0,
      Subchart: !0,
      Transition: !0,
      EventRect: !0,
      Dimension: !0,
      TrimXDomain: !0,
      Transform: !1,
      UpdateXDomain: !1,
      UpdateOrgXDomain: !1,
      Legend: !1,
      UpdateXAxis: "UpdateXDomain",
      TransitionForExit: "Transition",
      TransitionForAxis: "Transition"
    };
    return Object.keys(withOptions).forEach(function (key) {
      var defVal = withOptions[key];
      isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with" + key, defVal);
    }), withOptions;
  }, _proto.redraw = function redraw(options, transitionsValue) {
    options === void 0 && (options = {});
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hasRadar = $$.hasRadar,
        main = $el.main,
        targetsToShow = $$.filterTargetsToShow($$.data.targets),
        initializing = options.initializing,
        flow = options.flow,
        wth = $$.getWithOption(options),
        duration = wth.Transition ? config.transition_duration : 0,
        durationForExit = wth.TransitionForExit ? duration : 0,
        durationForAxis = wth.TransitionForAxis ? duration : 0,
        transitions = transitionsValue || $$.axis && $$.axis.generateTransitions(durationForAxis);
    initializing && config.tooltip_init_show || state.inputType !== "touch" || $$.hideTooltip(), $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.hasDataLabel() && $$.updateText(durationForExit), (!$$.hasArcType() || hasRadar) && $$.updateCircleY(), ($$.hasPointType() || hasRadar) && $$.updateCircle(), $$.hasAxis ? ($$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updategridFocus(), config.data_empty_label_text && main.select("text." + config_classes.text + "." + config_classes.empty).attr("x", state.width / 2).attr("y", state.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.hasType("bar") && $$.updateBar(durationForExit), $$.hasTypeOf("Line") && $$.updateLine(durationForExit), $$.hasTypeOf("Area") && $$.updateArea(durationForExit), $el.text && main.selectAll("." + config_classes.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent()) : ($el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(durationForExit)), $$.redrawTitle && $$.redrawTitle(), initializing && $$.setChartElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
  }
  /**
   * Generate redraw list
   * @param {Object} targets targets data to be shown
   * @param {Object} flow
   * @param {Object} duration
   * @param {Boolean} withSubchart whether or not to show subchart
   * @private
   */
  , _proto.generateRedrawList = function generateRedrawList(targets, flow, duration, withSubchart) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        shape = $$.getDrawShape();
    $$.hasAxis && config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
    // generate flow
    var flowFn = flow && $$.generateFlow({
      targets: targets,
      flow: flow,
      duration: flow.duration,
      shape: shape,
      xv: $$.xv.bind($$)
    }),
        isTransition = (duration || flowFn) && isTabVisible(),
        redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
        afterRedraw = flow || config.onrendered ? function () {
      flowFn && flowFn(), callFn(config.onrendered, $$.api);
    } : null;
    if (afterRedraw) // Only use transition when current tab is visible.
      if (isTransition && redrawList.length) {
        // Wait for end of transitions for callback
        var waitForDraw = $$.generateWait(); // transition should be derived from one transition

        Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
          redrawList.reduce(function (acc, t1) {
            return acc.concat(t1);
          }, []).forEach(function (t) {
            return waitForDraw.add(t);
          });
        }).call(waitForDraw, afterRedraw);
      } else state.transiting || afterRedraw(); // update fadein condition

    $$.mapToIds($$.data.targets).forEach(function (id) {
      state.withoutFadeIn[id] = !0;
    });
  }, _proto.getRedrawList = function getRedrawList(shape, flow, flowFn, isTransition) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.hasAxis,
        hasRadar = $$.hasRadar,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        list = [];

    if (hasAxis) {
      var _shape$type = shape.type,
          area = _shape$type.area,
          bar = _shape$type.bar,
          line = _shape$type.line;
      (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition)), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition));
    }

    return (!$$.hasArcType() || hasRadar) && notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition)), ($$.hasPointType() || hasRadar) && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
  }, _proto.updateAndRedraw = function updateAndRedraw(options) {
    options === void 0 && (options = {});
    var transitions,
        $$ = this,
        config = $$.config;
    options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
  }, _proto.redrawWithoutRescale = function redrawWithoutRescale() {
    this.redraw({
      withY: !1,
      withSubchart: !1,
      withEventRect: !1,
      withTransitionForAxis: !1
    });
  }, _proto.isCategorized = function isCategorized() {
    return this.config.axis_x_type.indexOf("category") >= 0 || this.hasRadar;
  }, _proto.isCustomX = function isCustomX() {
    var $$ = this,
        config = $$.config;
    return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  }, _proto.isTimeSeries = function isTimeSeries(id) {
    return id === void 0 && (id = "x"), this.config["axis_" + id + "_type"] === "timeseries";
  }, _proto.isTimeSeriesY = function isTimeSeriesY() {
    return this.isTimeSeries("y");
  }, _proto.initialOpacity = function initialOpacity(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? "1" : "0";
  }
  /**
   * Get the zoom or unzoomed scaled value
   * @param {Date|Number|Object} d Data value
   * @private
   */
  , _proto.xx = function xx(d) {
    var $$ = this,
        config = $$.config,
        _$$$scale3 = $$.scale,
        x = _$$$scale3.x,
        zoom = _$$$scale3.zoom,
        fn = config.zoom_enabled && zoom ? zoom : x;
    return d ? fn(isValue(d.x) ? d.x : d) : null;
  }, _proto.xv = function xv(d) {
    var $$ = this,
        config = $$.config,
        x = $$.scale.x,
        value = $$.getBaseValue(d);
    return $$.isTimeSeries() ? value = parseDate.call($$, value) : $$.isCategorized() && isString(value) && (value = config.axis_x_categories.indexOf(value)), Math.ceil(x(value));
  }, _proto.yv = function yv(d) {
    var $$ = this,
        _$$$scale4 = $$.scale,
        y = _$$$scale4.y,
        y2 = _$$$scale4.y2,
        yScale = d.axis && d.axis === "y2" ? y2 : y;
    return Math.ceil(yScale($$.getBaseValue(d)));
  }, _proto.subxx = function subxx(d) {
    return d ? this.scale.subX(d.x) : null;
  }, _proto.bindResize = function bindResize() {
    var $$ = this,
        config = $$.config;
    $$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(function () {
      return callFn(config.onresize, $$.api);
    }), config.resize_auto && $$.resizeFunction.add(function () {
      $$.resizeTimeout && (win.clearTimeout($$.resizeTimeout), $$.resizeTimeout = null), $$.resizeTimeout = win.setTimeout(function () {
        $$.api.flush(!1, !0);
      }, 200);
    }), $$.resizeFunction.add(function () {
      return callFn(config.onresized, $$.api);
    }), win.addEventListener("resize", $$.resizeFunction);
  }, _proto.generateResize = function generateResize() {
    function callResizeFunctions() {
      resizeFunctions.forEach(function (f) {
        return f();
      });
    }

    var resizeFunctions = [];
    return callResizeFunctions.add = function (f) {
      return resizeFunctions.push(f);
    }, callResizeFunctions.remove = function (f) {
      return resizeFunctions.splice(resizeFunctions.indexOf(f), 1);
    }, callResizeFunctions;
  }, _proto.endall = function endall(transition, callback) {
    var n = 0;
    transition.each(function () {
      return ++n;
    }).on("end", function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      --n || callback.apply.apply(callback, [this].concat(args));
    });
  }, _proto.generateWait = function generateWait() {
    var transitionsToWait = [],
        f = function (t, callback) {
      function loop() {
        for (var _t, done = 0, i = 0; _t = transitionsToWait[i]; i++) {
          if (_t.empty()) {
            done++;
            continue;
          }

          try {
            _t.transition();
          } catch (e) {
            done++;
          }
        }

        timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
      }

      var timer;
      loop();
    };

    return f.add = function (t) {
      isArray(t) ? transitionsToWait = transitionsToWait.concat(t) : transitionsToWait.push(t);
    }, f;
  }
  /**
   * Call plugin hook
   * @param {String} phase The lifecycle phase
   * @private
   */
  , _proto.callPluginHook = function callPluginHook(phase) {
    for (var _this = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

    this.config.plugins.forEach(function (v) {
      phase === "$beforeInit" && (v.$$ = _this, _this.api.plugins.push(v)), v[phase].apply(v, args);
    });
  }, ChartInternal;
}();


extend(ChartInternal_ChartInternal.prototype, [// common
data_convert, ChartInternal_data_data, data_load, internals_class, internals_color, internals_domain, interactions_interaction, internals_format, internals_legend, internals_scale, internals_size, internals_text, internals_title, internals_tooltip, internals_transform, internals_type].concat(resolver_arc.internal, resolver_axis.internal));
// CONCATENATED MODULE: ./src/config/config.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Load configuration option
 * @param {Object} config User's generation config value
 * @private
 */

function loadConfig(config) {
  var target,
      keys,
      read,
      thisConfig = this.config,
      find = function () {
    var key = keys.shift();
    return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
  };

  Object.keys(thisConfig).forEach(function (key) {
    target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
  });
}
// CONCATENATED MODULE: ./src/chart/api/chart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_chart = ({
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var config = this.internal.config;
    config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0);
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, _isFromResize) {
    var $$ = this.internal;
    $$.state.rendered ? (_isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.scale.zoom = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), svg.select("*").interrupt(), isDefined($$.resizeTimeout) && win.clearTimeout($$.resizeTimeout), win.removeEventListener("resize", $$.resizeFunction), chart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function (name, value, redraw) {
    var res,
        $$ = this.internal,
        config = $$.config,
        key = name && name.replace(/\./g, "_");
    return key in config && (isDefined(value) ? (config[key] = value, res = value, redraw && this.flush()) : res = config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/chart/api/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_color = ({
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/chart/api/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

function api_data_data(targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
}

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method datashown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method datavalues
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId, flat) {
    flat === void 0 && (flat = !0);
    var values;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method datanames
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    var $$ = this.internal; // reset existing legend item dimension data

    return $$.getLegendItemTextBox(), $$.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method datacolors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @method dataaxes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method datamin
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method datamax
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
});
/* harmony default export */ var api_data = ({
  data: api_data_data
});
// CONCATENATED MODULE: ./src/chart/api/export.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode(+("0x" + p));
  }));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @param {object} size
 * @return {String}
 * @private
 */


function nodeToSvgDataUrl(node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = ("<svg xmlns=\"" + external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg + "\" width=\"" + size.width + "\" height=\"" + size.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t" + styleXml + "\n\t\t\t\t" + nodeXml.replace(/(url\()[^#]+/g, "$1") + "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
}

/* harmony default export */ var api_export = ({
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  export: function _export(mimeType, callback) {
    var _this = this,
        $$ = this.internal,
        _$$$state = $$.state,
        width = _$$$state.currentWidth,
        height = _$$$state.currentHeight,
        size = {
      width: width,
      height: height
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (callback && isFunction(callback)) {
      var img = new Image();
      img.crossOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback.bind(_this)(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/chart/api/focus.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_focus = ({
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && !$$.hasRadar && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !0), state.focusedTargetIds = targetIds, state.defocusedTargetIds = state.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !1), state.focusedTargetIds = state.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), state.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $el.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $el.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), state.focusedTargetIds = [], state.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/chart/api/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define legend
 * @ignore
 */
var legend_legend = {
  /**
   * Show legend for each target.
   * @method legendshow
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legendhide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
};
/* harmony default export */ var api_legend = ({
  legend: legend_legend
});
// CONCATENATED MODULE: ./src/chart/api/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var load = ({
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [dataheaders](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [datakeys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [datamimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var _this = this,
        $$ = this.internal,
        args = argsValue || {};

    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.cache.remove(ids), args.done && args.done.call(_this);
    });
  }
});
// CONCATENATED MODULE: ./src/chart/api/show.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Show/Hide data series
 * @private
 */
function showHide(show, targetIdsValue, options) {
  var $$ = this.internal,
      targetIds = $$.mapToTargetIds(targetIdsValue);
  $$[(show ? "remove" : "add") + "HiddenTargetIds"](targetIds);
  var targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds)),
      opacity = show ? "1" : "0";
  targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
    targets.style("opacity", null).style("opacity", opacity);
  }), options.withLegend && $$[(show ? "show" : "hide") + "Legend"](targetIds), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0,
    withLegend: !0
  });
}

/* harmony default export */ var api_show = ({
  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds, options) {
    var _this = this;

    options === void 0 && (options = {});
    var $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };
    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/chart/api/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define tooltip
 * @ignore
 */

var tooltip_tooltip = {
  /**
   * Show tooltip
   * @method tooltipshow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: data id<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show(args) {
    var index,
        mouse,
        $$ = this.internal,
        config = $$.config,
        inputType = $$.state.inputType;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.scale.x(args.data.x), y] : (!config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    (inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltiphide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal;
    $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
};
/* harmony default export */ var api_tooltip = ({
  tooltip: tooltip_tooltip
});
// CONCATENATED MODULE: ./src/chart/Chart.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */













/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access instance's primary node elements
 * @member {Object} $
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {d3.selection} $.circles Data point circle elements
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart =
/**
 * Plugin instance array
 * @member {Array} plugins
 * @memberof Chart
 * @instance
 * @example
 *  var chart = bb.generate({
 *     ...
 *     plugins: [
 *        new bb.plugin.stanford({ ... }),
 *        new PluginA()
 *     ]
 *  });
 *
 *  chart.plugins; // [Stanford, PluginA] - instance array
 */
function Chart(options) {
  _defineProperty(this, "plugins", []), _defineProperty(this, "internal", void 0);
  var ctx = this,
      _options$data = options.data,
      type = _options$data.type,
      types = _options$data.types,
      $$ = new ChartInternal_ChartInternal(ctx);
  // bind to namespaced APIs
  this.internal = $$, function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      var isFunc = isFunction(fn[key]),
          isChild = target !== argThis,
          hasChild = Object.keys(fn[key]).length > 0;
      isFunc && (!isChild && hasChild || isChild) ? target[key] = fn[key].bind(argThis) : !isFunc && (target[key] = {}), hasChild && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this), loadConfig.call($$, options), $$.beforeInit(), $$.init(), $$.afterInit();
}; // extend common APIs as part of Chart class



extend(Chart_Chart.prototype, [api_chart, api_color, api_data, api_export, api_focus, api_legend, load, api_show, api_tooltip].concat(resolver_axis.api));
// CONCATENATED MODULE: ./src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bb", function() { return bb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return bb; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */

 // eslint-disable-next-line no-use-before-define


var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "2.0.0-alpha",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {}
};
/**
 * @namespace bb
 * @version 2.0.0-alpha
 */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3JlbG9hZEFwcC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvY3JlYXRlU29ja2V0VXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2Nzcz8xYjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2NzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdGltZS1mb3JtYXRcIixcImNvbW1vbmpzMlwiOlwiZDMtdGltZS1mb3JtYXRcIixcImFtZFwiOlwiZDMtdGltZS1mb3JtYXRcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2VsZWN0aW9uXCIsXCJjb21tb25qczJcIjpcImQzLXNlbGVjdGlvblwiLFwiYW1kXCI6XCJkMy1zZWxlY3Rpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdHJhbnNpdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJhbWRcIjpcImQzLXRyYW5zaXRpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYnJ1c2hcIixcImNvbW1vbmpzMlwiOlwiZDMtYnJ1c2hcIixcImFtZFwiOlwiZDMtYnJ1c2hcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYXhpc1wiLFwiY29tbW9uanMyXCI6XCJkMy1heGlzXCIsXCJhbWRcIjpcImQzLWF4aXNcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2NhbGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2NhbGVcIixcImFtZFwiOlwiZDMtc2NhbGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHN2XCIsXCJjb21tb25qczJcIjpcImQzLWRzdlwiLFwiYW1kXCI6XCJkMy1kc3ZcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHJhZ1wiLFwiY29tbW9uanMyXCI6XCJkMy1kcmFnXCIsXCJhbWRcIjpcImQzLWRyYWdcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtem9vbVwiLFwiY29tbW9uanMyXCI6XCJkMy16b29tXCIsXCJhbWRcIjpcImQzLXpvb21cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZWFzZVwiLFwiY29tbW9uanMyXCI6XCJkMy1lYXNlXCIsXCJhbWRcIjpcImQzLWVhc2VcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtY29sb3JcIixcImNvbW1vbmpzMlwiOlwiZDMtY29sb3JcIixcImFtZFwiOlwiZDMtY29sb3JcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2hhcGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2hhcGVcIixcImFtZFwiOlwiZDMtc2hhcGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtaW50ZXJwb2xhdGVcIixcImNvbW1vbmpzMlwiOlwiZDMtaW50ZXJwb2xhdGVcIixcImFtZFwiOlwiZDMtaW50ZXJwb2xhdGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NsYXNzZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9TdG9yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9pbnRlcmFjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2xlZ2VuZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3RpdGxlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vdG9vbHRpcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9kYXRhL3NlbGVjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy94LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9heGlzL3kudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMveTIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9icm93c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvdXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3BvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vc3ViY2hhcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi96b29tLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9hcmVhLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9iYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2J1YmJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvc3BsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9kb251dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvZ2F1Z2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3BpZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL09wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9DYWNoZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXNSZW5kZXJlckhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXNSZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvZGF0YS9kYXRhLmNvbnZlcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvZGF0YS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS5sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xhc3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9kb21haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2Zvcm1hdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zY2FsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2l6ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGV4dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGl0bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbnN0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy90eXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2NhdGVnb3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvZmxvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2dyaWQueC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2dyaWQueS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2dyb3VwLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvcmVnaW9ucy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3NlbGVjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS96b29tLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9kcmFnLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9mbG93LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9ldmVudHJlY3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL3N1YmNoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy96b29tLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xpcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVnaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYmFyLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2J1YmJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9saW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3BvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3NoYXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvcmVzb2x2ZXIvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9hcmMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9yZXNvbHZlci9hcmMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQ2hhcnRJbnRlcm5hbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZXhwb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZm9jdXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvc2hvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L0NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJhcmMiLCJhcmNMYWJlbExpbmUiLCJhcmNzIiwiYXJlYSIsImFyZWFzIiwiYXhpcyIsImF4aXNYIiwiYXhpc1hMYWJlbCIsImF4aXNZIiwiYXhpc1kyIiwiYXhpc1kyTGFiZWwiLCJheGlzWUxhYmVsIiwiYmFyIiwiYmFycyIsImJydXNoIiwiYnV0dG9uIiwiYnV0dG9uWm9vbVJlc2V0IiwiY2hhcnQiLCJjaGFydEFyYyIsImNoYXJ0QXJjcyIsImNoYXJ0QXJjc0JhY2tncm91bmQiLCJjaGFydEFyY3NHYXVnZU1heCIsImNoYXJ0QXJjc0dhdWdlTWluIiwiY2hhcnRBcmNzR2F1Z2VVbml0IiwiY2hhcnRBcmNzVGl0bGUiLCJjaGFydEFyY3NHYXVnZVRpdGxlIiwiY2hhcnRCYXIiLCJjaGFydEJhcnMiLCJjaGFydENpcmNsZXMiLCJjaGFydExpbmUiLCJjaGFydExpbmVzIiwiY2hhcnRSYWRhciIsImNoYXJ0UmFkYXJzIiwiY2hhcnRUZXh0IiwiY2hhcnRUZXh0cyIsImNpcmNsZSIsImNpcmNsZXMiLCJjb2xvclBhdHRlcm4iLCJjb2xvclNjYWxlIiwiZGVmb2N1c2VkIiwiZHJhZ2FyZWEiLCJlbXB0eSIsImV2ZW50UmVjdCIsImV2ZW50UmVjdHMiLCJldmVudFJlY3RzTXVsdGlwbGUiLCJldmVudFJlY3RzU2luZ2xlIiwiZm9jdXNlZCIsImdhdWdlVmFsdWUiLCJncmlkIiwiZ3JpZExpbmVzIiwibGVnZW5kQmFja2dyb3VuZCIsImxlZ2VuZEl0ZW0iLCJsZWdlbmRJdGVtRXZlbnQiLCJsZWdlbmRJdGVtRm9jdXNlZCIsImxlZ2VuZEl0ZW1IaWRkZW4iLCJsZWdlbmRJdGVtUG9pbnQiLCJsZWdlbmRJdGVtVGlsZSIsImxldmVsIiwibGV2ZWxzIiwibGluZSIsImxpbmVzIiwicmVnaW9uIiwicmVnaW9ucyIsInNlbGVjdGVkQ2lyY2xlIiwic2VsZWN0ZWRDaXJjbGVzIiwic2hhcGUiLCJzaGFwZXMiLCJzdGFuZm9yZEVsZW1lbnRzIiwic3RhbmZvcmRMaW5lIiwic3RhbmZvcmRMaW5lcyIsInN0YW5mb3JkUmVnaW9uIiwic3RhbmZvcmRSZWdpb25zIiwidGFyZ2V0IiwidGV4dCIsInRleHRzIiwidGl0bGUiLCJ0b29sdGlwIiwidG9vbHRpcENvbnRhaW5lciIsInRvb2x0aXBOYW1lIiwieGdyaWQiLCJ4Z3JpZEZvY3VzIiwieGdyaWRMaW5lIiwieGdyaWRMaW5lcyIsInhncmlkcyIsInlncmlkIiwieWdyaWRGb2N1cyIsInlncmlkTGluZSIsInlncmlkTGluZXMiLCJ5Z3JpZHMiLCJ6b29tQnJ1c2giLCJ6b29tUmVjdCIsIkVYUEFOREVEIiwiU0VMRUNURUQiLCJJTkNMVURFRCIsIlRleHRPdmVybGFwcGluZyIsInN0YXRlIiwid2lkdGgiLCJ3aWR0aDIiLCJoZWlnaHQiLCJoZWlnaHQyIiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwibWFyZ2luMiIsIm1hcmdpbjMiLCJhcmNXaWR0aCIsImFyY0hlaWdodCIsImN1cnJlbnRXaWR0aCIsImN1cnJlbnRIZWlnaHQiLCJpc0xlZ2VuZFJpZ2h0IiwiaXNMZWdlbmRJbnNldCIsImlzTGVnZW5kVG9wIiwiaXNMZWdlbmRMZWZ0IiwibGVnZW5kU3RlcCIsImxlZ2VuZEl0ZW1XaWR0aCIsImxlZ2VuZEl0ZW1IZWlnaHQiLCJsZWdlbmRIYXNSZW5kZXJlZCIsImN1cnJlbnRNYXhUaWNrV2lkdGhzIiwieCIsInNpemUiLCJkb21haW4iLCJ5IiwieTIiLCJyb3RhdGVkUGFkZGluZyIsIndpdGhvdXRGYWRlSW4iLCJpbnB1dFR5cGUiLCJkYXRldGltZUlkIiwiY2xpcCIsImlkIiwiaWRYQXhpcyIsImlkWUF4aXMiLCJpZEdyaWQiLCJpZFN1YmNoYXJ0IiwicGF0aCIsInBhdGhYQXhpcyIsInBhdGhZQXhpcyIsInBhdGhHcmlkIiwiZHJhZ1N0YXJ0IiwiZHJhZ2dpbmciLCJmbG93aW5nIiwiY2FuY2VsQ2xpY2siLCJtb3VzZW92ZXIiLCJyZW5kZXJlZCIsInRyYW5zaXRpbmciLCJoYXNOZWdhdGl2ZVZhbHVlIiwiaGFzUG9zaXRpdmVWYWx1ZSIsIm9yZ0FyZWFPcGFjaXR5IiwiaGlkZGVuVGFyZ2V0SWRzIiwiaGlkZGVuTGVnZW5kSWRzIiwiZm9jdXNlZFRhcmdldElkcyIsImRlZm9jdXNlZFRhcmdldElkcyIsInJhZGl1cyIsImlubmVyUmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImdhdWdlQXJjV2lkdGgiLCJyYWRpdXNFeHBhbmRlZCIsInhncmlkQXR0ciIsIngxIiwieDIiLCJ5MSIsImRhdGFfaWRDb252ZXJ0ZXIiLCJkYXRhX25hbWVzIiwiZGF0YV9jbGFzc2VzIiwiZGF0YV90eXBlIiwidW5kZWZpbmVkIiwiZGF0YV90eXBlcyIsImRhdGFfb3JkZXIiLCJkYXRhX2NvbG9yIiwiZGF0YV9jb2xvcnMiLCJkYXRhX2hpZGUiLCJkYXRhX2ZpbHRlciIsImRhdGFfb25jbGljayIsImRhdGFfb25vdmVyIiwiZGF0YV9vbm91dCIsImRhdGFfb25taW4iLCJkYXRhX29ubWF4IiwiZGF0YV91cmwiLCJkYXRhX2hlYWRlcnMiLCJkYXRhX2pzb24iLCJkYXRhX3Jvd3MiLCJkYXRhX2NvbHVtbnMiLCJkYXRhX21pbWVUeXBlIiwiZGF0YV9rZXlzIiwiZGF0YV9lbXB0eV9sYWJlbF90ZXh0IiwiY29sb3JfcGF0dGVybiIsImNvbG9yX3RpbGVzIiwiY29sb3JfdGhyZXNob2xkIiwiY29sb3Jfb25vdmVyIiwiaW50ZXJhY3Rpb25fZW5hYmxlZCIsImludGVyYWN0aW9uX2JyaWdodGVuIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoIiwibGVnZW5kX3Nob3ciLCJsZWdlbmRfaGlkZSIsImxlZ2VuZF9jb250ZW50c19iaW5kdG8iLCJsZWdlbmRfY29udGVudHNfdGVtcGxhdGUiLCJsZWdlbmRfcG9zaXRpb24iLCJsZWdlbmRfaW5zZXRfYW5jaG9yIiwibGVnZW5kX2luc2V0X3giLCJsZWdlbmRfaW5zZXRfeSIsImxlZ2VuZF9pbnNldF9zdGVwIiwibGVnZW5kX2l0ZW1fb25jbGljayIsImxlZ2VuZF9pdGVtX29ub3ZlciIsImxlZ2VuZF9pdGVtX29ub3V0IiwibGVnZW5kX2VxdWFsbHkiLCJsZWdlbmRfcGFkZGluZyIsImxlZ2VuZF9pdGVtX3RpbGVfd2lkdGgiLCJsZWdlbmRfaXRlbV90aWxlX2hlaWdodCIsImxlZ2VuZF91c2VQb2ludCIsInRpdGxlX3RleHQiLCJ0aXRsZV9wYWRkaW5nIiwidGl0bGVfcG9zaXRpb24iLCJ0b29sdGlwX3Nob3ciLCJ0b29sdGlwX2RvTm90SGlkZSIsInRvb2x0aXBfZ3JvdXBlZCIsInRvb2x0aXBfZm9ybWF0X3RpdGxlIiwidG9vbHRpcF9mb3JtYXRfbmFtZSIsInRvb2x0aXBfZm9ybWF0X3ZhbHVlIiwidG9vbHRpcF9wb3NpdGlvbiIsInRvb2x0aXBfY29udGVudHMiLCJ0b29sdGlwX2luaXRfc2hvdyIsInRvb2x0aXBfaW5pdF94IiwidG9vbHRpcF9pbml0X3Bvc2l0aW9uIiwidG9vbHRpcF9saW5rZWQiLCJ0b29sdGlwX2xpbmtlZF9uYW1lIiwidG9vbHRpcF9vbnNob3ciLCJ0b29sdGlwX29uaGlkZSIsInRvb2x0aXBfb25zaG93biIsInRvb2x0aXBfb25oaWRkZW4iLCJ0b29sdGlwX29yZGVyIiwiZGF0YV94IiwiZGF0YV94cyIsImRhdGFfeEZvcm1hdCIsImRhdGFfeExvY2FsdGltZSIsImRhdGFfeFNvcnQiLCJkYXRhX2dyb3VwcyIsImRhdGFfYXhlcyIsImRhdGFfbGFiZWxzIiwiZGF0YV9sYWJlbHNfY29sb3JzIiwiZGF0YV9sYWJlbHNfcG9zaXRpb24iLCJkYXRhX3JlZ2lvbnMiLCJkYXRhX3N0YWNrX25vcm1hbGl6ZSIsImRhdGFfc2VsZWN0aW9uX2VuYWJsZWQiLCJkYXRhX3NlbGVjdGlvbl9ncm91cGVkIiwiZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlIiwiZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUiLCJkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUiLCJkYXRhX29uc2VsZWN0ZWQiLCJkYXRhX29udW5zZWxlY3RlZCIsImF4aXNfeF9jbGlwUGF0aCIsImF4aXNfeF9zaG93IiwiYXhpc194X3R5cGUiLCJheGlzX3hfbG9jYWx0aW1lIiwiYXhpc194X2NhdGVnb3JpZXMiLCJheGlzX3hfdGlja19jZW50ZXJlZCIsImF4aXNfeF90aWNrX2Zvcm1hdCIsImF4aXNfeF90aWNrX2N1bGxpbmciLCJheGlzX3hfdGlja19jdWxsaW5nX21heCIsImF4aXNfeF90aWNrX2NvdW50IiwiYXhpc194X3RpY2tfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3hfdGlja19maXQiLCJheGlzX3hfdGlja192YWx1ZXMiLCJheGlzX3hfdGlja19yb3RhdGUiLCJheGlzX3hfdGlja19vdXRlciIsImF4aXNfeF90aWNrX211bHRpbGluZSIsImF4aXNfeF90aWNrX3dpZHRoIiwiYXhpc194X3RpY2tfdG9vbHRpcCIsImF4aXNfeF9tYXgiLCJheGlzX3hfbWluIiwiYXhpc194X3BhZGRpbmciLCJheGlzX3hfaGVpZ2h0IiwiYXhpc194X2V4dGVudCIsImF4aXNfeF9sYWJlbCIsImF4aXNfeF9heGVzIiwiYXhpc195X2NsaXBQYXRoIiwiYXhpc195X3Nob3ciLCJheGlzX3lfdHlwZSIsImF4aXNfeV9tYXgiLCJheGlzX3lfbWluIiwiYXhpc195X2ludmVydGVkIiwiYXhpc195X2NlbnRlciIsImF4aXNfeV9pbm5lciIsImF4aXNfeV9sYWJlbCIsImF4aXNfeV90aWNrX2Zvcm1hdCIsImF4aXNfeV90aWNrX2N1bGxpbmciLCJheGlzX3lfdGlja19jdWxsaW5nX21heCIsImF4aXNfeV90aWNrX291dGVyIiwiYXhpc195X3RpY2tfdmFsdWVzIiwiYXhpc195X3RpY2tfcm90YXRlIiwiYXhpc195X3RpY2tfY291bnQiLCJheGlzX3lfdGlja19zaG93IiwiYXhpc195X3RpY2tfc3RlcFNpemUiLCJheGlzX3lfdGlja190ZXh0X3Nob3ciLCJheGlzX3lfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195X3RpY2tfdGltZV92YWx1ZSIsImF4aXNfeV9wYWRkaW5nIiwiYXhpc195X2RlZmF1bHQiLCJheGlzX3lfYXhlcyIsImF4aXNfeTJfc2hvdyIsImF4aXNfeTJfbWF4IiwiYXhpc195Ml9taW4iLCJheGlzX3kyX2ludmVydGVkIiwiYXhpc195Ml9jZW50ZXIiLCJheGlzX3kyX2lubmVyIiwiYXhpc195Ml9sYWJlbCIsImF4aXNfeTJfdGlja19mb3JtYXQiLCJheGlzX3kyX3RpY2tfY3VsbGluZyIsImF4aXNfeTJfdGlja19jdWxsaW5nX21heCIsImF4aXNfeTJfdGlja19vdXRlciIsImF4aXNfeTJfdGlja192YWx1ZXMiLCJheGlzX3kyX3RpY2tfcm90YXRlIiwiYXhpc195Ml90aWNrX2NvdW50IiwiYXhpc195Ml90aWNrX3Nob3ciLCJheGlzX3kyX3RpY2tfc3RlcFNpemUiLCJheGlzX3kyX3RpY2tfdGV4dF9zaG93IiwiYXhpc195Ml90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3kyX3BhZGRpbmciLCJheGlzX3kyX2RlZmF1bHQiLCJheGlzX3kyX2F4ZXMiLCJ3aW4iLCJkZWYiLCJvIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsImRvYyIsImRvY3VtZW50IiwiaXNWYWx1ZSIsInYiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNCb29sZWFuIiwiY2VpbDEwIiwiTWF0aCIsImNlaWwiLCJhc0hhbGZQaXhlbCIsIm4iLCJkaWZmRG9tYWluIiwiZCIsImlzT2JqZWN0VHlwZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJEYXRlIiwiT2JqZWN0Iiwia2V5cyIsImlzTmFOIiwibm90RW1wdHkiLCJpc0FycmF5IiwiYXJyIiwiQXJyYXkiLCJpc09iamVjdCIsIm9iaiIsIm5vZGVUeXBlIiwiZ2V0T3B0aW9uIiwib3B0aW9ucyIsImtleSIsImRlZmF1bHRWYWx1ZSIsImhhc1ZhbHVlIiwiZGljdCIsInZhbHVlIiwiZm91bmQiLCJmb3JFYWNoIiwiY2FsbEZuIiwiZm4iLCJpc0ZuIiwiYXJncyIsImNhbGwiLCJzYW5pdGlzZSIsInN0ciIsInJlcGxhY2UiLCJzZXRUZXh0VmFsdWUiLCJub2RlIiwiZHkiLCJ0b01pZGRsZSIsImluZGV4T2YiLCJkaWZmIiwibWFwIiwibXVsdGlsaW5lIiwic3BsaXQiLCJsZW4iLCJodG1sIiwiaSIsImFwcGVuZCIsImF0dHIiLCJnZXRSZWN0U2VnTGlzdCIsImdldEJCb3giLCJnZXRQYXRoQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXRlbXMiLCJtaW4iLCJnZXRCcnVzaFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsIiRlbCIsImV2ZW50IiwiZDNFdmVudCIsIm1haW4iLCJzdWJjaGFydCIsInR5cGUiLCJzZWxlY3QiLCJDTEFTUyIsImQzQnJ1c2hTZWxlY3Rpb24iLCJnZXRCb3VuZGluZ1JlY3QiLCJyZWN0IiwiZ2V0UmFuZG9tIiwiYXNTdHIiLCJyYW5kIiwicmFuZG9tIiwiYnJ1c2hFbXB0eSIsImN0eCIsImV4dGVuZCIsInNvdXJjZSIsInAiLCJ0ZXN0IiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0FycmF5IiwiZ2V0Q3NzUnVsZXMiLCJzdHlsZVNoZWV0cyIsInJ1bGVzIiwic2hlZXQiLCJjc3NSdWxlcyIsImNvbmNhdCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJocmVmIiwidG9TdHJpbmciLCJnZXRUcmFuc2xhdGlvbiIsInRyYW5zZm9ybSIsImJhc2VWYWwiLCJnZXRJdGVtIiwibWF0cml4IiwiYSIsImIiLCJjIiwiZiIsImdldFVuaXF1ZSIsImRhdGEiLCJpc0RhdGUiLCJOdW1iZXIiLCJmaWx0ZXIiLCJtZXJnZUFycmF5IiwicmVkdWNlIiwibWVyZ2VPYmoiLCJvYmplY3ROIiwic2hpZnQiLCJzb3J0VmFsdWUiLCJpc0FzYyIsImV2ZXJ5Iiwic29ydCIsImdldE1pbk1heCIsInJlcyIsImdldFJhbmdlIiwic3RhcnQiLCJlbmQiLCJwdXNoIiwiZW11bGF0ZUV2ZW50IiwibW91c2UiLCJnZXRQYXJhbXMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZUV2ZW50IiwiZWwiLCJldmVudFR5cGUiLCJwYXJhbXMiLCJkaXNwYXRjaEV2ZW50IiwibW91c2VFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ0b3VjaCIsInRvdWNoT2JqIiwiVG91Y2giLCJpZGVudGlmaWVyIiwibm93IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbkFuZ2xlIiwiZm9yY2UiLCJUb3VjaEV2ZW50Iiwic2hpZnRLZXkiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwidHBsUHJvY2VzcyIsInRwbCIsIlJlZ0V4cCIsInBhcnNlRGF0ZSIsImRhdGUiLCJwYXJzZWREYXRlIiwiY29uZmlnIiwiZm9ybWF0IiwiZGF0YVRpbWUiLCJpc1RhYlZpc2libGUiLCJoaWRkZW4iLCJjb252ZXJ0SW5wdXRUeXBlIiwiaXNNb2JpbGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJoYXNUb3VjaFBvaW50cyIsIm1heFRvdWNoUG9pbnRzIiwiaGFzVG91Y2giLCJEb2N1bWVudFRvdWNoIiwiaGFzTW91c2UiLCJheGlzX3JvdGF0ZWQiLCJncmlkX3hfc2hvdyIsImdyaWRfeF90eXBlIiwiZ3JpZF94X2xpbmVzIiwiZ3JpZF95X3Nob3ciLCJncmlkX3lfbGluZXMiLCJncmlkX3lfdGlja3MiLCJncmlkX2ZvY3VzX2VkZ2UiLCJncmlkX2ZvY3VzX3Nob3ciLCJncmlkX2ZvY3VzX3kiLCJncmlkX2Zyb250IiwiZ3JpZF9saW5lc19mcm9udCIsInBvaW50X3Nob3ciLCJwb2ludF9yIiwicG9pbnRfc2Vuc2l0aXZpdHkiLCJwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCIsInBvaW50X2ZvY3VzX2V4cGFuZF9yIiwicG9pbnRfcGF0dGVybiIsInBvaW50X3NlbGVjdF9yIiwicG9pbnRfdHlwZSIsInN1YmNoYXJ0X3Nob3ciLCJzdWJjaGFydF9zaXplX2hlaWdodCIsInN1YmNoYXJ0X2F4aXNfeF9zaG93Iiwic3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdyIsInN1YmNoYXJ0X29uYnJ1c2giLCJ6b29tX2VuYWJsZWQiLCJ6b29tX2V4dGVudCIsInpvb21fcHJpdmlsZWdlZCIsInpvb21fcmVzY2FsZSIsInpvb21fb256b29tIiwiem9vbV9vbnpvb21zdGFydCIsInpvb21fb256b29tZW5kIiwiem9vbV9yZXNldEJ1dHRvbiIsInpvb21feF9taW4iLCJ6b29tX3hfbWF4IiwiYXJlYV96ZXJvYmFzZWQiLCJhcmVhX2Fib3ZlIiwiYXJlYV9saW5lYXJHcmFkaWVudCIsImJhcl9wYWRkaW5nIiwiYmFyX3JhZGl1cyIsImJhcl9yYWRpdXNfcmF0aW8iLCJiYXJfc2Vuc2l0aXZpdHkiLCJiYXJfd2lkdGgiLCJiYXJfd2lkdGhfcmF0aW8iLCJiYXJfd2lkdGhfbWF4IiwiYmFyX3plcm9iYXNlZCIsImJ1YmJsZV9tYXhSIiwiYnViYmxlX3plcm9iYXNlZCIsImxpbmVfY29ubmVjdE51bGwiLCJsaW5lX3N0ZXBfdHlwZSIsImxpbmVfemVyb2Jhc2VkIiwibGluZV9jbGFzc2VzIiwibGluZV9wb2ludCIsInNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGUiLCJkb251dF9sYWJlbF9zaG93IiwiZG9udXRfbGFiZWxfZm9ybWF0IiwiZG9udXRfbGFiZWxfdGhyZXNob2xkIiwiZG9udXRfbGFiZWxfcmF0aW8iLCJkb251dF93aWR0aCIsImRvbnV0X3RpdGxlIiwiZG9udXRfZXhwYW5kIiwiZG9udXRfZXhwYW5kX3JhdGUiLCJkb251dF9leHBhbmRfZHVyYXRpb24iLCJkb251dF9wYWRBbmdsZSIsImRvbnV0X3N0YXJ0aW5nQW5nbGUiLCJnYXVnZV9mdWxsQ2lyY2xlIiwiZ2F1Z2VfbGFiZWxfc2hvdyIsImdhdWdlX2xhYmVsX2Zvcm1hdCIsImdhdWdlX2xhYmVsX2V4dGVudHMiLCJnYXVnZV9taW4iLCJnYXVnZV9tYXgiLCJnYXVnZV90eXBlIiwiZ2F1Z2Vfc3RhcnRpbmdBbmdsZSIsIlBJIiwiZ2F1Z2VfdGl0bGUiLCJnYXVnZV91bml0cyIsImdhdWdlX3dpZHRoIiwiZ2F1Z2VfYXJjc19taW5XaWR0aCIsImdhdWdlX2V4cGFuZCIsImdhdWdlX2V4cGFuZF9yYXRlIiwiZ2F1Z2VfZXhwYW5kX2R1cmF0aW9uIiwicGllX2xhYmVsX3Nob3ciLCJwaWVfbGFiZWxfZm9ybWF0IiwicGllX2xhYmVsX3RocmVzaG9sZCIsInBpZV9sYWJlbF9yYXRpbyIsInBpZV9leHBhbmQiLCJwaWVfZXhwYW5kX3JhdGUiLCJwaWVfZXhwYW5kX2R1cmF0aW9uIiwicGllX2lubmVyUmFkaXVzIiwicGllX3BhZEFuZ2xlIiwicGllX3BhZGRpbmciLCJwaWVfc3RhcnRpbmdBbmdsZSIsInJhZGFyX2F4aXNfbWF4IiwicmFkYXJfYXhpc19saW5lX3Nob3ciLCJyYWRhcl9heGlzX3RleHRfc2hvdyIsInJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbiIsInJhZGFyX2xldmVsX2RlcHRoIiwicmFkYXJfbGV2ZWxfc2hvdyIsInJhZGFyX2xldmVsX3RleHRfZm9ybWF0IiwidG9GaXhlZCIsInJhZGFyX2xldmVsX3RleHRfc2hvdyIsInJhZGFyX3NpemVfcmF0aW8iLCJyYWRhcl9kaXJlY3Rpb25fY2xvY2t3aXNlIiwiT3B0aW9ucyIsImNvbG9yIiwiaW50ZXJhY3Rpb24iLCJsZWdlbmQiLCJkb251dCIsImdhdWdlIiwicGllIiwicmFkYXIiLCJkYXRhQXhpcyIsImRhdGFTZWxlY3Rpb24iLCJwb2ludCIsInpvb20iLCJidWJibGUiLCJzcGxpbmUiLCJiaW5kdG8iLCJiYWNrZ3JvdW5kIiwiY2xpcFBhdGgiLCJzdmdfY2xhc3NuYW1lIiwic2l6ZV93aWR0aCIsInNpemVfaGVpZ2h0IiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsInBhZGRpbmdfdG9wIiwicGFkZGluZ19ib3R0b20iLCJyZXNpemVfYXV0byIsIm9ub3ZlciIsIm9ub3V0Iiwib25yZXNpemUiLCJvbnJlc2l6ZWQiLCJvbmJlZm9yZWluaXQiLCJvbmluaXQiLCJvbmFmdGVyaW5pdCIsIm9ucmVuZGVyZWQiLCJ0cmFuc2l0aW9uX2R1cmF0aW9uIiwic2NhdHRlcl96ZXJvYmFzZWQiLCJwbHVnaW5zIiwicmVuZGVyIiwiQ2FjaGUiLCJhZGQiLCJpc0RhdGFUeXBlIiwiY2FjaGUiLCJjbG9uZVRhcmdldCIsInJlbW92ZSIsImdldCIsInRhcmdldHMiLCJyZXNldCIsImFsbCIsIiQkIiwiaWRfb3JnIiwidmFsdWVzIiwiQXhpc1JlbmRlcmVySGVscGVyIiwib3duZXIiLCJzY2FsZSIsImQzU2NhbGVMaW5lYXIiLCJub1RyYW5zaXRpb24iLCJ3aXRob3V0VHJhbnNpdGlvbiIsInJhbmdlIiwic2NhbGVFeHRlbnQiLCJvcmdYU2NhbGUiLCJnZXRTaXplRm9yMUNoYXIiLCJ3IiwiaCIsInRpY2tPZmZzZXQiLCJzdG9wIiwiZ2VuZXJhdGVUaWNrcyIsImlzWUF4ZXMiLCJ0aWNrU3RlcFNpemUiLCJ0aWNrcyIsImludGVydmFsIiwidGlja0FyZ3VtZW50cyIsInJvdW5kIiwidW5zaGlmdCIsImNvcHlTY2FsZSIsIm5ld1NjYWxlIiwiY29weSIsInRleHRGb3JtYXR0ZWQiLCJ0aWNrRm9ybWF0IiwiZm9ybWF0dGVkIiwidHJhbnNpdGlvbmlzZSIsImludGVycnVwdCIsInRyYW5zaXRpb24iLCJBeGlzUmVuZGVyZXIiLCJpbm5lclRpY2tTaXplIiwib3V0ZXJUaWNrU2l6ZSIsIm91dGVyVGljayIsIm9yaWVudCIsInRpY2tDZW50ZXJlZCIsInRpY2tDdWxsaW5nIiwidGlja0xlbmd0aCIsInRpY2tQYWRkaW5nIiwidGlja1ZhbHVlcyIsIm1heCIsImhlbHBlciIsIkhlbHBlciIsImNyZWF0ZSIsImciLCJoZWxwZXJJbnN0Iiwic3BsaXRUaWNrVGV4dCIsImJpbmQiLCJpc0xlZnRSaWdodCIsImlzVG9wQm90dG9tIiwidGlja1RyYW5zZm9ybSIsImF4aXNQeCIsInNpZ24iLCJyb3RhdGUiLCJ0aWNrVGV4dFJvdGF0ZSIsInJhbmdlRXh0ZW50IiwiJGciLCJuYW1lIiwidGlja1RleHRQb3MiLCJwcmVmaXgiLCJheGlzU2hvdyIsInRpY2tTaG93IiwidGljayIsImVhY2giLCJkM1NlbGVjdCIsInNjYWxlMCIsIl9fY2hhcnRfXyIsInNjYWxlMSIsImlzQ2F0ZWdvcnkiLCJzZWxlY3RBbGwiLCJlbnRlciIsIm1lcmdlIiwib3V0ZXJUaWNrU2l6ZWQiLCJ0aWNrRW50ZXIiLCJpbnNlcnQiLCJzdHlsZSIsInRpY2tFeGl0IiwiZXhpdCIsInNpemVGb3IxQ2hhciIsImNvdW50cyIsInRzcGFuIiwiaW5kZXgiLCJ0aWNrTXVsdGlsaW5lIiwic3BsaXR0ZWQiLCJkeCIsInNpbiIsImxpbmVVcGRhdGUiLCJ0ZXh0VXBkYXRlIiwic2V0VGlja0xpbmVUZXh0UG9zaXRpb24iLCJ0aWNrVGl0bGUiLCJiYW5kd2lkdGgiLCJnZXRUaWNrWFkiLCJwb3MiLCJnZXRUaWNrU2l6ZSIsInRpY2tQb3NpdGlvbiIsInRpY2tQb3MiLCJ0ZXh0QW5jaG9yRm9yVGV4dCIsInIiLCJyZXZlcnNlIiwidGV4dFRyYW5zZm9ybSIsInlGb3JUZXh0IiwicjIiLCJjaGFyV2lkdGgiLCJzdWJ0ZXh0Iiwic3BhY2VJbmRleCIsInRleHRXaWR0aCIsInN1YnN0ciIsInRpY2tXaWR0aCIsInRpY2tUZXh0IiwiYXJndW1lbnRzIiwiaXNDZW50ZXJlZCIsInRpY2tJbnRlcnZhbCIsImdldFRvdGFsTGVuZ3RoIiwiSW5maW5pdHkiLCJjdWxsaW5nIiwic2V0VHJhbnNpdGlvbiIsInQiLCJBeGlzIiwic3ViWCIsInNldE9yaWVudCIsImdldEF4aXNDbGFzc05hbWUiLCJpc0hvcml6b250YWwiLCJmb3JIb3Jpem9udGFsIiwiaXNSb3RhdGVkIiwiaW5pdCIsImNsYXNzQXhpcyIsImF4aXNJZCIsImNsYXNzTGFiZWwiLCJnZXRUcmFuc2xhdGUiLCJnZW5lcmF0ZUF4ZXMiLCJ5SW5uZXIiLCJ5MklubmVyIiwiZDNBeGlzIiwiYXhlcyIsImF4ZXNDb25maWciLCJkM0F4aXNMZWZ0IiwiZDNBeGlzQm90dG9tIiwiZDNBeGlzVG9wIiwiZDNBeGlzUmlnaHQiLCJjb3VudCIsImFwaSIsInRpY2tTaXplT3V0ZXIiLCJvdXRlciIsImF4ZXNMaXN0IiwidXBkYXRlQXhlcyIsImF4aXNSYW5nZSIsImNsYXNzTmFtZSIsImdldEF4aXMiLCJub1RpY2tUZXh0Um90YXRlIiwiaXNYIiwiaXNDYXRlZ29yaXplZCIsInhBeGlzVGljayIsImF4aXNQYXJhbXMiLCJjYXRlZ29yaWVzIiwiaXNUaW1lU2VyaWVzIiwiaXNUaW1lU2VyaWVzWSIsImlzU3RhY2tOb3JtYWxpemVkIiwidXBkYXRlWEF4aXNUaWNrVmFsdWVzIiwiZml0IiwiZ2VuZXJhdGVUaWNrVmFsdWVzIiwibWFwVGFyZ2V0c1RvVW5pcXVlWHMiLCJnZXRJZCIsImdldFhBeGlzVGlja0Zvcm1hdCIsImN1cnJGb3JtYXQiLCJheGlzVGltZSIsImRlZmF1bHRBeGlzVGltZSIsImNhdGVnb3J5TmFtZSIsImFwcGx5IiwiZ2V0VGlja1ZhbHVlcyIsImdldExhYmVsT3B0aW9uQnlBeGlzSWQiLCJnZXRMYWJlbFRleHQiLCJvcHRpb24iLCJzZXRMYWJlbFRleHQiLCJnZXRMYWJlbFBvc2l0aW9uIiwiZGVmYXVsdFBvc2l0aW9uIiwicG9zaXRpb24iLCJoYXMiLCJpc0lubmVyIiwiaXNPdXRlciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldFhBeGlzTGFiZWxQb3NpdGlvbiIsImdldFlBeGlzTGFiZWxQb3NpdGlvbiIsImdldFkyQXhpc0xhYmVsUG9zaXRpb24iLCJnZXRMYWJlbFBvc2l0aW9uQnlJZCIsInRleHRGb3JYQXhpc0xhYmVsIiwidGV4dEZvcllBeGlzTGFiZWwiLCJ0ZXh0Rm9yWTJBeGlzTGFiZWwiLCJ4Rm9yQXhpc0xhYmVsIiwiZHhGb3JBeGlzTGFiZWwiLCJ0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsIiwiYW5jaG9yIiwieEZvclhBeGlzTGFiZWwiLCJ4Rm9yWUF4aXNMYWJlbCIsInhGb3JZMkF4aXNMYWJlbCIsImR4Rm9yWEF4aXNMYWJlbCIsImR4Rm9yWUF4aXNMYWJlbCIsImR4Rm9yWTJBeGlzTGFiZWwiLCJkeUZvclhBeGlzTGFiZWwiLCJ4SGVpZ2h0IiwiZ2V0TWF4VGlja1dpZHRoIiwiZHlGb3JZQXhpc0xhYmVsIiwiZHlGb3JZMkF4aXNMYWJlbCIsInRleHRBbmNob3JGb3JYQXhpc0xhYmVsIiwidGV4dEFuY2hvckZvcllBeGlzTGFiZWwiLCJ0ZXh0QW5jaG9yRm9yWTJBeGlzTGFiZWwiLCJ3aXRob3V0UmVjb21wdXRlIiwic3ZnIiwiY3VycmVudFRpY2tNYXgiLCJtYXhXaWR0aCIsImlzWUF4aXMiLCJ0YXJnZXRzVG9TaG93IiwiZmlsdGVyVGFyZ2V0c1RvU2hvdyIsInRpY2tDb3VudCIsImR1bW15IiwidXBkYXRlTGFiZWxzIiwid2l0aFRyYW5zaXRpb24iLCJsYWJlbHMiLCJYIiwiWSIsIlkyIiwiYXhpc0xhYmVsIiwiZ2V0UGFkZGluZyIsInBhZGRpbmciLCJkb21haW5MZW5ndGgiLCJjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyIsInBpeGVscyIsImZvclRpbWVTZXJpZXMiLCJ0aWNrVmFsdWUiLCJ0YXJnZXRDb3VudCIsImdlbmVyYXRlVHJhbnNpdGlvbnMiLCJkdXJhdGlvbiIsImF4IiwiYXhpc1N1YlgiLCJyZWRyYXciLCJ0cmFuc2l0aW9ucyIsImlzSGlkZGVuIiwiaXNJbml0Iiwib3BhY2l0eSIsIiRheGlzIiwicmVkcmF3QXhpcyIsInd0aCIsImZsb3ciLCJ4RG9tYWluRm9yWm9vbSIsImhhc1pvb20iLCJ1cGRhdGVYRG9tYWluIiwiVXBkYXRlWERvbWFpbiIsIlVwZGF0ZU9yZ1hEb21haW4iLCJUcmltWERvbWFpbiIsIm9yZ0RvbWFpbiIsImdldFlEb21haW4iLCJoYXNBcmNUeXBlIiwiVHJhbnNpdGlvbiIsIlVwZGF0ZVhBeGlzIiwic2V0Q3VsbGluZyIsInN1YlkiLCJzdWJZMiIsInRvQ3VsbCIsImludGVydmFsRm9yQ3VsbGluZyIsInRpY2tTaXplIiwiY3VsbGluZ01heCIsImRpc3BsYXkiLCJjb252ZXJ0RGF0YSIsImNhbGxiYWNrIiwidXJsIiwiY29udmVydFVybFRvRGF0YSIsIm1pbWVUeXBlIiwiaGVhZGVycyIsImpzb24iLCJjb252ZXJ0SnNvblRvRGF0YSIsInJvd3MiLCJjb252ZXJ0Um93c1RvRGF0YSIsImNvbHVtbnMiLCJjb252ZXJ0Q29sdW1uc1RvRGF0YSIsIkVycm9yIiwiZG9uZSIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJKU09OIiwicGFyc2UiLCJzZW5kIiwiY29udmVydENzdlRzdlRvRGF0YSIsInBhcnNlciIsInhzdiIsImNvbnZlcnRDc3ZUb0RhdGEiLCJkM0NzdlBhcnNlUm93cyIsImQzQ3N2UGFyc2UiLCJjb252ZXJ0VHN2VG9EYXRhIiwidHN2IiwiZDNUc3ZQYXJzZVJvd3MiLCJkM1RzdlBhcnNlIiwia2V5c1BhcmFtIiwidGFyZ2V0S2V5cyIsIm5ld1Jvd3MiLCJuZXdSb3ciLCJmaW5kVmFsdWVJbkpzb24iLCJ0bXAiLCJvYmplY3QiLCJjb252ZXJ0ZWRQYXRoIiwicGF0aEFycmF5Iiwic29tZSIsImsiLCJyb3ciLCJqIiwiY29sIiwiY29udmVydERhdGFUb1RhcmdldHMiLCJhcHBlbmRYcyIsInhzRGF0YSIsImRhdGFLZXlzIiwiaWRzIiwiaXNOb3RYIiwieHMiLCJ4S2V5IiwiZ2V0WEtleSIsImlzQ3VzdG9tWCIsInJhd1giLCJnZW5lcmF0ZVRhcmdldFgiLCJnZXRPdGhlclRhcmdldFhzIiwiZ2V0WFZhbHVlc09mWEtleSIsImNvbnZlcnRlZElkIiwiaGFzQ2F0ZWdvcnkiLCJ2MSIsInYyIiwiaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyIsImhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHMiLCJzZXRUYXJnZXRUeXBlIiwibWFwVG9JZHMiLCJkYXRhS2V5IiwiZXhpc3RWYWx1ZSIsImlzR3JvdXBlZCIsInhWYWx1ZXMiLCJnZXRJbmRleEJ5WCIsImJhc2VkWCIsImZpbHRlckJ5WCIsImdldFhWYWx1ZSIsImlkc0ZvclgiLCJnZXRPdGhlclRhcmdldFgiLCJhZGRYcyIsImlzTXVsdGlwbGVYIiwiaGFzVHlwZSIsImFkZE5hbWUiLCJnZXRBbGxWYWx1ZXNPbkluZGV4IiwiZ2V0VmFsdWVPbkluZGV4IiwidmFsdWVPbkluZGV4IiwidXBkYXRlVGFyZ2V0WCIsInVwZGF0ZVRhcmdldFhzIiwidXBkYXRlWHMiLCJnZXRQcmV2WCIsImdldE5leHRYIiwiZ2V0QmFzZVZhbHVlIiwiaGFzQXhpcyIsImlzQXJlYVJhbmdlVHlwZSIsImdldEFyZWFSYW5nZURhdGEiLCJpc0J1YmJsZVpUeXBlIiwiZ2V0QnViYmxlWkRhdGEiLCJnZXRNaW5NYXhWYWx1ZSIsImdldE1pbk1heERhdGEiLCJjYWNoZUtleSIsIm1pbk1heERhdGEiLCJtaW5NYXgiLCJtaW5EYXRhIiwiZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSIsIm1heERhdGEiLCJnZXRUb3RhbFBlckluZGV4Iiwic3VtIiwiZ2V0VG90YWxEYXRhU3VtIiwidG90YWxEYXRhU3VtIiwidG90YWwiLCJnZXRNYXhEYXRhQ291bnQiLCJnZXRNYXhEYXRhQ291bnRUYXJnZXQiLCJtYXBUb1RhcmdldElkcyIsImhhc1RhcmdldCIsInZhbCIsImlzVGFyZ2V0VG9TaG93IiwidGFyZ2V0SWQiLCJpc0xlZ2VuZFRvU2hvdyIsImFkZEhpZGRlblRhcmdldElkcyIsInRhcmdldElkcyIsInJlbW92ZUhpZGRlblRhcmdldElkcyIsImFkZEhpZGRlbkxlZ2VuZElkcyIsInJlbW92ZUhpZGRlbkxlZ2VuZElkcyIsImdldFZhbHVlc0FzSWRLZXllZCIsInlzIiwiY2hlY2tWYWx1ZUluVGFyZ2V0cyIsImNoZWNrZXIiLCJoYXNNdWx0aVRhcmdldHMiLCJfY2hlY2tPcmRlciIsIm9yZGVyIiwidG9Mb3dlckNhc2UiLCJpc09yZGVyRGVzYyIsImlzT3JkZXJBc2MiLCJvcmRlclRhcmdldHMiLCJ0YXJnZXRzVmFsdWUiLCJvcmRlckFzYyIsIm9yZGVyRGVzYyIsInQxIiwidDIiLCJyZWR1Y2VyIiwiYWJzIiwidDFTdW0iLCJ0MlN1bSIsImZpbHRlclJlbW92ZU51bGwiLCJmaWx0ZXJCeVhEb21haW4iLCJ4RG9tYWluIiwiaGFzRGF0YUxhYmVsIiwiZGF0YUxhYmVscyIsImdldERhdGFMYWJlbExlbmd0aCIsImxlbmd0aHMiLCJkYXRhTGFiZWxGb3JtYXQiLCJpc05vbmVBcmMiLCJpc0FyYyIsImZpbmRTYW1lWE9mVmFsdWVzIiwidGFyZ2V0WCIsInNhbWVzIiwiZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyIsImNhbmRpZGF0ZXMiLCJmaW5kQ2xvc2VzdCIsImNsb3Nlc3QiLCJtaW5EaXN0IiwiaXNCYXJUeXBlIiwiZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgiLCJpc1dpdGhpbkJhciIsImRpc3QiLCJ4SW5kZXgiLCJ5SW5kZXgiLCJjaXJjbGVZIiwic3FydCIsInBvdyIsImNvbnZlcnRWYWx1ZXNUb1N0ZXAiLCJzdGVwVHlwZSIsImNvbnZlcnRlZCIsImNvbnZlcnRWYWx1ZXNUb1JhbmdlIiwicmFuZ2VzIiwidXBkYXRlRGF0YUF0dHJpYnV0ZXMiLCJhdHRycyIsImN1cnJlbnQiLCJ3aXRoTGVnZW5kIiwiZ2V0UmF0aW8iLCJhc1BlcmNlbnQiLCJyYXRpbyIsInNob3duIiwiZGF0YVZhbHVlcyIsInBhZEFuZ2xlIiwiZW5kQW5nbGUiLCJzdGFydEFuZ2xlIiwiaGlkZGVuU3VtIiwiYWNjIiwiY3VyciIsInBhcnNlRmxvYXQiLCJtYXhWYWx1ZSIsInVwZGF0ZURhdGFJbmRleEJ5WCIsInRpY2tWYWx1ZU1hcCIsIm91dCIsInZhbHVlSW5kZXgiLCJsb2FkIiwicmF3VGFyZ2V0cyIsInR5cGVzIiwic3BsaWNlIiwidXBkYXRlVGFyZ2V0cyIsIndpdGhVcGRhdGVPcmdYRG9tYWluIiwid2l0aFVwZGF0ZVhEb21haW4iLCJsb2FkRnJvbUFyZ3MiLCJ1bmxvYWQiLCJyYXdUYXJnZXRJZHMiLCJjdXN0b21Eb25lQ2IiLCJzZWxlY3RvclRhcmdldCIsImVuZGFsbCIsInNldE92ZXJPdXQiLCJpc092ZXIiLCJzZXRPdmVyQ29sb3IiLCJjYWxsZWUiLCJsYXN0IiwiaXNXaXRoaW5TaGFwZSIsImRhdHVtIiwiZXhwYW5kQ2lyY2xlc0JhcnMiLCJjYWxsT3Zlck91dEZvclRvdWNoIiwiZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uIiwiZHJhZyIsImQzRHJhZyIsIm9uIiwiZDNNb3VzZSIsImRyYWdzdGFydCIsImRyYWdlbmQiLCJzZWxlY3RvciIsImdlbmVyYXRlQ2xhc3MiLCJjbGFzc1RleHQiLCJjbGFzc1RleHRzIiwiY2xhc3NTaGFwZSIsImNsYXNzU2hhcGVzIiwiZ2VuZXJhdGVFeHRyYUxpbmVDbGFzcyIsImNsYXNzZXMiLCJjbGFzc0xpbmUiLCJjbGFzc0xpbmVzIiwiY2xhc3NDaXJjbGUiLCJjbGFzc0NpcmNsZXMiLCJjbGFzc0JhciIsImNsYXNzQmFycyIsImNsYXNzQXJjIiwiY2xhc3NBcmNzIiwiY2xhc3NBcmVhIiwiY2xhc3NBcmVhcyIsImNsYXNzUmVnaW9uIiwiY2xhc3MiLCJjbGFzc0V2ZW50IiwiY2xhc3NUYXJnZXQiLCJhZGRpdGlvbmFsQ2xhc3NTdWZmaXgiLCJhZGRpdGlvbmFsQ2xhc3MiLCJjbGFzc0ZvY3VzIiwiY2xhc3NGb2N1c2VkIiwiY2xhc3NEZWZvY3VzZWQiLCJjbGFzc0NoYXJ0VGV4dCIsImNsYXNzQ2hhcnRMaW5lIiwiY2xhc3NDaGFydEJhciIsImNsYXNzQ2hhcnRBcmMiLCJjbGFzc0NoYXJ0UmFkYXIiLCJwZngiLCJzZWxlY3RvclRhcmdldHMiLCJpZHNWYWx1ZSIsInNlbGVjdG9yTGVnZW5kIiwic2VsZWN0b3JMZWdlbmRzIiwiY29sb3JpemVQYXR0ZXJuIiwicGF0dGVybiIsImNsb25lTm9kZSIsInNjaGVtZUNhdGVnb3J5MTAiLCJnZXRDb2xvckZyb21Dc3MiLCJib2R5Iiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidHJpbSIsIkJvb2xlYW4iLCJnZW5lcmF0ZUNvbG9yIiwiY29sb3JzIiwiZDNTY2FsZU9yZGluYWwiLCJvcmlnaW5hbENvbG9yUGF0dGVybiIsInRpbGVzIiwiY29sb3JpemVkUGF0dGVybnMiLCJwYXR0ZXJucyIsImlzTGluZSIsImlzVHlwZU9mIiwiZ2VuZXJhdGVMZXZlbENvbG9yIiwidGhyZXNob2xkIiwiYXNWYWx1ZSIsInVuaXQiLCJsIiwiZ2V0WURvbWFpbk1pbk1heCIsImlzTWluIiwiZGF0YUdyb3VwcyIsImlkc0luR3JvdXAiLCJiYXNlSWQiLCJiYXNlQXhpc0lkIiwibWVldENvbmRpdGlvbiIsImdldFlEb21haW5NaW4iLCJnZXRZRG9tYWluTWF4IiwidGFyZ2V0c0J5QXhpc0lkIiwieVRhcmdldHMiLCJ5TWluIiwieU1heCIsInlEb21haW5NaW4iLCJ5RG9tYWluTWF4IiwiY2VudGVyIiwiaXNaZXJvQmFzZWQiLCJpc0ludmVydGVkIiwic2hvd0hvcml6b250YWxEYXRhTGFiZWwiLCJzaG93VmVydGljYWxEYXRhTGFiZWwiLCJpc0FsbFBvc2l0aXZlIiwiaXNBbGxOZWdhdGl2ZSIsInlEb21haW5BYnMiLCJnZXRYRG9tYWluTWluTWF4IiwiZ2V0WERvbWFpbk1pbiIsImdldFhEb21haW5NYXgiLCJnZXRYRG9tYWluUGFkZGluZyIsIm1heERhdGFDb3VudCIsInhQYWRkaW5nIiwiZ2V0WERvbWFpbiIsImZpcnN0WCIsImxhc3RYIiwiZ2V0VGltZSIsIndpdGhUcmltIiwib3JnIiwiem9vbUVuYWJsZWQiLCJ1cGRhdGVTY2FsZUV4dGVudCIsImRvbWFpblZhbHVlIiwiaW52ZXJ0IiwidHJpbVhEb21haW4iLCJ6b29tRG9tYWluIiwiZ2V0Wm9vbURvbWFpbiIsImdldEZvcm1hdCIsInR5cGVWYWx1ZSIsImRlZmF1bHRWYWx1ZUZvcm1hdCIsImdldFlGb3JtYXQiLCJmb3JBcmMiLCJ5Rm9ybWF0IiwieTJGb3JtYXQiLCJkZWZhdWx0QXJjVmFsdWVGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiaW5pdExlZ2VuZCIsInVwZGF0ZUxlZ2VuZCIsIm9wdGlvbnoiLCJ3aXRoVHJhbnNmb3JtIiwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0iLCJ1cGRhdGVMZWdlbmRUZW1wbGF0ZSIsInVwZGF0ZUxlZ2VuZEVsZW1lbnQiLCJjbGFzc2VkIiwidXBkYXRlU2NhbGVzIiwidXBkYXRlU3ZnU2l6ZSIsInRyYW5zZm9ybUFsbCIsIndyYXBwZXIiLCJ0ZW1wbGF0ZSIsIkNPTE9SIiwiVElUTEUiLCJjaGlsZE5vZGVzIiwic2V0TGVnZW5kSXRlbSIsInVwZGF0ZVNpemVGb3JMZWdlbmQiLCJpbnNldExlZ2VuZFBvc2l0aW9uIiwiZ2V0Q3VycmVudFBhZGRpbmdUb3AiLCJnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSIsImdldEN1cnJlbnRQYWRkaW5nTGVmdCIsImdldEN1cnJlbnRQYWRkaW5nUmlnaHQiLCJOYU4iLCJ0cmFuc2Zvcm1MZWdlbmQiLCJ1cGRhdGVMZWdlbmRTdGVwIiwic3RlcCIsInVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCIsInVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJ1cGRhdGVMZWdlbmRJdGVtQ29sb3IiLCJnZXRMZWdlbmRXaWR0aCIsImdldExlZ2VuZEhlaWdodCIsIm9wYWNpdHlGb3JMZWdlbmQiLCJvcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJmb2N1cyIsInRhcmdldElkeiIsInJldmVydExlZ2VuZCIsInNob3dMZWdlbmQiLCJoaWRlTGVnZW5kIiwiZ2V0TGVnZW5kSXRlbVRleHRCb3giLCJ0ZXh0RWxlbWVudCIsImdldFRleHRSZWN0IiwiaXRlbSIsImlzVG91Y2giLCJoYXNHYXVnZSIsIml0ZW1DbGFzcyIsImFsdEtleSIsImhpZGUiLCJzaG93IiwidG9nZ2xlIiwicmV2ZXJ0IiwiaGlkZVRvb2x0aXAiLCJ1bmRvTWFya092ZXJsYXBwZWQiLCJtYXJrT3ZlcmxhcHBlZCIsInhGb3JMZWdlbmQiLCJ5Rm9yTGVnZW5kIiwicG9zTWluIiwidGlsZVdpZHRoIiwibWF4SGVpZ2h0IiwidG90YWxMZW5ndGgiLCJvZmZzZXRzIiwid2lkdGhzIiwiaGVpZ2h0cyIsIm1hcmdpbnMiLCJzdGVwcyIsImlzTGVnZW5kUmlnaHRPckluc2V0IiwidXBkYXRlUG9zaXRpb25zIiwiaXNMYXN0IiwiYm94IiwiaXRlbVdpZHRoIiwiaXRlbUhlaWdodCIsIml0ZW1MZW5ndGgiLCJhcmVhTGVuZ3RoIiwidXBkYXRlVmFsdWVzIiwiaWQyIiwid2l0aG91dFN0ZXAiLCJtYXhMZW5ndGgiLCJ4Rm9yTGVnZW5kVGV4dCIsInhGb3JMZWdlbmRSZWN0IiwieDFGb3JMZWdlbmRUaWxlIiwieDJGb3JMZWdlbmRUaWxlIiwieUZvckxlZ2VuZFRleHQiLCJ5Rm9yTGVnZW5kUmVjdCIsInlGb3JMZWdlbmRUaWxlIiwidXNlUG9pbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJkM05hbWVzcGFjZXMiLCJoYXNWYWxpZFBvaW50VHlwZSIsImlkeCIsIm5vZGVOYW1lIiwicmVjdHMiLCJwb2ludFIiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImxldmVsQ29sb3IiLCJnZXRTY2FsZSIsImZvclRpbWVzZXJpZXMiLCJkM1NjYWxlVGltZSIsImdldFgiLCJvZmZzZXQiLCJnZXRDdXN0b21pemVkU2NhbGUiLCJnZXRZIiwic2NhbGVWYWx1ZSIsIm9mZnNldFZhbHVlIiwicmF3Iiwib3JnU2NhbGUiLCJnZXRZU2NhbGUiLCJnZXRTdWJZU2NhbGUiLCJ4U3ViRG9tYWluIiwidXBkYXRlQXJjIiwic2V0Q29udGFpbmVyU2l6ZSIsImdldEN1cnJlbnRXaWR0aCIsImdldEN1cnJlbnRIZWlnaHQiLCJnZXRQYXJlbnRXaWR0aCIsImdldFBhcmVudEhlaWdodCIsImdldEF4aXNTaXplIiwiZ2V0QXhpc1dpZHRoQnlBeGlzSWQiLCJnZXRIb3Jpem9udGFsQXhpc0hlaWdodCIsImF4ZXNMZW4iLCJnZXRUaXRsZVBhZGRpbmciLCJheGlzV2lkdGgiLCJsZWdlbmRXaWR0aE9uUmlnaHQiLCJnZXRQYXJlbnRSZWN0VmFsdWUiLCJvZmZzZXROYW1lIiwicGFyZW50IiwidGFnTmFtZSIsImJvZHlXaWR0aCIsIm9mZnNldFdpZHRoIiwicGFyc2VJbnQiLCJnZXRTdmdMZWZ0IiwiaGFzTGVmdEF4aXNSZWN0IiwibGVmdEF4aXNDbGFzcyIsImxlZnRBeGlzIiwic3ZnUmVjdCIsImNoYXJ0UmVjdCIsImhhc0FyYyIsInN2Z0xlZnQiLCJjb3MiLCJnZXRFdmVudFJlY3RXaWR0aCIsInVwZGF0ZURpbWVuc2lvbiIsIndpdGhvdXRBeGlzIiwiYnJ1c2hTaXplIiwiZ2V0WEF4aXNDbGlwWCIsImdldFhBeGlzQ2xpcFkiLCJnZXRYQXhpc0NsaXBXaWR0aCIsImdldFhBeGlzQ2xpcEhlaWdodCIsImdldFlBeGlzQ2xpcFgiLCJnZXRZQXhpc0NsaXBZIiwiZ2V0WUF4aXNDbGlwV2lkdGgiLCJnZXRZQXhpc0NsaXBIZWlnaHQiLCJ1cGRhdGVTaXplcyIsImN1cnJMZWdlbmQiLCJsZWdlbmRIZWlnaHRGb3JCb3R0b20iLCJ4QXhpc0hlaWdodCIsInN1YmNoYXJ0WEF4aXNIZWlnaHQiLCJzdWJjaGFydEhlaWdodCIsImdldEdhdWdlTGFiZWxIZWlnaHQiLCJ1cGRhdGVSYWRpdXMiLCJvcGFjaXR5Rm9yVGV4dCIsImluaXRUZXh0IiwidXBkYXRlVGFyZ2V0c0ZvclRleHQiLCJtYWluVGV4dFVwZGF0ZSIsIm1haW5UZXh0RW50ZXIiLCJ1cGRhdGVUZXh0IiwiZHVyYXRpb25Gb3JFeGl0IiwiZGF0YUZuIiwibGFiZWxpc2hEYXRhIiwiaXNSYWRhclR5cGUiLCJ1cGRhdGVUZXh0Q29sb3IiLCJsYWJlbENvbG9ycyIsInJlZHJhd1RleHQiLCJmb3JGbG93IiwiZWxlbWVudCIsImJhc2UiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJnZW5lcmF0ZVhZRm9yVGV4dCIsImluZGljZXMiLCJmb3JYIiwicG9pbnRzIiwiZ2V0dGVyIiwiZ2V0WEZvclRleHQiLCJnZXRZRm9yVGV4dCIsImlzQXJlYVR5cGUiLCJnZXRDZW50ZXJlZFRleHRQb3MiLCJjZW50ZXJlZCIsImlzUG9zaXRpdmUiLCJnZXRUZXh0UG9zIiwieFBvcyIsInlQb3MiLCJiYXNlWSIsImlzTGluZVR5cGUiLCJpc1NjYXR0ZXJUeXBlIiwiaXNCdWJibGVUeXBlIiwiYm94SGVpZ2h0IiwidGV4dE5vZGVzIiwiZmlsdGVyZWRUZXh0Tm9kZXMiLCJ0ZXh0Tm9kZSIsInRyYW5zbGF0ZSIsImNhbGNIeXBvIiwiY29vcmRpbmF0ZSIsImZpbHRlcmVkVGV4dE5vZGUiLCJub2RlRm9yV2lkdGgiLCJvdmVybGFwc1giLCJnZXRDb21wdXRlZFRleHRMZW5ndGgiLCJvdmVybGFwc1kiLCJkM1NlbGVjdEFsbCIsInByZXZpb3VzU2libGluZyIsImlzTnVtIiwiaW5pdFRpdGxlIiwicmVkcmF3VGl0bGUiLCJ5Rm9yVGl0bGUiLCJ4Rm9yVGl0bGUiLCJ0ZXh0UmVjdFdpZHRoIiwiaW5pdFRvb2x0aXAiLCJnZXRUb29sdGlwSFRNTCIsImdldFRvb2x0aXBDb250ZW50IiwiZGVmYXVsdFRpdGxlRm9ybWF0IiwidGl0bGVGb3JtYXQiLCJuYW1lRm9ybWF0IiwidmFsdWVGb3JtYXQiLCJnZXRSb3dWYWx1ZSIsImdldEJnQ29sb3IiLCJjb250ZW50cyIsInRwbFN0ciIsImkyIiwicGFyYW0iLCJnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlIiwiQ0xBU1NfVE9PTFRJUCIsImhpZ2giLCJsb3ciLCJjb250ZW50VmFsdWUiLCJDTEFTU19UT09MVElQX05BTUUiLCJOQU1FIiwiVkFMVUUiLCJ0b29sdGlwUG9zaXRpb24iLCJkYXRhVG9TaG93IiwidFdpZHRoIiwidEhlaWdodCIsImNoYXJ0UmlnaHQiLCJkYXRhU2NhbGUiLCJzaG93VG9vbHRpcCIsInNlbGVjdGVkRGF0YSIsImRhdGFTdHIiLCJzdHJpbmdpZnkiLCJwcm9wZXJ0eSIsIl9oYW5kbGVMaW5rZWRDaGFydHMiLCJjaGFydHMiLCJsaW5rZWROYW1lIiwiaW50ZXJuYWwiLCJpc0xpbmtlZCIsImlzSW5Eb20iLCJjb250YWlucyIsImlzTm90U2FtZUluZGV4IiwiZ2V0UmFkYXJTaXplIiwidHJhbnNmb3JtTWFpbiIsInhBeGlzIiwieUF4aXMiLCJ5MkF4aXMiLCJ0cmFuc2Zvcm1Db250ZXh0IiwiVFlQRVMiLCJBcmVhIiwiQXJlYVJhbmdlIiwiQXJjIiwiTGluZSIsIlN0ZXAiLCJTcGxpbmUiLCJoYXNUeXBlT2YiLCJleGNsdWRlIiwiZGF0YVR5cGUiLCJoYXNQb2ludFR5cGUiLCJoYXNNdWx0aUFyY0dhdWdlIiwiaXNTdGVwVHlwZSIsImlzU3BsaW5lVHlwZSIsImlzUGllVHlwZSIsImlzR2F1Z2VUeXBlIiwiaXNEb251dFR5cGUiLCJpc0FyY1R5cGUiLCJpc0NpcmNsZVBvaW50IiwibGluZURhdGEiLCJhcmNEYXRhIiwiYmFyRGF0YSIsImJhckxpbmVCdWJibGVEYXRhIiwiaXNJbnRlcnBvbGF0aW9uVHlwZSIsInNldE1pbk1heCIsImNhdGVnb3J5IiwidG8iLCJ0YWlsIiwibm90Zm91bmRJZHMiLCJvcmdEYXRhQ291bnQiLCJtaXNzaW5nIiwiYmFzZVRhcmdldCIsImJhc2VWYWx1ZSIsIndpdGhUcmltWERvbWFpbiIsIndpdGhVcGRhdGVYQXhpcyIsImdyaWRzIiwicmVkcmF3V2l0aG91dFJlc2NhbGUiLCJyZW1vdmVHcmlkTGluZXMiLCJodHRwIiwiZ3JvdXBzIiwib3B0aW9uc1ZhbHVlIiwic2VsZWN0ZWQiLCJkYXRhUG9pbnQiLCJyZXNldE90aGVyIiwiZ2V0VG9nZ2xlIiwiaXNUYXJnZXRJZCIsImlzVGFyZ2V0SW5kZXgiLCJpc1NlbGVjdGVkIiwidW5zZWxlY3QiLCJ3aXRoaW5SYW5nZSIsInJlc3VsdERvbWFpbiIsInhTY2FsZSIsImdldFNlbGVjdGlvbiIsIm1vdmUiLCJ3aXRoWSIsIndpdGhEaW1lbnNpb24iLCJzZXRab29tUmVzZXRCdXR0b24iLCJlbmFibGUiLCJlbmFibGVkIiwiZW5hYmxlVHlwZSIsImJpbmRab29tRXZlbnQiLCJpbml0Wm9vbSIsInVwZGF0ZUFuZFJlZHJhdyIsInVuem9vbSIsInVwZGF0ZVRyYW5zZm9ybVNjYWxlIiwiZDNab29tSWRlbnRpdHkiLCJ1cGRhdGVab29tIiwicmVzZXRCdG4iLCJkM1pvb21UcmFuc2Zvcm0iLCJhbHREb21haW4iLCJzeCIsInN5IiwibXgiLCJteSIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJpc0luY2x1ZGVkIiwiaXNXaXRoaW4iLCJ0b2dnbGVQb2ludCIsInRvZ2dsZVBhdGgiLCJzZXREcmFnU3RhdHVzIiwiaXNEcmFnZ2luZyIsImdlbmVyYXRlRmxvdyIsImZsb3dMZW5ndGgiLCJ1cGRhdGVYR3JpZCIsImVsZW1lbnRzIiwiaGlkZUdyaWRGb2N1cyIsInNldEZsb3dMaXN0IiwiZmxvd0luZGV4IiwiZ2V0Rmxvd1RyYW5zZm9ybSIsIndhaXQiLCJnZW5lcmF0ZVdhaXQiLCJndCIsImQzVHJhbnNpdGlvbiIsImVhc2UiLCJkM0Vhc2VMaW5lYXIiLCJpc1JlZ2lvbk9uWCIsImNsZWFuVXBGbG93IiwieHYiLCJjeCIsImN5IiwieEZvclRleHQiLCJyZWdpb25YIiwicmVnaW9uV2lkdGgiLCJ4RnVuYyIsInlGdW5jIiwicmVkcmF3RXZlbnRSZWN0IiwidHJhbnNsYXRlWCIsImZsb3dTdGFydCIsImZsb3dFbmQiLCJzY2FsZVgiLCJpbml0RXZlbnRSZWN0IiwiZXZlbnRSZWN0VXBkYXRlIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yTXVsdGlwbGVYcyIsInhBeGlzVGlja1ZhbHVlcyIsInVwZGF0ZVBvaW50Q2xhc3MiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYIiwidXBkYXRlRXZlbnRSZWN0IiwiYmluZFRvdWNoT25FdmVudFJlY3QiLCJzdGFydFB4IiwiZ2V0RXZlbnRSZWN0IiwiZWxlbWVudEZyb21Qb2ludCIsImdldEluZGV4Iiwic2VsZWN0UmVjdCIsImNvbnRleHQiLCJzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyIsInVuc2VsZWN0UmVjdCIsInNlbGVjdFJlY3RGb3JTaW5nbGUiLCJwcmV2ZW50RGVmYXVsdCIsImlzUHJldmVudGVkIiwicHJldmVudFRocmVzaG9sZCIsInByZXZlbnRFdmVudCIsImN1cnJlbnRYWSIsInRvZ2dsZVNoYXBlIiwiZXZlbnRSZWN0RGF0YSIsInJlY3RXIiwicmVjdFgiLCJnZXRQcmV2TmV4dFgiLCJwcmV2IiwibmV4dCIsInRoaXNYIiwiaXNTZWxlY3Rpb25FbmFibGVkIiwiaXNTZWxlY3Rpb25Hcm91cGVkIiwiaXNUb29sdGlwR3JvdXBlZCIsInNob3dHcmlkRm9jdXMiLCJ1bmV4cGFuZENpcmNsZXMiLCJleHBhbmRDaXJjbGVzIiwiZXhwYW5kQmFycyIsInNhbWVYRGF0YSIsInVuZXhwYW5kQmFycyIsImV2ZW50UmVjdEVudGVyIiwiY2xpY2tIYW5kbGVyRm9yU2luZ2xlWCIsImQyIiwiY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUyIsImluaXRCcnVzaCIsImQzQnJ1c2hZIiwiZDNCcnVzaFgiLCJsYXN0RG9tYWluIiwidGltZW91dCIsImJydXNoSGFuZGxlciIsInJlZHJhd0ZvckJydXNoIiwiZ2V0QnJ1c2hTaXplIiwidXBkYXRlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInVwZGF0ZSIsImV4dGVudCIsImdldEV4dGVudCIsImluaXRTdWJjaGFydCIsImRlZnMiLCJ2aXNpYmlsaXR5IiwiY2xpcElkIiwiZ2V0Q2xpcFBhdGgiLCJhcHBlbmRDbGlwIiwidXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0IiwiYmFyVXBkYXRlIiwiYmFyRW50ZXIiLCJsaW5lRW50ZXIiLCJ1cGRhdGVCYXJGb3JTdWJjaGFydCIsImluaXRpYWxPcGFjaXR5IiwicmVkcmF3QmFyRm9yU3ViY2hhcnQiLCJkcmF3QmFyT25TdWIiLCJ1cGRhdGVMaW5lRm9yU3ViY2hhcnQiLCJyZWRyYXdMaW5lRm9yU3ViY2hhcnQiLCJkcmF3TGluZU9uU3ViIiwidXBkYXRlQXJlYUZvclN1YmNoYXJ0IiwicmVkcmF3QXJlYUZvclN1YmNoYXJ0IiwiZHJhd0FyZWFPblN1YiIsInJlZHJhd1N1YmNoYXJ0Iiwid2l0aFN1YmNoYXJ0IiwiZHJhdyIsInN1YlhBeGlzIiwiZ2VuZXJhdGVab29tIiwiaW5pdFpvb21CZWhhdmlvdXIiLCJiaW5kWm9vbU9uRXZlbnRSZWN0IiwiZDNab29tIiwib25ab29tU3RhcnQiLCJvblpvb20iLCJvblpvb21FbmQiLCJvcmdTY2FsZUV4dGVudCIsInJlc2NhbGUiLCJzb3VyY2VFdmVudCIsInN0YXJ0RXZlbnQiLCJpc01vdXNlbW92ZSIsImlzWm9vbU91dCIsIndoZWVsRGVsdGEiLCJ3aXRoRXZlbnRSZWN0IiwiZGVsdGEiLCJpc2Z1bGx5U2hvd24iLCJiZWhhdmlvdXIiLCJ6b29tQmVoYXZpb3VyIiwicHJvcCIsImNsaWNrRGlzdGFuY2UiLCJyZXNldEJ1dHRvbiIsIm9uY2xpY2siLCJpbml0Q2xpcCIsImlzSUU5IiwiYXBwVmVyc2lvbiIsIlVSTCIsImdldEF4aXNDbGlwWCIsImdldEF4aXNDbGlwWSIsImdldEF4aXNDbGlwV2lkdGgiLCJnZXRBeGlzQ2xpcEhlaWdodCIsImdldEdyaWRUZXh0QW5jaG9yIiwiZ2V0R3JpZFRleHREeCIsImdldEdyaWRUZXh0WCIsInNtb290aExpbmVzIiwiaW5pdEdyaWQiLCJpbml0R3JpZExpbmVzIiwiaW5pdEZvY3VzR3JpZCIsIndpdGhvdXRVcGRhdGUiLCJ4Z3JpZERhdGEiLCJnZW5lcmF0ZUdyaWREYXRhIiwidXBkYXRlWUdyaWQiLCJncmlkVmFsdWVzIiwidXBkYXRlR3JpZCIsInVwZGF0ZVhHcmlkTGluZXMiLCJ1cGRhdGVZR3JpZExpbmVzIiwieExpbmVzIiwieXYiLCJyZWRyYXdHcmlkIiwiaXNGcm9udCIsImZvY3VzRWwiLCJpc0VkZ2UiLCJ4eCIsInh5IiwiaXNZMiIsInVwZGF0ZWdyaWRGb2N1cyIsInRpY2tOdW0iLCJncmlkRGF0YSIsImZpcnN0WWVhciIsImdldEZ1bGxZZWFyIiwibGFzdFllYXIiLCJnZXRHcmlkRmlsdGVyVG9SZW1vdmUiLCJ0b1JlbW92ZSIsImluaXRSZWdpb24iLCJ1cGRhdGVSZWdpb24iLCJsaXN0IiwicmVkcmF3UmVnaW9uIiwicmVnaW9uWSIsInJlZ2lvbkhlaWdodCIsImdldFJlZ2lvblhZIiwiY3VyclNjYWxlIiwiZ2V0UmVnaW9uU2l6ZSIsImlzV2lkdGgiLCJzZWxlY3RQb2ludCIsImNpcmNsZVgiLCJwb2ludFNlbGVjdFIiLCJ1bnNlbGVjdFBvaW50IiwibWV0aG9kIiwic2VsZWN0UGF0aCIsImQzUmdiIiwiYnJpZ2h0ZXIiLCJ1bnNlbGVjdFBhdGgiLCJ0aGF0IiwidG9nZ2xlZFNoYXBlIiwiaW5pdEJhciIsInVwZGF0ZVRhcmdldHNGb3JCYXIiLCJtYWluQmFyVXBkYXRlIiwibWFpbkJhckVudGVyIiwidXBkYXRlQmFyIiwicmVkcmF3QmFyIiwiZHJhd0JhciIsImdldEJhclciLCJiYXJUYXJnZXRzTnVtIiwicmVzdWx0IiwiZ2V0V2lkdGgiLCJnZXRCYXJzIiwic3VmZml4IiwiZ2VuZXJhdGVEcmF3QmFyIiwiYmFySW5kaWNlcyIsImlzU3ViIiwiZ2V0UG9pbnRzIiwiZ2VuZXJhdGVHZXRCYXJQb2ludHMiLCJiYXJSYWRpdXMiLCJiYXJSYWRpdXNSYXRpbyIsImdldFJhZGl1cyIsImluZGV4WCIsImluZGV4WSIsImlzTmVnYXRpdmUiLCJwYXRoUmFkaXVzIiwiYmFyVyIsImdldEluZGljZXNNYXgiLCJiYXJYIiwiZ2V0U2hhcGVYIiwiYmFyWSIsImdldFNoYXBlWSIsImJhck9mZnNldCIsImdldFNoYXBlT2Zmc2V0IiwieVNjYWxlIiwieTAiLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsIm1haW5MaW5lVXBkYXRlIiwibWFpbkxpbmVFbnRlciIsInVwZGF0ZUxpbmUiLCJleHRyYUxpbmVDbGFzc2VzIiwicmVkcmF3TGluZSIsImRyYXdMaW5lIiwiZ2V0Q3VydmUiLCJpc1JvdGF0ZWRTdGVwVHlwZSIsImdldEludGVycG9sYXRlIiwib3JnUG9pbnQiLCJwb2ludFJvdGF0ZWQiLCJfcG9pbnQiLCJfeSIsIl90IiwiX2NvbnRleHQiLCJsaW5lVG8iLCJfeCIsImdlbmVyYXRlRHJhd0xpbmUiLCJsaW5lSW5kaWNlcyIsImxpbmVDb25uZWN0TnVsbCIsImdlbmVyYXRlR2V0TGluZVBvaW50cyIsInlTY2FsZUdldHRlciIsInhWYWx1ZSIsInN1Ynh4IiwieVZhbHVlIiwiZDNMaW5lIiwiZGVmaW5lZCIsIngwIiwibGluZVdpdGhSZWdpb25zIiwiY3VydmUiLCJpc1N1YlZhbHVlIiwibGluZU9mZnNldCIsIl9yZWdpb25zIiwieHAiLCJ5cCIsImRpZmZ4MiIsImRhc2hhcnJheSIsImlzV2l0aGluUmVnaW9ucyIsIndpdGhpblgiLCJ3aXRoaW5SZWdpb25zIiwicmVnIiwiZ2V0VmFsdWUiLCJkdCIsImdlbmVyYXRlTSIsInNXaXRoUmVnaW9uIiwiZDAiLCJkMSIsInRpbWVzZXJpZXNEaWZmIiwieERpZmYiLCJ4djAiLCJ4djEiLCJvdGhlckRpZmYiLCJwcmV2RGF0YSIsImhhc1ByZXZEYXRhIiwiZGQiLCJ1cGRhdGVBcmVhR3JhZGllbnQiLCJzdG9wcyIsImxpbmVhckdyYWRpZW50Iiwic3RvcENvbG9yIiwidXBkYXRlQXJlYUNvbG9yIiwidXBkYXRlQXJlYSIsInJlZHJhd0FyZWEiLCJkcmF3QXJlYSIsImdlbmVyYXRlRHJhd0FyZWEiLCJhcmVhSW5kaWNlcyIsImdlbmVyYXRlR2V0QXJlYVBvaW50cyIsInZhbHVlMCIsInZhbHVlMSIsImQzQXJlYSIsImFyZWFPZmZzZXQiLCJpc1dpdGhpblN0ZXAiLCJzaG91bGREcmF3UG9pbnRzRm9yTGluZSIsImxpbmVQb2ludCIsImhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyIsInBvaW50VHlwZSIsImluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlIiwib3BhY2l0eUZvckNpcmNsZSIsImluaXRDaXJjbGUiLCJnZW5lcmF0ZVBvaW50IiwidXBkYXRlVGFyZ2V0Rm9yQ2lyY2xlIiwibWFpbkNpcmNsZSIsIm1haW5DaXJjbGVFbnRlciIsInVwZGF0ZUNpcmNsZSIsInJlZHJhd0NpcmNsZSIsInBvc0F0dHIiLCJvcGFjaXR5U3R5bGVGbiIsIm1haW5DaXJjbGVzIiwidXBkYXRlQ2lyY2xlWSIsImdldFNoYXBlSW5kaWNlcyIsImdldENpcmNsZXMiLCJwb2ludEV4cGFuZGVkUiIsInNlbGVjdFIiLCJpc1dpdGhpbkNpcmNsZSIsImluc2VydFBvaW50SW5mb0RlZnMiLCJjb3B5QXR0ciIsImZyb20iLCJhdHRyaWJzIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNsb25lIiwiZmlsbCIsInN0cm9rZSIsImlubmVySFRNTCIsInBvaW50RnJvbURlZnMiLCJwb2ludENsYXNzIiwicG9pbnRJZCIsImN1c3RvbSIsImdldFRyYW5zaXRpb25OYW1lIiwic2l6ZUZuIiwiZmlsbFN0eWxlRm4iLCJ4UG9zRm4iLCJ5UG9zRm4iLCJ4UG9zRm4yIiwidHJhbnNpdGlvbk5hbWUiLCJyZWN0YW5nbGUiLCJyZWN0U2l6ZUZuIiwicmVjdFhQb3NGbiIsImdldERyYXdTaGFwZSIsImhhc1JhZGFyIiwicmFkYXJDaXJjbGVYIiwicmFkYXJDaXJjbGVZIiwidHlwZUZpbHRlciIsImhhc1hzIiwiaW5kIiwiX19tYXhfXyIsImdldEluZGljZXMiLCJiYXJQYWRkaW5nIiwiaGFsZldpZHRoIiwidGFyZ2V0c051bSIsImdldFNoYXBlT2Zmc2V0RGF0YSIsInNoYXBlT2Zmc2V0VGFyZ2V0cyIsInJvd1ZhbHVlcyIsInJvd1ZhbHVlTWFwQnlYVmFsdWUiLCJpbmRleE1hcEJ5VGFyZ2V0SWQiLCJkYXRhWEFzTnVtYmVyIiwicm93VmFsdWUiLCJpbnRlcnBvbGF0aW9uIiwiZ2V0SW50ZXJwb2xhdGVUeXBlIiwiZDNDdXJ2ZUJhc2lzIiwiZDNDdXJ2ZUJhc2lzQ2xvc2VkIiwiZDNDdXJ2ZUJhc2lzT3BlbiIsImQzQ3VydmVCdW5kbGUiLCJkM0N1cnZlQ2FyZGluYWwiLCJkM0N1cnZlQ2FyZGluYWxDbG9zZWQiLCJkM0N1cnZlQ2FyZGluYWxPcGVuIiwiZDNDdXJ2ZUNhdG11bGxSb20iLCJkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCIsImQzQ3VydmVDYXRtdWxsUm9tT3BlbiIsImQzQ3VydmVNb25vdG9uZVgiLCJkM0N1cnZlTW9ub3RvbmVZIiwiZDNDdXJ2ZU5hdHVyYWwiLCJkM0N1cnZlTGluZWFyQ2xvc2VkIiwiZDNDdXJ2ZUxpbmVhciIsImQzQ3VydmVTdGVwIiwiZDNDdXJ2ZVN0ZXBBZnRlciIsImQzQ3VydmVTdGVwQmVmb3JlIiwiYXBpQXhpcyIsImFwaUNhdGVnb3J5IiwiYXBpRmxvdyIsImFwaVhHcmlkIiwiYXBpWUdyaWQiLCJhcGlHcm91cCIsImFwaVJlZ2lvbiIsImFwaVNlbGVjdGlvbiIsImFwaVgiLCJhcGlab29tIiwiZXZlbnRyZWN0IiwiaW5pdFBpZSIsInN0YXJ0aW5nQW5nbGUiLCJkM1BpZSIsInNvcnRWYWx1ZXMiLCJnZXRJbm5lclJhZGl1cyIsInN2Z0FyYyIsImdldFN2Z0FyYyIsInN2Z0FyY0V4cGFuZGVkIiwiZ2V0U3ZnQXJjRXhwYW5kZWQiLCJ1cGRhdGVBbmdsZSIsImRWYWx1ZSIsImdTdGFydCIsInRvdGFsU3VtIiwiZ0VuZCIsImdNaW4iLCJnTWF4IiwiZ1ZhbHVlIiwiaXIiLCJzaW5nbGVBcmNXaWR0aCIsImQzQXJjIiwib3V0ZXJSYWRpdXMiLCJuZXdBcmMiLCJ1cGRhdGVkIiwiY2VudHJvaWQiLCJyYXRlIiwibmV3UmF0ZSIsImV4cGFuZFdpZHRoIiwiZ2V0QXJjIiwidHJhbnNmb3JtRm9yQXJjTGFiZWwiLCJjb252ZXJ0VG9BcmNEYXRhIiwidGV4dEZvckFyY0xhYmVsIiwic2hvdWxkU2hvd0FyY0xhYmVsIiwiaXNVbmRlclRocmVzaG9sZCIsIm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQiLCJnZXRBcmNMYWJlbEZvcm1hdCIsInRleHRGb3JHYXVnZU1pbk1heCIsImlzTWF4IiwiZXhwYW5kQXJjIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmV3VGFyZ2V0SWRzIiwic2hvdWxkRXhwYW5kIiwiZXhwYW5kRHVyYXRpb24iLCJnZXRFeHBhbmRDb25maWciLCJzdmdBcmNFeHBhbmRlZFN1YiIsInVuZXhwYW5kQXJjIiwiZ2V0QXJjVGl0bGUiLCJ1cGRhdGVUYXJnZXRzRm9yQXJjIiwibWFpblBpZVVwZGF0ZSIsIm1haW5QaWVFbnRlciIsImluaXRBcmMiLCJzZXRBcmNUaXRsZSIsInJlZHJhd0FyYyIsImhhc0ludGVyYWN0aW9uIiwibWFpbkFyYyIsIl9jdXJyZW50IiwicmVkcmF3TXVsdGlBcmNHYXVnZSIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJhcmNMYWJlbExpbmVzIiwibWFpbkFyY0xhYmVsTGluZSIsImxpbmVMZW5ndGgiLCJsaW5lVGhpY2tuZXNzIiwiaW5uZXJMaW5lTGVuZ3RoIiwibGluZUFuZ2xlIiwiYXJjSW5uZXJSYWRpdXMiLCJsaW5lUG9zaXRpb25pbmdBbmdsZSIsInNlbGVjdEFyYyIsIl90aGlzIiwidW5zZWxlY3RBcmMiLCJpc01vdXNlIiwicmFkYXJzIiwiZ2V0RXZlbnRBcmMiLCJldmVudEFyYyIsImhhbmRsZXIiLCJpc0Z1bGxDaXJjbGUiLCJiYWNrZ3JvdW5kQXJjIiwiaW5pdEdhdWdlIiwiYXBwZW5kVGV4dCIsImdldFBvc2l0aW9uIiwiaXNDbG9ja3dpc2UiLCJlZGdlIiwiZnVuYyIsImluaXRSYWRhciIsInVwZGF0ZVRhcmdldHNGb3JSYWRhciIsImdlbmVyYXRlUmFkYXJQb2ludHMiLCJnZXRSYWRhclBvc2l0aW9uIiwiX3NpemUiLCJyZWRyYXdSYWRhciIsInVwZGF0ZVJhZGFyTGV2ZWwiLCJ1cGRhdGVSYWRhckF4ZXMiLCJ1cGRhdGVSYWRhclNoYXBlIiwiZ2VuZXJhdGVHZXRSYWRhclBvaW50cyIsImRlcHRoIiwic2hvd1RleHQiLCJyYWRhckxldmVscyIsImxldmVsRGF0YSIsImxldmVsUmF0aW8iLCJsZXZlbFRleHRGb3JtYXQiLCJqb2luIiwibGV2ZWxFbnRlciIsImF4aXNFbnRlciIsImZpcnN0Q2hpbGQiLCJiaW5kRXZlbnQiLCJub0luZGV4IiwiYXJlYXNFbnRlciIsIkNoYXJ0SW50ZXJuYWwiLCJTdG9yZSIsImJlZm9yZUluaXQiLCJjYWxsUGx1Z2luSG9vayIsImFmdGVySW5pdCIsImluaXRQYXJhbXMiLCJjbGFzc25hbWUiLCJpbml0VG9SZW5kZXIiLCJmb3JjZWQiLCJpc0xhenkiLCJsYXp5IiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJtdXRhdGlvbiIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImF0dHJpYnV0ZUZpbHRlciIsImNvbnZlcnRlZERhdGEiLCJpbml0V2l0aERhdGEiLCJkM1RpbWVQYXJzZSIsImQzVXRjUGFyc2UiLCJkM1RpbWVGb3JtYXQiLCJkM1V0Y0Zvcm1hdCIsImlzRHJhZ1pvb20iLCJpc1pvb21lZCIsInNwZWNpZmllciIsImdldE1pbGxpc2Vjb25kcyIsImdldFNlY29uZHMiLCJnZXRNaW51dGVzIiwiZ2V0SG91cnMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJyb3RhdGVkUGFkZGluZ1JpZ2h0IiwiaGFzQ29sb3JQYXR0ZXJucyIsImluaXRDaGFydEVsZW1lbnRzIiwic2V0QmFja2dyb3VuZCIsIndpdGhUcmFuc2l0aW9uRm9yQXhpcyIsImluaXRpYWxpemluZyIsImJpbmRSZXNpemUiLCJzZXRDaGFydEVsZW1lbnRzIiwiJCIsImJnIiwiaW1nVXJsIiwic2hvd1RhcmdldHMiLCJnZXRXaXRoT3B0aW9uIiwid2l0aE9wdGlvbnMiLCJTdWJjaGFydCIsIkV2ZW50UmVjdCIsIkRpbWVuc2lvbiIsIlRyYW5zZm9ybSIsIkxlZ2VuZCIsIlRyYW5zaXRpb25Gb3JFeGl0IiwiVHJhbnNpdGlvbkZvckF4aXMiLCJkZWZWYWwiLCJ0cmFuc2l0aW9uc1ZhbHVlIiwiZHVyYXRpb25Gb3JBeGlzIiwiZ2VuZXJhdGVSZWRyYXdMaXN0IiwiZmxvd0ZuIiwiaXNUcmFuc2l0aW9uIiwicmVkcmF3TGlzdCIsImdldFJlZHJhd0xpc3QiLCJhZnRlclJlZHJhdyIsIndhaXRGb3JEcmF3Iiwid2l0aFRyYW5zaXRpb25Gb3JFeGl0IiwicmVzaXplRnVuY3Rpb24iLCJnZW5lcmF0ZVJlc2l6ZSIsInJlc2l6ZVRpbWVvdXQiLCJmbHVzaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYWxsUmVzaXplRnVuY3Rpb25zIiwicmVzaXplRnVuY3Rpb25zIiwidHJhbnNpdGlvbnNUb1dhaXQiLCJsb29wIiwidGltZXIiLCJwaGFzZSIsInByb3RvdHlwZSIsImRhdGFDb252ZXJ0IiwiZGF0YUxvYWQiLCJjbGFzc01vZHVsZSIsIm1vZHVsZUFyYyIsIm1vZHVsZUF4aXMiLCJsb2FkQ29uZmlnIiwicmVhZCIsInRoaXNDb25maWciLCJmaW5kIiwicmVzaXplIiwic29mdCIsIl9pc0Zyb21SZXNpemUiLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZsYXQiLCJkYXRhVmFsdWUiLCJuYW1lcyIsImI2NEVuY29kZVVuaWNvZGUiLCJidG9hIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJub2RlVG9TdmdEYXRhVXJsIiwic2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJjc3NUZXh0IiwieGh0bWwiLCJub2RlWG1sIiwic2VyaWFsaXplVG9TdHJpbmciLCJjcmVhdGVUZXh0Tm9kZSIsInN0eWxlWG1sIiwiZXhwb3J0Iiwic3ZnRGF0YVVybCIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbmxvYWQiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwic3JjIiwidGFyZ2V0SWRzVmFsdWUiLCJkZWZvY3VzIiwiYXJnc1ZhbHVlIiwic2hvd0hpZGUiLCJldmVudE5hbWUiLCJDaGFydCIsImJpbmRUaGlzIiwiYXJnVGhpcyIsImlzRnVuYyIsImlzQ2hpbGQiLCJoYXNDaGlsZCIsImFwaUNoYXJ0IiwiYXBpQ29sb3IiLCJhcGlEYXRhIiwiYXBpRXhwb3J0IiwiYXBpRm9jdXMiLCJhcGlMZWdlbmQiLCJhcGlMb2FkIiwiYXBpU2hvdyIsImFwaVRvb2x0aXAiLCJkZWZhdWx0cyIsImJiIiwidmVyc2lvbiIsImdlbmVyYXRlIiwiaW5zdCIsImluc3RhbmNlIiwicGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBLHVEQUFhO0FBQ2I7O0FBRUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBWTs7QUFFcEMsYUFBYSxtQkFBTyxDQUFDLENBQVU7O0FBRS9CLGNBQWMsbUJBQU8sQ0FBQyxDQUFXOztBQUVqQyxlQUFlLG1CQUFPLENBQUMsRUFBYTtBQUNwQztBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLEVBQXFCOztBQUUvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFtQjs7QUFFM0Ms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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSw4WEFB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGdGQUFnRjtBQUNuRjtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHdHQUF3RztBQUMzRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUscUZBQXFGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FB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RkFBb0Y7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsbUJBQW1CLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtJQUFrSTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHlCQUF5QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSxpQ0FBaUM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLGtHQUFrRztBQUNyRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBLENBQUMsRUFBRSwrRkFBK0Y7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7O0FBRUEsQ0FBQyxFQUFFLDBFQUEwRTtBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBLENBQUMsRUFBRSx1R0FBdUc7QUFDMUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsNkhBQTZIO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDLEVBQUUsV0FBVztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUN2SFk7O0FBRVo7O0FBRUE7QUFDQSxtREFBbUQsSUFBSSxTQUFTLE1BQU0sSUFBSTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSDtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsK0JBQStCO0FBQ2hGO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9LQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxFQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUNwRDs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsV0FBVztBQUNYLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFKQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEpBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDN0xhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyxFQUFVOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsb0NBQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzFCLEtBQUssTUFBTSxFQUlOO0FBQ0wsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7OztBQzNRWTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHlCOzs7Ozs7O0FDYmE7QUFDYjs7QUFFQSxlQUFlLG1CQUFPLENBQUMsRUFBTztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsRUFBcUI7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDdERBLG1CQUFtQixtQkFBTyxDQUFDLEVBQVE7QUFDbkM7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzN0QkE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLEtBQTBCO0FBQzdDO0FBQ0Esa0JBQWtCLEtBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qix5Q0FBeUMscUJBQXFCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFFVTtBQUNaO0FBQ0EsRUFBRSxtQ0FBbUI7QUFDckI7QUFDQSxHQUFHO0FBQUEsb0dBQUM7QUFDSixFQUFFLE1BQU0sRUFVTjs7QUFFRixDQUFDOzs7Ozs7OztBQ2poQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2ZhOztBQUViLGlDQUFpQyxtQkFBTyxDQUFDLEVBQVU7QUFDbkQscUNBQXFDLG1CQUFPLENBQUMsRUFBVTs7Ozs7Ozs7QUNIdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9EYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQSx3Qzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCOzs7Ozs7QUN0QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7QUMxREEsVUFBVSxtQkFBTyxDQUFDLEVBQTJFO0FBQzdGLDBCQUEwQixtQkFBTyxDQUFDLEVBQXlHOztBQUUzSTs7QUFFQTtBQUNBLDBCQUEwQixRQUFTO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQSwwQjs7Ozs7OztBQ3BCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsU0FBSTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EscUVBQXFFLHFCQUFxQixhQUFhOztBQUV2Rzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7OztBQzVRQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLEVBQW1EO0FBQzdGO0FBQ0E7QUFDQSxjQUFjLFFBQVMsNkJBQTZCLDBCQUEwQixrREFBa0QsRUFBRSx3QkFBd0IsZUFBZSxpQkFBaUIsRUFBRSw4QkFBOEIsOEJBQThCLDJCQUEyQixzQkFBc0IsRUFBRSwyR0FBMkcsZ0NBQWdDLEVBQUUsbUNBQW1DLGVBQWUsRUFBRSx3QkFBd0IsaUJBQWlCLEVBQUUsd0JBQXdCLGlCQUFpQixvQkFBb0IsRUFBRSx3QkFBd0IsZUFBZSxvQkFBb0IsRUFBRSw4QkFBOEIsZ0NBQWdDLEVBQUUsbUNBQW1DLGlCQUFpQixFQUFFLG1CQUFtQixlQUFlLEVBQUUsMEJBQTBCLDBCQUEwQixFQUFFLGdEQUFnRCxrQkFBa0IsbUJBQW1CLEVBQUUsOEJBQThCLHNCQUFzQixFQUFFLDRDQUE0QyxzQkFBc0Isa0JBQWtCLEVBQUUseUJBQXlCLGdCQUFnQixzQkFBc0IsRUFBRSw0QkFBNEIsb0JBQW9CLEVBQUUsd0JBQXdCLHlCQUF5QixFQUFFLG9FQUFvRSxlQUFlLEVBQUUsc0pBQXNKLHNCQUFzQixFQUFFLHVEQUF1RCw0QkFBNEIsRUFBRSwyRkFBMkYsOEJBQThCLEVBQUUsa0NBQWtDLG9CQUFvQixxQkFBcUIsRUFBRSwyQ0FBMkMscUJBQXFCLEVBQUUsd0NBQXdDLHFCQUFxQixFQUFFLGdFQUFnRSxvQkFBb0Isc0JBQXNCLEVBQUUsNEJBQTRCLGtCQUFrQixFQUFFLDJCQUEyQixrQkFBa0IsZ0JBQWdCLHNCQUFzQixvQkFBb0IsRUFBRSxnQ0FBZ0MsMEJBQTBCLEVBQUUsOENBQThDLGdCQUFnQixzQkFBc0IsRUFBRSxpQkFBaUIsOEJBQThCLHNCQUFzQiwyQkFBMkIsc0JBQXNCLGlCQUFpQixrREFBa0QsK0NBQStDLDBDQUEwQyxFQUFFLG9CQUFvQiw2QkFBNkIsRUFBRSxvQkFBb0IsNkJBQTZCLHNCQUFzQix1QkFBdUIsdUJBQXVCLGtCQUFrQixFQUFFLG9CQUFvQixzQkFBc0IsdUJBQXVCLDZCQUE2QixtQ0FBbUMsRUFBRSxtREFBbUQsOEJBQThCLG9CQUFvQixxQkFBcUIsMEJBQTBCLEVBQUUsdUJBQXVCLHdCQUF3QixFQUFFLDhCQUE4QixvQkFBb0IsaUJBQWlCLEVBQUUseUNBQXlDLDhCQUE4QixxQkFBcUIsRUFBRSxnQ0FBZ0MsOEJBQThCLHFCQUFxQixFQUFFLDhDQUE4QyxrQkFBa0IsaUJBQWlCLEVBQUUsOENBQThDLGVBQWUsb0JBQW9CLEVBQUUsNkNBQTZDLGVBQWUsRUFBRSw2Q0FBNkMsZUFBZSxFQUFFLDBEQUEwRCxlQUFlLG9CQUFvQix1QkFBdUIsRUFBRSxzQ0FBc0Msa0JBQWtCLEVBQUUsb0NBQW9DLG9CQUFvQix1QkFBdUIsRUFBRSxvQ0FBb0Msc0JBQXNCLG9CQUFvQixFQUFFLHlDQUF5QyxxQkFBcUIsc0JBQXNCLEVBQUUsa0NBQWtDLHVCQUF1QixjQUFjLGdCQUFnQixFQUFFLCtCQUErQixzQkFBc0IsNkJBQTZCLDZCQUE2QixtQkFBbUIseUJBQXlCLHNCQUFzQixFQUFFO0FBQzN3STtBQUNBOzs7Ozs7OztBQ05hOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBLEM7Ozs7OztBQzdGQSxpRDs7Ozs7O0FDQUEsaUQ7Ozs7OztBQ0FBLGlEOzs7Ozs7QUNBQSxpRDs7Ozs7O0FDQUEsaUQ7Ozs7OztBQ0FBLGlEOzs7Ozs7QUNBQSxpRDs7Ozs7O0FDQUEsaUQ7Ozs7OztBQ0FBLGlEOzs7Ozs7QUNBQSxpRDs7Ozs7O0FDQUEsaUQ7Ozs7OztBQ0FBLGlEOzs7Ozs7QUNBQSxpRDs7Ozs7Ozs7OztBQ0FlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7QUNiQTs7Ozs7QUFJQTs7OztBQUllO0FBQ2RBLEtBQUcsRUFBRSxRQURTO0FBRWRDLGNBQVksRUFBRSxtQkFGQTtBQUdkQyxNQUFJLEVBQUUsU0FIUTtBQUlkQyxNQUFJLEVBQUUsU0FKUTtBQUtkQyxPQUFLLEVBQUUsVUFMTztBQU1kQyxNQUFJLEVBQUUsU0FOUTtBQU9kQyxPQUFLLEVBQUUsV0FQTztBQVFkQyxZQUFVLEVBQUUsaUJBUkU7QUFTZEMsT0FBSyxFQUFFLFdBVE87QUFVZEMsUUFBTSxFQUFFLFlBVk07QUFXZEMsYUFBVyxFQUFFLGtCQVhDO0FBWWRDLFlBQVUsRUFBRSxpQkFaRTtBQWFkQyxLQUFHLEVBQUUsUUFiUztBQWNkQyxNQUFJLEVBQUUsU0FkUTtBQWVkQyxPQUFLLEVBQUUsVUFmTztBQWdCZEMsUUFBTSxFQUFFLFdBaEJNO0FBaUJkQyxpQkFBZSxFQUFFLGVBakJIO0FBa0JkQyxPQUFLLEVBQUUsVUFsQk87QUFtQmRDLFVBQVEsRUFBRSxjQW5CSTtBQW9CZEMsV0FBUyxFQUFFLGVBcEJHO0FBcUJkQyxxQkFBbUIsRUFBRSwwQkFyQlA7QUFzQmRDLG1CQUFpQixFQUFFLHlCQXRCTDtBQXVCZEMsbUJBQWlCLEVBQUUseUJBdkJMO0FBd0JkQyxvQkFBa0IsRUFBRSwwQkF4Qk47QUF5QmRDLGdCQUFjLEVBQUUscUJBekJGO0FBMEJkQyxxQkFBbUIsRUFBRSwyQkExQlA7QUEyQmRDLFVBQVEsRUFBRSxjQTNCSTtBQTRCZEMsV0FBUyxFQUFFLGVBNUJHO0FBNkJkQyxjQUFZLEVBQUUsa0JBN0JBO0FBOEJkQyxXQUFTLEVBQUUsZUE5Qkc7QUErQmRDLFlBQVUsRUFBRSxnQkEvQkU7QUFnQ2RDLFlBQVUsRUFBRSxnQkFoQ0U7QUFpQ2RDLGFBQVcsRUFBRSxpQkFqQ0M7QUFrQ2RDLFdBQVMsRUFBRSxlQWxDRztBQW1DZEMsWUFBVSxFQUFFLGdCQW5DRTtBQW9DZEMsUUFBTSxFQUFFLFdBcENNO0FBcUNkQyxTQUFPLEVBQUUsWUFyQ0s7QUFzQ2RDLGNBQVksRUFBRSxrQkF0Q0E7QUF1Q2RDLFlBQVUsRUFBRSxlQXZDRTtBQXdDZEMsV0FBUyxFQUFFLGNBeENHO0FBeUNkQyxVQUFRLEVBQUUsYUF6Q0k7QUEwQ2RDLE9BQUssRUFBRSxVQTFDTztBQTJDZEMsV0FBUyxFQUFFLGVBM0NHO0FBNENkQyxZQUFVLEVBQUUsZ0JBNUNFO0FBNkNkQyxvQkFBa0IsRUFBRSx5QkE3Q047QUE4Q2RDLGtCQUFnQixFQUFFLHVCQTlDSjtBQStDZEMsU0FBTyxFQUFFLFlBL0NLO0FBZ0RkQyxZQUFVLEVBQUUsZ0JBaERFO0FBaURkQyxNQUFJLEVBQUUsU0FqRFE7QUFrRGRDLFdBQVMsRUFBRSxlQWxERztBQW1EZEMsa0JBQWdCLEVBQUUsc0JBbkRKO0FBb0RkQyxZQUFVLEVBQUUsZ0JBcERFO0FBcURkQyxpQkFBZSxFQUFFLHNCQXJESDtBQXNEZEMsbUJBQWlCLEVBQUUsd0JBdERMO0FBdURkQyxrQkFBZ0IsRUFBRSx1QkF2REo7QUF3RGRDLGlCQUFlLEVBQUUsc0JBeERIO0FBeURkQyxnQkFBYyxFQUFFLHFCQXpERjtBQTBEZEMsT0FBSyxFQUFFLFVBMURPO0FBMkRkQyxRQUFNLEVBQUUsV0EzRE07QUE0RGRDLE1BQUksRUFBRSxTQTVEUTtBQTZEZEMsT0FBSyxFQUFFLFVBN0RPO0FBOERkQyxRQUFNLEVBQUUsV0E5RE07QUErRGRDLFNBQU8sRUFBRSxZQS9ESztBQWdFZEMsZ0JBQWMsRUFBRSxvQkFoRUY7QUFpRWRDLGlCQUFlLEVBQUUscUJBakVIO0FBa0VkQyxPQUFLLEVBQUUsVUFsRU87QUFtRWRDLFFBQU0sRUFBRSxXQW5FTTtBQW9FZEMsa0JBQWdCLEVBQUUsc0JBcEVKO0FBcUVkQyxjQUFZLEVBQUUsa0JBckVBO0FBc0VkQyxlQUFhLEVBQUUsbUJBdEVEO0FBdUVkQyxnQkFBYyxFQUFFLG9CQXZFRjtBQXdFZEMsaUJBQWUsRUFBRSxxQkF4RUg7QUF5RWRDLFFBQU0sRUFBRSxXQXpFTTtBQTBFZEMsTUFBSSxFQUFFLFNBMUVRO0FBMkVkQyxPQUFLLEVBQUUsVUEzRU87QUE0RWRDLE9BQUssRUFBRSxVQTVFTztBQTZFZEMsU0FBTyxFQUFFLFlBN0VLO0FBOEVkQyxrQkFBZ0IsRUFBRSxzQkE5RUo7QUErRWRDLGFBQVcsRUFBRSxpQkEvRUM7QUFnRmRDLE9BQUssRUFBRSxVQWhGTztBQWlGZEMsWUFBVSxFQUFFLGdCQWpGRTtBQWtGZEMsV0FBUyxFQUFFLGVBbEZHO0FBbUZkQyxZQUFVLEVBQUUsZ0JBbkZFO0FBb0ZkQyxRQUFNLEVBQUUsV0FwRk07QUFxRmRDLE9BQUssRUFBRSxVQXJGTztBQXNGZEMsWUFBVSxFQUFFLGdCQXRGRTtBQXVGZEMsV0FBUyxFQUFFLGVBdkZHO0FBd0ZkQyxZQUFVLEVBQUUsZ0JBeEZFO0FBeUZkQyxRQUFNLEVBQUUsV0F6Rk07QUEwRmRDLFdBQVMsRUFBRSxlQTFGRztBQTJGZEMsVUFBUSxFQUFFLGNBM0ZJO0FBNEZkQyxVQUFRLEVBQUUsWUE1Rkk7QUE2RmRDLFVBQVEsRUFBRSxZQTdGSTtBQThGZEMsVUFBUSxFQUFFLFlBOUZJO0FBK0ZkQyxpQkFBZSxFQUFFO0FBL0ZILENBQWYsRTs7QUNSQTs7OztJQUlxQkMsVyxHQUNwQixZQUFjO0FBQ2IsU0FBTztBQUNOQyxTQUFLLEVBQUUsQ0FERDtBQUVOQyxVQUFNLEVBQUUsQ0FGRjtBQUdOQyxVQUFNLEVBQUUsQ0FIRjtBQUlOQyxXQUFPLEVBQUUsQ0FKSDtBQUtOQyxVQUFNLEVBQUU7QUFDUEMsU0FBRyxFQUFFLENBREU7QUFFUEMsWUFBTSxFQUFFLENBRkQ7QUFHUEMsVUFBSSxFQUFFLENBSEM7QUFJUEMsV0FBSyxFQUFFO0FBSkEsS0FMRjtBQVdOQyxXQUFPLEVBQUU7QUFDUkosU0FBRyxFQUFFLENBREc7QUFFUkMsWUFBTSxFQUFFLENBRkE7QUFHUkMsVUFBSSxFQUFFLENBSEU7QUFJUkMsV0FBSyxFQUFFO0FBSkMsS0FYSDtBQWlCTkUsV0FBTyxFQUFFO0FBQ1JMLFNBQUcsRUFBRSxDQURHO0FBRVJDLFlBQU0sRUFBRSxDQUZBO0FBR1JDLFVBQUksRUFBRSxDQUhFO0FBSVJDLFdBQUssRUFBRTtBQUpDLEtBakJIO0FBdUJORyxZQUFRLEVBQUUsQ0F2Qko7QUF3Qk5DLGFBQVMsRUFBRSxDQXhCTDtBQXlCTkMsZ0JBQVksRUFBRSxDQXpCUjtBQTBCTkMsaUJBQWEsRUFBRSxDQTFCVDtBQTRCTjtBQUNBQyxpQkFBYSxJQTdCUDtBQThCTkMsaUJBQWEsSUE5QlA7QUErQk5DLGVBQVcsSUEvQkw7QUFnQ05DLGdCQUFZLElBaENOO0FBaUNOQyxjQUFVLEVBQUUsQ0FqQ047QUFrQ05DLG1CQUFlLEVBQUUsQ0FsQ1g7QUFtQ05DLG9CQUFnQixFQUFFLENBbkNaO0FBb0NOQyxxQkFBaUIsSUFwQ1g7QUFzQ05DLHdCQUFvQixFQUFFO0FBQ3JCQyxPQUFDLEVBQUU7QUFBQ0MsWUFBSSxFQUFFLENBQVA7QUFBVUMsY0FBTSxFQUFFO0FBQWxCLE9BRGtCO0FBRXJCQyxPQUFDLEVBQUU7QUFBQ0YsWUFBSSxFQUFFLENBQVA7QUFBVUMsY0FBTSxFQUFFO0FBQWxCLE9BRmtCO0FBR3JCRSxRQUFFLEVBQUU7QUFBQ0gsWUFBSSxFQUFFLENBQVA7QUFBVUMsY0FBTSxFQUFFO0FBQWxCO0FBSGlCLEtBdENoQjtBQTRDTkcsa0JBQWMsRUFBRTtBQUNmdEIsVUFBSSxFQUFFLEVBRFM7QUFFZkMsV0FBSyxFQUFFLENBRlE7QUFHZkgsU0FBRyxFQUFFO0FBSFUsS0E1Q1Y7QUFrRE55QixpQkFBYSxFQUFFLEVBbERUO0FBbUROQyxhQUFTLEVBQUUsRUFuREw7QUFxRE5DLGNBQVUsRUFBRSxFQXJETjtBQXVETjtBQUNBQyxRQUFJLEVBQUU7QUFDTEMsUUFBRSxFQUFFLEVBREM7QUFFTEMsYUFBTyxFQUFFLEVBRko7QUFHTEMsYUFBTyxFQUFFLEVBSEo7QUFJTEMsWUFBTSxFQUFFLEVBSkg7QUFLTEMsZ0JBQVUsRUFBRSxFQUxQO0FBS1c7QUFDaEJDLFVBQUksRUFBRSxFQU5EO0FBT0xDLGVBQVMsRUFBRSxFQVBOO0FBUUxDLGVBQVMsRUFBRSxFQVJOO0FBU0xDLGNBQVEsRUFBRTtBQVRMLEtBeERBO0FBb0VOO0FBQ0FDLGFBQVMsRUFBRSxJQXJFTDtBQXNFTkMsWUFBUSxJQXRFRjtBQXVFTkMsV0FBTyxJQXZFRDtBQXdFTkMsZUFBVyxJQXhFTDtBQXlFTkMsYUFBUyxJQXpFSDtBQTBFTkMsWUFBUSxJQTFFRjtBQTJFTkMsY0FBVSxJQTNFSjtBQTRFTkMsb0JBQWdCLElBNUVWO0FBNkVOQyxvQkFBZ0IsSUE3RVY7QUErRU5DLGtCQUFjLEVBQUUsS0EvRVY7QUFpRk47QUFDQUMsbUJBQWUsRUFBRSxFQWxGWDtBQW1GTkMsbUJBQWUsRUFBRSxFQW5GWDtBQW9GTkMsb0JBQWdCLEVBQUUsRUFwRlo7QUFxRk5DLHNCQUFrQixFQUFFLEVBckZkO0FBdUZOO0FBQ0FDLFVBQU0sRUFBRSxDQXhGRjtBQXlGTkMsZUFBVyxFQUFFLENBekZQO0FBMEZOQyxvQkFBZ0IsRUFBRSxDQTFGWjtBQTJGTkMsaUJBQWEsRUFBRSxDQTNGVDtBQTRGTkMsa0JBQWMsRUFBRSxDQTVGVjtBQThGTjtBQUNBQyxhQUFTLEVBQUU7QUFDVkMsUUFBRSxFQUFFLElBRE07QUFFVkMsUUFBRSxFQUFFLElBRk07QUFHVkMsUUFBRSxFQUFFLElBSE07QUFJVnJDLFFBQUUsRUFBRTtBQUpNO0FBL0ZMLEdBQVA7QUFzR0EsQzs7OztBQzVHRjs7Ozs7QUFNQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQXNDLGtCQUFnQixFQUFFLDBCQUFBaEMsRUFBRTtBQUFBLFdBQUlBLEVBQUo7QUFBQSxHQXBCVDs7QUFzQlg7Ozs7Ozs7Ozs7Ozs7OztBQWVBaUMsWUFBVSxFQUE0QixFQXJDM0I7O0FBdUNYOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsY0FBWSxFQUE0QixFQXREN0I7O0FBd0RYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBQyxXQUFTLEVBQXlCQyxTQXBGdkI7O0FBc0ZYOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBQyxZQUFVLEVBQWdDLEVBdEcvQjs7QUF3R1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBQyxZQUFVLEVBQStCLE1BOUk5Qjs7QUFnSlg7Ozs7Ozs7Ozs7Ozs7QUFhQUMsWUFBVSxFQUF1QkgsU0E3SnRCOztBQStKWDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFJLGFBQVcsRUFBNEMsRUFoTDVDOztBQWtMWDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQUMsV0FBUyxJQWxNRTs7QUFvTVg7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQUMsYUFBVyxFQUE4Qk4sU0F0TjlCOztBQXdOWDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQU8sY0FBWSxFQUFFLHdCQUFNLENBQUUsQ0EzT1g7O0FBNk9YOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBQyxhQUFXLEVBQUUsdUJBQU0sQ0FBRSxDQWhRVjs7QUFrUVg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFDLFlBQVUsRUFBRSxzQkFBTSxDQUFFLENBclJUOztBQXVSVjs7Ozs7Ozs7Ozs7Ozs7QUFjREMsWUFBVSxFQUF1QlYsU0FyU3RCOztBQXVTWDs7Ozs7Ozs7Ozs7Ozs7QUFjQVcsWUFBVSxFQUF1QlgsU0FyVHRCOztBQXVUWDs7Ozs7Ozs7Ozs7O0FBWUFZLFVBQVEsRUFBcUJaLFNBblVsQjs7QUFxVVg7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBYSxjQUFZLEVBQXFCYixTQXRWdEI7O0FBd1ZYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBYyxXQUFTLEVBQXVCZCxTQTlXckI7O0FBZ1hYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJEQWUsV0FBUyxFQUFrQ2YsU0EzYWhDOztBQTZhWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkNBZ0IsY0FBWSxFQUFrQ2hCLFNBMWRuQzs7QUE0ZFg7Ozs7Ozs7Ozs7Ozs7OztBQWVBaUIsZUFBYSxFQUF1QixLQTNlekI7O0FBNmVYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkFDLFdBQVMsRUFBNkNsQixTQWxnQjNDOztBQW9nQlg7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkFtQix1QkFBcUIsRUFBRTtBQXBoQlosQ0FBZixFOztBQ1RBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUVBQyxlQUFhLEVBQWEsRUExRWY7QUEyRVhDLGFBQVcsRUFBeUJyQixTQTNFekI7QUE0RVhzQixpQkFBZSxFQUFxRCxFQTVFekQ7QUE2RVhDLGNBQVksRUFBNEJ2QjtBQTdFN0IsQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBd0IscUJBQW1CLElBaENSO0FBaUNYQyxzQkFBb0IsSUFqQ1Q7QUFrQ1hDLDZCQUEyQixJQWxDaEI7QUFtQ1hDLDZCQUEyQixFQUE4QztBQW5DOUQsQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvRkFDLGFBQVcsSUFyRkE7QUFzRlhDLGFBQVcsSUF0RkE7QUF1RlhDLHdCQUFzQixFQUFpQzlCLFNBdkY1QztBQXdGWCtCLDBCQUF3QixFQUFtQy9CLFNBeEZoRDtBQXlGWGdDLGlCQUFlLEVBQTZCLFFBekZqQztBQTBGWEMscUJBQW1CLEVBQXdELFVBMUZoRTtBQTJGWEMsZ0JBQWMsRUFBRSxFQTNGTDtBQTRGWEMsZ0JBQWMsRUFBRSxDQTVGTDtBQTZGWEMsbUJBQWlCLEVBQXFCcEMsU0E3RjNCO0FBOEZYcUMscUJBQW1CLEVBQXVCckMsU0E5Ri9CO0FBK0ZYc0Msb0JBQWtCLEVBQXVCdEMsU0EvRjlCO0FBZ0dYdUMsbUJBQWlCLEVBQXVCdkMsU0FoRzdCO0FBaUdYd0MsZ0JBQWMsSUFqR0g7QUFrR1hDLGdCQUFjLEVBQUUsQ0FsR0w7QUFtR1hDLHdCQUFzQixFQUFFLEVBbkdiO0FBb0dYQyx5QkFBdUIsRUFBRSxFQXBHZDtBQXFHWEMsaUJBQWU7QUFyR0osQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBQyxZQUFVLEVBQXFCN0MsU0E3QnBCO0FBOEJYOEMsZUFBYSxFQUFFO0FBQ1gvRyxPQUFHLEVBQUUsQ0FETTtBQUVYRyxTQUFLLEVBQUUsQ0FGSTtBQUdYRixVQUFNLEVBQUUsQ0FIRztBQUlYQyxRQUFJLEVBQUU7QUFKSyxHQTlCSjtBQW9DWDhHLGdCQUFjLEVBQTRCO0FBcEMvQixDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7OztBQUdlO0FBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0xBQyxjQUFZLElBakxEO0FBa0xYQyxtQkFBaUIsSUFsTE47QUFtTFhDLGlCQUFlLElBbkxKO0FBb0xYQyxzQkFBb0IsRUFBNkJuRCxTQXBMdEM7QUFxTFhvRCxxQkFBbUIsRUFBNkJwRCxTQXJMckM7QUFzTFhxRCxzQkFBb0IsRUFBNkJyRCxTQXRMdEM7QUF1TFhzRCxrQkFBZ0IsRUFBbUR0RCxTQXZMeEQ7QUF3TFh1RCxrQkFBZ0IsRUFBd0YsRUF4TDdGO0FBeUxYQyxtQkFBaUIsSUF6TE47QUEwTFhDLGdCQUFjLEVBQUUsQ0ExTEw7QUEyTFhDLHVCQUFxQixFQUFFO0FBQ25CM0gsT0FBRyxFQUFFLEtBRGM7QUFFbkJFLFFBQUksRUFBRTtBQUZhLEdBM0xaO0FBK0xYMEgsZ0JBQWMsSUEvTEg7QUFnTVhDLHFCQUFtQixFQUFFLEVBaE1WO0FBaU1YQyxnQkFBYyxFQUFFLDBCQUFNLENBQUUsQ0FqTWI7QUFrTVhDLGdCQUFjLEVBQUUsMEJBQU0sQ0FBRSxDQWxNYjtBQW1NWEMsaUJBQWUsRUFBRSwyQkFBTSxDQUFFLENBbk1kO0FBb01YQyxrQkFBZ0IsRUFBRSw0QkFBTSxDQUFFLENBcE1mO0FBcU1YQyxlQUFhLEVBQXlCO0FBck0zQixDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7OztBQUdlO0FBQ1g7Ozs7Ozs7Ozs7OztBQVlBQyxRQUFNLEVBQXFCbEUsU0FiaEI7O0FBZVg7Ozs7Ozs7Ozs7Ozs7OztBQWVBbUUsU0FBTyxFQUFFLEVBOUJFOztBQWdDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkFDLGNBQVksRUFBRSxVQXZESDs7QUF5RFg7Ozs7Ozs7Ozs7O0FBV0FDLGlCQUFlLElBcEVKOztBQXNFWDs7Ozs7Ozs7Ozs7QUFXQUMsWUFBVSxJQWpGQzs7QUFtRlg7Ozs7Ozs7Ozs7Ozs7O0FBY0FDLGFBQVcsRUFBZSxFQWpHZjs7QUFtR1g7Ozs7Ozs7Ozs7Ozs7OztBQWVBQyxXQUFTLEVBQTRCLEVBbEgxQjs7QUFvSFg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtRUFDLGFBQVcsRUFNSixFQTdMSTtBQThMWEMsb0JBQWtCLEVBQTRCMUUsU0E5TG5DO0FBK0xYMkUsc0JBQW9CLEVBQUUsRUEvTFg7O0FBaU1YOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBQyxjQUFZLEVBQW1FLEVBN05wRTs7QUErTlg7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQUMsc0JBQW9CO0FBalBULENBQWYsRTs7QUNQQTs7Ozs7QUFJQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7O0FBZUFDLHdCQUFzQixJQWhCWDs7QUFrQlg7Ozs7Ozs7Ozs7Ozs7O0FBY0FDLHdCQUFzQixJQWhDWDs7QUFrQ1g7Ozs7Ozs7Ozs7Ozs7O0FBY0FDLDZCQUEyQixFQUFFO0FBQUE7QUFBQSxHQWhEbEI7O0FBa0RYOzs7Ozs7Ozs7Ozs7OztBQWNBQyx5QkFBdUIsSUFoRVo7O0FBa0VYOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsMEJBQXdCLElBakZiOztBQW1GWDs7Ozs7Ozs7Ozs7Ozs7O0FBZUFDLGlCQUFlLEVBQUUsMkJBQU0sQ0FBRSxDQWxHZDs7QUFvR1g7Ozs7Ozs7Ozs7Ozs7OztBQWVBQyxtQkFBaUIsRUFBRSw2QkFBTSxDQUFFO0FBbkhoQixDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7OztBQUdlO0FBQ1g7Ozs7Ozs7Ozs7O0FBV0FDLGlCQUFlLElBWko7O0FBY1g7Ozs7Ozs7Ozs7Ozs7QUFhQUMsYUFBVyxJQTNCQTs7QUE2Qlg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBQyxhQUFXLEVBQXNDLFNBakR0Qzs7QUFtRFg7Ozs7Ozs7Ozs7Ozs7O0FBY0FDLGtCQUFnQixJQWpFTDs7QUFtRVg7Ozs7Ozs7Ozs7Ozs7O0FBY0FDLG1CQUFpQixFQUFhLEVBakZuQjs7QUFtRlg7Ozs7Ozs7Ozs7Ozs7OztBQWVBQyxzQkFBb0IsSUFsR1Q7O0FBb0dYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkFDLG9CQUFrQixFQUE4QjNGLFNBL0hyQzs7QUFpSVg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE0RixxQkFBbUIsRUFBRSxFQXBKVjs7QUFzSlg7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBQyx5QkFBdUIsRUFBRSxFQXZLZDs7QUF5S1g7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkFDLG1CQUFpQixFQUFvQjlGLFNBekwxQjs7QUEyTFg7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkErRixrQkFBZ0IsSUEzTUw7O0FBNk1YOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkFDLHVCQUFxQixJQS9OVjs7QUFpT1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBQywyQkFBeUIsRUFBRTtBQUFDL0ksS0FBQyxFQUFFLENBQUo7QUFBT0csS0FBQyxFQUFFO0FBQVYsR0FyUGhCOztBQXVQWDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTZJLGlCQUFlLElBMVFKOztBQTRRWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQUMsb0JBQWtCLEVBQWdELElBbFN2RDs7QUFvU1g7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQUMsb0JBQWtCLEVBQUUsQ0F0VFQ7O0FBd1RYOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsbUJBQWlCLElBdlVOOztBQXlVWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQUMsdUJBQXFCLElBcldWOztBQXdXWDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFDLG1CQUFpQixFQUFnQixJQXpYdEI7O0FBMlhYOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBQyxxQkFBbUIsSUEzWVI7O0FBNllYOzs7Ozs7Ozs7Ozs7O0FBYUFDLFlBQVUsRUFBcUJ6RyxTQTFacEI7O0FBNFpYOzs7Ozs7Ozs7Ozs7O0FBYUEwRyxZQUFVLEVBQXFCMUcsU0F6YXBCOztBQTJhWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EyRyxnQkFBYyxFQUE0QyxFQTNjL0M7O0FBNmNYOzs7Ozs7Ozs7Ozs7OztBQWNBQyxlQUFhLEVBQXFCNUcsU0EzZHZCOztBQTZkWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTZHLGVBQWEsRUFBeUM3RyxTQXpmM0M7O0FBMmZYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDQThHLGNBQVksRUFBRSxFQXBpQkg7O0FBc2lCWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQUMsYUFBVyxFQUFZO0FBM2tCWixDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7OztBQUdlO0FBQ1g7Ozs7Ozs7Ozs7O0FBV0FDLGlCQUFlLElBWko7O0FBY1g7Ozs7Ozs7Ozs7Ozs7QUFhQUMsYUFBVyxJQTNCQTs7QUE2Qlg7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBQyxhQUFXLEVBQTZDbEgsU0E5QzdDOztBQWdEWDs7Ozs7Ozs7Ozs7Ozs7QUFjQW1ILFlBQVUsRUFBcUJuSCxTQTlEcEI7O0FBZ0VYOzs7Ozs7Ozs7Ozs7Ozs7QUFlQW9ILFlBQVUsRUFBcUJwSCxTQS9FcEI7O0FBaUZYOzs7Ozs7Ozs7Ozs7OztBQWNBcUgsaUJBQWUsSUEvRko7O0FBaUdYOzs7Ozs7Ozs7Ozs7O0FBYUFDLGVBQWEsRUFBcUJ0SCxTQTlHdkI7O0FBZ0hYOzs7Ozs7Ozs7Ozs7O0FBYUF1SCxjQUFZLElBN0hEOztBQStIWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBQyxjQUFZLEVBQWtCLEVBdkpuQjs7QUF5Slg7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQUMsb0JBQWtCLEVBQXVCekgsU0EzSzlCOztBQTZLWDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEwSCxxQkFBbUIsSUE5TFI7O0FBZ01YOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQUMseUJBQXVCLEVBQUUsQ0FqTmQ7O0FBbU5YOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsbUJBQWlCLElBbE9OOztBQW9PWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkFDLG9CQUFrQixFQUFrQyxJQXhQekM7O0FBMFBYOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQUMsb0JBQWtCLEVBQUUsQ0EzUVQ7O0FBNlFYOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBQyxtQkFBaUIsRUFBcUIvSCxTQTdSM0I7O0FBK1JYOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBZ0ksa0JBQWdCLElBL1NMOztBQWlUWDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBQyxzQkFBb0IsRUFBZ0IsSUFuVXpCOztBQXFVWDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBQyx1QkFBcUIsSUF2VlY7O0FBeVZYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQUMsMkJBQXlCLEVBQUU7QUFBQ2pMLEtBQUMsRUFBRSxDQUFKO0FBQU9HLEtBQUMsRUFBRTtBQUFWLEdBN1doQjs7QUErV1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBK0ssd0JBQXNCLEVBQXVCcEksU0FyWWxDOztBQXVZWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkFxSSxnQkFBYyxFQUE0QyxFQTlaL0M7O0FBZ2FYOzs7Ozs7Ozs7Ozs7OztBQWNBQyxnQkFBYyxFQUF1QnRJLFNBOWExQjs7QUFnYlg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0F1SSxhQUFXLEVBQWE7QUFyZGIsQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBQyxjQUFZLElBakJEOztBQW1CWDs7Ozs7Ozs7Ozs7OztBQWFBQyxhQUFXLEVBQXFCekksU0FoQ3JCOztBQWtDWDs7Ozs7Ozs7Ozs7OztBQWFBMEksYUFBVyxFQUFxQjFJLFNBL0NyQjs7QUFpRFg7Ozs7Ozs7Ozs7Ozs7O0FBY0EySSxrQkFBZ0IsSUEvREw7O0FBaUVYOzs7Ozs7Ozs7Ozs7O0FBYUFDLGdCQUFjLEVBQXFCNUksU0E5RXhCOztBQWdGWDs7Ozs7Ozs7Ozs7OztBQWFBNkksZUFBYSxJQTdGRjs7QUErRlg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQUMsZUFBYSxFQUFrQixFQXZIcEI7O0FBeUhYOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQUMscUJBQW1CLEVBQXVCL0ksU0ExSS9COztBQTRJWDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFnSixzQkFBb0IsSUE3SlQ7O0FBK0pYOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQUMsMEJBQXdCLEVBQUUsQ0FoTGY7O0FBa0xYOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsb0JBQWtCLElBak1QOztBQW1NWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkFDLHFCQUFtQixFQUFrQyxJQXZOMUM7O0FBeU5YOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQUMscUJBQW1CLEVBQUUsQ0ExT1Y7O0FBNE9YOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBQyxvQkFBa0IsRUFBcUJySixTQTVQNUI7O0FBOFBYOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBc0osbUJBQWlCLElBOVFOOztBQWdSWDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBQyx1QkFBcUIsRUFBZ0IsSUFsUzFCOztBQW9TWDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBQyx3QkFBc0IsSUF0VFg7O0FBd1RYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQUMsNEJBQTBCLEVBQUU7QUFBQ3ZNLEtBQUMsRUFBRSxDQUFKO0FBQU9HLEtBQUMsRUFBRTtBQUFWLEdBNVVqQjs7QUE4VVg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFxTSxpQkFBZSxFQUE0QyxFQWpXaEQ7O0FBbVdYOzs7Ozs7Ozs7Ozs7OztBQWNBQyxpQkFBZSxFQUFFM0osU0FqWE47O0FBbVhYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBNEosY0FBWSxFQUFFO0FBeFpILENBQWYsRTs7Ozs7QUNQQTs7Ozs7QUFJQTs7Ozs7O0FBS0E7QUFDQTs7SUFFTUMsR0FBRyxHQUFJLFlBQU07QUFDbEIsTUFBTUMsR0FBRyxHQUFHLFVBQUFDLENBQUM7QUFBQSxXQUFJLE9BQU9BLENBQVAsS0FBYSxXQUFiLElBQTRCQSxDQUFoQztBQUFBLEdBQWI7O0FBRUEsU0FBT0QsR0FBRyxDQUFDRSxJQUFELENBQUgsSUFBYUYsR0FBRyxDQUFDRyxNQUFELENBQWhCLElBQTRCSCxHQUFHLENBQUNJLE1BQUQsQ0FBL0IsSUFBMkNKLEdBQUcsQ0FBQ0ssVUFBRCxDQUE5QyxJQUE4REMsUUFBUSxDQUFDLGFBQUQsQ0FBUixFQUFyRTtBQUNBLENBSlcsRTtJQU9OQyxXQUFHLEdBQUdSLEdBQUcsSUFBSUEsR0FBRyxDQUFDUyxRO0FBRnZCLHlDOztBQ2pCQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztJQTZDTUMsT0FBTyxHQUFHLFVBQUNDLENBQUQ7QUFBQSxTQUFxQkEsQ0FBQyxJQUFJQSxDQUFDLEtBQUssQ0FBaEM7QUFBQSxDO0lBQ1ZDLFVBQVUsR0FBRyxVQUFDRCxDQUFEO0FBQUEsU0FBcUIsT0FBT0EsQ0FBUCxLQUFhLFVBQWxDO0FBQUEsQztJQUNiRSxRQUFRLEdBQUcsVUFBQ0YsQ0FBRDtBQUFBLFNBQXFCLE9BQU9BLENBQVAsS0FBYSxRQUFsQztBQUFBLEM7SUFDWEcsUUFBUSxHQUFHLFVBQUNILENBQUQ7QUFBQSxTQUFxQixPQUFPQSxDQUFQLEtBQWEsUUFBbEM7QUFBQSxDO0lBQ1hJLFdBQVcsR0FBRyxVQUFDSixDQUFEO0FBQUEsU0FBcUIsT0FBT0EsQ0FBUCxLQUFhLFdBQWxDO0FBQUEsQztJQUNkSyxTQUFTLEdBQUcsVUFBQ0wsQ0FBRDtBQUFBLFNBQXFCLE9BQU9BLENBQVAsS0FBYSxXQUFsQztBQUFBLEM7SUFDWk0sU0FBUyxHQUFHLFVBQUNOLENBQUQ7QUFBQSxTQUFxQixPQUFPQSxDQUFQLEtBQWEsU0FBbEM7QUFBQSxDO0lBQ1pPLE1BQU0sR0FBRyxVQUFDUCxDQUFEO0FBQUEsU0FBb0JRLElBQUksQ0FBQ0MsSUFBTCxDQUFVVCxDQUFDLEdBQUcsRUFBZCxJQUFvQixFQUF4QztBQUFBLEM7SUFDVFUsV0FBVyxHQUFHLFVBQUNDLENBQUQ7QUFBQSxTQUFvQkgsSUFBSSxDQUFDQyxJQUFMLENBQVVFLENBQVYsSUFBZSxFQUFuQztBQUFBLEM7SUFDZEMsVUFBVSxHQUFHLFVBQUNDLENBQUQ7QUFBQSxTQUF5QkEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPQSxDQUFDLENBQUMsQ0FBRCxDQUFqQztBQUFBLEM7SUFDYkMsWUFBWSxHQUFHLFVBQUNkLENBQUQ7QUFBQSxTQUFxQixPQUFPQSxDQUFQLEtBQWEsUUFBbEM7QUFBQSxDO0lBQ2ZlLE9BQU8sR0FBRyxVQUFDeEIsQ0FBRDtBQUFBLFNBQ2ZhLFdBQVcsQ0FBQ2IsQ0FBRCxDQUFYLElBQWtCQSxDQUFDLEtBQUssSUFBeEIsSUFDQ1csUUFBUSxDQUFDWCxDQUFELENBQVIsSUFBZUEsQ0FBQyxDQUFDeUIsTUFBRixLQUFhLENBRDdCLElBRUNGLFlBQVksQ0FBQ3ZCLENBQUQsQ0FBWixJQUFtQixFQUFFQSxDQUFDLFlBQVkwQixJQUFmLENBQW5CLElBQTJDQyxNQUFNLENBQUNDLElBQVAsQ0FBWTVCLENBQVosRUFBZXlCLE1BQWYsS0FBMEIsQ0FGdEUsSUFHQ2IsUUFBUSxDQUFDWixDQUFELENBQVIsSUFBZTZCLEtBQUssQ0FBQzdCLENBQUQsQ0FKTjtBQUFBLEM7SUFNVjhCLFFBQVEsR0FBRyxVQUFDOUIsQ0FBRDtBQUFBLFNBQXFCLENBQUN3QixPQUFPLENBQUN4QixDQUFELENBQTdCO0FBQUEsQztJQVFYK0IsT0FBTyxHQUFHLFVBQUNDLEdBQUQ7QUFBQSxTQUF1QkMsS0FBSyxDQUFDRixPQUFOLENBQWNDLEdBQWQsQ0FBdkI7QUFBQSxDO0lBUVZFLFFBQVEsR0FBRyxVQUFDQyxHQUFEO0FBQUEsU0FBdUJBLEdBQUcsSUFBSSxDQUFDQSxHQUFHLENBQUNDLFFBQVosSUFBd0JiLFlBQVksQ0FBQ1ksR0FBRCxDQUFwQyxJQUE2QyxDQUFDSixPQUFPLENBQUNJLEdBQUQsQ0FBNUU7QUFBQSxDOztBQUVqQixTQUFTRSxTQUFULENBQW1CQyxPQUFuQixFQUFvQ0MsR0FBcEMsRUFBaURDLFlBQWpELEVBQW9FO0FBQ25FLFNBQU8xQixTQUFTLENBQUN3QixPQUFPLENBQUNDLEdBQUQsQ0FBUixDQUFULEdBQTBCRCxPQUFPLENBQUNDLEdBQUQsQ0FBakMsR0FBeUNDLFlBQWhEO0FBQ0E7O0FBRUQsU0FBU0MsYUFBVCxDQUFrQkMsSUFBbEIsRUFBZ0NDLEtBQWhDLEVBQXFEO0FBQ3BELE1BQUlDLEtBQUssS0FBVDtBQUlBLFNBRkFqQixNQUFNLENBQUNDLElBQVAsQ0FBWWMsSUFBWixFQUFrQkcsT0FBbEIsQ0FBMEIsVUFBQU4sR0FBRztBQUFBLFdBQUtHLElBQUksQ0FBQ0gsR0FBRCxDQUFKLEtBQWNJLEtBQWYsS0FBMEJDLEtBQUssS0FBL0IsQ0FBSjtBQUFBLEdBQTdCLENBRUEsRUFBT0EsS0FBUDtBQUNBO0FBRUQ7Ozs7Ozs7OztBQU9BLFNBQVNFLE1BQVQsQ0FBZ0JDLEVBQWhCLEVBQXNDO0FBQUEsV0FDL0JDLElBQUksR0FBR3RDLFVBQVUsQ0FBQ3FDLEVBQUQsQ0FEYywyQkFBZkUsSUFBZSxrRUFBZkEsSUFBZTs7QUFJckMsU0FEQUQsSUFBSSxJQUFJRCxFQUFFLENBQUNHLElBQUgsT0FBQUgsRUFBRSxFQUFTRSxJQUFULENBQ1YsRUFBT0QsSUFBUDtBQUNBO0FBRUQ7Ozs7Ozs7O0FBTUEsU0FBU0csUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUM7QUFDdEMsU0FBT3pDLFFBQVEsQ0FBQ3lDLEdBQUQsQ0FBUixHQUNOQSxHQUFHLENBQUNDLE9BQUosQ0FBWSxJQUFaLEVBQWtCLE1BQWxCLEVBQTBCQSxPQUExQixDQUFrQyxJQUFsQyxFQUF3QyxNQUF4QyxDQURNLEdBQzRDRCxHQURuRDtBQUVBO0FBRUQ7Ozs7Ozs7Ozs7QUFRQSxTQUFTRSxZQUFULENBQXNCQyxJQUF0QixFQUF5Q25ULElBQXpDLEVBQXVEb1QsRUFBdkQsRUFBK0VDLFFBQS9FLEVBQTBHO0FBQ3pHLE1BRHNERCxFQUN0RCxnQkFEc0RBLEVBQ3RELEdBRHFFLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxDQUNyRSxHQUQ4RUMsUUFDOUUsZ0JBRDhFQSxRQUM5RSxRQUFLRixJQUFELElBQVU1QyxRQUFRLENBQUN2USxJQUFELENBQXRCLEVBSUEsSUFBSUEsSUFBSSxDQUFDc1QsT0FBTCxDQUFhLElBQWIsTUFBdUIsQ0FBQyxDQUE1QixFQUNDSCxJQUFJLENBQUNuVCxJQUFMLENBQVVBLElBQVYsQ0FERCxNQUVPO0FBQ04sUUFBTXVULElBQUksR0FBRyxDQUFDSixJQUFJLENBQUNuVCxJQUFMLEVBQUQsRUFBY0EsSUFBZCxFQUFvQndULEdBQXBCLENBQXdCLFVBQUFuRCxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDNEMsT0FBRixDQUFVLFNBQVYsRUFBcUIsRUFBckIsQ0FBSjtBQUFBLEtBQXpCLENBQWI7O0FBRUEsUUFBSU0sSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZQSxJQUFJLENBQUMsQ0FBRCxDQUFwQixFQUF5QjtBQUFBLFVBQ2xCRSxTQUFTLEdBQUd6VCxJQUFJLENBQUMwVCxLQUFMLENBQVcsSUFBWCxDQURNO0FBQUEsVUFFbEJDLEdBQUcsR0FBR04sUUFBUSxHQUFHSSxTQUFTLENBQUNwQyxNQUFWLEdBQW1CLENBQXRCLEdBQTBCLENBRnRCO0FBS3hCOEIsVUFBSSxDQUFDUyxJQUFMLENBQVUsRUFBVixDQUx3QixFQU94QkgsU0FBUyxDQUFDaEIsT0FBVixDQUFrQixVQUFDcEMsQ0FBRCxFQUFJd0QsQ0FBSixFQUFVO0FBQzNCVixZQUFJLENBQUNXLE1BQUwsQ0FBWSxPQUFaLEVBQ0VDLElBREYsQ0FDTyxHQURQLEVBQ1ksQ0FEWixFQUVFQSxJQUZGLENBRU8sSUFGUCxHQUVnQkYsQ0FBQyxLQUFLLENBQU4sR0FBVVQsRUFBRSxDQUFDLENBQUQsQ0FBRixHQUFRTyxHQUFsQixHQUF3QlAsRUFBRSxDQUFDLENBQUQsQ0FGMUMsVUFHRXBULElBSEYsQ0FHT3FRLENBSFAsQ0FEMkI7QUFLM0IsT0FMRCxDQVB3QjtBQWF4QjtBQUNEO0FBQ0QsQyxDQUVEOzs7QUFDQSxTQUFTMkQsY0FBVCxDQUF3QmxRLElBQXhCLEVBQTRFO0FBQzNFOzs7Ozs7O0FBRDJFLHNCQVE3Q0EsSUFBSSxDQUFDbVEsT0FBTCxFQVI2QztBQUFBLE1BUXBFbFIsQ0FSb0UsaUJBUXBFQSxDQVJvRTtBQUFBLE1BUWpFRyxDQVJpRSxpQkFRakVBLENBUmlFO0FBQUEsTUFROUQzQixLQVI4RCxpQkFROURBLEtBUjhEO0FBQUEsTUFRdkRFLE1BUnVELGlCQVF2REEsTUFSdUQ7O0FBVTNFLFNBQU8sQ0FDTjtBQUFDc0IsS0FBQyxFQUFEQSxDQUFEO0FBQUlHLEtBQUMsRUFBRUEsQ0FBQyxHQUFHekI7QUFBWCxHQURNLEVBQ2M7QUFDcEI7QUFBQ3NCLEtBQUMsRUFBREEsQ0FBRDtBQUFJRyxLQUFDLEVBQURBO0FBQUosR0FGTSxFQUVFO0FBQ1I7QUFBQ0gsS0FBQyxFQUFFQSxDQUFDLEdBQUd4QixLQUFSO0FBQWUyQixLQUFDLEVBQURBO0FBQWYsR0FITSxFQUdhO0FBQ25CO0FBQUNILEtBQUMsRUFBRUEsQ0FBQyxHQUFHeEIsS0FBUjtBQUFlMkIsS0FBQyxFQUFFQSxDQUFDLEdBQUd6QjtBQUF0QixHQUpNLENBSXdCO0FBSnhCLEdBQVA7QUFNQTs7QUFFRCxTQUFTeVMsVUFBVCxDQUFvQnBRLElBQXBCLEVBQXFHO0FBQUEsOEJBQzVFQSxJQUFJLENBQUNxUSxxQkFBTCxFQUQ0RTtBQUFBLE1BQzdGNVMsS0FENkYseUJBQzdGQSxLQUQ2RjtBQUFBLE1BQ3RGRSxNQURzRix5QkFDdEZBLE1BRHNGO0FBQUEsTUFFOUYyUyxLQUY4RixHQUV0RkosY0FBYyxDQUFDbFEsSUFBRCxDQUZ3RTtBQUFBLE1BRzlGZixDQUg4RixHQUcxRnFSLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU3JSLENBSGlGO0FBQUEsTUFJOUZHLENBSjhGLEdBSTFGMk4sSUFBSSxDQUFDd0QsR0FBTCxDQUFTRCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNsUixDQUFsQixFQUFxQmtSLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2xSLENBQTlCLENBSjBGOztBQU1wRyxTQUFPO0FBQ05ILEtBQUMsRUFBREEsQ0FETTtBQUNIRyxLQUFDLEVBQURBLENBREc7QUFDQTNCLFNBQUssRUFBTEEsS0FEQTtBQUNPRSxVQUFNLEVBQU5BO0FBRFAsR0FBUDtBQUdBLEMsQ0FFRDs7O0FBQ0EsU0FBUzZTLGlCQUFULE9BQWtDO0FBRzdCLE1BQUFDLFNBQVM7QUFBQSxNQUhjQyxHQUdkLFFBSGNBLEdBR2Q7QUFBQSxNQUZQQyxLQUVPLEdBRkNDLHdGQUVEO0FBQUEsTUFEUEMsSUFDTyxHQURBSCxHQUFHLENBQUNJLFFBQUosQ0FBYUQsSUFBYixJQUFxQkgsR0FBRyxDQUFDRyxJQUN6QjtBQVViLFNBUElGLEtBQUssSUFBSUEsS0FBSyxDQUFDSSxJQUFOLEtBQWUsT0FPNUIsR0FOQ04sU0FBUyxHQUFHRSxLQUFLLENBQUNGLFNBTW5CLEdBSldJLElBQUksS0FBS0osU0FBUyxHQUFHSSxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQzFZLEtBQXRCLEVBQStCOFcsSUFBL0IsRUFBakIsQ0FJZixLQUhDb0IsU0FBUyxHQUFHUyw2RkFBZ0IsQ0FBQ1QsU0FBRCxDQUc3QixHQUFPQSxTQUFQO0FBQ0EsQyxDQUVEOzs7QUFDQSxJQUFNVSxlQUFlLEdBQUcsVUFBQTlCLElBQUk7QUFBQSxTQUFJQSxJQUFJLENBQUMrQixJQUFMLEtBQWMvQixJQUFJLENBQUMrQixJQUFMLEdBQVkvQixJQUFJLENBQUNnQixxQkFBTCxFQUExQixDQUFKO0FBQUEsQ0FBNUIsQyxDQUVBOzs7QUFDQSxTQUFTZ0IsU0FBVCxDQUFtQkMsS0FBbkIsRUFBMkQ7QUFBeENBLE9BQXdDLGdCQUF4Q0EsS0FBd0M7QUFDMUQsTUFBTUMsSUFBSSxHQUFHeEUsSUFBSSxDQUFDeUUsTUFBTCxFQUFiO0FBRUEsU0FBT0YsS0FBSyxHQUFVQyxJQUFWLFFBQWtCQSxJQUE5QjtBQUNBOztBQUVELFNBQVNFLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3hCLE1BQU1qQixTQUFTLEdBQUdELGlCQUFpQixDQUFDa0IsR0FBRCxDQUFuQztBQUR3QixVQUdwQmpCLFNBSG9CLElBT2hCQSxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCQSxTQUFTLENBQUMsQ0FBRCxDQVBWO0FBV3hCOztBQUVELFNBQVNrQixNQUFULENBQWdCMVYsTUFBaEIsRUFBNkIyVixNQUE3QixFQUE2QztBQUs1QztBQUNBLE9BQUssSUFBTUMsQ0FBWCxJQU5lNVYsTUFNZixnQkFOZUEsTUFNZixHQU53QixFQU14QixHQUxJNFIsT0FBTyxDQUFDK0QsTUFBRCxDQUtYLElBSkNBLE1BQU0sQ0FBQ2pELE9BQVAsQ0FBZSxVQUFBcEMsQ0FBQztBQUFBLFdBQUlvRixNQUFNLENBQUMxVixNQUFELEVBQVNzUSxDQUFULENBQVY7QUFBQSxHQUFoQixDQUlELEVBQWdCcUYsTUFBaEIsRUFDSyxRQUFRRSxJQUFSLENBQWFELENBQWIsQ0FETCxLQUtDNVYsTUFBTSxDQUFDNFYsQ0FBRCxDQUFOLEdBQVlELE1BQU0sQ0FBQ0MsQ0FBRCxDQUxuQjs7QUFRQSxTQUFPNVYsTUFBUDtBQUNBO0FBRUQ7Ozs7Ozs7O0lBTU04VixVQUFVLEdBQUcsVUFBQzdDLEdBQUQ7QUFBQSxTQUF5QkEsR0FBRyxDQUFDOEMsTUFBSixDQUFXLENBQVgsRUFBY0MsV0FBZCxLQUE4Qi9DLEdBQUcsQ0FBQ2dELEtBQUosQ0FBVSxDQUFWLENBQXZEO0FBQUEsQztJQVFiQyxPQUFPLEdBQUcsVUFBQzVGLENBQUQ7QUFBQSxTQUF1QyxHQUFHMkYsS0FBSCxDQUFTbEQsSUFBVCxDQUFjekMsQ0FBZCxDQUF2QztBQUFBLEM7QUFOaEI7Ozs7Ozs7O0FBUUE7Ozs7OztBQU1BLFNBQVM2RixXQUFULENBQXFCQyxXQUFyQixFQUF5QztBQUN4QyxNQUFJQyxLQUFLLEdBQUcsRUFBWjtBQVlBLFNBVkFELFdBQVcsQ0FBQzFELE9BQVosQ0FBb0IsVUFBQTRELEtBQUssRUFBSTtBQUM1QixRQUFJO0FBQ0NBLFdBQUssQ0FBQ0MsUUFBTixJQUFrQkQsS0FBSyxDQUFDQyxRQUFOLENBQWVqRixNQURsQyxLQUVGK0UsS0FBSyxHQUFHQSxLQUFLLENBQUNHLE1BQU4sQ0FBYU4sT0FBTyxDQUFDSSxLQUFLLENBQUNDLFFBQVAsQ0FBcEIsQ0FGTjtBQUlILEtBSkQsQ0FJRSxPQUFPRSxDQUFQLEVBQVU7QUFDWEMsYUFBTyxDQUFDQyxLQUFSLHFDQUFnREwsS0FBSyxDQUFDTSxJQUF0RCxVQUErREgsQ0FBQyxDQUFDSSxRQUFGLEVBQS9ELENBRFc7QUFFWDtBQUNELEdBUkQsQ0FVQSxFQUFPUixLQUFQO0FBQ0E7QUFFRDs7Ozs7Ozs7QUFNQSxTQUFTUyxjQUFULENBQXdCMUQsSUFBeEIsRUFBOEI7QUFBQSxNQUN2QjJELFNBQVMsR0FBRzNELElBQUksR0FBR0EsSUFBSSxDQUFDMkQsU0FBUixHQUFvQixJQURiO0FBQUEsTUFFdkJDLE9BQU8sR0FBR0QsU0FBUyxHQUFHQSxTQUFTLENBQUNDLE9BQWIsR0FBdUIsRUFGbkI7QUFJN0IsU0FBT0EsT0FBTyxDQUFDMUYsTUFBUixHQUFpQjBGLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQixDQUFoQixFQUFtQkMsTUFBcEMsR0FBNkM7QUFBQ0MsS0FBQyxFQUFFLENBQUo7QUFBT0MsS0FBQyxFQUFFLENBQVY7QUFBYUMsS0FBQyxFQUFFLENBQWhCO0FBQW1CbEcsS0FBQyxFQUFFLENBQXRCO0FBQXlCc0YsS0FBQyxFQUFFLENBQTVCO0FBQStCYSxLQUFDLEVBQUU7QUFBbEMsR0FBcEQ7QUFDQTtBQUVEOzs7Ozs7OztBQU1BLFNBQVNDLFNBQVQsQ0FBbUJDLElBQW5CLEVBQXVDO0FBQUEsTUFDaENDLE1BQU0sR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBSixZQUFtQmpHLElBREk7QUFBQSxNQUVoQ0osQ0FBQyxHQUFHLENBQUNzRyxNQUFNLEdBQUdELElBQUksQ0FBQy9ELEdBQUwsQ0FBU2lFLE1BQVQsQ0FBSCxHQUFzQkYsSUFBN0IsRUFDUkcsTUFEUSxDQUNELFVBQUNySCxDQUFELEVBQUl3RCxDQUFKLEVBQU9oRSxJQUFQO0FBQUEsV0FBZ0JBLElBQUksQ0FBQ3lELE9BQUwsQ0FBYWpELENBQWIsTUFBb0J3RCxDQUFwQztBQUFBLEdBREMsQ0FGNEI7QUFLdEMsU0FBTzJELE1BQU0sR0FBR3RHLENBQUMsQ0FBQ3NDLEdBQUYsQ0FBTSxVQUFBbkQsQ0FBQztBQUFBLFdBQUksSUFBSWlCLElBQUosQ0FBU2pCLENBQVQsQ0FBSjtBQUFBLEdBQVAsQ0FBSCxHQUE2QmEsQ0FBMUM7QUFDQTtBQUVEOzs7Ozs7OztBQU1BLFNBQVN5RyxVQUFULENBQW9CL0YsR0FBcEIsRUFBdUM7QUFDdEMsU0FBT0EsR0FBRyxJQUFJQSxHQUFHLENBQUNQLE1BQVgsR0FBb0JPLEdBQUcsQ0FBQ2dHLE1BQUosQ0FBVyxVQUFDakMsQ0FBRCxFQUFJeUIsQ0FBSjtBQUFBLFdBQVV6QixDQUFDLENBQUNZLE1BQUYsQ0FBU2EsQ0FBVCxDQUFWO0FBQUEsR0FBWCxDQUFwQixHQUF3RCxFQUEvRDtBQUNBO0FBRUQ7Ozs7Ozs7OztBQU9BLFNBQVNTLFFBQVQsQ0FBa0I5WCxNQUFsQixFQUFtRDtBQUFBLHFDQUFkK1gsT0FBYyx3RUFBZEEsT0FBYzs7QUFDbEQsTUFBSSxDQUFDQSxPQUFPLENBQUN6RyxNQUFULElBQW9CeUcsT0FBTyxDQUFDekcsTUFBUixLQUFtQixDQUFuQixJQUF3QixDQUFDeUcsT0FBTyxDQUFDLENBQUQsQ0FBeEQsRUFDQyxPQUFPL1gsTUFBUDtBQUdELE1BQU0yVixNQUFNLEdBQUdvQyxPQUFPLENBQUNDLEtBQVIsRUFBZjtBQWdCQSxTQWRJakcsUUFBUSxDQUFDL1IsTUFBRCxDQUFSLElBQW9CK1IsUUFBUSxDQUFDNEQsTUFBRCxDQWNoQyxJQWJDbkUsTUFBTSxDQUFDQyxJQUFQLENBQVlrRSxNQUFaLEVBQW9CakQsT0FBcEIsQ0FBNEIsVUFBQU4sR0FBRyxFQUFJO0FBQ2xDLFFBQU1JLEtBQUssR0FBR21ELE1BQU0sQ0FBQ3ZELEdBQUQsQ0FBcEI7QUFFSUwsWUFBUSxDQUFDUyxLQUFELENBSHNCLElBSWpDLENBQUN4UyxNQUFNLENBQUNvUyxHQUFELENBQVAsS0FBaUJwUyxNQUFNLENBQUNvUyxHQUFELENBQU4sR0FBYyxFQUEvQixDQUppQyxFQUtqQ3BTLE1BQU0sQ0FBQ29TLEdBQUQsQ0FBTixHQUFjMEYsUUFBUSxDQUFDOVgsTUFBTSxDQUFDb1MsR0FBRCxDQUFQLEVBQWNJLEtBQWQsQ0FMVyxJQU9qQ3hTLE1BQU0sQ0FBQ29TLEdBQUQsQ0FBTixHQUFjUixPQUFPLENBQUNZLEtBQUQsQ0FBUCxHQUNiQSxLQUFLLENBQUNnRSxNQUFOLEVBRGEsR0FDSWhFLEtBUmU7QUFVbEMsR0FWRCxDQWFELEVBQU9zRixRQUFRLE1BQVIsVUFBUzlYLE1BQVQsU0FBb0IrWCxPQUFwQixFQUFQO0FBQ0E7QUFFRDs7Ozs7Ozs7O0FBT0EsU0FBU0UsY0FBVCxDQUFtQlQsSUFBbkIsRUFBZ0NVLEtBQWhDLEVBQXFEO0FBQXJCQSxPQUFxQixnQkFBckJBLEtBQXFCO0FBQ3BELE1BQUl0RixFQUFKO0FBWUEsU0FWSTRFLElBQUksQ0FBQyxDQUFELENBQUosWUFBbUJqRyxJQVV2QixHQVRDcUIsRUFBRSxHQUFHc0YsS0FBSyxHQUFHLFVBQUNmLENBQUQsRUFBSUMsQ0FBSjtBQUFBLFdBQVVELENBQUMsR0FBR0MsQ0FBZDtBQUFBLEdBQUgsR0FBcUIsVUFBQ0QsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsV0FBVUEsQ0FBQyxHQUFHRCxDQUFkO0FBQUEsR0FTaEMsR0FQS2UsS0FBSyxJQUFJLENBQUNWLElBQUksQ0FBQ1csS0FBTCxDQUFXekcsS0FBWCxDQU9mLEdBTkVrQixFQUFFLEdBQUcsVUFBQ3VFLENBQUQsRUFBSUMsQ0FBSjtBQUFBLFdBQVVELENBQUMsR0FBR0MsQ0FBZDtBQUFBLEdBTVAsR0FMWSxDQUFDYyxLQUtiLEtBSkV0RixFQUFFLEdBQUcsVUFBQ3VFLENBQUQsRUFBSUMsQ0FBSjtBQUFBLFdBQVdELENBQUMsR0FBR0MsQ0FBSixJQUFTLENBQUMsQ0FBWCxJQUFrQkQsQ0FBQyxHQUFHQyxDQUFKLElBQVMsQ0FBM0IsSUFBa0NELENBQUMsS0FBS0MsQ0FBTixJQUFXLENBQXZEO0FBQUEsR0FJUCxHQUFPSSxJQUFJLENBQUNoQixNQUFMLEdBQWM0QixJQUFkLENBQW1CeEYsRUFBbkIsQ0FBUDtBQUNBO0FBRUQ7Ozs7Ozs7OztBQU9BLFNBQVN5RixTQUFULENBQW1CdkQsSUFBbkIsRUFBd0MwQyxJQUF4QyxFQUF1RTtBQUN0RSxNQUFJYyxHQUFHLEdBQUdkLElBQUksQ0FBQ0csTUFBTCxDQUFZLFVBQUFySCxDQUFDO0FBQUEsV0FBSXFCLFFBQVEsQ0FBQ3JCLENBQUQsQ0FBWjtBQUFBLEdBQWIsQ0FBVjtBQVlBLFNBVklnSSxHQUFHLENBQUNoSCxNQVVSLEdBVEtiLFFBQVEsQ0FBQzZILEdBQUcsQ0FBQyxDQUFELENBQUosQ0FTYixHQVJFQSxHQUFHLEdBQUd4SCxJQUFJLENBQUNnRSxJQUFELENBQUosT0FBQWhFLElBQUksRUFBVXdILEdBQVYsQ0FRWixHQVBZQSxHQUFHLENBQUMsQ0FBRCxDQUFILFlBQWtCL0csSUFPOUIsS0FORStHLEdBQUcsR0FBR0wsY0FBUyxDQUFDSyxHQUFELEVBQU14RCxJQUFJLEtBQUssS0FBZixDQUFULENBQStCLENBQS9CLENBTVIsSUFIQ3dELEdBQUcsR0FBR3hTLFNBR1AsRUFBT3dTLEdBQVA7QUFDQTtBQUVEOzs7Ozs7Ozs7QUFPQSxTQUFTQyxRQUFULENBQWtCQyxLQUFsQixFQUFpQ0MsR0FBakMsRUFBd0Q7QUFDdkQsTUFBTUgsR0FBYSxHQUFHLEVBQXRCOztBQUVBLE9BQUssSUFBSXhFLENBQVMsR0FBRzBFLEtBQXJCLEVBQTRCMUUsQ0FBQyxHQUFHMkUsR0FBaEMsRUFBcUMzRSxDQUFDLEVBQXRDLEVBQ0N3RSxHQUFHLENBQUNJLElBQUosQ0FBUzVFLENBQVQsQ0FERDs7QUFJQSxTQUFPd0UsR0FBUDtBQUNBLEMsQ0FFRDs7O0FBQ0EsSUFBTUssWUFBWSxHQUFHO0FBQ3BCQyxPQUFLLEVBQUcsWUFBTTtBQUNiLFFBQU1DLFNBQVMsR0FBRztBQUFBLGFBQU87QUFDeEJDLGVBQU8sSUFEaUI7QUFDUkMsa0JBQVUsSUFERjtBQUNXQyxlQUFPLEVBQUUsQ0FEcEI7QUFDdUJDLGVBQU8sRUFBRSxDQURoQztBQUNtQ0MsZUFBTyxFQUFFLENBRDVDO0FBQytDQyxlQUFPLEVBQUU7QUFEeEQsT0FBUDtBQUFBLEtBQWxCOztBQUlBLFFBQUk7QUFJSCxhQUZBLElBQUlDLFVBQUosQ0FBZSxHQUFmLENBRUEsRUFBTyxVQUFDQyxFQUFELEVBQStCQyxTQUEvQixFQUFrREMsTUFBbEQsRUFBMkU7QUFBekJBLGNBQXlCLGdCQUF6QkEsTUFBeUIsR0FBaEJWLFNBQVMsRUFBTyxHQUNqRlEsRUFBRSxDQUFDRyxhQUFILENBQWlCLElBQUlKLFVBQUosQ0FBZUUsU0FBZixFQUEwQkMsTUFBMUIsQ0FBakIsQ0FEaUY7QUFFakYsT0FGRDtBQUdBLEtBUEQsQ0FPRSxPQUFPOUMsQ0FBUCxFQUFVO0FBQ1g7QUFDQSxhQUFPLFVBQUM0QyxFQUFELEVBQStCQyxTQUEvQixFQUFrREMsTUFBbEQsRUFBMkU7QUFBekJBLGNBQXlCLGdCQUF6QkEsTUFBeUIsR0FBaEJWLFNBQVMsRUFBTztBQUNqRixZQUFNWSxVQUFVLEdBQUdySixXQUFRLENBQUNzSixXQUFULENBQXFCLFlBQXJCLENBQW5CLENBRGlGLENBR2pGOztBQUNBRCxrQkFBVSxDQUFDRSxjQUFYLENBQ0NMLFNBREQsRUFFQ0MsTUFBTSxDQUFDVCxPQUZSLEVBR0NTLE1BQU0sQ0FBQ1IsVUFIUixFQUlDaEosR0FKRCxFQUtDLENBTEQsRUFLSTtBQUNId0osY0FBTSxDQUFDUCxPQU5SLEVBTWlCTyxNQUFNLENBQUNOLE9BTnhCLEVBT0NNLE1BQU0sQ0FBQ0wsT0FQUixFQU9pQkssTUFBTSxDQUFDSixPQVB4QixrQkFRNkIsQ0FSN0IsRUFRZ0MsSUFSaEMsQ0FKaUYsRUFlakZFLEVBQUUsQ0FBQ0csYUFBSCxDQUFpQkMsVUFBakIsQ0FmaUY7QUFnQmpGLE9BaEJEO0FBaUJBO0FBQ0QsR0FoQ00sRUFEYTtBQWtDcEJHLE9BQUssRUFBRSxlQUFDUCxFQUFELEVBQStCQyxTQUEvQixFQUFrREMsTUFBbEQsRUFBa0U7QUFDeEUsUUFBTU0sUUFBUSxHQUFHLElBQUlDLEtBQUosQ0FBVWhDLFFBQVEsQ0FBQztBQUNuQ2lDLGdCQUFVLEVBQUV4SSxJQUFJLENBQUN5SSxHQUFMLEVBRHVCO0FBRW5DaGEsWUFBTSxFQUFFcVosRUFGMkI7QUFHbkNZLGFBQU8sRUFBRSxHQUgwQjtBQUluQ0MsYUFBTyxFQUFFLEdBSjBCO0FBS25DQyxtQkFBYSxFQUFFLEVBTG9CO0FBTW5DQyxXQUFLLEVBQUU7QUFONEIsS0FBRCxFQU9oQ2IsTUFQZ0MsQ0FBbEIsQ0FBakI7QUFTQUYsTUFBRSxDQUFDRyxhQUFILENBQWlCLElBQUlhLFVBQUosQ0FBZWYsU0FBZixFQUEwQjtBQUMxQ1AsZ0JBQVUsSUFEZ0M7QUFFMUNELGFBQU8sSUFGbUM7QUFHMUN3QixjQUFRLElBSGtDO0FBSTFDQyxhQUFPLEVBQUUsQ0FBQ1YsUUFBRCxDQUppQztBQUsxQ1csbUJBQWEsRUFBRSxFQUwyQjtBQU0xQ0Msb0JBQWMsRUFBRSxDQUFDWixRQUFEO0FBTjBCLEtBQTFCLENBQWpCLENBVndFO0FBa0J4RTtBQXBEbUIsQ0FBckI7QUF1REE7Ozs7Ozs7O0FBT0EsU0FBU2EsVUFBVCxDQUFvQkMsR0FBcEIsRUFBaUNuRCxJQUFqQyxFQUF1RDtBQUN0RCxNQUFJYyxHQUFHLEdBQUdxQyxHQUFWOztBQUVBLE9BQUssSUFBTTNYLENBQVgsSUFBZ0J3VSxJQUFoQixFQUNDYyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3BGLE9BQUosQ0FBWSxJQUFJMEgsTUFBSixRQUFnQjVYLENBQWhCLFFBQXNCLEdBQXRCLENBQVosRUFBd0N3VSxJQUFJLENBQUN4VSxDQUFELENBQTVDLENBRFA7O0FBSUEsU0FBT3NWLEdBQVA7QUFDQTtBQUVEOzs7Ozs7Ozs7QUFPQSxTQUFTdUMsU0FBVCxDQUFtQkMsSUFBbkIsRUFBdUQ7QUFDdEQsTUFBSUMsVUFBSjtBQUVBLE1BQUlELElBQUksWUFBWXZKLElBQXBCLEVBQ0N3SixVQUFVLEdBQUdELElBRGQsTUFFTyxJQUFJdEssUUFBUSxDQUFDc0ssSUFBRCxDQUFaLEVBQW9CO0FBQUEsUUFDbkJFLE1BRG1CLEdBQ0QsSUFEQyxDQUNuQkEsTUFEbUI7QUFBQSxRQUNYQyxNQURXLEdBQ0QsSUFEQyxDQUNYQSxNQURXO0FBRzFCRixjQUFVLEdBQUdFLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkYsTUFBTSxDQUFDOVEsWUFBdkIsRUFBcUM0USxJQUFyQyxDQUhhO0FBSTFCLEdBSk0sTUFJSXJLLFFBQVEsQ0FBQ3FLLElBQUQsQ0FBUixJQUFrQixDQUFDcEosS0FBSyxDQUFDb0osSUFBRCxDQUo1QixLQUtOQyxVQUFVLEdBQUcsSUFBSXhKLElBQUosQ0FBUyxDQUFDdUosSUFBVixDQUxQO0FBYVAsVUFMSSxDQUFDQyxVQUFELElBQWVySixLQUFLLENBQUMsQ0FBQ3FKLFVBQUYsQ0FLeEIsS0FKQ3JFLE9BQU8sSUFBSUEsT0FBTyxDQUFDQyxLQUFuQixJQUNDRCxPQUFPLENBQUNDLEtBQVIseUJBQW9DbUUsSUFBcEMsc0JBR0YsRUFBT0MsVUFBUDtBQUNBO0FBRUQ7Ozs7Ozs7QUFLQSxTQUFTSSxZQUFULEdBQWlDO0FBQ2hDLFNBQU8sQ0FBQy9LLFdBQVEsQ0FBQ2dMLE1BQWpCO0FBQ0E7QUFFRDs7Ozs7OztBQUtBLFNBQVNDLGdCQUFULENBQTBCekMsS0FBMUIsRUFBaUNnQixLQUFqQyxFQUFrRTtBQUNqRSxNQUFJMEIsUUFBUSxLQUFaLENBRGlFLENBR2pFOztBQUNBLE1BQUksT0FBT3pGLElBQVAsQ0FBWTlGLEdBQU0sQ0FBQ3dMLFNBQVAsQ0FBaUJDLFNBQTdCLEtBQTJDNUIsS0FBL0MsRUFBc0Q7QUFDckQ7QUFEcUQsUUFFL0M2QixjQUFjLEdBQUcxTCxHQUFNLENBQUN3TCxTQUFQLElBQW9CLG9CQUFvQnhMLEdBQU0sQ0FBQ3dMLFNBQS9DLElBQTREeEwsR0FBTSxDQUFDd0wsU0FBUCxDQUFpQkcsY0FBakIsR0FBa0MsQ0FGaEU7QUFBQSxRQU0vQ0MsUUFBUSxHQUFJLGlCQUFpQjVMLEdBQWpCLElBQTRCQSxHQUFNLENBQUM2TCxhQUFQLElBQXdCeEwsV0FBUSxZQUFZTCxHQUFNLENBQUM2TCxhQU41QyxFQUlyRDtBQUNBOztBQUdBTixZQUFRLEdBQUdHLGNBQWMsSUFBSUUsUUFSd0I7QUFTckQ7O0FBRUQsTUFBTUUsUUFBUSxLQUFHLENBQUFqRCxLQUFLLElBQUswQyxRQUFiLEtBQXlCLGlCQUFpQnZMLEdBQXhEO0FBRUEsU0FBUThMLFFBQVEsSUFBSSxPQUFiLElBQTBCUCxRQUFRLElBQUksT0FBdEMsSUFBa0QsSUFBekQ7QUFDQSxDOztBQ3hpQkQ7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVDOzs7O0FBR2N4RCxzREFBUSxDQUFDO0FBQ3BCOzs7Ozs7Ozs7OztBQVdBZ0UsY0FBWTtBQVpRLENBQUQsRUFhcEI5WSxNQWJvQixFQWFqQkcsTUFiaUIsRUFhZEMsT0FiYyxDQUF2QixFOztBQ2JBOzs7OztBQUlBOzs7QUFLZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzREEyWSxhQUFXLElBdkRBO0FBd0RYQyxhQUFXLEVBQUUsTUF4REY7QUF5RFhDLGNBQVksRUFBVSxFQXpEWDtBQTBEWEMsYUFBVyxJQTFEQTtBQTJEWEMsY0FBWSxFQUFVLEVBM0RYO0FBNERYQyxjQUFZLEVBQUUsRUE1REg7QUE2RFhDLGlCQUFlLElBN0RKO0FBOERYQyxpQkFBZSxJQTlESjtBQStEWEMsY0FBWSxJQS9ERDtBQWdFWEMsWUFBVSxJQWhFQztBQWlFWEMsa0JBQWdCO0FBakVMLENBQWYsRTs7QUNUQTs7Ozs7QUFJQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0VBQyxZQUFVLElBbkVDO0FBb0VYQyxTQUFPLEVBQUUsR0FwRUU7QUFxRVhDLG1CQUFpQixFQUFFLEVBckVSO0FBc0VYQyw0QkFBMEIsSUF0RWY7QUF1RVhDLHNCQUFvQixFQUFxQmhYLFNBdkU5QjtBQXdFWGlYLGVBQWEsRUFBYSxFQXhFZjtBQXlFWEMsZ0JBQWMsRUFBcUJsWCxTQXpFeEI7QUEwRVhtWCxZQUFVLEVBQUU7QUExRUQsQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0FDLGVBQWEsSUFsQ0Y7QUFtQ1hDLHNCQUFvQixFQUFFLEVBbkNYO0FBb0NYQyxzQkFBb0IsSUFwQ1Q7QUFxQ1hDLDJCQUF5QixJQXJDZDtBQXNDWEMsZ0NBQThCLElBdENuQjtBQXVDWEMsa0JBQWdCLEVBQUUsNEJBQU0sQ0FBRTtBQXZDZixDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7OztBQUdlO0FBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0RBQyxjQUFZLEVBQStDMVgsU0F6RGhEO0FBMERYMlgsYUFBVyxFQUF1QjNYLFNBMUR2QjtBQTJEWDRYLGlCQUFlLElBM0RKO0FBNERYQyxjQUFZLElBNUREO0FBNkRYQyxhQUFXLEVBQXVCOVgsU0E3RHZCO0FBOERYK1gsa0JBQWdCLEVBQXVCL1gsU0E5RDVCO0FBK0RYZ1ksZ0JBQWMsRUFBdUJoWSxTQS9EMUI7QUFnRVhpWSxrQkFBZ0IsSUFoRUw7QUFpRVhDLFlBQVUsRUFBMEJsWSxTQWpFekI7QUFrRVhtWSxZQUFVLEVBQTBCblk7QUFsRXpCLENBQWYsRTs7QUNQQTs7Ozs7QUFJQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQW9ZLGdCQUFjLElBL0NIO0FBZ0RYQyxZQUFVLElBaERDO0FBaURYQyxxQkFBbUI7QUFqRFIsQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMERBQyxhQUFXLEVBQUUsQ0EzREY7QUE0RFhDLFlBQVUsRUFBcUN4WSxTQTVEcEM7QUE2RFh5WSxrQkFBZ0IsRUFBcUJ6WSxTQTdEMUI7QUE4RFgwWSxpQkFBZSxFQUFFLENBOUROO0FBK0RYQyxXQUFTLEVBQXFEM1ksU0EvRG5EO0FBZ0VYNFksaUJBQWUsRUFBRSxFQWhFTjtBQWlFWEMsZUFBYSxFQUFFN1ksU0FqRUo7QUFrRVg4WSxlQUFhO0FBbEVGLENBQWYsRTs7QUNQQTs7Ozs7QUFJQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQUMsYUFBVyxFQUEwQixFQXZCMUI7QUF3QlhDLGtCQUFnQjtBQXhCTCxDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7OztBQUdlO0FBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0FDLGtCQUFnQixJQXRDTDtBQXVDWEMsZ0JBQWMsRUFBc0MsTUF2Q3pDO0FBd0NYQyxnQkFBYyxJQXhDSDtBQXlDWEMsY0FBWSxFQUF1QnBaLFNBekN4QjtBQTBDWHFaLFlBQVU7QUExQ0MsQ0FBZixFOztBQ1BBOzs7OztBQUtBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0FDLDJCQUF5QixFQUFnQjtBQWxDOUIsQ0FBZixFOztBQ1JBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5REFDLGtCQUFnQixJQTFETDtBQTJEWEMsb0JBQWtCLEVBQW9DeFosU0EzRDNDO0FBNERYeVosdUJBQXFCLEVBQUUsR0E1RFo7QUE2RFhDLG1CQUFpQixFQUFvQzFaLFNBN0QxQztBQThEWDJaLGFBQVcsRUFBcUIzWixTQTlEckI7QUErRFg0WixhQUFXLEVBQUUsRUEvREY7QUFnRVhDLGNBQVksRUFBZ0QsRUFoRWpEO0FBaUVYQyxtQkFBaUIsRUFBRSxHQWpFUjtBQWtFWEMsdUJBQXFCLEVBQUUsRUFsRVo7QUFtRVhDLGdCQUFjLEVBQUUsQ0FuRUw7QUFvRVhDLHFCQUFtQixFQUFFO0FBcEVWLENBQWYsRTs7QUNQQTs7Ozs7QUFJQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZEQUMsa0JBQWdCLElBOURMO0FBK0RYQyxrQkFBZ0IsSUEvREw7QUFnRVhDLG9CQUFrQixFQUE2QnBhLFNBaEVwQztBQWlFWHFhLHFCQUFtQixFQUE2QnJhLFNBakVyQztBQWtFWHNhLFdBQVMsRUFBRSxDQWxFQTtBQW1FWEMsV0FBUyxFQUFFLEdBbkVBO0FBb0VYQyxZQUFVLEVBQUUsUUFwRUQ7QUFxRVhDLHFCQUFtQixFQUFFLENBQUMsQ0FBRCxHQUFLelAsSUFBSSxDQUFDMFAsRUFBVixHQUFlLENBckV6QjtBQXNFWEMsYUFBVyxFQUFFLEVBdEVGO0FBdUVYQyxhQUFXLEVBQXFCNWEsU0F2RXJCO0FBd0VYNmEsYUFBVyxFQUFxQjdhLFNBeEVyQjtBQXlFWDhhLHFCQUFtQixFQUFFLENBekVWO0FBMEVYQyxjQUFZLEVBQStCLEVBMUVoQztBQTJFWEMsbUJBQWlCLEVBQUUsR0EzRVI7QUE0RVhDLHVCQUFxQixFQUFFO0FBNUVaLENBQWYsRTs7QUNQQTs7Ozs7QUFJQTs7O0FBR2U7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZEQUMsZ0JBQWMsSUE5REg7QUErRFhDLGtCQUFnQixFQUFvQ25iLFNBL0R6QztBQWdFWG9iLHFCQUFtQixFQUFFLEdBaEVWO0FBaUVYQyxpQkFBZSxFQUE2QnJiLFNBakVqQztBQWtFWHNiLFlBQVUsRUFBZ0QsRUFsRS9DO0FBbUVYQyxpQkFBZSxFQUFFLEdBbkVOO0FBb0VYQyxxQkFBbUIsRUFBRSxFQXBFVjtBQXFFWEMsaUJBQWUsRUFBbUMsQ0FyRXZDO0FBc0VYQyxjQUFZLEVBQUUsQ0F0RUg7QUF1RVhDLGFBQVcsRUFBRSxDQXZFRjtBQXdFWEMsbUJBQWlCLEVBQUU7QUF4RVIsQ0FBZixFOztBQ1BBOzs7OztBQUlBOzs7QUFHZTtBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdURBQyxnQkFBYyxFQUFxQjdiLFNBeER4QjtBQXlEWDhiLHNCQUFvQixJQXpEVDtBQTBEWEMsc0JBQW9CLElBMURUO0FBMkRYQywwQkFBd0IsRUFBOEIsRUEzRDNDO0FBNERYQyxtQkFBaUIsRUFBRSxDQTVEUjtBQTZEWEMsa0JBQWdCLElBN0RMO0FBOERYQyx5QkFBdUIsRUFBRSxpQ0FBQ2pmLENBQUQ7QUFBQSxXQUFnQkEsQ0FBQyxHQUFHLENBQUosS0FBVSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQUMsQ0FBQ2tmLE9BQUYsQ0FBVSxDQUFWLENBQWxDO0FBQUEsR0E5RGQ7QUErRFhDLHVCQUFxQixJQS9EVjtBQWdFWEMsa0JBQWdCLEVBQUUsR0FoRVA7QUFpRVhDLDJCQUF5QjtBQWpFZCxDQUFmLEU7O0FDUEE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0NBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7O0lBTXFCQyxPLEdBQ3BCLFlBQWM7QUFBQSxNQU1QdEgsTUFBTSxJQUNYeEQsU0FEVyxFQUVYK0ssWUFGVyxFQUdYQyxXQUhXLEVBSVhDLGFBSlcsRUFLWHRpQixZQUxXLEVBTVhDLGNBTlcsU0FMVyxDQUFDc2lCLEtBQUQsRUFBUUMsS0FBUixFQUFlQyxHQUFmLEVBQW9CQyxLQUFwQixDQUtYLEVBSE8sQ0FBQ0MsU0FBRCxFQUFXQyxjQUFYLEVBQTBCbG5CLFNBQTFCLEVBQWdDMkMsV0FBaEMsRUFBc0N3a0IsWUFBdEMsRUFBNkNuTyxlQUE3QyxFQUF1RG9PLFdBQXZELENBR1AsRUFGWSxDQUFDdG5CLFVBQUQsRUFBT1MsU0FBUCxFQUFZOG1CLE1BQVosRUFBb0IvakIsVUFBcEIsRUFBMEJna0IsTUFBMUIsQ0FFWixDQU5DO0FBa0JiLFNBQU9yTCxRQUFRLE1BQVIsVUFBUztBQUNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQXNMLFVBQU0sRUFBaUQsUUEzQnhDOztBQTZCZjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBQyxjQUFVLEVBQXVELEVBL0NsRDs7QUFpRGY7Ozs7Ozs7Ozs7Ozs7O0FBY0FDLFlBQVEsSUEvRE87O0FBaUVmOzs7Ozs7Ozs7OztBQVdBQyxpQkFBYSxFQUFxQnpkLFNBNUVuQjs7QUE4RWY7Ozs7Ozs7Ozs7Ozs7OztBQWVBMGQsY0FBVSxFQUFxQjFkLFNBN0ZoQjtBQThGZjJkLGVBQVcsRUFBcUIzZCxTQTlGakI7O0FBZ0dmOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTRkLGdCQUFZLEVBQXFCNWQsU0FqSGxCO0FBa0hmNmQsaUJBQWEsRUFBcUI3ZCxTQWxIbkI7QUFtSGY4ZCxlQUFXLEVBQXFCOWQsU0FuSGpCO0FBb0hmK2Qsa0JBQWMsRUFBcUIvZCxTQXBIcEI7O0FBc0hmOzs7Ozs7Ozs7OztBQVdBZ2UsZUFBVyxJQWpJSTs7QUFtSWY7Ozs7Ozs7Ozs7OztBQVlBQyxVQUFNLEVBQTJCamUsU0EvSWxCOztBQWlKZjs7Ozs7Ozs7Ozs7O0FBWUFrZSxTQUFLLEVBQTJCbGUsU0E3SmpCOztBQStKZjs7Ozs7Ozs7Ozs7O0FBWUFtZSxZQUFRLEVBQTJCbmUsU0EzS3BCOztBQTZLZjs7Ozs7Ozs7Ozs7O0FBWUFvZSxhQUFTLEVBQTJCcGUsU0F6THJCOztBQTJMZjs7Ozs7Ozs7Ozs7O0FBWUFxZSxnQkFBWSxFQUEyQnJlLFNBdk14Qjs7QUF5TWY7Ozs7Ozs7Ozs7OztBQVlBc2UsVUFBTSxFQUEyQnRlLFNBck5sQjs7QUF1TmY7Ozs7Ozs7Ozs7OztBQVlBdWUsZUFBVyxFQUEyQnZlLFNBbk92Qjs7QUFxT2Y7Ozs7Ozs7Ozs7OztBQVlBd2UsY0FBVSxFQUEyQnhlLFNBalB0Qjs7QUFtUGY7Ozs7Ozs7Ozs7OztBQVlBeWUsdUJBQW1CLEVBQUUsR0EvUE47O0FBaVFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkFDLHFCQUFpQixJQXpSRjs7QUEyUmY7Ozs7Ozs7Ozs7OztBQVlBQyxXQUFPLEVBQUUsRUF2U007O0FBeVNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0FDLFVBQU0sRUFBeUMsRUFoVmhDOztBQWtWZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQXBsQixXQUFPLEVBQXFFO0FBeFc3RCxHQUFULFNBeVdEMGIsTUF6V0MsRUFBUDtBQTBXQSxDOzs7Ozs7QUN0YUY7Ozs7QUFJQTs7SUFFcUIySixXOzs7O21DQUNKLEU7Ozs7Z0JBU2hCQyxHO0FBUEE7Ozs7Ozs7QUFPQSxlQUFJeFMsR0FBSixFQUFpQkksS0FBakIsRUFBd0JxUyxVQUF4QixFQUE0QztBQUUzQyxXQUZ1QkEsVUFFdkIsZ0JBRnVCQSxVQUV2QixRQURBLEtBQUtDLEtBQUwsQ0FBVzFTLEdBQVgsSUFBa0J5UyxVQUFVLEdBQUcsS0FBS0UsV0FBTCxDQUFpQnZTLEtBQWpCLENBQUgsR0FBNkJBLEtBQ3pELEVBQU8sS0FBS3NTLEtBQUwsQ0FBVzFTLEdBQVgsQ0FBUDtBQUNBO0FBRUQ7Ozs7O1dBS0E0UyxNLEdBQUEsZ0JBQU81UyxHQUFQLEVBQStCO0FBQUE7O0FBQzlCOEQsV0FBTyxDQUFDOUQsR0FBRCxDQUFQLENBQWFNLE9BQWIsQ0FBcUIsVUFBQXBDLENBQUM7QUFBQSxhQUFJLE9BQU8sS0FBSSxDQUFDd1UsS0FBTCxDQUFXeFUsQ0FBWCxDQUFYO0FBQUEsS0FBdEIsQ0FEOEI7QUFFOUI7QUFFRDs7Ozs7OztXQU9BMlUsRyxHQUFBLGFBQUk3UyxHQUFKLEVBQVN5UyxVQUFULEVBQTZCO0FBQzVCLFFBRFFBLFVBQ1IsZ0JBRFFBLFVBQ1IsUUFBSUEsVUFBSixFQUFnQjtBQUdmLGVBQWdCbmhCLEVBQWhCLEVBRk13aEIsT0FBYyxHQUFHLEVBRXZCLEVBQVNwUixDQUFDLEdBQUcsQ0FBYixFQUFxQnBRLEVBQUUsR0FBRzBPLEdBQUcsQ0FBQzBCLENBQUQsQ0FBN0IsRUFBbUNBLENBQUMsRUFBcEMsRUFDS3BRLEVBQUUsSUFBSSxLQUFLb2hCLEtBRGhCLElBRUVJLE9BQU8sQ0FBQ3hNLElBQVIsQ0FBYSxLQUFLcU0sV0FBTCxDQUFpQixLQUFLRCxLQUFMLENBQVdwaEIsRUFBWCxDQUFqQixDQUFiLENBRkY7O0FBTUEsYUFBT3doQixPQUFQO0FBQ0E7O0FBQ0EsV0FBTyxLQUFLSixLQUFMLENBQVcxUyxHQUFYLEtBQW1CLElBQTFCO0FBRUQ7QUFFRDs7Ozs7V0FLQStTLEssR0FBQSxlQUFNQyxHQUFOLEVBQXFCO0FBQ3BCLFFBQU1DLEVBQUUsR0FBRyxJQUFYOztBQUVBLFNBQUssSUFBTXJpQixDQUFYLElBQWdCcWlCLEVBQUUsQ0FBQ1AsS0FBbkIsR0FFS00sR0FBRyxJQUFJLE1BQU12UCxJQUFOLENBQVc3UyxDQUFYLENBRlosTUFHRXFpQixFQUFFLENBQUNQLEtBQUgsQ0FBUzloQixDQUFULElBQWMsSUFIaEI7QUFNQSxHLFNBRUQraEIsVyxHQUFBLHFCQUFZL2tCLE1BQVosRUFBb0I7QUFDbkIsV0FBTztBQUNOMEQsUUFBRSxFQUFFMUQsTUFBTSxDQUFDMEQsRUFETDtBQUVONGhCLFlBQU0sRUFBRXRsQixNQUFNLENBQUNzbEIsTUFGVDtBQUdOQyxZQUFNLEVBQUV2bEIsTUFBTSxDQUFDdWxCLE1BQVAsQ0FBYzlSLEdBQWQsQ0FBa0IsVUFBQXRDLENBQUM7QUFBQSxlQUFLO0FBQUNuTyxXQUFDLEVBQUVtTyxDQUFDLENBQUNuTyxDQUFOO0FBQVN3UCxlQUFLLEVBQUVyQixDQUFDLENBQUNxQixLQUFsQjtBQUF5QjlPLFlBQUUsRUFBRXlOLENBQUMsQ0FBQ3pOO0FBQS9CLFNBQUw7QUFBQSxPQUFuQjtBQUhGLEtBQVA7QUFLQSxHOzs7Ozs7Ozs7Ozs7O0FDM0VGOzs7OztBQUtBO0FBQ0E7O0lBRXFCOGhCLHFDOzs7QUFLcEIsOEJBQVlDLEtBQVosRUFBbUI7QUFBQTtBQUNaLFFBQUFDLEtBQUssR0FBR0MsMEZBQWEsRUFBckI7QUFBQSxRQUNDM0ssTUFERCxHQUNtQnlLLEtBRG5CLENBQ0N6SyxNQUREO0FBQUEsUUFDU3pCLE1BRFQsR0FDbUJrTSxLQURuQixDQUNTbE0sTUFEVDtBQUdOLFNBQUtrTSxLQUFMLEdBQWFBLEtBSkssRUFLbEIsS0FBS3pLLE1BQUwsR0FBY0EsTUFMSSxFQU1sQixLQUFLMEssS0FBTCxHQUFhQSxLQU5LLEdBUWQxSyxNQUFNLENBQUM0SyxZQUFQLElBQXVCLENBQUNyTSxNQUFNLENBQUN5QixNQUFQLENBQWN1SixtQkFSeEIsTUFTakJ2SixNQUFNLENBQUM2SyxpQkFBUCxLQVRpQixHQWFsQjdLLE1BQU0sQ0FBQzhLLEtBQVAsR0FBZSxLQUFLQyxXQUFMLENBQWlCLENBQUN4TSxNQUFNLENBQUN5TSxTQUFQLElBQW9CTixLQUFyQixFQUE0QkksS0FBNUIsRUFBakIsQ0FiRztBQWNsQjtBQUVEOzs7Ozs7OztxQkFNT0csZSxHQUFQLHlCQUF1QjdTLElBQXZCLEVBQTZCO0FBQzVCO0FBQ0EsUUFBTW5RLElBQUksR0FBRztBQUNaaWpCLE9BQUMsRUFBRSxHQURTO0FBRVpDLE9BQUMsRUFBRTtBQUZTLEtBQWI7QUFzQkEsV0FqQkMvUyxJQUFJLENBQUNuVixLQUFMLEVBQUQsSUFBaUJtVixJQUFJLENBQUMyQixNQUFMLENBQVksTUFBWixFQUNmOVUsSUFEZSxDQUNWLEdBRFUsRUFFZjhTLElBRmUsQ0FFVixVQUFBc0csRUFBRSxFQUFJO0FBQ1gsVUFBSTtBQUFBLCtCQUNxQkEsRUFBRSxDQUFDakcsSUFBSCxHQUFVYyxPQUFWLEVBRHJCO0FBQUEsWUFDSTFTLEtBREosb0JBQ0lBLEtBREo7QUFBQSxZQUNXRSxNQURYLG9CQUNXQSxNQURYOztBQUdDRixhQUFLLElBQUlFLE1BSFYsS0FJRnVCLElBQUksQ0FBQ2lqQixDQUFMLEdBQVMxa0IsS0FKUCxFQUtGeUIsSUFBSSxDQUFDa2pCLENBQUwsR0FBU3prQixNQUxQLEdBUUgyWCxFQUFFLENBQUNwWixJQUFILENBQVEsRUFBUixDQVJHO0FBU0gsT0FURCxDQVNFLE9BQU93VyxDQUFQLEVBQVUsQ0FBRTtBQUNkLEtBYmUsQ0FpQmpCLEVBRkEsS0FBS3dQLGVBQUwsR0FBdUI7QUFBQSxhQUFNaGpCLElBQU47QUFBQSxLQUV2QixFQUFPQSxJQUFQO0FBQ0EsRzs7O2dCQUVEbkgsSyxHQUFBLGVBQU0wWSxTQUFOLEVBQWlCeFIsQ0FBakIsRUFBb0I7QUFBQTs7QUFDbkJ3UixhQUFTLENBQUNSLElBQVYsQ0FBZSxXQUFmLEVBQTRCLFVBQUE3QyxDQUFDO0FBQUEsNEJBQWlCTCxJQUFJLENBQUNDLElBQUwsQ0FBVS9OLENBQUMsQ0FBQ21PLENBQUQsQ0FBRCxHQUFPLEtBQUksQ0FBQzZKLE1BQUwsQ0FBWW9MLFVBQTdCLENBQWpCO0FBQUEsS0FBN0IsQ0FEbUI7QUFFbkIsRyxTQUVEcHFCLEssR0FBQSxlQUFNd1ksU0FBTixFQUFpQnJSLENBQWpCLEVBQW9CO0FBQ25CcVIsYUFBUyxDQUFDUixJQUFWLENBQWUsV0FBZixFQUE0QixVQUFBN0MsQ0FBQztBQUFBLDhCQUFtQkwsSUFBSSxDQUFDQyxJQUFMLENBQVU1TixDQUFDLENBQUNnTyxDQUFELENBQVgsQ0FBbkI7QUFBQSxLQUE3QixDQURtQjtBQUVuQixHLFNBRUQ0VSxXLEdBQUEscUJBQVk3aUIsTUFBWixFQUFvQjtBQUFBLFFBQ2JzVixLQUFLLEdBQUd0VixNQUFNLENBQUMsQ0FBRCxDQUREO0FBQUEsUUFFYm1qQixJQUFJLEdBQUduakIsTUFBTSxDQUFDQSxNQUFNLENBQUNvTyxNQUFQLEdBQWdCLENBQWpCLENBRkE7QUFJbkIsV0FBT2tILEtBQUssR0FBRzZOLElBQVIsR0FBZSxDQUFDN04sS0FBRCxFQUFRNk4sSUFBUixDQUFmLEdBQStCLENBQUNBLElBQUQsRUFBTzdOLEtBQVAsQ0FBdEM7QUFDQSxHLFNBRUQ4TixhLEdBQUEsdUJBQWNaLEtBQWQsRUFBcUJhLE9BQXJCLEVBQThCO0FBQ3ZCLFFBQUNDLFlBQUQsR0FBaUIsS0FBS2YsS0FBTCxDQUFXbE0sTUFBNUIsQ0FBQ2lOLFlBQUQ7QUFBQSxRQUNGQyxLQURFLEdBQ00sRUFETjtBQUdOO0FBQ0EsUUFBSUYsT0FBTyxJQUFJQyxZQUFmLDJCQUNzQmQsS0FBSyxDQUFDeGlCLE1BQU4sRUFEdEIsRUFDUXNWLEtBRFIscUJBQ2VDLEdBRGYscUJBRUtpTyxRQUZMLEdBRWdCbE8sS0FGaEIsRUFJUWtPLFFBQVEsSUFBSWpPLEdBSnBCLEdBS0VnTyxLQUFLLENBQUMvTixJQUFOLENBQVdnTyxRQUFYLENBTEYsRUFNRUEsUUFBUSxJQUFJRixZQU5kLE1BUU8sSUFBSWQsS0FBSyxDQUFDZSxLQUFWLEVBQ05BLEtBQUssR0FBR2YsS0FBSyxDQUFDZSxLQUFOLE9BQUFmLEtBQUssRUFDUixLQUFLMUssTUFBTCxDQUFZMkwsYUFBWixJQUE2QixFQURyQixDQUFMLENBRU5sVCxHQUZNLENBRUYsVUFBQW5ELENBQUM7QUFBQSxhQUNOO0FBQ0NFLGdCQUFRLENBQUNGLENBQUQsQ0FBUixJQUFlRyxRQUFRLENBQUNILENBQUQsQ0FBdkIsSUFBOEIsQ0FBQ29CLEtBQUssQ0FBQ3BCLENBQUQsQ0FBcEMsSUFDQVEsSUFBSSxDQUFDOFYsS0FBTCxDQUFXdFcsQ0FBQyxHQUFHLEVBQWYsSUFBcUIsRUFEdEIsSUFFS0E7QUFKQztBQUFBLEtBRkMsQ0FERixNQVNBO0FBR04sZUFGTXBOLE1BQU0sR0FBR3dpQixLQUFLLENBQUN4aUIsTUFBTixFQUVmLEVBQVM0USxDQUFDLEdBQUdoRCxJQUFJLENBQUNDLElBQUwsQ0FBVTdOLE1BQU0sQ0FBQyxDQUFELENBQWhCLENBQWIsRUFBbUM0USxDQUFDLEdBQUc1USxNQUFNLENBQUMsQ0FBRCxDQUE3QyxFQUFrRDRRLENBQUMsRUFBbkQsRUFDQzJTLEtBQUssQ0FBQy9OLElBQU4sQ0FBVzVFLENBQVgsQ0FERDs7QUFJSTJTLFdBQUssQ0FBQ25WLE1BQU4sR0FBZSxDQUFmLElBQW9CbVYsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLENBUDdCLElBUUxBLEtBQUssQ0FBQ0ksT0FBTixDQUFjSixLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVlBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV0EsS0FBSyxDQUFDLENBQUQsQ0FBNUIsQ0FBZCxDQVJLO0FBVU47QUFFRCxXQUFPQSxLQUFQO0FBQ0EsRyxTQUVESyxTLEdBQUEscUJBQVk7QUFDWCxRQUFNQyxRQUFRLEdBQUcsS0FBS3JCLEtBQUwsQ0FBV3NCLElBQVgsRUFBakI7QUFNQSxXQUpLRCxRQUFRLENBQUM3akIsTUFBVCxHQUFrQm9PLE1BSXZCLElBSEN5VixRQUFRLENBQUM3akIsTUFBVCxDQUFnQixLQUFLd2lCLEtBQUwsQ0FBV3hpQixNQUFYLEVBQWhCLENBR0QsRUFBTzZqQixRQUFQO0FBQ0EsRyxTQUVERSxhLEdBQUEsdUJBQWMzVyxDQUFkLEVBQWlCO0FBQUEsUUFDVjRXLFVBQVUsR0FBRyxLQUFLbE0sTUFBTCxDQUFZa00sVUFEZjtBQUFBLFFBTVYxVSxLQUFLLEdBQUcsbUJBQW1CcUQsSUFBbkIsQ0FBd0J2RixDQUF4QixJQUE2QixDQUFDLENBQU9BLENBQVAsT0FBVTRDLE9BQVYsQ0FBa0IsT0FBbEIsRUFBMkIsRUFBM0IsQ0FBOUIsR0FBK0Q1QyxDQU43RDtBQUFBLFFBT1Y2VyxTQUFTLEdBQUdELFVBQVUsR0FBR0EsVUFBVSxDQUFDMVUsS0FBRCxDQUFiLEdBQXVCQSxLQVBuQyxFQUdoQjtBQUNBO0FBQ0E7O0FBSUEsV0FBTzdCLFNBQVMsQ0FBQ3dXLFNBQUQsQ0FBVCxHQUF1QkEsU0FBdkIsR0FBbUMsRUFBMUM7QUFDQSxHLFNBRURDLGEsR0FBQSx1QkFBYzVTLFNBQWQsRUFBeUI7QUFBQSxRQUNqQndHLE1BRGlCLEdBQ1AsSUFETyxDQUNqQkEsTUFEaUI7QUFHeEIsV0FBT0EsTUFBTSxDQUFDNkssaUJBQVAsR0FDTnJSLFNBQVMsQ0FBQzZTLFNBQVYsRUFETSxHQUNrQjdTLFNBQVMsQ0FBQzhTLFVBQVYsQ0FBcUJ0TSxNQUFNLENBQUNzTSxVQUE1QixDQUR6QjtBQUVBLEc7Ozs7Ozs7QUM3SUY7Ozs7O0FBS0E7QUFDQTtBQUNBOztJQUdxQkMseUI7OztBQU1wQix3QkFBWWhPLE1BQVosRUFBOEI7QUFBbEJBLFVBQWtCLGdCQUFsQkEsTUFBa0IsR0FBSixFQUFJO0FBQzdCLFFBQU15QixNQUFNLEdBQUc7QUFDZHdNLG1CQUFhLEVBQUUsQ0FERDtBQUVkQyxtQkFBYSxFQUFFbE8sTUFBTSxDQUFDbU8sU0FBUCxHQUFtQixDQUFuQixHQUF1QixDQUZ4QjtBQUdkQyxZQUFNLEVBQUUsUUFITTtBQUlkN0IsV0FBSyxFQUFFLEVBSk87QUFLZGEsbUJBQWEsRUFBRSxJQUxEO0FBTWRpQixrQkFBWSxFQUFFLElBTkE7QUFPZEMsaUJBQVcsSUFQRztBQVFkWCxnQkFBVSxFQUFFLElBUkU7QUFTZFksZ0JBQVUsRUFBRSxDQVRFO0FBVWQxQixnQkFBVSxFQUFFLENBVkU7QUFXZDJCLGlCQUFXLEVBQUUsQ0FYQztBQVlkQyxnQkFBVSxFQUFFLElBWkU7QUFhZFYsZ0JBQVUsRUFBRSxJQWJFO0FBY2QxQixrQkFBWSxFQUFFck0sTUFBTSxDQUFDcU07QUFkUCxLQUFmO0FBaUJBNUssVUFBTSxDQUFDOE0sVUFBUCxHQUFvQmhYLElBQUksQ0FBQ21YLEdBQUwsQ0FBU2pOLE1BQU0sQ0FBQ3dNLGFBQWhCLEVBQStCLENBQS9CLElBQW9DeE0sTUFBTSxDQUFDK00sV0FsQmxDLEVBb0I3QixLQUFLL00sTUFBTCxHQUFjQSxNQXBCZSxFQXFCN0IsS0FBS3pCLE1BQUwsR0FBY0EsTUFyQmUsRUFzQjdCLEtBQUsyTyxNQUFMLEdBQWMsSUFBSUMscUNBQUosQ0FBVyxJQUFYLENBdEJlO0FBdUI3QjtBQUVEOzs7Ozs7OztnQkFLQUMsTSxHQUFBLGdCQUFPQyxDQUFQLEVBQXVCO0FBQ2hCLFFBQUE1UyxHQUFHLEdBQUcsSUFBTjtBQUFBLFFBQ0N1RixNQURELEdBQ3VDLElBRHZDLENBQ0NBLE1BREQ7QUFBQSxRQUNTekIsTUFEVCxHQUN1QyxJQUR2QyxDQUNTQSxNQURUO0FBQUEsUUFDeUIrTyxVQUR6QixHQUN1QyxJQUR2QyxDQUNpQkosTUFEakI7QUFBQSxRQUVBeEMsS0FGQSxHQUVRNEMsVUFBVSxDQUFDNUMsS0FGbkI7QUFBQSxRQUdBaUMsTUFIQSxHQUdTM00sTUFBTSxDQUFDMk0sTUFIaEI7QUFBQSxRQUlBWSxhQUpBLEdBSWdCLEtBQUtBLGFBQUwsQ0FBbUJDLElBQW5CLENBQXdCLElBQXhCLENBSmhCO0FBQUEsUUFLQUMsV0FMQSxHQUtjLGlCQUFpQjVTLElBQWpCLENBQXNCOFIsTUFBdEIsQ0FMZDtBQUFBLFFBTUFlLFdBTkEsR0FNYyxpQkFBaUI3UyxJQUFqQixDQUFzQjhSLE1BQXRCLENBTmQ7QUFBQSxRQVNBZ0IsYUFUQSxHQVNnQkwsVUFBVSxDQUFDSSxXQUFXLEdBQUcsT0FBSCxHQUFhLE9BQXpCLENBVDFCO0FBQUEsUUFVQUUsTUFWQSxHQVVTRCxhQUFhLEtBQUtMLFVBQVUsQ0FBQ3hzQixLQUE3QixHQUFxQyxHQUFyQyxHQUEyQyxHQVZwRDtBQUFBLFFBV0Erc0IsSUFYQSxHQVdPLGVBQWVoVCxJQUFmLENBQW9COFIsTUFBcEIsSUFBOEIsQ0FBQyxDQUEvQixHQUFtQyxDQVgxQztBQUFBLFFBY0FtQixNQWRBLEdBY1N2UCxNQUFNLENBQUN3UCxjQWRoQjtBQWdCTixTQUFLL04sTUFBTCxDQUFZOEssS0FBWixHQUFvQkosS0FBSyxDQUFDc0QsV0FBTixHQUNuQnRELEtBQUssQ0FBQ3NELFdBQU4sRUFEbUIsR0FFbkJWLFVBQVUsQ0FBQ3ZDLFdBQVgsQ0FBdUIsQ0FBQ3hNLE1BQU0sQ0FBQ3lNLFNBQVAsSUFBb0JOLEtBQXJCLEVBQTRCSSxLQUE1QixFQUF2QixDQW5CcUI7QUFvQ2xCLFFBQUFtRCxFQUFFO0FBQUEsa0JBZnFDak8sTUFlckM7QUFBQSxRQWZDd00sYUFlRCxXQWZDQSxhQWVEO0FBQUEsUUFmZ0JNLFVBZWhCLFdBZmdCQSxVQWVoQjtBQUFBLFFBZjRCaEMsS0FlNUIsV0FmNEJBLEtBZTVCO0FBQUEsUUFaQW9ELElBWUEsR0FaTzNQLE1BQU0sQ0FBQzJQLElBWWQ7QUFBQSxRQVhBQyxXQVdBLEdBWGNELElBQUksSUFBSSxhQUFhclQsSUFBYixDQUFrQnFULElBQWxCLENBQVIsR0FDbkIzUCxNQUFNLENBQUN5QixNQUFQLFdBQXNCa08sSUFBdEIseUJBRG1CLEdBQ2dDO0FBQUNsbUIsT0FBQyxFQUFFLENBQUo7QUFBT0csT0FBQyxFQUFFO0FBQVYsS0FVOUM7QUFBQSxRQVBBaW1CLE1BT0EsR0FQU0YsSUFBSSxLQUFLLE1BQVQsaUNBQThDQSxJQU92RDtBQUFBLFFBTkFHLFFBTUEsR0FOVzlQLE1BQU0sQ0FBQ3lCLE1BQVAsQ0FBaUJvTyxNQUFqQixXQU1YO0FBQUEsUUFMQUUsUUFLQSxHQUxXO0FBQ2hCQyxVQUFJLElBQUVGLFFBQUYsSUFBYTlQLE1BQU0sQ0FBQ3lCLE1BQVAsQ0FBaUJvTyxNQUFqQixnQkFERDtBQUVoQm5wQixVQUFJLElBQUVvcEIsUUFBRixJQUFhOVAsTUFBTSxDQUFDeUIsTUFBUCxDQUFpQm9PLE1BQWpCO0FBRkQsS0FLWCxDQXBDZ0IsQ0F1QnRCOztBQWVBZixLQUFDLENBQUNtQixJQUFGLENBQU8sWUFBVztBQUFBLFVBQ1huQixDQUFDLEdBQUdvQixpR0FBUSxDQUFDLElBQUQsQ0FERDtBQUFBLFVBRWJDLE1BQU0sR0FBRyxLQUFLQyxTQUFMLElBQWtCakUsS0FGZDtBQUFBLFVBR2JrRSxNQUFNLEdBQUd0QixVQUFVLENBQUN4QixTQUFYLEVBSEk7QUFLakJtQyxRQUFFLEdBQUdaLENBTFksRUFNakIsS0FBS3NCLFNBQUwsR0FBaUJDLE1BTkEsRUFRakI1TyxNQUFNLENBQUNvTCxVQUFQLEdBQW9CN00sTUFBTSxDQUFDc1EsVUFBUCxHQUNuQi9ZLElBQUksQ0FBQ0MsSUFBTCxDQUFVLENBQUM2WSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVlBLE1BQU0sQ0FBQyxDQUFELENBQW5CLElBQTBCLENBQXBDLENBRG1CLEdBQ3NCLENBVHpCO0FBV2pCO0FBQ0EsVUFBTTdsQixJQUFJLEdBQUdza0IsQ0FBQyxDQUFDeUIsU0FBRixDQUFZLFNBQVosRUFBdUJ0UyxJQUF2QixDQUE0QixDQUFDLENBQUQsQ0FBNUIsQ0FBYixDQVppQixDQWNqQjs7QUFZQSxVQVhBelQsSUFBSSxDQUFDZ21CLEtBQUwsR0FBYWhXLE1BQWIsQ0FBb0IsTUFBcEIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0IsUUFEaEIsRUFFRWdXLEtBRkYsQ0FFUTFCLFVBQVUsQ0FBQ2xCLGFBQVgsQ0FBeUJyakIsSUFBekIsQ0FGUixFQUdFaVEsSUFIRixDQUdPLEdBSFAsRUFHWSxZQUFNO0FBQ2hCLFlBQU1pVyxjQUFjLEdBQUdqUCxNQUFNLENBQUN5TSxhQUFQLEdBQXVCb0IsSUFBOUM7QUFFQSxlQUFPSCxXQUFXLFNBQ2I1QyxLQUFLLENBQUMsQ0FBRCxDQURRLFNBQ0RtRSxjQURDLFdBQ21CbkUsS0FBSyxDQUFDLENBQUQsQ0FEeEIsU0FDK0JtRSxjQUQvQixTQUViQSxjQUZhLFNBRUtuRSxLQUFLLENBQUMsQ0FBRCxDQUZWLFdBRW1CQSxLQUFLLENBQUMsQ0FBRCxDQUZ4QixTQUUrQm1FLGNBRmpEO0FBR0EsT0FURixDQVdBLEVBQUlYLFFBQVEsQ0FBQ0MsSUFBVCxJQUFpQkQsUUFBUSxDQUFDcnBCLElBQTlCLEVBQW9DO0FBQ25DO0FBRG1DLFlBRTdCd21CLEtBQUssR0FBR3pMLE1BQU0sQ0FBQ2dOLFVBQVAsSUFBcUJNLFVBQVUsQ0FBQ2hDLGFBQVgsQ0FBeUJzRCxNQUF6QixFQUFpQ25CLFdBQWpDLENBRkE7QUFBQSxZQUsvQmMsSUFBaUIsR0FBR2xCLENBQUMsQ0FBQ3lCLFNBQUYsQ0FBWSxPQUFaLEVBQ3RCdFMsSUFEc0IsQ0FDakJpUCxLQURpQixFQUNWbUQsTUFEVSxDQUxXO0FBQUEsWUFTN0JNLFNBQVMsR0FBR1gsSUFBSSxDQUNwQlEsS0FEZ0IsR0FFaEJJLE1BRmdCLENBRVQsR0FGUyxFQUVKLFNBRkksRUFHaEJuVyxJQUhnQixDQUdYLE9BSFcsRUFHRixNQUhFLEVBSWhCb1csS0FKZ0IsQ0FJVixTQUpVLEVBSUMsR0FKRCxDQVRpQjtBQUFBLFlBZ0I3QkMsUUFBUSxHQUFHZCxJQUFJLENBQUNlLElBQUwsR0FBWXRGLE1BQVosRUFoQmtCLEVBSW5DOztBQWVBdUUsWUFBSSxHQUFHVyxTQUFTLENBQUNGLEtBQVYsQ0FBZ0JULElBQWhCLENBbkI0QixFQXFCbkNELFFBQVEsQ0FBQ0MsSUFBVCxJQUFpQlcsU0FBUyxDQUFDblcsTUFBVixDQUFpQixNQUFqQixDQXJCa0IsRUFzQm5DdVYsUUFBUSxDQUFDcnBCLElBQVQsSUFBaUJpcUIsU0FBUyxDQUFDblcsTUFBVixDQUFpQixNQUFqQixDQXRCa0I7QUFBQSxZQXdCN0J3VyxZQUFZLEdBQUdwQyxxQ0FBTSxDQUFDbEMsZUFBUCxDQUF1QnNELElBQXZCLENBeEJjO0FBQUEsWUF5QjdCaUIsTUFBZ0IsR0FBRyxFQXpCVTtBQUFBLFlBMkIvQkMsS0FBa0IsR0FBR2xCLElBQUksQ0FBQ3hVLE1BQUwsQ0FBWSxNQUFaLEVBQ3ZCK1UsU0FEdUIsQ0FDYixPQURhLEVBRXZCdFMsSUFGdUIsQ0FFbEIsVUFBQ3JHLENBQUQsRUFBSXVaLEtBQUosRUFBYztBQUNuQixjQUFNL1csS0FBSyxHQUFHNEYsTUFBTSxDQUFDb1IsYUFBUCxHQUNicEMsYUFBYSxDQUFDcFgsQ0FBRCxFQUFJeVksTUFBSixFQUFZbkQsS0FBWixFQUFtQmdDLFdBQW5CLEVBQWdDOEIsWUFBWSxDQUFDckUsQ0FBN0MsQ0FEQSxHQUVadFUsT0FBTyxDQUFDMFcsVUFBVSxDQUFDckIsYUFBWCxDQUF5QjlWLENBQXpCLENBQUQsQ0FBUCxHQUNDbVgsVUFBVSxDQUFDckIsYUFBWCxDQUF5QjlWLENBQXpCLEVBQTRCcUYsTUFBNUIsRUFERCxHQUN3QyxDQUFDOFIsVUFBVSxDQUFDckIsYUFBWCxDQUF5QjlWLENBQXpCLENBQUQsQ0FIMUM7QUFRQSxpQkFGQXFaLE1BQU0sQ0FBQ0UsS0FBRCxDQUFOLEdBQWdCL1csS0FBSyxDQUFDckMsTUFFdEIsRUFBT3FDLEtBQUssQ0FBQ0YsR0FBTixDQUFVLFVBQUFtWCxRQUFRO0FBQUEsbUJBQUs7QUFBQ0YsbUJBQUssRUFBTEEsS0FBRDtBQUFRRSxzQkFBUSxFQUFSQTtBQUFSLGFBQUw7QUFBQSxXQUFsQixDQUFQO0FBQ0EsU0FadUIsQ0EzQlU7QUF5Q25DSCxhQUFLLENBQUNILElBQU4sR0FBYXRGLE1BQWIsRUF6Q21DLEVBMkNuQ3lGLEtBQUssR0FBR0EsS0FBSyxDQUNYVixLQURNLEdBRU5oVyxNQUZNLENBRUMsT0FGRCxFQUdOaVcsS0FITSxDQUdBUyxLQUhBLEVBSU54cUIsSUFKTSxDQUlELFVBQUFrUixDQUFDO0FBQUEsaUJBQUlBLENBQUMsQ0FBQ3laLFFBQU47QUFBQSxTQUpBLENBM0MyQixFQWtEbkNILEtBQUssQ0FDSHpXLElBREYsQ0FDTyxHQURQLEVBQ1kwVSxXQUFXLEdBQUcsQ0FBSCxHQUFPWixVQUFVLEdBQUdlLElBRDNDLEVBRUU3VSxJQUZGLENBRU8sSUFGUCxFQUVjLFlBQU07QUFDbEIsY0FBSTZXLEVBQUUsR0FBRyxDQUFUO0FBTUEsaUJBSkksZUFBZWhWLElBQWYsQ0FBb0I4UixNQUFwQixLQUErQm1CLE1BSW5DLEtBSEMrQixFQUFFLEdBQUcsSUFBSS9aLElBQUksQ0FBQ2dhLEdBQUwsQ0FBU2hhLElBQUksQ0FBQzBQLEVBQUwsSUFBV3NJLE1BQU0sR0FBRyxHQUFwQixDQUFULENBQUosSUFBMENuQixNQUFNLEtBQUssS0FBWCxHQUFtQixDQUFDLENBQXBCLEdBQXdCLENBQWxFLENBR04sR0FBT2tELEVBQUUsSUFBSTFCLFdBQVcsQ0FBQ25tQixDQUFaLElBQWlCLENBQXJCLENBQVQ7QUFDQSxTQVJXLEVBRmIsRUFXRWdSLElBWEYsQ0FXTyxJQVhQLEVBV2EsVUFBQzdDLENBQUQsRUFBSTJDLENBQUosRUFBVTtBQUFBLGNBRWpCVCxFQUFtQixHQUFHLENBRkw7QUFhckIsaUJBVElzVSxNQUFNLEtBQUssS0FTZixLQVJDdFUsRUFBRSxHQUFHa1gsWUFBWSxDQUFDcEUsQ0FRbkIsRUFOS3JTLENBQUMsS0FBSyxDQU1YLEtBTEVULEVBQUUsR0FBR29WLFdBQVcsR0FBRyxFQUFFLENBQUMrQixNQUFNLENBQUNyWixDQUFDLENBQUN1WixLQUFILENBQU4sR0FBa0IsQ0FBbkIsS0FBeUJILFlBQVksQ0FBQ3BFLENBQWIsR0FBaUIsQ0FBMUMsSUFBK0MsQ0FBakQsQ0FBSCxHQUNkZ0QsV0FBVyxDQUFDaG1CLENBQVosS0FBa0IsQ0FBbEIsYUFBaUMsQ0FJckMsSUFBT3NOLFFBQVEsQ0FBQzRDLEVBQUQsQ0FBUixJQUFnQjhWLFdBQVcsQ0FBQ2htQixDQUE1QixHQUNOa1EsRUFBRSxHQUFHOFYsV0FBVyxDQUFDaG1CLENBRFgsR0FDZWtRLEVBQUUsV0FEeEI7QUFFQSxTQTFCRixDQWxEbUM7QUFBQSxZQThFN0IwWCxVQUFVLEdBQUd4QixJQUFJLENBQUN4VSxNQUFMLENBQVksTUFBWixDQTlFZ0I7QUFBQSxZQStFN0JpVyxVQUFVLEdBQUd6QixJQUFJLENBQUN4VSxNQUFMLENBQVksTUFBWixDQS9FZ0I7O0FBNEZuQyxZQVhBbVYsU0FBUyxDQUFDblYsTUFBVixDQUFpQixNQUFqQixFQUF5QmYsSUFBekIsQ0FBaUM0VSxNQUFqQyxRQUE0Q3BCLGFBQWEsR0FBR3FCLElBQTVELENBV0EsRUFWQXFCLFNBQVMsQ0FBQ25WLE1BQVYsQ0FBaUIsTUFBakIsRUFBeUJmLElBQXpCLE1BQWlDNFUsTUFBakMsRUFBMkNkLFVBQVUsR0FBR2UsSUFBeEQsQ0FVQSxFQVJBcFQsR0FBRyxDQUFDd1YsdUJBQUosQ0FBNEJGLFVBQTVCLEVBQXdDQyxVQUF4QyxDQVFBLEVBTEF6UixNQUFNLENBQUMyUixTQUFQLElBQW9CRixVQUFVLENBQUNqWCxNQUEvQixJQUF5Q2lYLFVBQVUsQ0FBQ2pYLE1BQVgsQ0FBa0IsT0FBbEIsRUFDdkN5VixJQUR1QyxDQUNsQyxVQUFTa0IsS0FBVCxFQUFnQjtBQUNyQmpCLDJHQUFRLENBQUMsSUFBRCxDQUFSLENBQWV4cEIsSUFBZixDQUFvQnNaLE1BQU0sQ0FBQzJSLFNBQVAsQ0FBaUJSLEtBQWpCLENBQXBCLENBRHFCO0FBRXJCLFNBSHVDLENBS3pDLEVBQUlkLE1BQU0sQ0FBQ3VCLFNBQVgsRUFBc0I7QUFBQSxjQUNmbm9CLENBQUMsR0FBRzRtQixNQURXO0FBQUEsY0FFZmlCLEVBQUUsR0FBRzduQixDQUFDLENBQUNtb0IsU0FBRixLQUFnQixDQUZOO0FBSXJCekIsZ0JBQU0sR0FBRyxVQUFBdlksQ0FBQztBQUFBLG1CQUFJbk8sQ0FBQyxDQUFDbU8sQ0FBRCxDQUFELEdBQU8wWixFQUFYO0FBQUEsV0FKVyxFQUtyQmpCLE1BQU0sR0FBR0YsTUFMWTtBQU1yQixTQU5ELE1BTVdBLE1BQU0sQ0FBQ3lCLFNBTmxCLEdBT0N6QixNQUFNLEdBQUdFLE1BUFYsR0FTQ2pCLGFBQWEsQ0FBQzVWLElBQWQsQ0FBbUJ1VixVQUFuQixFQUErQitCLFFBQS9CLEVBQXlDVCxNQUF6QyxDQVREOztBQVlBakIscUJBQWEsQ0FBQzVWLElBQWQsQ0FBbUJ1VixVQUFuQixFQUErQjRCLFNBQS9CLEVBQTBDUixNQUExQyxDQXhHbUMsRUF5R25DZixhQUFhLENBQUM1VixJQUFkLENBQW1CdVYsVUFBbkIsRUFBK0JBLFVBQVUsQ0FBQ2xCLGFBQVgsQ0FBeUJtQyxJQUF6QixFQUErQmEsS0FBL0IsQ0FBcUMsU0FBckMsRUFBZ0QsR0FBaEQsQ0FBL0IsRUFBcUZSLE1BQXJGLENBekdtQztBQTBHbkM7QUFDRCxLQXJJRCxDQXRDc0IsRUE2S3RCLEtBQUt2QixDQUFMLEdBQVNZLEVBN0thO0FBOEt0QjtBQUVEOzs7OztXQUtBbUMsUyxHQUFBLHFCQUFZO0FBQ0wsUUFBQ3BRLE1BQUQsR0FBVyxJQUFYLENBQUNBLE1BQUQ7QUFBQSxRQUNBcVEsR0FEQSxHQUNNO0FBQUNyb0IsT0FBQyxFQUFFLENBQUo7QUFBT0csT0FBQyxFQUFFO0FBQVYsS0FETjtBQVFOLFdBTEksS0FBS29XLE1BQUwsQ0FBWXNRLFVBS2hCLEtBSkN3QixHQUFHLENBQUNyb0IsQ0FBSixHQUFRZ1ksTUFBTSxDQUFDNE0sWUFBUCxHQUFzQixDQUF0QixHQUEwQjVNLE1BQU0sQ0FBQ29MLFVBSTFDLEVBSENpRixHQUFHLENBQUNsb0IsQ0FBSixHQUFRNlgsTUFBTSxDQUFDNE0sWUFBUCxHQUFzQjVNLE1BQU0sQ0FBQ29MLFVBQTdCLEdBQTBDLENBR25ELEdBQU9pRixHQUFQO0FBQ0E7QUFFRDs7Ozs7O1dBTUFDLFcsR0FBQSxxQkFBWW5hLENBQVosRUFBZTtBQUNSLFFBQUN1VSxLQUFELEdBQVUsS0FBS3dDLE1BQWYsQ0FBQ3hDLEtBQUQ7QUFBQSxRQUNDMUssTUFERCxHQUNXLElBRFgsQ0FDQ0EsTUFERDtBQUFBLG1CQUV5QkEsTUFGekI7QUFBQSxRQUVDd00sYUFGRCxZQUVDQSxhQUZEO0FBQUEsUUFFZ0IxQixLQUZoQixZQUVnQkEsS0FGaEI7QUFBQSxRQUlBeUYsWUFKQSxHQUllN0YsS0FBSyxDQUFDdlUsQ0FBRCxDQUFMLElBQ25CNkosTUFBTSxDQUFDNE0sWUFBUCxHQUFzQixDQUF0QixHQUEwQjVNLE1BQU0sQ0FBQ29MLFVBRGQsQ0FKZjtBQU9OLFdBQU9OLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV3lGLFlBQVgsSUFBMkJBLFlBQVksR0FBR3pGLEtBQUssQ0FBQyxDQUFELENBQS9DLEdBQXFEMEIsYUFBckQsR0FBcUUsQ0FBNUU7QUFDQTtBQUVEOzs7Ozs7O1dBT0F5RCx1QixHQUFBLGlDQUF3QkYsVUFBeEIsRUFBb0NDLFVBQXBDLEVBQWdEO0FBQ3pDLFFBQUFRLE9BQU8sR0FBRyxLQUFLSixTQUFMLEVBQVY7QUFBQSx1QkFDa0QsS0FBS3BRLE1BRHZEO0FBQUEsUUFDQ3dNLGFBREQsZ0JBQ0NBLGFBREQ7QUFBQSxRQUNnQkcsTUFEaEIsZ0JBQ2dCQSxNQURoQjtBQUFBLFFBQ3dCRyxVQUR4QixnQkFDd0JBLFVBRHhCO0FBQUEsUUFDb0MxQixVQURwQyxnQkFDb0NBLFVBRHBDO0FBQUEsUUFFQTBDLE1BRkEsR0FFUyxLQUFLdlAsTUFBTCxDQUFZd1AsY0FGckI7QUFBQSxRQUlBMEMsaUJBSkEsR0FJb0IsVUFBQUMsQ0FBQyxFQUFJO0FBQzlCLFVBQU1sWixLQUFLLEdBQUcsQ0FBQyxPQUFELEVBQVUsS0FBVixDQUFkO0FBSUEsYUFGQW1WLE1BQU0sS0FBSyxLQUFYLElBQW9CblYsS0FBSyxDQUFDbVosT0FBTixFQUVwQixFQUFRRCxDQUFELEdBQWlCQSxDQUFDLEdBQUcsQ0FBSixHQUFRbFosS0FBSyxDQUFDLENBQUQsQ0FBYixHQUFtQkEsS0FBSyxDQUFDLENBQUQsQ0FBekMsR0FBSyxRQUFaO0FBQ0EsS0FWSztBQUFBLFFBV0FvWixhQVhBLEdBV2dCLFVBQUFGLENBQUM7QUFBQSxhQUFLQSxDQUFDLGVBQWFBLENBQWIsU0FBb0IsSUFBMUI7QUFBQSxLQVhqQjtBQUFBLFFBWUFHLFFBWkEsR0FZVyxVQUFBSCxDQUFDLEVBQUk7QUFDckIsVUFBTUksRUFBRSxHQUFHSixDQUFDLElBQUkvRCxNQUFNLEtBQUssUUFBWCxHQUFzQixFQUF0QixHQUEyQixFQUEvQixDQUFaO0FBRUEsYUFBTytELENBQUMsR0FBRyxPQUFPLE1BQU1JLEVBQU4sSUFBWUosQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFSLEdBQVksQ0FBQyxDQUF6QixDQUFWLEdBQXdDNUQsVUFBaEQ7QUFDQSxLQWhCSzs7QUFrQkVILFVBbkJ1QyxLQW9CekMsUUFwQnlDLElBcUI3Q29ELFVBQVUsQ0FDUi9XLElBREYsQ0FDTyxJQURQLEVBQ2F3WCxPQUFPLENBQUN4b0IsQ0FEckIsRUFFRWdSLElBRkYsQ0FFTyxJQUZQLEVBRWF3WCxPQUFPLENBQUN4b0IsQ0FGckIsRUFHRWdSLElBSEYsQ0FHTyxJQUhQLEVBR2EsS0FBS3NYLFdBQUwsQ0FBaUI5QyxJQUFqQixDQUFzQixJQUF0QixDQUhiLENBckI2QyxFQTBCN0N3QyxVQUFVLENBQ1JoWCxJQURGLENBQ08sR0FEUCxFQUNZLENBRFosRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWTZYLFFBQVEsQ0FBQy9DLE1BQUQsQ0FGcEIsRUFHRXNCLEtBSEYsQ0FHUSxhQUhSLEVBR3VCcUIsaUJBQWlCLENBQUMzQyxNQUFELENBSHhDLEVBSUU5VSxJQUpGLENBSU8sV0FKUCxFQUlvQjRYLGFBQWEsQ0FBQzlDLE1BQUQsQ0FKakMsQ0ExQjZDLElBbUJ2Q25CLE1BbkJ1QyxLQWdDekMsS0FoQ3lDLElBaUM3Q29ELFVBQVUsQ0FDUi9XLElBREYsQ0FDTyxJQURQLEVBQ2EsQ0FEYixFQUVFQSxJQUZGLENBRU8sSUFGUCxFQUVhLENBQUN3VCxhQUZkLENBakM2QyxFQXFDN0N3RCxVQUFVLENBQ1JoWCxJQURGLENBQ08sR0FEUCxFQUNZLENBRFosRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWSxDQUFDNlgsUUFBUSxDQUFDL0MsTUFBRCxDQUFULEdBQW9CLENBRmhDLEVBR0VzQixLQUhGLENBR1EsYUFIUixFQUd1QnFCLGlCQUFpQixDQUFDM0MsTUFBRCxDQUh4QyxFQUlFOVUsSUFKRixDQUlPLFdBSlAsRUFJb0I0WCxhQUFhLENBQUM5QyxNQUFELENBSmpDLENBckM2QyxJQW1CdkNuQixNQW5CdUMsS0EyQ3pDLE1BM0N5QyxJQTRDN0NvRCxVQUFVLENBQ1IvVyxJQURGLENBQ08sSUFEUCxFQUNhLENBQUN3VCxhQURkLEVBRUV4VCxJQUZGLENBRU8sSUFGUCxFQUVhd1gsT0FBTyxDQUFDcm9CLENBRnJCLEVBR0U2USxJQUhGLENBR08sSUFIUCxFQUdhd1gsT0FBTyxDQUFDcm9CLENBSHJCLENBNUM2QyxFQWlEN0M2bkIsVUFBVSxDQUNSaFgsSUFERixDQUNPLEdBRFAsRUFDWSxDQUFDOFQsVUFEYixFQUVFOVQsSUFGRixDQUVPLEdBRlAsRUFFWW9TLFVBRlosRUFHRWdFLEtBSEYsQ0FHUSxhQUhSLEVBR3VCLEtBSHZCLENBakQ2QyxJQW1CdkN6QyxNQW5CdUMsS0FzRHpDLE9BdER5QyxJQXVEN0NvRCxVQUFVLENBQ1IvVyxJQURGLENBQ08sSUFEUCxFQUNhd1QsYUFEYixFQUVFeFQsSUFGRixDQUVPLElBRlAsRUFFYSxDQUZiLENBdkQ2QyxFQTJEN0NnWCxVQUFVLENBQ1JoWCxJQURGLENBQ08sR0FEUCxFQUNZOFQsVUFEWixFQUVFOVQsSUFGRixDQUVPLEdBRlAsRUFFWSxDQUZaLEVBR0VvVyxLQUhGLENBR1EsYUFIUixFQUd1QixPQUh2QixDQTNENkM7QUFnRS9DLEcsQ0FFRDtXQUNBN0IsYSxHQUFBLHVCQUFjcFgsQ0FBZCxFQUFpQnVVLEtBQWpCLEVBQXdCZSxLQUF4QixFQUErQmdDLFdBQS9CLEVBQTRDc0QsU0FBNUMsRUFBdUQ7QUF1QnRELGFBQVNwWSxLQUFULENBQWVpWCxRQUFmLEVBQXlCM3FCLElBQXpCLEVBQStCO0FBSzlCLGVBSkkrckIsT0FJSixFQUhJQyxVQUdKLEVBRklDLFNBRUosRUFBU3BZLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc3VCxJQUFJLENBQUNxUixNQUF6QixFQUFpQ3dDLENBQUMsRUFBbEMsRUFRQztBQUNBLFVBUkk3VCxJQUFJLENBQUM4VixNQUFMLENBQVlqQyxDQUFaLE1BQW1CLEdBUXZCLEtBUENtWSxVQUFVLEdBQUduWSxDQU9kLEdBSkFrWSxPQUFPLEdBQUcvckIsSUFBSSxDQUFDa3NCLE1BQUwsQ0FBWSxDQUFaLEVBQWVyWSxDQUFDLEdBQUcsQ0FBbkIsQ0FJVixFQUhBb1ksU0FBUyxHQUFHSCxTQUFTLEdBQUdDLE9BQU8sQ0FBQzFhLE1BR2hDLEVBQUk4YSxTQUFTLEdBQUdGLFNBQWhCLEVBQ0MsT0FBT3ZZLEtBQUssQ0FDWGlYLFFBQVEsQ0FBQ3BVLE1BQVQsQ0FBZ0J2VyxJQUFJLENBQUNrc0IsTUFBTCxDQUFZLENBQVosRUFBZUYsVUFBVSxJQUFJblksQ0FBN0IsQ0FBaEIsQ0FEVyxFQUVYN1QsSUFBSSxDQUFDZ1csS0FBTCxDQUFXZ1csVUFBVSxHQUFHQSxVQUFVLEdBQUcsQ0FBaEIsR0FBb0JuWSxDQUF6QyxDQUZXLENBQVo7O0FBT0YsYUFBTzhXLFFBQVEsQ0FBQ3BVLE1BQVQsQ0FBZ0J2VyxJQUFoQixDQUFQO0FBQ0E7O0FBN0NLLFFBQUNzWixNQUFELEdBQVcsSUFBWCxDQUFDQSxNQUFEO0FBQUEsUUFDQThTLFFBREEsR0FDVyxLQUFLbkUsTUFBTCxDQUFZakIsYUFBWixDQUEwQjlWLENBQTFCLENBRFg7QUFBQSxRQUVBeVosUUFGQSxHQUVXcGEsUUFBUSxDQUFDNmIsUUFBRCxDQUFSLElBQXNCQSxRQUFRLENBQUM5WSxPQUFULENBQWlCLElBQWpCLElBQXlCLENBQUMsQ0FBaEQsR0FDaEI4WSxRQUFRLENBQUMxWSxLQUFULENBQWUsSUFBZixDQURnQixHQUNPLEVBSGxCO0FBS04sUUFBSWlYLFFBQVEsQ0FBQ3RaLE1BQWIsRUFDQyxPQUFPc1osUUFBUDtBQUdELFFBQUloWixPQUFPLENBQUN5YSxRQUFELENBQVgsRUFDQyxPQUFPQSxRQUFQO0FBR0QsUUFBSUQsU0FBUyxHQUFHN1MsTUFBTSxDQUFDNlMsU0FBdkI7QUFrQ0EsWUFoQ0ksQ0FBQ0EsU0FBRCxJQUFjQSxTQUFTLElBQUksQ0FnQy9CLE1BL0JDQSxTQUFTLEdBQUczRCxXQUFXLEdBQUcsRUFBSCxHQUN0QmxQLE1BQU0sQ0FBQ3NRLFVBQVAsR0FDRS9ZLElBQUksQ0FBQ0MsSUFBTCxDQUFVMlUsS0FBSyxDQUFDZSxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQUwsR0FBa0JmLEtBQUssQ0FBQ2UsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFqQyxJQUErQyxFQURqRCxHQUN1RCxHQTZCekQsR0FBTzlTLEtBQUssQ0FBQ2lYLFFBQUQsRUFBa0J5QixRQUFsQixNQUFaO0FBQ0EsRyxTQUVEM0csSyxHQUFBLGVBQU0xaUIsQ0FBTixFQUFTO0FBQUEsV0FDSHNwQixTQUFTLENBQUNoYixNQURQLElBS1IsS0FBSzRXLE1BQUwsQ0FBWXhDLEtBQVosR0FBb0IxaUIsQ0FMWixFQU9ELElBUEMsSUFFQSxLQUFLa2xCLE1BQUwsQ0FBWXhDLEtBRlo7QUFRUixHLFNBRURpQyxNLEdBQUEsZ0JBQU8za0IsQ0FBUCxFQUFVO0FBQUEsV0FDSnNwQixTQUFTLENBQUNoYixNQUROLElBS1QsS0FBSzBKLE1BQUwsQ0FBWTJNLE1BQVosR0FBcUIza0IsQ0FBQyxJQUFJO0FBQ3pCbkIsU0FBRyxFQUFFLENBRG9CO0FBRXpCRyxXQUFLLEVBQUUsQ0FGa0I7QUFHekJGLFlBQU0sRUFBRSxDQUhpQjtBQUl6QkMsVUFBSSxFQUFFO0FBSm1CLEtBQUwsR0FLVmlCLENBTFUsUUFLTCxRQVZQLEVBWUYsSUFaRSxJQUVELEtBQUtnWSxNQUFMLENBQVkyTSxNQUZYO0FBYVQsRyxTQUVEVCxVLEdBQUEsb0JBQVdqTSxNQUFYLEVBQW1CO0FBQUEsUUFDWEQsTUFEVyxHQUNELElBREMsQ0FDWEEsTUFEVztBQUFBLFdBR2JzUixTQUFTLENBQUNoYixNQUhHLElBT2xCMEosTUFBTSxDQUFDa00sVUFBUCxHQUFvQmpNLE1BUEYsRUFTWCxJQVRXLElBSVZELE1BQU0sQ0FBQ2tNLFVBSkc7QUFVbEIsRyxTQUVEVSxZLEdBQUEsc0JBQWEyRSxVQUFiLEVBQXlCO0FBQUEsUUFDakJ2UixNQURpQixHQUNQLElBRE8sQ0FDakJBLE1BRGlCO0FBQUEsV0FHbkJzUixTQUFTLENBQUNoYixNQUhTLElBT3hCMEosTUFBTSxDQUFDNE0sWUFBUCxHQUFzQjJFLFVBUEUsRUFTakIsSUFUaUIsSUFJaEJ2UixNQUFNLENBQUM0TSxZQUpTO0FBVXhCO0FBRUQ7Ozs7OztXQU1BeEIsVSxHQUFBLHNCQUFhO0FBQ1osV0FBTyxLQUFLcEwsTUFBTCxDQUFZb0wsVUFBbkI7QUFDQTtBQUVEOzs7Ozs7V0FNQW9HLFksR0FBQSxzQkFBYXZwQixJQUFiLEVBQW1CO0FBQ2xCLFFBQUl5akIsUUFBSjtBQUVBLFFBQUksS0FBS25OLE1BQUwsQ0FBWXNRLFVBQWhCLEVBQ0NuRCxRQUFRLEdBQUcsS0FBSzFMLE1BQUwsQ0FBWW9MLFVBQVosR0FBeUIsQ0FEckMsTUFFTztBQUNOLFVBQU05VSxNQUFNLEdBQUcsS0FBSytXLENBQUwsQ0FBT3RULE1BQVAsQ0FBYyxhQUFkLEVBQ2IzQixJQURhLEdBRWJxWixjQUZhLEtBRU0sS0FBS3pSLE1BQUwsQ0FBWXlNLGFBQVosR0FBNEIsQ0FGakQ7QUFJQWYsY0FBUSxHQUFHcFYsTUFBTSxJQUFJck8sSUFBSSxJQUFJLEtBQUtvbEIsQ0FBTCxDQUFPeUIsU0FBUCxDQUFpQixNQUFqQixFQUF5QjdtQixJQUF6QixFQUFaLENBTFg7QUFNTjtBQUVELFdBQU95akIsUUFBUSxLQUFLZ0csUUFBYixHQUF3QixDQUF4QixHQUE0QmhHLFFBQW5DO0FBQ0EsRyxTQUVERCxLLEdBQUEsaUJBQWU7QUFBQSxTQUNSLElBQUN6TCxNQUFELEdBQVcsSUFBWCxDQUFDQSxNQUFELDJCQURFbEksSUFDRix3QkFEUSx1QkFBTkEsSUFBTTs7QUFBQSxXQUdUQSxJQUFJLENBQUN4QixNQUhJLElBT2QwSixNQUFNLENBQUMyTCxhQUFQLEdBQXVCelEsT0FBTyxDQUFDcEQsSUFBRCxDQVBoQixFQVNQLElBVE8sSUFJTmtJLE1BQU0sQ0FBQzJMLGFBSkQ7QUFVZCxHLFNBRURrQixXLEdBQUEscUJBQVk4RSxPQUFaLEVBQXFCO0FBQUEsUUFDYjNSLE1BRGEsR0FDSCxJQURHLENBQ2JBLE1BRGE7QUFBQSxXQUdmc1IsU0FBUyxDQUFDaGIsTUFISyxJQU9wQjBKLE1BQU0sQ0FBQzZNLFdBQVAsR0FBcUI4RSxPQVBELEVBU2IsSUFUYSxJQUlaM1IsTUFBTSxDQUFDNk0sV0FKSztBQVVwQixHLFNBRURHLFUsR0FBQSxvQkFBV2hsQixDQUFYLEVBQWM7QUFBQTtBQUFBLFFBQ05nWSxNQURNLEdBQ0ksSUFESixDQUNOQSxNQURNOztBQUdiLFFBQUl6SyxVQUFVLENBQUN2TixDQUFELENBQWQsRUFDQ2dZLE1BQU0sQ0FBQ2dOLFVBQVAsR0FBb0I7QUFBQSxhQUFNaGxCLENBQUMsQ0FBQyxLQUFJLENBQUNrbEIsTUFBTCxDQUFZeEMsS0FBWixDQUFrQnhpQixNQUFsQixFQUFELENBQVA7QUFBQSxLQURyQixNQUVPO0FBQ04sVUFBSSxDQUFDb3BCLFNBQVMsQ0FBQ2hiLE1BQWYsRUFDQyxPQUFPMEosTUFBTSxDQUFDZ04sVUFBZDtBQUdEaE4sWUFBTSxDQUFDZ04sVUFBUCxHQUFvQmhsQixDQUxkO0FBTU47QUFFRCxXQUFPLElBQVA7QUFDQSxHLFNBRUQ0cEIsYSxHQUFBLHVCQUFjQyxDQUFkLEVBQWlCO0FBR2hCLFdBRkEsS0FBSzdSLE1BQUwsQ0FBWXNNLFVBQVosR0FBeUJ1RixDQUV6QixFQUFPLElBQVA7QUFDQSxHOzs7Ozs7O0FDMWZGOzs7O0FBSUE7QUFNQTtBQUNBO0FBQ0E7O0lBR3FCQyxTOzs7QUFjcEIsZ0JBQVlySCxLQUFaLEVBQW1CO0FBQUEsOEVBWkEsRUFZQSxpQ0FYTDtBQUNiemlCLE9BQUMsRUFBRSxJQURVO0FBQ0pHLE9BQUMsRUFBRSxJQURDO0FBQ0tDLFFBQUUsRUFBRTtBQURULEtBV0ssK0JBUlAsRUFRTyxtQ0FQRjtBQUNoQkosT0FBQyxFQUFFLFFBRGE7QUFFaEJHLE9BQUMsRUFBRSxNQUZhO0FBR2hCQyxRQUFFLEVBQUUsT0FIWTtBQUloQjJwQixVQUFJLEVBQUU7QUFKVSxLQU9FLEdBQ2xCLEtBQUt0SCxLQUFMLEdBQWFBLEtBREssRUFFbEIsS0FBS3VILFNBQUwsRUFGa0I7QUFHbEI7OztnQkFFT0MsZ0IsR0FBUiwwQkFBeUJ2cEIsRUFBekIsRUFBNkI7QUFDNUIsV0FBVXNSLGNBQUssQ0FBQ25aLElBQWhCLFNBQXdCbVosY0FBSyxVQUFRYyxVQUFVLENBQUNwUyxFQUFELENBQWxCLENBQTdCO0FBQ0EsRyxTQUVPd3BCLFksR0FBUixzQkFBcUI3SCxFQUFyQixFQUF5QjhILGFBQXpCLEVBQXdDO0FBQ3ZDLFFBQU1DLFNBQVMsR0FBRy9ILEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWMsWUFBNUI7QUFFQSxXQUFPcVIsYUFBYSxHQUFHQyxTQUFILEdBQWUsQ0FBQ0EsU0FBcEM7QUFDQSxHLFNBRURDLEksR0FBQSxnQkFBTztBQUFBO0FBQUEsUUFDQWhJLEVBREEsR0FDSyxLQUFLSSxLQURWO0FBQUEsUUFFQ3pLLE1BRkQsR0FFNkNxSyxFQUY3QyxDQUVDckssTUFGRDtBQUFBLGtCQUU2Q3FLLEVBRjdDLENBRVM1USxHQUZUO0FBQUEsUUFFZUcsSUFGZixXQUVlQSxJQUZmO0FBQUEsUUFFcUIvWSxJQUZyQixXQUVxQkEsSUFGckI7QUFBQSxRQUVvQzRILElBRnBDLEdBRTZDNGhCLEVBRjdDLENBRTRCOWpCLEtBRjVCLENBRW9Da0MsSUFGcEM7QUFBQSxRQUdBMnBCLFNBSEEsR0FHWXBTLE1BQU0sQ0FBQ2MsWUFIbkI7QUFBQSxRQUlBOWIsTUFKQSxHQUlTLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FKVDs7QUFNTmdiLFVBQU0sQ0FBQzFNLFlBQVAsSUFBdUJ0TyxNQUFNLENBQUMwWSxJQUFQLENBQVksSUFBWixDQU5qQixFQVFOMVksTUFBTSxDQUFDMFMsT0FBUCxDQUFlLFVBQUFwQyxDQUFDLEVBQUk7QUFBQSxVQUNiZ2QsU0FBUyxHQUFHLEtBQUksQ0FBQ0wsZ0JBQUwsQ0FBc0IzYyxDQUF0QixDQURDO0FBQUEsVUFFYmlkLE1BQU0sR0FBR2pkLENBQUMsQ0FBQzBGLFdBQUYsRUFGSTtBQUFBLFVBR2J3WCxVQUFVLEdBQUd4WSxjQUFLLFVBQVF1WSxNQUFSLFdBSEw7O0FBS25CMXhCLFVBQUksQ0FBQ3lVLENBQUQsQ0FBSixHQUFVc0UsSUFBSSxDQUFDYixNQUFMLENBQVksR0FBWixFQUNSQyxJQURRLENBQ0gsT0FERyxFQUNNc1osU0FETixFQUVSdFosSUFGUSxDQUVILFdBRkcsRUFFVSxZQUFNO0FBQ3hCLFlBQUlzRSxHQUFHLEdBQUcsSUFBVjtBQVFBLGVBTkloSSxDQUFDLEtBQUssR0FNVixHQUxDZ0ksR0FBRyxHQUFHN1UsSUFBSSxDQUFDTyxTQUtaLEdBSldzTSxDQUFDLEtBQUssR0FBTixJQUFhMEssTUFBTSxDQUFDM04sWUFJL0IsS0FIQ2lMLEdBQUcsR0FBRzdVLElBQUksQ0FBQ1EsU0FHWixHQUFPcVUsR0FBUDtBQUNBLE9BWlEsRUFhUnRFLElBYlEsQ0FhSCxXQWJHLEVBYVVxUixFQUFFLENBQUNvSSxZQUFILENBQWdCbmQsQ0FBaEIsQ0FiVixFQWNSOFosS0FkUSxDQWNGLFlBZEUsRUFjWXBQLE1BQU0sV0FBUzFLLENBQVQsV0FBTixHQUEyQixTQUEzQixHQUF1QyxRQWRuRCxDQUxTLEVBcUJuQnpVLElBQUksQ0FBQ3lVLENBQUQsQ0FBSixDQUFReUQsTUFBUixDQUFlLE1BQWYsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0J3WixVQURoQixFQUVFeFosSUFGRixDQUVPLFdBRlAsRUFFb0IsQ0FBQyxhQUFELEVBQWdCLElBQWhCLEVBQ2xCMUQsQ0FBQyxLQUFLLEdBQU4sR0FBWSxDQUFDLENBQUM4YyxTQUFkLEdBQTBCLENBQUNBLFNBRFQsQ0FGcEIsRUFLRWhELEtBTEYsQ0FLUSxhQUxSLEVBS3VCLEtBQUksbUJBQWlCbUQsTUFBakIsZUFBSixDQUF3Qy9FLElBQXhDLENBQTZDLEtBQTdDLENBTHZCLENBckJtQixFQTRCbkIsS0FBSSxDQUFDa0YsWUFBTCxDQUFrQnBkLENBQWxCLENBNUJtQjtBQTZCbkIsS0E3QkQsQ0FSTTtBQXNDTjtBQUVEOzs7O1dBSUEwYyxTLEdBQUEscUJBQVk7QUFDTCxRQUFBM0gsRUFBRSxHQUFHLEtBQUtJLEtBQVY7QUFBQSxxQkFLRkosRUFBRSxDQUFDckssTUFMRDtBQUFBLFFBRVNvUyxTQUZULGNBRUx0UixZQUZLO0FBQUEsUUFHUzZSLE1BSFQsY0FHTHRnQixZQUhLO0FBQUEsUUFJVXVnQixPQUpWLGNBSUxqZixhQUpLO0FBT04sU0FBS2daLE1BQUwsR0FBYztBQUNiM2tCLE9BQUMsRUFBRW9xQixTQUFTLEdBQUcsTUFBSCxHQUFZLFFBRFg7QUFFYmpxQixPQUFDLEVBQUVpcUIsU0FBUyxHQUFJTyxNQUFNLEdBQUcsS0FBSCxHQUFXLFFBQXJCLEdBQWtDQSxNQUFNLEdBQUcsT0FBSCxHQUFhLE1BRnBEO0FBR2J2cUIsUUFBRSxFQUFFZ3FCLFNBQVMsR0FBSVEsT0FBTyxHQUFHLFFBQUgsR0FBYyxLQUF6QixHQUFtQ0EsT0FBTyxHQUFHLE1BQUgsR0FBWSxPQUh0RDtBQUliYixVQUFJLEVBQUVLLFNBQVMsR0FBRyxNQUFILEdBQVk7QUFKZCxLQVJIO0FBY1g7QUFFRDs7Ozs7O1dBTUFNLFksR0FBQSxzQkFBYWhxQixFQUFiLEVBQXlCO0FBTXBCLFFBQUFtcUIsTUFBTTtBQUFBLFFBTEp4SSxFQUtJLEdBTEMsS0FBS0ksS0FLTjtBQUFBLFFBSkh6SyxNQUlHLEdBSk9xSyxFQUlQLENBSkhySyxNQUlHO0FBQUEsUUFISjhTLElBR0ksR0FIVSxFQUdWO0FBQUEsUUFGSkMsVUFFSSxHQUZTL1MsTUFBTSxXQUFTdFgsRUFBVCxXQUVmO0FBQUEsUUFESjBwQixTQUNJLEdBRFFwUyxNQUFNLENBQUNjLFlBQ2Y7QUFFTnBZLE1BQUUsS0FBSyxHQVJhLEdBU3ZCbXFCLE1BQU0sR0FBR1QsU0FBUyxHQUFHWSw0RUFBSCxHQUFnQkMsOEVBVFgsR0FVYnZxQixFQUFFLEtBQUssR0FWTSxHQVd2Qm1xQixNQUFNLEdBQUdULFNBQVMsR0FBR2EsOEVBQUgsR0FBa0JELDRFQVhiLEdBWWJ0cUIsRUFBRSxLQUFLLElBWk0sS0FhdkJtcUIsTUFBTSxHQUFHVCxTQUFTLEdBQUdjLDJFQUFILEdBQWVDLDZFQWJWLEdBZ0JwQkosVUFBVSxDQUFDemMsTUFoQlMsSUFpQnZCeWMsVUFBVSxDQUFDcmIsT0FBWCxDQUFtQixVQUFBcEMsQ0FBQyxFQUFJO0FBQUEsVUFDakJpWixJQUFJLEdBQUdqWixDQUFDLENBQUNpWixJQUFGLElBQVUsRUFEQTtBQUFBLFVBRWpCN0QsS0FBSyxHQUFHTCxFQUFFLENBQUNLLEtBQUgsQ0FBU2hpQixFQUFULEVBQWFzakIsSUFBYixFQUZTO0FBSXZCMVcsT0FBQyxDQUFDcE4sTUFBRixJQUFZd2lCLEtBQUssQ0FBQ3hpQixNQUFOLENBQWFvTixDQUFDLENBQUNwTixNQUFmLENBSlcsRUFNdkI0cUIsSUFBSSxDQUFDcFYsSUFBTCxDQUNDbVYsTUFBTSxDQUFDbkksS0FBRCxDQUFOLENBQ0VlLEtBREYsQ0FDUThDLElBQUksQ0FBQzZFLEtBRGIsRUFFRWxILFVBRkYsQ0FFYTNXLFVBQVUsQ0FBQ2daLElBQUksQ0FBQ3RPLE1BQU4sQ0FBVixHQUEwQnNPLElBQUksQ0FBQ3RPLE1BQUwsQ0FBWXVOLElBQVosQ0FBaUJuRCxFQUFFLENBQUNnSixHQUFwQixDQUExQixHQUFzRCxVQUFDcnJCLENBQUQ7QUFBQSxlQUFZQSxDQUFaO0FBQUEsT0FGbkUsRUFHRWdsQixVQUhGLENBR2F1QixJQUFJLENBQUNoRSxNQUhsQixFQUlFK0ksYUFKRixDQUlnQi9FLElBQUksQ0FBQ2dGLEtBQUwsVUFBdUIsQ0FBdkIsR0FBMkIsQ0FKM0MsQ0FERCxDQU51QjtBQWF2QixLQWJELENBakJ1QixFQWlDeEIsS0FBS0MsUUFBTCxDQUFjOXFCLEVBQWQsSUFBb0JvcUIsSUFqQ0k7QUFrQ3hCO0FBRUQ7Ozs7V0FJQVcsVSxHQUFBLHNCQUFhO0FBQUE7QUFBQSxRQUNOcEosRUFETSxHQUNELEtBQUtJLEtBREo7QUFBQSxRQUVMekssTUFGSyxHQUVrQnFLLEVBRmxCLENBRUxySyxNQUZLO0FBQUEsUUFFU3BHLElBRlQsR0FFa0J5USxFQUZsQixDQUVHNVEsR0FGSCxDQUVTRyxJQUZUOztBQUlacEQsVUFBTSxDQUFDQyxJQUFQLENBQVksS0FBSytjLFFBQWpCLEVBQTJCOWIsT0FBM0IsQ0FBbUMsVUFBQWhQLEVBQUUsRUFBSTtBQUFBLFVBQ2xDcXFCLFVBQVUsR0FBRy9TLE1BQU0sV0FBU3RYLEVBQVQsV0FEZTtBQUFBLFVBRWxDZ2lCLEtBQUssR0FBR0wsRUFBRSxDQUFDSyxLQUFILENBQVNoaUIsRUFBVCxFQUFhc2pCLElBQWIsRUFGMEI7QUFBQSxVQUdsQ2xCLEtBQUssR0FBR0osS0FBSyxDQUFDSSxLQUFOLEVBSDBCOztBQUt4QyxZQUFJLENBQUMwSSxRQUFMLENBQWM5cUIsRUFBZCxFQUFrQmdQLE9BQWxCLENBQTBCLFVBQUNwQyxDQUFELEVBQUl3RCxDQUFKLEVBQVU7QUFDbkMsWUFBTTRhLFNBQVMsR0FBR3BlLENBQUMsQ0FBQ29WLEtBQUYsR0FBVUksS0FBVixFQUFsQixDQURtQyxDQUduQztBQUNBOztBQUNLQSxhQUFLLENBQUMzTixLQUFOLENBQVksVUFBQzdILENBQUQsRUFBSXdELENBQUo7QUFBQSxpQkFBVXhELENBQUMsS0FBS29lLFNBQVMsQ0FBQzVhLENBQUQsQ0FBekI7QUFBQSxTQUFaLENBTDhCLElBTWxDeEQsQ0FBQyxDQUFDb1YsS0FBRixHQUFVSSxLQUFWLENBQWdCQSxLQUFoQixDQU5rQztBQUFBLFlBUzdCNkksU0FBUyxHQUFNLE1BQUksQ0FBQzFCLGdCQUFMLENBQXNCdnBCLEVBQXRCLENBQU4sVUFBbUNvUSxDQUFDLEdBQUcsQ0FBdkMsQ0FUb0I7QUFBQSxZQVUvQnVVLENBQUMsR0FBR3pULElBQUksQ0FBQ0csTUFBTCxPQUFnQjRaLFNBQVMsQ0FBQ3piLE9BQVYsQ0FBa0IsSUFBbEIsRUFBd0IsR0FBeEIsQ0FBaEIsQ0FWMkI7QUFZL0JtVixTQUFDLENBQUNwcUIsS0FBRixFQVorQixHQWFsQ29xQixDQUFDLEdBQUd6VCxJQUFJLENBQUNiLE1BQUwsQ0FBWSxHQUFaLEVBQ0ZDLElBREUsQ0FDRyxPQURILEVBQ1kyYSxTQURaLEVBRUZ2RSxLQUZFLENBRUksWUFGSixFQUVrQnBQLE1BQU0sV0FBU3RYLEVBQVQsV0FBTixHQUE0QixTQUE1QixHQUF3QyxRQUYxRCxFQUdGcVAsSUFIRSxDQUdHekMsQ0FISCxDQWI4QixJQWtCbEN5ZCxVQUFVLENBQUNqYSxDQUFELENBQVYsQ0FBYzVRLE1BQWQsSUFBd0J3aUIsS0FBSyxDQUFDeGlCLE1BQU4sQ0FBYTZxQixVQUFVLENBQUNqYSxDQUFELENBQVYsQ0FBYzVRLE1BQTNCLENBbEJVLEVBb0JsQ21pQixFQUFFLENBQUN4cEIsSUFBSCxDQUFRbUgsQ0FBUixDQUFVa2xCLE1BQVYsQ0FBaUJkLGFBQWpCLENBQStCaUIsQ0FBL0IsRUFDRXRWLElBREYsQ0FDT3pDLENBQUMsQ0FBQ29WLEtBQUYsQ0FBUUEsS0FBUixDQURQLENBcEJrQyxHQXdCbkMyQyxDQUFDLENBQUNyVSxJQUFGLENBQU8sV0FBUCxFQUFvQnFSLEVBQUUsQ0FBQ29JLFlBQUgsQ0FBZ0IvcEIsRUFBaEIsRUFBb0JvUSxDQUFDLEdBQUcsQ0FBeEIsQ0FBcEIsQ0F4Qm1DO0FBeUJuQyxPQXpCRCxDQUx3QztBQStCeEMsS0EvQkQsQ0FKWTtBQW9DWixHLENBRUQ7V0FDQThhLE8sR0FBQSxpQkFBUTFGLElBQVIsRUFBY3hELEtBQWQsRUFBcUJnQyxTQUFyQixFQUFnQzlCLFlBQWhDLEVBQThDaUosZ0JBQTlDLEVBQThFO0FBU3pFLFFBQUEzSCxVQUFVO0FBQUEsUUFSUjdCLEVBUVEsR0FSSCxLQUFLSSxLQVFGO0FBQUEsUUFQUHpLLE1BT08sR0FQR3FLLEVBT0gsQ0FQUHJLLE1BT087QUFBQSxRQU5SOFQsR0FNUSxHQU5GLGFBQWFqWixJQUFiLENBQWtCcVQsSUFBbEIsQ0FNRTtBQUFBLFFBTFJwVSxJQUtRLEdBTERnYSxHQUFHLEdBQUcsR0FBSCxHQUFTNUYsSUFLWDtBQUFBLFFBSFJXLFVBR1EsR0FIS2lGLEdBQUcsSUFBSXpKLEVBQUUsQ0FBQzBKLGFBQUgsRUFHWjtBQUFBLFFBRlJwSCxNQUVRLEdBRkMsS0FBS0EsTUFBTCxDQUFZdUIsSUFBWixDQUVEO0FBRWQsUUFBSTRGLEdBQUosRUFDQzVILFVBQVUsR0FBRzdCLEVBQUUsQ0FBQ3BLLE1BQUgsQ0FBVStULFNBRHhCLE1BRU87QUFDTixVQUFNcGMsRUFBRSxHQUFHb0ksTUFBTSxXQUFTa08sSUFBVCxrQkFBakI7QUFFSTNZLGdCQUFVLENBQUNxQyxFQUFELENBSFIsS0FJTHNVLFVBQVUsR0FBR3RVLEVBQUUsQ0FBQzRWLElBQUgsQ0FBUW5ELEVBQUUsQ0FBQ2dKLEdBQVgsQ0FKUjtBQU1OO0FBbkI0RSxRQXFCekVyRyxVQUFVLEdBQUczQyxFQUFFLENBQUN4cEIsSUFBSCxDQUFRMHRCLElBQVIsQ0FBYXpVLElBQWIsQ0FyQjREO0FBQUEsUUF1QnZFbWEsVUFBVSxHQUFHblgsUUFBUSxDQUFDO0FBQzNCNFAsZUFBUyxFQUFUQSxTQUQyQjtBQUUzQjlCLGtCQUFZLEVBQVpBLFlBRjJCO0FBRzNCNUssWUFBTSxFQUFOQSxNQUgyQjtBQUkzQmtPLFVBQUksRUFBSkEsSUFKMkI7QUFLM0JILG9CQUFjLEVBQUU4RixnQkFBZ0IsR0FBRyxDQUFILEdBQU83VCxNQUFNLFdBQVNsRyxJQUFUO0FBTGxCLEtBQUQsRUFNeEJnYSxHQUFHLElBQUk7QUFDVGpGLGdCQUFVLEVBQVZBLFVBRFM7QUFFVGMsbUJBQWEsRUFBRTNQLE1BQU0sQ0FBQzVPLHFCQUZiO0FBR1RnZ0IsZUFBUyxFQUFFcFIsTUFBTSxDQUFDM08saUJBSFQ7QUFJVDZlLGVBQVMsRUFBRXJCLFVBQVUsSUFBSTdPLE1BQU0sQ0FBQzFPLG1CQUFyQixJQUE0QytZLEVBQUUsQ0FBQ2dKLEdBQUgsQ0FBT2EsVUFBUCxFQUo5QztBQUtUbEosZUFBUyxFQUFFWCxFQUFFLENBQUNLLEtBQUgsQ0FBUzFpQjtBQUxYLEtBTmlCLENBdkJrRDtBQXFDeEU4ckIsT0FyQ3dFLEtBc0M1RUcsVUFBVSxDQUFDekksWUFBWCxHQUEwQnhMLE1BQU0sV0FBU2xHLElBQVQsb0JBdEM0QztBQXlDN0UsUUFBTWpaLElBQUksR0FBRyxJQUFJMHJCLHlCQUFKLENBQWlCMEgsVUFBakIsRUFDWHZKLEtBRFcsQ0FDSm9KLEdBQUcsSUFBSXpKLEVBQUUsQ0FBQ0ssS0FBSCxDQUFTekMsSUFBakIsSUFBMEJ5QyxLQURyQixFQUVYaUMsTUFGVyxDQUVKQSxNQUZJLENBQWI7O0FBSUEsUUFBSW1ILEdBQUcsSUFBSXpKLEVBQUUsQ0FBQzhKLFlBQUgsRUFBUCxJQUE0Qm5ILFVBQTVCLElBQTBDLENBQUN6WCxVQUFVLENBQUN5WCxVQUFELENBQXpELEVBQXVFO0FBQ3RFLFVBQU1wVixHQUFFLEdBQUdpSSxTQUFTLENBQUMyTixJQUFWLENBQWVuRCxFQUFmLENBQVg7O0FBRUEyQyxnQkFBVSxHQUFHQSxVQUFVLENBQUN2VSxHQUFYLENBQWUsVUFBQW5ELENBQUM7QUFBQSxlQUFJc0MsR0FBRSxDQUFDdEMsQ0FBRCxDQUFOO0FBQUEsT0FBaEIsQ0FIeUQ7QUFJdEUsS0FKRCxNQUlXLENBQUN3ZSxHQUFELElBQVF6SixFQUFFLENBQUMrSixhQUFILEVBSm5CLE1BS0M7QUFDQXZ6QixRQUFJLENBQUM0cUIsS0FBTCxDQUFXekwsTUFBTSxDQUFDOU0sc0JBQWxCLENBTkQsRUFPQzhaLFVBQVUsR0FBRyxJQVBkOztBQTZCQSxXQW5CQUEsVUFBVSxJQUFJbnNCLElBQUksQ0FBQ21zQixVQUFMLENBQWdCQSxVQUFoQixDQW1CZCxFQWhCQW5zQixJQUFJLENBQUNxckIsVUFBTCxDQUNDQSxVQUFVLElBQ1QsQ0FBQzRILEdBQUQsSUFBU3pKLEVBQUUsQ0FBQ2dLLGlCQUFILE1BQTJCLFVBQUFyc0IsQ0FBQztBQUFBLGFBQU9BLENBQVA7QUFBQSxLQUZ2QyxDQWdCQSxFQVZJNm1CLFVBVUosS0FUQ2h1QixJQUFJLENBQUMrckIsWUFBTCxDQUFrQjVNLE1BQU0sQ0FBQ3hQLG9CQUF6QixDQVNELEVBUEs2RixPQUFPLENBQUMySixNQUFNLENBQUN0UCxtQkFBUixDQU9aLEtBTkVzUCxNQUFNLENBQUN0UCxtQkFBUCxLQU1GLElBRkFzUCxNQUFNLFdBQVNsRyxJQUFULGlCQUFOLElBQXFDalosSUFBSSxDQUFDNHFCLEtBQUwsQ0FBV3pMLE1BQU0sV0FBU2xHLElBQVQsaUJBQWpCLENBRXJDLEVBQU9qWixJQUFQO0FBQ0EsRyxTQUVEeXpCLHFCLEdBQUEsK0JBQXNCcEssT0FBdEIsRUFBK0JycEIsSUFBL0IsRUFBZ0Q7QUFLM0MsUUFBQTBwQixNQUFNO0FBQUEsUUFKSkYsRUFJSSxHQUpDLEtBQUtJLEtBSU47QUFBQSxRQUhIekssTUFHRyxHQUhPcUssRUFHUCxDQUhIckssTUFHRztBQUFBLFFBRkp1VSxHQUVJLEdBRkV2VSxNQUFNLENBQUNoUCxlQUVUO0FBQUEsUUFESm9pQixLQUNJLEdBRElwVCxNQUFNLENBQUNwUCxpQkFDWDtBQWlCVixZQWZJMmpCLEdBQUcsSUFBS25CLEtBQUssSUFBSW1CLEdBZXJCLE1BZENoSyxNQUFNLEdBQUcsS0FBS2lLLGtCQUFMLENBQ1JuSyxFQUFFLENBQUNvSyxvQkFBSCxDQUF3QnZLLE9BQXhCLENBRFEsRUFFUmtKLEtBRlEsRUFHUi9JLEVBQUUsQ0FBQzhKLFlBQUgsRUFIUSxDQWNWLEdBUEl0ekIsSUFPSixHQU5DQSxJQUFJLENBQUNtc0IsVUFBTCxDQUFnQnpDLE1BQWhCLENBTUQsR0FMV0YsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBS25CLEtBSkNxaUIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBQVIsQ0FBVWdsQixVQUFWLENBQXFCekMsTUFBckIsQ0FJRCxFQUhDRixFQUFFLENBQUN4cEIsSUFBSCxDQUFRa3hCLElBQVIsSUFBZ0IxSCxFQUFFLENBQUN4cEIsSUFBSCxDQUFRa3hCLElBQVIsQ0FBYS9FLFVBQWIsQ0FBd0J6QyxNQUF4QixDQUdqQixHQUFPQSxNQUFQO0FBQ0EsRyxTQUVEbUssSyxHQUFBLGVBQU1oc0IsRUFBTixFQUFVO0FBQUEsc0JBQ2UsS0FBSytoQixLQURwQjtBQUFBLFFBQ0Z6SyxNQURFLGVBQ0ZBLE1BREU7QUFBQSxRQUNNMEssS0FETixlQUNNQSxLQUROO0FBQUEsUUFFTDdwQixJQUZLLEdBRUVtZixNQUFNLENBQUMxUSxTQUFQLENBQWlCNUcsRUFBakIsQ0FGRjtBQVNULFdBSks3SCxJQUFELElBQVU2cEIsS0FBSyxDQUFDN3BCLElBQUQsQ0FJbkIsS0FIQ0EsSUFBSSxHQUFHLEdBR1IsR0FBT0EsSUFBUDtBQUNBLEcsU0FFRDh6QixrQixHQUFBLDhCQUFxQjtBQU1oQixRQUFBQyxVQUFVO0FBQUEsUUFMUnZLLEVBS1EsR0FMSCxLQUFLSSxLQUtGO0FBQUEsUUFKUHpLLE1BSU8sR0FKV3FLLEVBSVgsQ0FKUHJLLE1BSU87QUFBQSxRQUpDQyxNQUlELEdBSldvSyxFQUlYLENBSkNwSyxNQUlEO0FBQUEsUUFIUmlNLFVBR1EsR0FIS2xNLE1BQU0sQ0FBQ3ZQLGtCQUdaO0FBQUEsUUFGUjBqQixZQUVRLEdBRk85SixFQUFFLENBQUM4SixZQUFILEVBRVA7QUFBQSxRQURSSixhQUNRLEdBRFExSixFQUFFLENBQUMwSixhQUFILEVBQ1I7QUFlZCxXQWJJN0gsVUFhSixHQVpLM1csVUFBVSxDQUFDMlcsVUFBRCxDQVlmLEdBWEUwSSxVQUFVLEdBQUcxSSxVQUFVLENBQUNzQixJQUFYLENBQWdCbkQsRUFBRSxDQUFDZ0osR0FBbkIsQ0FXZixHQVZZYyxZQVVaLEtBVEVTLFVBQVUsR0FBRyxVQUFBOVUsSUFBSTtBQUFBLGFBQUtBLElBQUksR0FBR0csTUFBTSxDQUFDNFUsUUFBUCxDQUFnQjNJLFVBQWhCLEVBQTRCcE0sSUFBNUIsQ0FBSCxHQUF1QyxFQUFoRDtBQUFBLEtBU25CLElBTkM4VSxVQUFVLEdBQUdULFlBQVksR0FBR2xVLE1BQU0sQ0FBQzZVLGVBQVYsR0FDeEJmLGFBQWEsR0FDWjFKLEVBQUUsQ0FBQzBLLFlBRFMsR0FDTSxVQUFBemYsQ0FBQztBQUFBLGFBQUtBLENBQUMsR0FBRyxDQUFKLEdBQVFBLENBQUMsQ0FBQzRSLE9BQUYsQ0FBVSxDQUFWLENBQVIsR0FBdUI1UixDQUE1QjtBQUFBLEtBSXRCLEVBQU9DLFVBQVUsQ0FBQ3FmLFVBQUQsQ0FBVixHQUF5QixVQUFBdGYsQ0FBQztBQUFBLGFBQ2hDc2YsVUFBVSxDQUFDSSxLQUFYLENBQWlCM0ssRUFBakIsRUFBcUIwSixhQUFhLEdBQ2pDLENBQUN6ZSxDQUFELEVBQUkrVSxFQUFFLENBQUMwSyxZQUFILENBQWdCemYsQ0FBaEIsQ0FBSixDQURpQyxHQUNQLENBQUNBLENBQUQsQ0FEM0IsQ0FEZ0M7QUFBQSxLQUExQixHQUdGc2YsVUFITDtBQUlBLEcsU0FFREssYSxHQUFBLHVCQUFjdnNCLEVBQWQsRUFBa0I7QUFBQSxRQUNYMmhCLEVBQUUsR0FBRyxLQUFLSSxLQURDO0FBQUEsUUFFWHVDLFVBQVUsR0FBRzNDLEVBQUUsQ0FBQ3JLLE1BQUgsV0FBa0J0WCxFQUFsQixrQkFGRjtBQUFBLFFBR1g3SCxJQUFJLEdBQUd3cEIsRUFBRSxDQUFJM2hCLEVBQUosVUFIRTtBQUtqQixXQUFPLENBQUM2TSxVQUFVLENBQUN5WCxVQUFELENBQVYsR0FBeUJBLFVBQVUsQ0FBQ2pWLElBQVgsQ0FBZ0JzUyxFQUFFLENBQUNnSixHQUFuQixDQUF6QixHQUFtRHJHLFVBQXBELE1BQ0xuc0IsSUFBSSxHQUFHQSxJQUFJLENBQUNtc0IsVUFBTCxFQUFILEdBQXVCbGlCLFNBRHRCLENBQVA7QUFFQSxHLFNBRURvcUIsc0IsR0FBQSxnQ0FBdUJ4c0IsRUFBdkIsRUFBMkI7QUFDMUIsV0FBTyxLQUFLK2hCLEtBQUwsQ0FBV3pLLE1BQVgsV0FBMEJ0WCxFQUExQixZQUFQO0FBQ0EsRyxTQUVEeXNCLFksR0FBQSxzQkFBYXpzQixFQUFiLEVBQWlCO0FBQ2hCLFFBQU0wc0IsTUFBTSxHQUFHLEtBQUtGLHNCQUFMLENBQTRCeHNCLEVBQTVCLENBQWY7QUFFQSxXQUFPOE0sUUFBUSxDQUFDNGYsTUFBRCxDQUFSLEdBQW1CQSxNQUFuQixHQUNOQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ253QixJQUFWLEdBQWlCLElBRHhCO0FBR0EsRyxTQUVEb3dCLFksR0FBQSxzQkFBYTNzQixFQUFiLEVBQWlCekQsSUFBakIsRUFBdUI7QUFDaEIsUUFBQW9sQixFQUFFLEdBQUcsS0FBS0ksS0FBVjtBQUFBLFFBQ0N6SyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQW9WLE1BRkEsR0FFUyxLQUFLRixzQkFBTCxDQUE0QnhzQixFQUE1QixDQUZUO0FBSUY4TSxZQUFRLENBQUM0ZixNQUFELENBTFUsR0FNckJwVixNQUFNLFdBQVN0WCxFQUFULFlBQU4sR0FBNkJ6RCxJQU5SLEdBT1htd0IsTUFQVyxLQVFyQkEsTUFBTSxDQUFDbndCLElBQVAsR0FBY0EsSUFSTztBQVV0QixHLFNBRURxd0IsZ0IsR0FBQSwwQkFBaUI1c0IsRUFBakIsRUFBcUI2c0IsZUFBckIsRUFBc0M7QUFBQSxRQUMvQm5ELFNBQVMsR0FBRyxLQUFLM0gsS0FBTCxDQUFXekssTUFBWCxDQUFrQmMsWUFEQztBQUFBLFFBRS9Cc1UsTUFBTSxHQUFHLEtBQUtGLHNCQUFMLENBQTRCeHNCLEVBQTVCLENBRnNCO0FBQUEsUUFHL0I4c0IsUUFBUSxHQUFJcGYsWUFBWSxDQUFDZ2YsTUFBRCxDQUFaLElBQXdCQSxNQUFNLENBQUNJLFFBQWhDLEdBQ2hCSixNQUFNLENBQUNJLFFBRFMsR0FDRUQsZUFBZSxDQUFDLENBQUMsQ0FBQ25ELFNBQUgsQ0FKRztBQUFBLFFBTS9CcUQsR0FBRyxHQUFHLFVBQUFuZ0IsQ0FBQztBQUFBLGFBQUksQ0FBQyxDQUFDLENBQUNrZ0IsUUFBUSxDQUFDamQsT0FBVCxDQUFpQmpELENBQWpCLENBQVA7QUFBQSxLQU53Qjs7QUFRckMsV0FBTztBQUNOb2dCLGFBQU8sRUFBRUQsR0FBRyxDQUFDLE9BQUQsQ0FETjtBQUVORSxhQUFPLEVBQUVGLEdBQUcsQ0FBQyxPQUFELENBRk47QUFHTkcsWUFBTSxFQUFFSCxHQUFHLENBQUMsTUFBRCxDQUhMO0FBSU5JLGNBQVEsRUFBRUosR0FBRyxDQUFDLFFBQUQsQ0FKUDtBQUtOSyxhQUFPLEVBQUVMLEdBQUcsQ0FBQyxPQUFELENBTE47QUFNTk0sV0FBSyxFQUFFTixHQUFHLENBQUMsS0FBRCxDQU5KO0FBT05PLGNBQVEsRUFBRVAsR0FBRyxDQUFDLFFBQUQsQ0FQUDtBQVFOUSxjQUFRLEVBQUVSLEdBQUcsQ0FBQyxRQUFEO0FBUlAsS0FBUDtBQVVBLEcsU0FFRFMscUIsR0FBQSxpQ0FBd0I7QUFDdkIsV0FBTyxLQUFLWixnQkFBTCxDQUFzQixHQUF0QixFQUEyQixDQUFDLFdBQUQsRUFBYyxhQUFkLENBQTNCLENBQVA7QUFDQSxHLFNBRURhLHFCLEdBQUEsaUNBQXdCO0FBQ3ZCLFdBQU8sS0FBS2IsZ0JBQUwsQ0FBc0IsR0FBdEIsRUFBMkIsQ0FBQyxhQUFELEVBQWdCLFdBQWhCLENBQTNCLENBQVA7QUFDQSxHLFNBRURjLHNCLEdBQUEsa0NBQXlCO0FBQ3hCLFdBQU8sS0FBS2QsZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsQ0FBQyxhQUFELEVBQWdCLFdBQWhCLENBQTVCLENBQVA7QUFDQSxHLFNBRURlLG9CLEdBQUEsOEJBQXFCM3RCLEVBQXJCLEVBQXlCO0FBQ3hCLFdBQU8sYUFBV0EsRUFBRSxDQUFDc1MsV0FBSCxFQUFYLHlCQUFQO0FBQ0EsRyxTQUVEc2IsaUIsR0FBQSw2QkFBb0I7QUFDbkIsV0FBTyxLQUFLbkIsWUFBTCxDQUFrQixHQUFsQixDQUFQO0FBQ0EsRyxTQUVEb0IsaUIsR0FBQSw2QkFBb0I7QUFDbkIsV0FBTyxLQUFLcEIsWUFBTCxDQUFrQixHQUFsQixDQUFQO0FBQ0EsRyxTQUVEcUIsa0IsR0FBQSw4QkFBcUI7QUFDcEIsV0FBTyxLQUFLckIsWUFBTCxDQUFrQixJQUFsQixDQUFQO0FBQ0EsRyxTQUVEc0IsYSxHQUFBLHVCQUFjakIsUUFBZCxFQUF3QnJELGFBQXhCLEVBQThDO0FBQXRCQSxpQkFBc0IsZ0JBQXRCQSxhQUFzQjtBQUN2QyxRQUFBOUgsRUFBRSxHQUFHLEtBQUtJLEtBQVY7QUFBQSxvQkFDa0JKLEVBQUUsQ0FBQzlqQixLQURyQjtBQUFBLFFBQ0NDLEtBREQsYUFDQ0EsS0FERDtBQUFBLFFBQ1FFLE1BRFIsYUFDUUEsTUFEUjtBQUFBLFFBRUZzQixDQUZFLEdBRUV3dEIsUUFBUSxDQUFDUSxRQUFULEdBQW9CLENBQUN0dkIsTUFBRCxHQUFVLENBQTlCLEdBQWtDLENBRnBDO0FBWU4sV0FSSSxLQUFLd3JCLFlBQUwsQ0FBa0I3SCxFQUFsQixFQUFzQjhILGFBQXRCLENBUUosR0FQQ25xQixDQUFDLEdBQUd3dEIsUUFBUSxDQUFDSSxNQUFULEdBQWtCLENBQWxCLEdBQ0hKLFFBQVEsQ0FBQ0ssUUFBVCxHQUFvQnJ2QixLQUFLLEdBQUcsQ0FBNUIsR0FBZ0NBLEtBTWxDLEdBSldndkIsUUFBUSxDQUFDUyxRQUlwQixLQUhDanVCLENBQUMsR0FBRyxDQUFDcWlCLEVBQUUsQ0FBQzlqQixLQUFILENBQVNHLE1BR2YsR0FBT3NCLENBQVA7QUFDQSxHLFNBRUQwdUIsYyxHQUFBLHdCQUFlbEIsUUFBZixFQUF5QnJELGFBQXpCLEVBQStDO0FBQXRCQSxpQkFBc0IsZ0JBQXRCQSxhQUFzQjtBQUFBLFFBQ3hDOUgsRUFBRSxHQUFHLEtBQUtJLEtBRDhCO0FBQUEsUUFFMUNvRixFQUFFLEdBQUcyRixRQUFRLENBQUNTLFFBQVQsR0FBb0IsT0FBcEIsR0FBOEIsR0FGTztBQVk5QyxXQVJJLEtBQUsvRCxZQUFMLENBQWtCN0gsRUFBbEIsRUFBc0I4SCxhQUF0QixDQVFKLEdBUEN0QyxFQUFFLEdBQUcyRixRQUFRLENBQUNJLE1BQVQsR0FBa0IsT0FBbEIsR0FDSkosUUFBUSxDQUFDTSxPQUFULEdBQW1CLFFBQW5CLEdBQThCLEdBTWhDLEdBSldOLFFBQVEsQ0FBQ08sS0FJcEIsS0FIQ2xHLEVBQUUsR0FBRyxRQUdOLEdBQU9BLEVBQVA7QUFDQSxHLFNBRUQ4RyxzQixHQUFBLGdDQUF1Qm5CLFFBQXZCLEVBQWlDckQsYUFBakMsRUFBdUQ7QUFBdEJBLGlCQUFzQixnQkFBdEJBLGFBQXNCO0FBQUEsUUFDaEQ5SCxFQUFFLEdBQUcsS0FBS0ksS0FEc0M7QUFBQSxRQUVsRG1NLE1BQU0sR0FBR3BCLFFBQVEsQ0FBQ1EsUUFBVCxHQUFvQixRQUFwQixHQUErQixLQUZVO0FBWXRELFdBUkksS0FBSzlELFlBQUwsQ0FBa0I3SCxFQUFsQixFQUFzQjhILGFBQXRCLENBUUosR0FQQ3lFLE1BQU0sR0FBR3BCLFFBQVEsQ0FBQ0ksTUFBVCxHQUFrQixPQUFsQixHQUNSSixRQUFRLENBQUNLLFFBQVQsR0FBb0IsUUFBcEIsR0FBK0IsS0FNakMsR0FKV0wsUUFBUSxDQUFDUyxRQUlwQixLQUhDVyxNQUFNLEdBQUcsT0FHVixHQUFPQSxNQUFQO0FBQ0EsRyxTQUVEQyxjLEdBQUEsMEJBQWlCO0FBQ2hCLFdBQU8sS0FBS0osYUFBTCxDQUFtQixLQUFLUCxxQkFBTCxFQUFuQixLQUFQO0FBQ0EsRyxTQUVEWSxjLEdBQUEsMEJBQWlCO0FBQ2hCLFdBQU8sS0FBS0wsYUFBTCxDQUFtQixLQUFLTixxQkFBTCxFQUFuQixDQUFQO0FBQ0EsRyxTQUVEWSxlLEdBQUEsMkJBQWtCO0FBQ2pCLFdBQU8sS0FBS04sYUFBTCxDQUFtQixLQUFLTCxzQkFBTCxFQUFuQixDQUFQO0FBQ0EsRyxTQUVEWSxlLEdBQUEsMkJBQWtCO0FBQ2pCLFdBQU8sS0FBS04sY0FBTCxDQUFvQixLQUFLUixxQkFBTCxFQUFwQixLQUFQO0FBQ0EsRyxTQUVEZSxlLEdBQUEsMkJBQWtCO0FBQ2pCLFdBQU8sS0FBS1AsY0FBTCxDQUFvQixLQUFLUCxxQkFBTCxFQUFwQixDQUFQO0FBQ0EsRyxTQUVEZSxnQixHQUFBLDRCQUFtQjtBQUNsQixXQUFPLEtBQUtSLGNBQUwsQ0FBb0IsS0FBS04sc0JBQUwsRUFBcEIsQ0FBUDtBQUNBLEcsU0FFRGUsZSxHQUFBLDJCQUFrQjtBQUNYLFFBQUE5TSxFQUFFLEdBQUcsS0FBS0ksS0FBVjtBQUFBLFFBQ0N6SyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQTBWLE9BRkEsR0FFVSxLQUFLUSxxQkFBTCxHQUE2QlIsT0FGdkM7QUFBQSxRQUdBMEIsT0FIQSxHQUdVcFgsTUFBTSxDQUFDdE8sYUFIakI7QUFEVyxXQU1ic08sTUFBTSxDQUFDYyxZQU5NLEdBT1Q0VSxPQUFPLEdBQUcsT0FBSCxHQUFhLENBQUMsRUFBRCxHQUFNLEtBQUsyQixlQUFMLENBQXFCLEdBQXJCLENBUGpCLEdBUU4zQixPQVJNLEdBU1QsUUFUUyxHQVVOMEIsT0FWTSxHQVdUQSxPQUFPLEdBQUcsRUFYRCxHQWFULEtBYlM7QUFlakIsRyxTQUVERSxlLEdBQUEsMkJBQWtCO0FBQUEsUUFDWGpOLEVBQUUsR0FBRyxLQUFLSSxLQURDO0FBQUEsUUFFWGlMLE9BQU8sR0FBRyxLQUFLUyxxQkFBTCxHQUE2QlQsT0FGNUI7QUFBQSxXQUlickwsRUFBRSxDQUFDckssTUFBSCxDQUFVYyxZQUpHLEdBS1Q0VSxPQUFPLEdBQUcsUUFBSCxHQUFjLEtBTFosR0FPVEEsT0FBTyxHQUFHLE9BQUgsR0FBYSxDQUFDLEVBQUQsSUFBT3JMLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVTNOLFlBQVYsR0FBeUIsQ0FBekIsR0FBOEIsS0FBS2dsQixlQUFMLENBQXFCLEdBQXJCLElBQTRCLEVBQWpFLENBUFg7QUFTakIsRyxTQUVERSxnQixHQUFBLDRCQUFtQjtBQUFBLFFBQ1psTixFQUFFLEdBQUcsS0FBS0ksS0FERTtBQUFBLFFBRVppTCxPQUFPLEdBQUcsS0FBS1Usc0JBQUwsR0FBOEJWLE9BRjVCO0FBQUEsV0FJZHJMLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWMsWUFKSSxHQUtWNFUsT0FBTyxHQUFHLE9BQUgsR0FBYSxRQUxWLEdBT1ZBLE9BQU8sR0FBRyxRQUFILEdBQWMsTUFBTXJMLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXJNLGFBQVYsR0FBMEIsQ0FBMUIsR0FBK0IsS0FBSzBqQixlQUFMLENBQXFCLElBQXJCLElBQTZCLEVBQWxFLENBUFg7QUFTbEIsRyxTQUVERyx1QixHQUFBLG1DQUEwQjtBQUN6QixXQUFPLEtBQUtiLHNCQUFMLENBQTRCLEtBQUtULHFCQUFMLEVBQTVCLEtBQVA7QUFDQSxHLFNBRUR1Qix1QixHQUFBLG1DQUEwQjtBQUN6QixXQUFPLEtBQUtkLHNCQUFMLENBQTRCLEtBQUtSLHFCQUFMLEVBQTVCLENBQVA7QUFDQSxHLFNBRUR1Qix3QixHQUFBLG9DQUEyQjtBQUMxQixXQUFPLEtBQUtmLHNCQUFMLENBQTRCLEtBQUtQLHNCQUFMLEVBQTVCLENBQVA7QUFDQSxHLFNBRURpQixlLEdBQUEseUJBQWdCM3VCLEVBQWhCLEVBQTRCaXZCLGdCQUE1QixFQUFnRTtBQUN6RCxRQUFBdE4sRUFBRSxHQUFHLEtBQUtJLEtBQVY7QUFBQSxRQUNDekssTUFERCxHQUM4QnFLLEVBRDlCLENBQ0NySyxNQUREO0FBQUEsbUJBQzhCcUssRUFEOUIsQ0FDUzVRLEdBRFQ7QUFBQSxRQUNlbWUsR0FEZixZQUNlQSxHQURmO0FBQUEsUUFDb0JuMkIsS0FEcEIsWUFDb0JBLEtBRHBCO0FBQUEsUUFFQW8yQixjQUZBLEdBRWlCeE4sRUFBRSxDQUFDOWpCLEtBQUgsQ0FBU3dCLG9CQUFULENBQThCVyxFQUE5QixDQUZqQjtBQUFBLFFBR0ZvdkIsUUFIRSxHQUdTLENBSFQ7QUFLTixRQUFJSCxnQkFBZ0IsSUFBSSxDQUFDM1gsTUFBTSxXQUFTdFgsRUFBVCxXQUEvQixFQUNDLE9BQU9tdkIsY0FBYyxDQUFDNXZCLElBQXRCOztBQUdELFFBQUkydkIsR0FBSixFQUFTO0FBQUEsVUFDRkcsT0FBTyxHQUFHLFFBQVFsZCxJQUFSLENBQWFuUyxFQUFiLENBRFI7QUFBQSxVQUVGc3ZCLGFBQWEsR0FBRzNOLEVBQUUsQ0FBQzROLG1CQUFILENBQXVCNU4sRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBL0IsQ0FGZDtBQUFBLFVBR0ZRLEtBQUssR0FBR0wsRUFBRSxDQUFDSyxLQUFILENBQVNoaUIsRUFBVCxFQUFhc2pCLElBQWIsR0FBb0I5akIsTUFBcEIsQ0FBMkJtaUIsRUFBRSxVQUFPME4sT0FBTyxHQUFHLEdBQUgsR0FBUyxHQUF2QixhQUFGLENBQXNDQyxhQUF0QyxFQUFxRHR2QixFQUFyRCxDQUEzQixDQUhOO0FBQUEsVUFJRlIsTUFBTSxHQUFHd2lCLEtBQUssQ0FBQ3hpQixNQUFOLEVBSlA7QUFNUjtBQUNBLFVBQUkwTyxPQUFPLENBQUNpaEIsY0FBYyxDQUFDM3ZCLE1BQWhCLENBQVAsSUFBa0MydkIsY0FBYyxDQUFDM3ZCLE1BQWYsQ0FBc0JpVixLQUF0QixDQUE0QixVQUFDN0gsQ0FBRCxFQUFJd0QsQ0FBSjtBQUFBLGVBQVV4RCxDQUFDLEtBQUtwTixNQUFNLENBQUM0USxDQUFELENBQXRCO0FBQUEsT0FBNUIsQ0FBdEMsRUFDQyxPQUFPK2UsY0FBYyxDQUFDNXZCLElBQXRCO0FBRUE0dkIsb0JBQWMsQ0FBQzN2QixNQUFmLEdBQXdCQSxNQVZqQjtBQUFBLFVBYUZySCxJQUFJLEdBQUcsS0FBSyt5QixPQUFMLENBQWFsckIsRUFBYixFQUFpQmdpQixLQUFqQixhQWJMO0FBQUEsVUFjRndOLFNBQVMsR0FBR2xZLE1BQU0sV0FBU3RYLEVBQVQsaUJBZGhCO0FBa0JKd3ZCLGVBbEJJLElBbUJQcjNCLElBQUksQ0FBQ21zQixVQUFMLENBQ0MsS0FBS3dILGtCQUFMLENBQ0N0c0IsTUFERCxFQUVDZ3dCLFNBRkQsRUFHQ0gsT0FBTyxHQUFHMU4sRUFBRSxDQUFDK0osYUFBSCxFQUFILEdBQXdCL0osRUFBRSxDQUFDOEosWUFBSCxFQUhoQyxDQURELENBbkJPLEVBMkJQNEQsT0FBRCxJQUFZLEtBQUt6RCxxQkFBTCxDQUEyQjBELGFBQTNCLEVBQTBDbjNCLElBQTFDLENBM0JKO0FBNkJSLFVBQU1zM0IsS0FBSyxHQUFHMTJCLEtBQUssQ0FBQ3NYLE1BQU4sQ0FBYSxLQUFiLEVBQ1pxVyxLQURZLENBQ04sWUFETSxFQUNRLFFBRFIsRUFFWkEsS0FGWSxDQUVOLFVBRk0sRUFFTSxPQUZOLEVBR1pBLEtBSFksQ0FHTixLQUhNLEVBR0MsS0FIRCxFQUlaQSxLQUpZLENBSU4sTUFKTSxFQUlFLEtBSkYsQ0FBZDtBQU1BdnVCLFVBQUksQ0FBQ3VzQixNQUFMLENBQVkrSyxLQUFaLENBbkNRLEVBcUNSQSxLQUFLLENBQUNySixTQUFOLENBQWdCLE1BQWhCLEVBQ0VOLElBREYsQ0FDTyxZQUFXO0FBQ2hCc0osZ0JBQVEsR0FBR2hpQixJQUFJLENBQUNtWCxHQUFMLENBQVM2SyxRQUFULEVBQW1CLEtBQUsxZSxxQkFBTCxHQUE2QjVTLEtBQWhELENBREs7QUFFaEIsT0FIRixDQXJDUSxFQTBDUjJ4QixLQUFLLENBQUNuTyxNQUFOLEVBMUNRO0FBMkNSOztBQU1ELFdBSkk4TixRQUFRLEdBQUcsQ0FJZixLQUhDRCxjQUFjLENBQUM1dkIsSUFBZixHQUFzQjZ2QixRQUd2QixHQUFPRCxjQUFjLENBQUM1dkIsSUFBdEI7QUFDQSxHLFNBRURtd0IsWSxHQUFBLHNCQUFhQyxjQUFiLEVBQTZCO0FBQUE7QUFBQSxRQUN0QmhPLEVBRHNCLEdBQ2pCLEtBQUtJLEtBRFk7QUFBQSxRQUVyQjdRLElBRnFCLEdBRWJ5USxFQUFFLENBQUM1USxHQUZVLENBRXJCRyxJQUZxQjtBQUFBLFFBSXRCMGUsTUFKc0IsR0FJYjtBQUNkQyxPQUFDLEVBQUUzZSxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ2xaLEtBQXRCLFVBQWdDa1osY0FBSyxDQUFDalosVUFBdEMsQ0FEVztBQUVkeTNCLE9BQUMsRUFBRTVlLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDaFosS0FBdEIsVUFBZ0NnWixjQUFLLENBQUM3WSxVQUF0QyxDQUZXO0FBR2RzM0IsUUFBRSxFQUFFN2UsSUFBSSxDQUFDRyxNQUFMLE9BQWdCQyxjQUFLLENBQUMvWSxNQUF0QixVQUFpQytZLGNBQUssQ0FBQzlZLFdBQXZDO0FBSFUsS0FKYTs7QUFVNUJzVixVQUFNLENBQUNDLElBQVAsQ0FBWTZoQixNQUFaLEVBQW9CM2IsTUFBcEIsQ0FBMkIsVUFBQWpVLEVBQUU7QUFBQSxhQUFJLENBQUM0dkIsTUFBTSxDQUFDNXZCLEVBQUQsQ0FBTixDQUFXekYsS0FBWCxFQUFMO0FBQUEsS0FBN0IsRUFDRXlVLE9BREYsQ0FDVSxVQUFBcEMsQ0FBQyxFQUFJO0FBQUEsVUFDUDhDLElBQUksR0FBR2tnQixNQUFNLENBQUNoakIsQ0FBRCxDQUROO0FBQUEsVUFFUG9qQixTQUFTLEdBQU1wakIsQ0FBTixjQUZGO0FBSWIsT0FBQytpQixjQUFjLEdBQUdqZ0IsSUFBSSxDQUFDa1UsVUFBTCxFQUFILEdBQXVCbFUsSUFBdEMsRUFDRVksSUFERixDQUNPLEdBRFAsRUFDWSxNQUFJLFVBQVEwZixTQUFSLENBQUosQ0FBeUJsTCxJQUF6QixDQUE4QixNQUE5QixDQURaLEVBRUV4VSxJQUZGLENBRU8sSUFGUCxFQUVhLE1BQUksV0FBUzBmLFNBQVQsQ0FBSixDQUEwQmxMLElBQTFCLENBQStCLE1BQS9CLENBRmIsRUFHRXhVLElBSEYsQ0FHTyxJQUhQLEVBR2EsTUFBSSxXQUFTMGYsU0FBVCxDQUFKLENBQTBCbEwsSUFBMUIsQ0FBK0IsTUFBL0IsQ0FIYixFQUlFdm9CLElBSkYsQ0FJTyxNQUFJLGFBQVd5ekIsU0FBWCxDQUFKLENBQTRCbEwsSUFBNUIsQ0FBaUMsTUFBakMsQ0FKUCxDQUphO0FBU2IsS0FWRixDQVY0QjtBQXFCNUIsRyxTQUVEbUwsVSxHQUFBLG9CQUFXQyxPQUFYLEVBQW9CeGhCLEdBQXBCLEVBQXlCQyxZQUF6QixFQUF1Q3doQixZQUF2QyxFQUFxRDtBQUNwRCxRQUFNamUsQ0FBQyxHQUFHbkYsUUFBUSxDQUFDbWpCLE9BQUQsQ0FBUixHQUFvQkEsT0FBcEIsR0FBOEJBLE9BQU8sQ0FBQ3hoQixHQUFELENBQS9DO0FBRG9ELFdBRy9DL0IsT0FBTyxDQUFDdUYsQ0FBRCxDQUh3QyxHQU83QyxLQUFLa2UsMEJBQUwsQ0FBZ0NsZSxDQUFoQyxFQUFtQ2llLFlBQW5DLENBUDZDLEdBSTVDeGhCLFlBSjRDO0FBUXBELEcsU0FFRHloQiwwQixHQUFBLG9DQUEyQkMsTUFBM0IsRUFBbUNGLFlBQW5DLEVBQWlEO0FBQzFDLFFBQUF4TyxFQUFFLEdBQUcsS0FBS0ksS0FBVjtBQUFBLFFBQ0N6SyxNQURELEdBQ21DcUssRUFEbkMsQ0FDQ3JLLE1BREQ7QUFBQSxxQkFDbUNxSyxFQURuQyxDQUNTOWpCLEtBRFQ7QUFBQSxRQUNpQkMsS0FEakIsY0FDaUJBLEtBRGpCO0FBQUEsUUFDd0JFLE1BRHhCLGNBQ3dCQSxNQUR4QjtBQUFBLFFBRUE0UCxNQUZBLEdBRVMwSixNQUFNLENBQUNjLFlBQVAsR0FBc0J0YSxLQUF0QixHQUE4QkUsTUFGdkM7QUFJTixXQUFPbXlCLFlBQVksSUFBSUUsTUFBTSxHQUFHemlCLE1BQWIsQ0FBbkI7QUFDQSxHLFNBRURrZSxrQixHQUFBLDRCQUFtQmpLLE1BQW5CLEVBQTJCMk4sU0FBM0IsRUFBc0NjLGFBQXRDLEVBQXFEO0FBQUEsUUFFaER4YixLQUZnRDtBQUFBLFFBR2hEQyxHQUhnRDtBQUFBLFFBSWhEMlYsS0FKZ0Q7QUFBQSxRQUtoRDFILFFBTGdEO0FBQUEsUUFNaEQ1UyxDQU5nRDtBQUFBLFFBT2hEbWdCLFNBUGdEO0FBQUEsUUFDaERqTSxVQUFVLEdBQUd6QyxNQURtQzs7QUFTcEQsUUFBSTJOLFNBQUosRUFBZTtBQUNkLFVBQU1nQixXQUFXLEdBQUczakIsVUFBVSxDQUFDMmlCLFNBQUQsQ0FBVixHQUF3QkEsU0FBUyxFQUFqQyxHQUFzQ0EsU0FBMUQsQ0FEYyxDQUdkOztBQUNBLFVBQUlnQixXQUFXLEtBQUssQ0FBcEIsRUFDQ2xNLFVBQVUsR0FBRyxDQUFDekMsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQURkLE1BRU8sSUFBSTJPLFdBQVcsS0FBSyxDQUFwQixFQUNObE0sVUFBVSxHQUFHLENBQUN6QyxNQUFNLENBQUMsQ0FBRCxDQUFQLEVBQVlBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDalUsTUFBUCxHQUFnQixDQUFqQixDQUFsQixDQURQLE1BRUEsSUFBSTRpQixXQUFXLEdBQUcsQ0FBbEIsRUFBcUI7QUFDM0IsWUFBTW5GLGFBQWEsR0FBRyxLQUFLdEosS0FBTCxDQUFXc0osYUFBWCxFQUF0Qjs7QUFVQSxhQVJBWCxLQUFLLEdBQUc4RixXQUFXLEdBQUcsQ0FRdEIsRUFQQTFiLEtBQUssR0FBRytNLE1BQU0sQ0FBQyxDQUFELENBT2QsRUFOQTlNLEdBQUcsR0FBRzhNLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDalUsTUFBUCxHQUFnQixDQUFqQixDQU1aLEVBTEFvVixRQUFRLEdBQUcsQ0FBQ2pPLEdBQUcsR0FBR0QsS0FBUCxLQUFpQjRWLEtBQUssR0FBRyxDQUF6QixDQUtYLEVBRkFwRyxVQUFVLEdBQUcsQ0FBQ3hQLEtBQUQsQ0FFYixFQUFLMUUsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHc2EsS0FBaEIsRUFBdUJ0YSxDQUFDLEVBQXhCLEVBQ0NtZ0IsU0FBUyxHQUFHLENBQUN6YixLQUFELEdBQVNrTyxRQUFRLElBQUk1UyxDQUFDLEdBQUcsQ0FBUixDQUQ5QixFQUVDa1UsVUFBVSxDQUFDdFAsSUFBWCxDQUNDc2IsYUFBYSxHQUFHLElBQUl6aUIsSUFBSixDQUFTMGlCLFNBQVQsQ0FBSCxHQUNabEYsYUFBYSxHQUFHamUsSUFBSSxDQUFDOFYsS0FBTCxDQUFXcU4sU0FBWCxDQUFILEdBQTJCQSxTQUYxQyxDQUZEOztBQVNBak0sa0JBQVUsQ0FBQ3RQLElBQVgsQ0FBZ0JELEdBQWhCLENBcEIyQjtBQXFCM0I7QUFDRDs7QUFNRCxXQUpLdWIsYUFJTCxLQUhDaE0sVUFBVSxHQUFHQSxVQUFVLENBQUM1UCxJQUFYLENBQWdCLFVBQUNqQixDQUFELEVBQUlDLENBQUo7QUFBQSxhQUFVRCxDQUFDLEdBQUdDLENBQWQ7QUFBQSxLQUFoQixDQUdkLEdBQU80USxVQUFQO0FBQ0EsRyxTQUVEbU0sbUIsR0FBQSw2QkFBb0JDLFFBQXBCLEVBQThCO0FBQ3ZCLFFBQUEvTyxFQUFFLEdBQUcsS0FBS0ksS0FBVjtBQUFBLFFBQ0E1cEIsSUFEQSxHQUNPd3BCLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBTzVZLElBRGQ7QUFBQSxlQUdtQyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsSUFBWCxFQUFpQixNQUFqQixFQUN2QzRYLEdBRHVDLENBQ25DLFVBQUFuRCxDQUFDLEVBQUk7QUFDVCxVQUFJK2pCLEVBQUUsR0FBR3g0QixJQUFJLENBQUN5VSxDQUFELENBQWI7QUFNQSxhQUpJK2pCLEVBQUUsSUFBSUQsUUFJVixLQUhDQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQy9NLFVBQUgsR0FBZ0I4TSxRQUFoQixDQUF5QkEsUUFBekIsQ0FHTixHQUFPQyxFQUFQO0FBQ0EsS0FUdUMsQ0FIbkM7QUFBQSxRQUdDdjRCLEtBSEQ7QUFBQSxRQUdRRSxLQUhSO0FBQUEsUUFHZUMsTUFIZjtBQUFBLFFBR3VCcTRCLFFBSHZCOztBQWNOLFdBQU87QUFBQ3g0QixXQUFLLEVBQUxBLEtBQUQ7QUFBUUUsV0FBSyxFQUFMQSxLQUFSO0FBQWVDLFlBQU0sRUFBTkEsTUFBZjtBQUF1QnE0QixjQUFRLEVBQVJBO0FBQXZCLEtBQVA7QUFDQSxHLFNBRURDLE0sR0FBQSxnQkFBT0MsV0FBUCxFQUFvQkMsUUFBcEIsRUFBOEJDLE1BQTlCLEVBQXNDO0FBQy9CLFFBQUFyUCxFQUFFLEdBQUcsS0FBS0ksS0FBVjtBQUFBLFFBQ0N6SyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBQUEsUUFFQWtnQixPQUZBLEdBRVVGLFFBQVEsR0FBRyxHQUFILEdBQVMsR0FGM0I7QUFJTixLQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsSUFBWCxFQUFpQixNQUFqQixFQUF5Qi9oQixPQUF6QixDQUFpQyxVQUFBaFAsRUFBRSxFQUFJO0FBQUEsVUFDaEM3SCxJQUFJLEdBQUd3cEIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUTZILEVBQVIsQ0FEeUI7QUFBQSxVQUVoQ2t4QixLQUFLLEdBQUduZ0IsR0FBRyxDQUFDNVksSUFBSixDQUFTNkgsRUFBVCxDQUZ3QjtBQUlsQzdILFVBQUksSUFBSSs0QixLQUowQixLQUtqQyxDQUFDRixNQUxnQyxLQU1wQzc0QixJQUFJLENBQUNtZixNQUFMLENBQVk2SyxpQkFBWixHQUFnQyxDQUFDN0ssTUFBTSxDQUFDdUosbUJBTkosR0FTckNxUSxLQUFLLENBQUN4SyxLQUFOLENBQVksU0FBWixFQUF1QnVLLE9BQXZCLENBVHFDLEVBVXJDOTRCLElBQUksQ0FBQ3VzQixNQUFMLENBQVlvTSxXQUFXLFVBQVExZSxVQUFVLENBQUNwUyxFQUFELENBQWxCLENBQXZCLENBVnFDO0FBWXRDLEtBWkQsQ0FMcUMsRUFtQnJDLEtBQUsrcUIsVUFBTCxFQW5CcUM7QUFvQnJDO0FBRUQ7Ozs7Ozs7O1dBUUFvRyxVLEdBQUEsb0JBQVc3QixhQUFYLEVBQTBCOEIsR0FBMUIsRUFBK0JOLFdBQS9CLEVBQTRDTyxJQUE1QyxFQUFrREwsTUFBbEQsRUFBMEQ7QUFBQSxRQUlyRE0sY0FKcUQ7QUFBQTtBQUFBLFFBQ25EM1AsRUFEbUQsR0FDOUMsS0FBS0ksS0FEeUM7QUFBQSxRQUVsRHpLLE1BRmtELEdBRTVCcUssRUFGNEIsQ0FFbERySyxNQUZrRDtBQUFBLFFBRTFDMEssS0FGMEMsR0FFNUJMLEVBRjRCLENBRTFDSyxLQUYwQztBQUFBLFFBRW5DalIsR0FGbUMsR0FFNUI0USxFQUY0QixDQUVuQzVRLEdBRm1DO0FBQUEsUUFHbkR3Z0IsT0FIbUQsR0FHekMsQ0FBQyxDQUFDdlAsS0FBSyxDQUFDekMsSUFIaUM7O0FBTXJELEtBQUNnUyxPQUFELElBQVk1UCxFQUFFLENBQUMwSixhQUFILEVBQVosSUFBa0NpRSxhQUFhLENBQUMxaEIsTUFBZCxLQUF5QixDQU5OLElBT3hEb1UsS0FBSyxDQUFDMWlCLENBQU4sQ0FBUUUsTUFBUixDQUFlLENBQUMsQ0FBRCxFQUFJdVIsR0FBRyxDQUFDNVksSUFBSixDQUFTbUgsQ0FBVCxDQUFXOG1CLFNBQVgsQ0FBcUIsT0FBckIsRUFBOEI3bUIsSUFBOUIsRUFBSixDQUFmLENBUHdELEVBVXJEeWlCLEtBQUssQ0FBQzFpQixDQUFOLElBQVdnd0IsYUFBYSxDQUFDMWhCLE1BVjRCLElBV3hELENBQUMyakIsT0FBRCxJQUNDNVAsRUFBRSxDQUFDNlAsYUFBSCxDQUFpQmxDLGFBQWpCLEVBQWdDOEIsR0FBRyxDQUFDSyxhQUFwQyxFQUFtREwsR0FBRyxDQUFDTSxnQkFBdkQsRUFBeUVOLEdBQUcsQ0FBQ08sV0FBN0UsQ0FadUQsRUFjcEQsQ0FBQ3JhLE1BQU0sQ0FBQy9PLGtCQWQ0QyxJQWV2RCxLQUFLcWpCLHFCQUFMLENBQTJCMEQsYUFBM0IsQ0FmdUQsSUFpQjlDM04sRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBakJzQyxLQWtCeERxaUIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBQVIsQ0FBVWdsQixVQUFWLENBQXFCLEVBQXJCLENBbEJ3RCxFQW1CeEQzQyxFQUFFLENBQUN4cEIsSUFBSCxDQUFRa3hCLElBQVIsSUFBZ0IxSCxFQUFFLENBQUN4cEIsSUFBSCxDQUFRa3hCLElBQVIsQ0FBYS9FLFVBQWIsQ0FBd0IsRUFBeEIsQ0FuQndDLEdBc0JyRGhOLE1BQU0sQ0FBQzJDLFlBQVAsSUFBdUIsQ0FBQ29YLElBdEI2QixLQXVCeERDLGNBQWMsR0FBR3RQLEtBQUssQ0FBQzFpQixDQUFOLENBQVFzeUIsU0FBUixFQXZCdUMsR0EwQnpELENBQUMsR0FBRCxFQUFNLElBQU4sRUFBWTVpQixPQUFaLENBQW9CLFVBQUFOLEdBQUcsRUFBSTtBQUMxQixVQUFNdlcsSUFBSSxHQUFHNnBCLEtBQUssQ0FBQ3RULEdBQUQsQ0FBbEI7O0FBRUEsVUFBSXZXLElBQUosRUFBVTtBQUFBLFlBQ0htc0IsVUFBVSxHQUFHaE4sTUFBTSxXQUFTNUksR0FBVCxrQkFEaEI7QUFBQSxZQUVIOGdCLFNBQVMsR0FBR2xZLE1BQU0sV0FBUzVJLEdBQVQsaUJBRmY7O0FBTVQsWUFGQXZXLElBQUksQ0FBQ3FILE1BQUwsQ0FBWW1pQixFQUFFLENBQUNrUSxVQUFILENBQWN2QyxhQUFkLEVBQTZCNWdCLEdBQTdCLEVBQWtDNGlCLGNBQWxDLENBQVosQ0FFQSxFQUFJLENBQUNoTixVQUFELElBQWVrTCxTQUFuQixFQUE4QjtBQUM3QixjQUFNaHdCLE1BQU0sR0FBR3JILElBQUksQ0FBQ3FILE1BQUwsRUFBZjtBQUVBbWlCLFlBQUUsQ0FBSWpULEdBQUosVUFBRixDQUFpQjRWLFVBQWpCLENBQ0MsTUFBSSxDQUFDd0gsa0JBQUwsQ0FDQ3RzQixNQURELEVBRUNBLE1BQU0sQ0FBQ2lWLEtBQVAsQ0FBYSxVQUFBN0gsQ0FBQztBQUFBLG1CQUFJQSxDQUFDLEtBQUssQ0FBVjtBQUFBLFdBQWQsSUFBNkIsQ0FBN0IsR0FBaUM0aUIsU0FGbEMsRUFHQzdOLEVBQUUsQ0FBQytKLGFBQUgsRUFIRCxDQURELENBSDZCO0FBVTdCO0FBQ0Q7QUFDRCxLQXJCRCxDQTFCeUQsRUFrRHpELEtBQUttRixNQUFMLENBQVlDLFdBQVosRUFBeUJuUCxFQUFFLENBQUNtUSxVQUFILEVBQXpCLEVBQTBDZCxNQUExQyxDQWxEeUQsRUFxRHpELEtBQUt0QixZQUFMLENBQWtCMEIsR0FBRyxDQUFDVyxVQUF0QixDQXJEeUQsRUF3RHJELENBQUNYLEdBQUcsQ0FBQ0ssYUFBSixJQUFxQkwsR0FBRyxDQUFDWSxXQUF6QixJQUF3Q1osR0FBRyxDQUFDdEIsQ0FBN0MsS0FBbURSLGFBQWEsQ0FBQzFoQixNQXhEWixJQXlEeEQsS0FBS3FrQixVQUFMLEVBekR3RCxFQTZEckRiLEdBQUcsQ0FBQ3RCLENBN0RpRCxLQThEeEQ5TixLQUFLLENBQUNrUSxJQUFOLElBQWNsUSxLQUFLLENBQUNrUSxJQUFOLENBQVcxeUIsTUFBWCxDQUFrQm1pQixFQUFFLENBQUNrUSxVQUFILENBQWN2QyxhQUFkLEVBQTZCLEdBQTdCLENBQWxCLENBOUQwQyxFQStEeER0TixLQUFLLENBQUNtUSxLQUFOLElBQWVuUSxLQUFLLENBQUNtUSxLQUFOLENBQVkzeUIsTUFBWixDQUFtQm1pQixFQUFFLENBQUNrUSxVQUFILENBQWN2QyxhQUFkLEVBQTZCLElBQTdCLENBQW5CLENBL0R5QztBQWlFekQ7QUFFRDs7OztXQUlBMkMsVSxHQUFBLHNCQUFhO0FBQ04sUUFBQXRRLEVBQUUsR0FBRyxLQUFLSSxLQUFWO0FBQUEsUUFDQ3pLLE1BREQsR0FDZ0JxSyxFQURoQixDQUNDckssTUFERDtBQUFBLFFBQ1N2RyxHQURULEdBQ2dCNFEsRUFEaEIsQ0FDUzVRLEdBRFQ7QUFHTixLQUFDLE1BQUQsRUFBUyxHQUFULEVBQWMsR0FBZCxFQUFtQixJQUFuQixFQUF5Qi9CLE9BQXpCLENBQWlDLFVBQUFvQyxJQUFJLEVBQUk7QUFBQSxVQUNsQ2paLElBQUksR0FBRzRZLEdBQUcsQ0FBQzVZLElBQUosQ0FBU2laLElBQVQsQ0FEMkI7QUFBQSxVQUlsQ3BSLEVBQUUsR0FBR29SLElBQUksS0FBSyxNQUFULEdBQWtCLEdBQWxCLEdBQXdCQSxJQUpLO0FBQUEsVUFLbENnaEIsTUFBTSxHQUFHOWEsTUFBTSxXQUFTdFgsRUFBVCxtQkFMbUIsRUFHeEM7O0FBSUEsVUFBSTdILElBQUksSUFBSWk2QixNQUFaLEVBQW9CO0FBQUEsWUFLZkMsa0JBTGU7QUFBQSxZQUNiMUosUUFBUSxHQUFHeHdCLElBQUksQ0FBQ2l1QixTQUFMLENBQWUsWUFBZixDQURFO0FBQUEsWUFFYjlCLFVBQVUsR0FBRy9QLGNBQVMsQ0FBQ29VLFFBQVEsQ0FBQzdVLElBQVQsRUFBRCxDQUZUO0FBQUEsWUFHYndlLFFBQVEsR0FBR2hPLFVBQVUsQ0FBQzFXLE1BSFQ7QUFBQSxZQUliMmtCLFVBQVUsR0FBR2piLE1BQU0sV0FBU3RYLEVBQVQsdUJBSk47O0FBT25CLFlBQUlzeUIsUUFBSixFQUFjO0FBQ2IsZUFBSyxJQUFJbGlCLEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUdraUIsUUFBcEIsRUFBOEJsaUIsRUFBQyxFQUEvQixFQUNDLElBQUlraUIsUUFBUSxHQUFHbGlCLEVBQVgsR0FBZW1pQixVQUFuQixFQUErQjtBQUM5QkYsOEJBQWtCLEdBQUdqaUIsRUFEUztBQUU5QjtBQUNBOztBQUdGdVksa0JBQVEsQ0FBQzdDLElBQVQsQ0FBYyxVQUFTclksQ0FBVCxFQUFZO0FBQ3pCLGlCQUFLaVosS0FBTCxDQUFXOEwsT0FBWCxHQUFxQmxPLFVBQVUsQ0FBQ3pVLE9BQVgsQ0FBbUJwQyxDQUFuQixJQUF3QjRrQixrQkFBeEIsR0FBNkMsTUFBN0MsR0FBc0QsT0FEbEQ7QUFFekIsV0FGRCxDQVJhO0FBV2IsU0FYRCxNQVlDMUosUUFBUSxDQUFDakMsS0FBVCxDQUFlLFNBQWYsRUFBMEIsT0FBMUIsQ0FaRDtBQWNBO0FBQ0QsS0E3QkQsQ0FKWTtBQWtDWixHOzs7Ozs7OztBQ3AwQkY7Ozs7QUFJQTtBQU1BO0FBRUE7Ozs7OztBQUtlO0FBQ2Q7Ozs7Ozs7QUFPQStMLGFBUmMsdUJBUUZyakIsSUFSRSxFQVFJc2pCLFFBUkosRUFRYztBQUMzQixRQUFJNWUsSUFBSjtBQWlCQSxRQWZJMUUsSUFBSSxDQUFDc1EsTUFlVCxJQWRDNUwsSUFBSSxHQUFHLEVBY1IsRUFaQyxDQUFDLEtBQUQsRUFBUSxVQUFSLEVBQW9CLFNBQXBCLEVBQStCLE1BQS9CLEVBQXVDLE1BQXZDLEVBQStDLE1BQS9DLEVBQXVELE1BQXZELEVBQStELFNBQS9ELEVBQ0U5RSxPQURGLENBQ1UsVUFBQXBDLENBQUMsRUFBSTtBQUNiLFVBQU04QixHQUFHLGFBQVc5QixDQUFwQjtBQUVJOEIsU0FBRyxJQUFJVSxJQUhFLEtBSVowRSxJQUFJLENBQUNsSCxDQUFELENBQUosR0FBVXdDLElBQUksQ0FBQ1YsR0FBRCxDQUpGO0FBTWIsS0FQRixDQVlELElBSENvRixJQUFJLEdBQUcxRSxJQUdSLEVBQUkwRSxJQUFJLENBQUM2ZSxHQUFMLElBQVlELFFBQWhCLEVBQ0MsS0FBS0UsZ0JBQUwsQ0FBc0I5ZSxJQUFJLENBQUM2ZSxHQUEzQixFQUFnQzdlLElBQUksQ0FBQytlLFFBQXJDLEVBQStDL2UsSUFBSSxDQUFDZ2YsT0FBcEQsRUFBNkRoZixJQUFJLENBQUMvRixJQUFsRSxFQUF3RTJrQixRQUF4RSxDQURELE1BRU8sSUFBSTVlLElBQUksQ0FBQ2lmLElBQVQsRUFDTmpmLElBQUksR0FBRyxLQUFLa2YsaUJBQUwsQ0FBdUJsZixJQUFJLENBQUNpZixJQUE1QixFQUFrQ2pmLElBQUksQ0FBQy9GLElBQXZDLENBREQsTUFFQSxJQUFJK0YsSUFBSSxDQUFDbWYsSUFBVCxFQUNObmYsSUFBSSxHQUFHLEtBQUtvZixpQkFBTCxDQUF1QnBmLElBQUksQ0FBQ21mLElBQTVCLENBREQsTUFFQSxJQUFJbmYsSUFBSSxDQUFDcWYsT0FBVCxFQUNOcmYsSUFBSSxHQUFHLEtBQUtzZixvQkFBTCxDQUEwQnRmLElBQUksQ0FBQ3FmLE9BQS9CLENBREQsTUFFQSxJQUFJL2pCLElBQUksQ0FBQ3NRLE1BQVQsRUFDTixNQUFNMlQsS0FBSyxDQUFDLDZDQUFELENBQVg7QUFHRCxXQUFPbmxCLE9BQU8sQ0FBQzRGLElBQUQsQ0FBUCxJQUFpQkEsSUFBeEI7QUFDQSxHQXZDYTs7QUF5Q2Q7Ozs7Ozs7OztBQVNBOGUsa0JBbERjLDRCQWtER0QsR0FsREgsRUFrRFFFLFFBbERSLEVBa0QwQkMsT0FsRDFCLEVBa0RtQy9rQixJQWxEbkMsRUFrRHlDdWxCLElBbER6QyxFQWtEK0M7QUFBQTs7QUFBdkNULFlBQXVDLGdCQUF2Q0EsUUFBdUMsR0FBNUIsS0FBNEI7QUFDNUQsUUFBTVUsR0FBRyxHQUFHLElBQUlDLGNBQUosRUFBWjtBQUVBRCxPQUFHLENBQUNFLElBQUosQ0FBUyxLQUFULEVBQWdCZCxHQUFoQixDQUg0RCxFQUt4REcsT0FMd0QsSUFNM0RobEIsTUFBTSxDQUFDQyxJQUFQLENBQVkra0IsT0FBWixFQUFxQjlqQixPQUFyQixDQUE2QixVQUFBTixHQUFHLEVBQUk7QUFDbkM2a0IsU0FBRyxDQUFDRyxnQkFBSixDQUFxQmhsQixHQUFyQixFQUEwQm9rQixPQUFPLENBQUNwa0IsR0FBRCxDQUFqQyxDQURtQztBQUVuQyxLQUZELENBTjJELEVBVzVENmtCLEdBQUcsQ0FBQ0ksa0JBQUosR0FBeUIsWUFBTTtBQUM5QixVQUFJSixHQUFHLENBQUNLLFVBQUosS0FBbUIsQ0FBdkIsRUFDQyxJQUFJTCxHQUFHLENBQUNNLE1BQUosS0FBZSxHQUFuQixFQUF3QjtBQUN2QixZQUFNQyxRQUFRLEdBQUdQLEdBQUcsQ0FBQ1EsWUFBckI7QUFFQUQsZ0JBQVEsSUFBSVIsSUFBSSxDQUFDamtCLElBQUwsQ0FBVSxLQUFWLEVBQ1gsS0FBSSxhQUFXK0MsVUFBVSxDQUFDeWdCLFFBQUQsQ0FBckIsWUFBSixDQUNDQSxRQUFRLEtBQUssTUFBYixHQUFzQm1CLElBQUksQ0FBQ0MsS0FBTCxDQUFXSCxRQUFYLENBQXRCLEdBQTZDQSxRQUQ5QyxFQUVDL2xCLElBRkQsQ0FEVyxDQUhXO0FBUXZCLE9BUkQsTUFTQyxNQUFNLElBQUlzbEIsS0FBSixDQUFhVixHQUFiLHFDQUFOO0FBR0YsS0F6QjJELEVBMkI1RFksR0FBRyxDQUFDVyxJQUFKLEVBM0I0RDtBQTRCNUQsR0E5RWE7O0FBZ0ZkOzs7Ozs7O0FBT0FDLHFCQXZGYywrQkF1Rk1DLE1BdkZOLEVBdUZjQyxHQXZGZCxFQXVGbUI7QUFBQSxRQUU1QjVtQixDQUY0QjtBQUFBLFFBQzFCd2xCLElBQUksR0FBR21CLE1BQU0sQ0FBQ25CLElBQVAsQ0FBWW9CLEdBQVosQ0FEbUI7QUFjaEMsV0FWSXBCLElBQUksQ0FBQ3JsQixNQUFMLEtBQWdCLENBVXBCLElBVENILENBQUMsR0FBRyxDQUFDLEVBQUQsQ0FTTCxFQVBDd2xCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUWprQixPQUFSLENBQWdCLFVBQUFoUCxFQUFFLEVBQUk7QUFDckJ5TixPQUFDLENBQUMsQ0FBRCxDQUFELENBQUt6TixFQUFMLElBQVcsSUFEVTtBQUVyQixLQUZELENBT0QsSUFIQ3lOLENBQUMsR0FBRzJtQixNQUFNLENBQUNILEtBQVAsQ0FBYUksR0FBYixDQUdMLEVBQU81bUIsQ0FBUDtBQUNBLEdBdEdhO0FBd0dkNm1CLGtCQXhHYyw0QkF3R0dELEdBeEdILEVBd0dRO0FBQ3JCLFdBQU8sS0FBS0YsbUJBQUwsQ0FBeUI7QUFDL0JsQixVQUFJLEVBQUVzQiw2RUFEeUI7QUFFL0JOLFdBQUssRUFBRU8seUVBQVVBO0FBRmMsS0FBekIsRUFHSkgsR0FISSxDQUFQO0FBSUEsR0E3R2E7QUErR2RJLGtCQS9HYyw0QkErR0dDLEdBL0dILEVBK0dRO0FBQ3JCLFdBQU8sS0FBS1AsbUJBQUwsQ0FBeUI7QUFDL0JsQixVQUFJLEVBQUUwQiw2RUFEeUI7QUFFL0JWLFdBQUssRUFBRVcseUVBQVVBO0FBRmMsS0FBekIsRUFHSkYsR0FISSxDQUFQO0FBSUEsR0FwSGE7QUFzSGQxQixtQkF0SGMsNkJBc0hJRCxJQXRISixFQXNIVThCLFNBdEhWLEVBc0hxQjtBQUFBLFFBRzlCQyxVQUg4QjtBQUFBLFFBSTlCaGhCLElBSjhCO0FBQUE7QUFBQSxRQUMzQndELE1BRDJCLEdBQ2pCLElBRGlCLENBQzNCQSxNQUQyQjtBQUFBLFFBRTVCeWQsT0FGNEIsR0FFTixFQUZNOztBQU1sQyxRQUFJN21CLE9BQU8sQ0FBQzZrQixJQUFELENBQVgsRUFBbUI7QUFDbEIsVUFBTWhsQixJQUFJLEdBQUc4bUIsU0FBUyxJQUFJdmQsTUFBTSxDQUFDaFUsU0FBakM7QUFFSXlLLFVBQUksQ0FBQ3pPLENBSFMsSUFJakJ3MUIsVUFBVSxHQUFHL21CLElBQUksQ0FBQ2UsS0FBTCxDQUFXZ0UsTUFBWCxDQUFrQi9FLElBQUksQ0FBQ3pPLENBQXZCLENBSkksRUFLakJnWSxNQUFNLENBQUNoUixNQUFQLEdBQWdCeUgsSUFBSSxDQUFDek8sQ0FMSixJQU9qQncxQixVQUFVLEdBQUcvbUIsSUFBSSxDQUFDZSxLQVBELEVBVWxCaW1CLE9BQU8sQ0FBQy9mLElBQVIsQ0FBYThmLFVBQWIsQ0FWa0IsRUFZbEIvQixJQUFJLENBQUMvakIsT0FBTCxDQUFhLFVBQUE3QyxDQUFDLEVBQUk7QUFDakIsWUFBTTZvQixNQUFNLEdBQUdGLFVBQVUsQ0FBQy9rQixHQUFYLENBQWUsVUFBQXJCLEdBQUcsRUFBSTtBQUNwQztBQUNBLGNBQUk5QixDQUFDLEdBQUcsTUFBSSxDQUFDcW9CLGVBQUwsQ0FBcUI5b0IsQ0FBckIsRUFBd0J1QyxHQUF4QixDQUFSOztBQU1BLGlCQUpJMUIsV0FBVyxDQUFDSixDQUFELENBSWYsS0FIQ0EsQ0FBQyxHQUFHLElBR0wsR0FBT0EsQ0FBUDtBQUNBLFNBVGMsQ0FBZjtBQVdBbW9CLGVBQU8sQ0FBQy9mLElBQVIsQ0FBYWdnQixNQUFiLENBWmlCO0FBYWpCLE9BYkQsQ0Faa0IsRUEyQmxCbGhCLElBQUksR0FBRyxLQUFLb2YsaUJBQUwsQ0FBdUI2QixPQUF2QixDQTNCVztBQTRCbEIsS0E1QkQsTUE2QkNqbkIsTUFBTSxDQUFDQyxJQUFQLENBQVlnbEIsSUFBWixFQUFrQi9qQixPQUFsQixDQUEwQixVQUFBTixHQUFHLEVBQUk7QUFDaEMsVUFBTXdtQixHQUFHLEdBQUduQyxJQUFJLENBQUNya0IsR0FBRCxDQUFKLENBQVVvRSxNQUFWLEVBQVo7QUFFQW9pQixTQUFHLENBQUMvUixPQUFKLENBQVl6VSxHQUFaLENBSGdDLEVBSWhDcW1CLE9BQU8sQ0FBQy9mLElBQVIsQ0FBYWtnQixHQUFiLENBSmdDO0FBS2hDLEtBTEQsQ0E3QkQsRUFvQ0NwaEIsSUFBSSxHQUFHLEtBQUtzZixvQkFBTCxDQUEwQjJCLE9BQTFCLENBcENSOztBQXVDQSxXQUFPamhCLElBQVA7QUFDQSxHQXBLYTtBQXNLZG1oQixpQkF0S2MsMkJBc0tFRSxNQXRLRixFQXNLVTkwQixJQXRLVixFQXNLZ0I7QUFDN0IsUUFBSTgwQixNQUFNLENBQUM5MEIsSUFBRCxDQUFOLEtBQWlCK0IsU0FBckIsRUFDQyxPQUFPK3lCLE1BQU0sQ0FBQzkwQixJQUFELENBQWI7QUFGNEIsUUFLdkIrMEIsYUFBYSxHQUFHLzBCLElBQUksQ0FBQ21QLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLEtBQTNCLENBTE87QUFBQSxRQU12QjZsQixTQUFTLEdBQUdELGFBQWEsQ0FBQzVsQixPQUFkLENBQXNCLEtBQXRCLEVBQTZCLEVBQTdCLEVBQWlDUyxLQUFqQyxDQUF1QyxHQUF2QyxDQU5XO0FBQUEsUUFPekIzVCxNQUFNLEdBQUc2NEIsTUFQZ0IsRUFLNEI7O0FBU3pELFdBTEFFLFNBQVMsQ0FBQ0MsSUFBVixDQUFlLFVBQUFDLENBQUM7QUFBQSxhQUFJLEVBQ25CajVCLE1BQU0sR0FBR0EsTUFBTSxJQUFJaTVCLENBQUMsSUFBSWo1QixNQUFmLEdBQ1JBLE1BQU0sQ0FBQ2k1QixDQUFELENBREUsR0FDSW56QixTQUZNLENBQUo7QUFBQSxLQUFoQixDQUtBLEVBQU85RixNQUFQO0FBQ0EsR0FyTGE7QUF1TGQ0MkIsbUJBdkxjLDZCQXVMSUQsSUF2TEosRUF1TFU7QUFBQSxRQUNqQmxsQixJQUFJLEdBQUdrbEIsSUFBSSxDQUFDLENBQUQsQ0FETTtBQUFBLFFBRWpCOEIsT0FBYyxHQUFHLEVBRkE7QUFvQnZCLFdBaEJBOUIsSUFBSSxDQUFDamtCLE9BQUwsQ0FBYSxVQUFDd21CLEdBQUQsRUFBTXBsQixDQUFOLEVBQVk7QUFDeEIsVUFBSUEsQ0FBQyxHQUFHLENBQVIsRUFBVztBQUNWLFlBQU00a0IsTUFBTSxHQUFHLEVBQWY7QUFFQVEsV0FBRyxDQUFDeG1CLE9BQUosQ0FBWSxVQUFDcEMsQ0FBRCxFQUFJNm9CLENBQUosRUFBVTtBQUNyQixjQUFJem9CLFdBQVcsQ0FBQ0osQ0FBRCxDQUFmLEVBQ0MsTUFBTSxJQUFJeW1CLEtBQUosNkNBQW9EampCLENBQXBELFVBQTBEcWxCLENBQTFELFFBQU47QUFHRFQsZ0JBQU0sQ0FBQ2puQixJQUFJLENBQUMwbkIsQ0FBRCxDQUFMLENBQU4sR0FBa0I3b0IsQ0FMRztBQU1yQixTQU5ELENBSFUsRUFXVm1vQixPQUFPLENBQUMvZixJQUFSLENBQWFnZ0IsTUFBYixDQVhVO0FBWVY7QUFDRCxLQWRELENBZ0JBLEVBQU9ELE9BQVA7QUFDQSxHQTVNYTtBQThNZDNCLHNCQTlNYyxnQ0E4TU9ELE9BOU1QLEVBOE1nQjtBQUM3QixRQUFNNEIsT0FBYyxHQUFHLEVBQXZCO0FBb0JBLFdBbEJBNUIsT0FBTyxDQUFDbmtCLE9BQVIsQ0FBZ0IsVUFBQzBtQixHQUFELEVBQU10bEIsQ0FBTixFQUFZO0FBQzNCLFVBQU0xQixHQUFHLEdBQUdnbkIsR0FBRyxDQUFDLENBQUQsQ0FBZjtBQUVBQSxTQUFHLENBQUMxbUIsT0FBSixDQUFZLFVBQUNwQyxDQUFELEVBQUk2b0IsQ0FBSixFQUFVO0FBQ3JCLFlBQUlBLENBQUMsR0FBRyxDQUFSLEVBQVc7QUFLVixjQUpJem9CLFdBQVcsQ0FBQytuQixPQUFPLENBQUNVLENBQUMsR0FBRyxDQUFMLENBQVIsQ0FJZixLQUhDVixPQUFPLENBQUNVLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUIsRUFHbEIsR0FBSXpvQixXQUFXLENBQUNKLENBQUQsQ0FBZixFQUNDLE1BQU0sSUFBSXltQixLQUFKLDZDQUFvRGpqQixDQUFwRCxVQUEwRHFsQixDQUExRCxRQUFOO0FBR0RWLGlCQUFPLENBQUNVLENBQUMsR0FBRyxDQUFMLENBQVAsQ0FBZS9tQixHQUFmLElBQXNCOUIsQ0FUWjtBQVVWO0FBQ0QsT0FaRCxDQUgyQjtBQWdCM0IsS0FoQkQsQ0FrQkEsRUFBT21vQixPQUFQO0FBQ0EsR0FwT2E7QUFzT2RZLHNCQXRPYyxnQ0FzT083aEIsSUF0T1AsRUFzT2E4aEIsUUF0T2IsRUFzT3VCO0FBQUEsUUFTaENDLE1BVGdDO0FBQUE7QUFBQSxRQUM5QmxVLEVBRDhCLEdBQ3pCLElBRHlCO0FBQUEsUUFFN0JySyxNQUY2QixHQUVacUssRUFGWSxDQUU3QnJLLE1BRjZCO0FBQUEsUUFFckJ6WixLQUZxQixHQUVaOGpCLEVBRlksQ0FFckI5akIsS0FGcUI7QUFBQSxRQUc5QjR0QixZQUg4QixHQUdmOUosRUFBRSxDQUFDOEosWUFBSCxFQUhlO0FBQUEsUUFLOUJxSyxRQUw4QixHQUtuQmhvQixNQUFNLENBQUNDLElBQVAsQ0FBWStGLElBQUksQ0FBQyxDQUFELENBQUosSUFBVyxFQUF2QixDQUxtQjtBQUFBLFFBTTlCaWlCLEdBTjhCLEdBTXhCRCxRQUFRLENBQUNsb0IsTUFBVCxHQUFrQmtvQixRQUFRLENBQUM3aEIsTUFBVCxDQUFnQjBOLEVBQUUsQ0FBQ3FVLE1BQW5CLEVBQTJCclUsRUFBM0IsQ0FBbEIsR0FBbUQsRUFOM0I7QUFBQSxRQU85QnNVLEVBUDhCLEdBT3pCSCxRQUFRLENBQUNsb0IsTUFBVCxHQUFrQmtvQixRQUFRLENBQUM3aEIsTUFBVCxDQUFnQjBOLEVBQUUsQ0FBQ3lKLEdBQW5CLEVBQXdCekosRUFBeEIsQ0FBbEIsR0FBZ0QsRUFQdkI7O0FBWXBDb1UsT0FBRyxDQUFDL21CLE9BQUosQ0FBWSxVQUFBaFAsRUFBRSxFQUFJO0FBQ2pCLFVBQU1rMkIsSUFBSSxHQUFHLE1BQUksQ0FBQ0MsT0FBTCxDQUFhbjJCLEVBQWIsQ0FBYjs7QUFFSSxZQUFJLENBQUNvMkIsU0FBTCxNQUFvQjNLLFlBSFAsR0FLWndLLEVBQUUsQ0FBQ3BtQixPQUFILENBQVdxbUIsSUFBWCxLQUFvQixDQUxSLEdBTWZMLE1BQU0sR0FBRyxDQUFFRCxRQUFRLElBQUlqVSxFQUFFLENBQUM3TixJQUFILENBQVFtaUIsRUFBUixDQUFXajJCLEVBQVgsQ0FBYixJQUFnQyxFQUFqQyxFQUNQOFMsTUFETyxDQUVQZ0IsSUFBSSxDQUFDL0QsR0FBTCxDQUFTLFVBQUF0QyxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDeW9CLElBQUQsQ0FBTDtBQUFBLE9BQVYsRUFDRWppQixNQURGLENBQ1N0SCxPQURULEVBRUVvRCxHQUZGLENBRU0sVUFBQ3NtQixJQUFELEVBQU9qbUIsQ0FBUDtBQUFBLGVBQWF1UixFQUFFLENBQUMyVSxlQUFILENBQW1CRCxJQUFuQixFQUF5QnIyQixFQUF6QixFQUE2Qm9RLENBQTdCLENBQWI7QUFBQSxPQUZOLENBRk8sQ0FOTSxHQVlMa0gsTUFBTSxDQUFDaFIsTUFaRixHQWNmdXZCLE1BQU0sR0FBRyxNQUFJLENBQUNVLGdCQUFMLEVBZE0sR0FlTHRvQixRQUFRLENBQUNxSixNQUFNLENBQUMvUSxPQUFSLENBZkgsS0FpQmZzdkIsTUFBTSxHQUFHbFUsRUFBRSxDQUFDNlUsZ0JBQUgsQ0FBb0JOLElBQXBCLEVBQTBCdlUsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBbEMsQ0FqQk0sSUFxQmhCcVUsTUFBTSxHQUFHL2hCLElBQUksQ0FBQy9ELEdBQUwsQ0FBUyxVQUFDdEMsQ0FBRCxFQUFJMkMsQ0FBSjtBQUFBLGVBQVVBLENBQVY7QUFBQSxPQUFULENBckJPLEVBd0JqQnlsQixNQUFNLEtBQUssTUFBSSxDQUFDL2hCLElBQUwsQ0FBVW1pQixFQUFWLENBQWFqMkIsRUFBYixJQUFtQjYxQixNQUF4QixDQXhCVztBQXlCakIsS0F6QkQsQ0Fab0MsRUF3Q3BDRSxHQUFHLENBQUMvbUIsT0FBSixDQUFZLFVBQUFoUCxFQUFFLEVBQUk7QUFDakIsVUFBSSxDQUFDLE1BQUksQ0FBQzhULElBQUwsQ0FBVW1pQixFQUFWLENBQWFqMkIsRUFBYixDQUFMLEVBQ0MsTUFBTSxJQUFJcXpCLEtBQUosa0NBQXdDcnpCLEVBQXhDLFNBQU47QUFFRCxLQUpELENBeENvQztBQThDcEM7QUFDQSxRQUFNd2hCLE9BQU8sR0FBR3VVLEdBQUcsQ0FBQ2htQixHQUFKLENBQVEsVUFBQy9QLEVBQUQsRUFBS2duQixLQUFMLEVBQWU7QUFBQSxVQUNoQ3lQLFdBQVcsR0FBR25mLE1BQU0sQ0FBQ3RWLGdCQUFQLENBQXdCOGlCLElBQXhCLENBQTZCbkQsRUFBRSxDQUFDZ0osR0FBaEMsRUFBcUMzcUIsRUFBckMsQ0FEa0I7QUFBQSxVQUVoQ2syQixJQUFJLEdBQUd2VSxFQUFFLENBQUN3VSxPQUFILENBQVduMkIsRUFBWCxDQUZ5QjtBQUFBLFVBR2hDcXJCLGFBQWEsR0FBRzFKLEVBQUUsQ0FBQ3lVLFNBQUgsTUFBa0J6VSxFQUFFLENBQUMwSixhQUFILEVBSEY7QUFBQSxVQUloQ3FMLFdBQVcsR0FBR3JMLGFBQWEsSUFBSXZYLElBQUksQ0FBQy9ELEdBQUwsQ0FBUyxVQUFBbkQsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ3ROLENBQU47QUFBQSxPQUFWLEVBQ25DbVYsS0FEbUMsQ0FDN0IsVUFBQTdILENBQUM7QUFBQSxlQUFJMEssTUFBTSxDQUFDelAsaUJBQVAsQ0FBeUJnSSxPQUF6QixDQUFpQ2pELENBQWpDLElBQXNDLENBQUMsQ0FBM0M7QUFBQSxPQUQ0QixDQUpDO0FBT3RDLGFBQU87QUFDTjVNLFVBQUUsRUFBRXkyQixXQURFO0FBRU43VSxjQUFNLEVBQUU1aEIsRUFGRjtBQUdONmhCLGNBQU0sRUFBRS9OLElBQUksQ0FBQy9ELEdBQUwsQ0FBUyxVQUFDdEMsQ0FBRCxFQUFJMkMsQ0FBSixFQUFVO0FBQUEsY0FHdEI5USxDQUhzQjtBQUFBLGNBQ3BCKzJCLElBQUksR0FBRzVvQixDQUFDLENBQUN5b0IsSUFBRCxDQURZO0FBQUEsY0FFdEJwbkIsS0FBSyxHQUFHckIsQ0FBQyxDQUFDek4sRUFBRCxDQUZhO0FBNkIxQixpQkF4QkE4TyxLQUFLLEdBQUdBLEtBQUssS0FBSyxJQUFWLElBQW1CZCxLQUFLLENBQUNjLEtBQUQsQ0FBeEIsSUFBb0NULFFBQVEsQ0FBQ1MsS0FBRCxDQUE1QyxHQUNHWixPQUFPLENBQUNZLEtBQUQsQ0FBUCxJQUFrQlQsUUFBUSxDQUFDUyxLQUFELENBQTFCLEdBQW9DQSxLQUFwQyxHQUE0QyxJQUQvQyxHQUNQLENBQUNBLEtBdUJGLEVBcEJJdWMsYUFBYSxJQUFJckUsS0FBSyxLQUFLLENBQTNCLElBQWdDLENBQUNoYSxXQUFXLENBQUNxcEIsSUFBRCxDQW9CaEQsSUFuQkssQ0FBQ0ssV0FBRCxJQUFnQjFQLEtBQUssS0FBSyxDQUExQixJQUErQjVXLENBQUMsS0FBSyxDQW1CMUMsS0FsQkVrSCxNQUFNLENBQUN6UCxpQkFBUCxHQUEyQixFQWtCN0IsR0FmQ3ZJLENBQUMsR0FBR2dZLE1BQU0sQ0FBQ3pQLGlCQUFQLENBQXlCZ0ksT0FBekIsQ0FBaUN3bUIsSUFBakMsQ0FlTCxFQWJLLzJCLENBQUMsS0FBSyxDQUFDLENBYVosS0FaRUEsQ0FBQyxHQUFHZ1ksTUFBTSxDQUFDelAsaUJBQVAsQ0FBeUIrRixNQVkvQixFQVhFMEosTUFBTSxDQUFDelAsaUJBQVAsQ0FBeUJtTixJQUF6QixDQUE4QnFoQixJQUE5QixDQVdGLEtBUkMvMkIsQ0FBQyxHQUFHcWlCLEVBQUUsQ0FBQzJVLGVBQUgsQ0FBbUJELElBQW5CLEVBQXlCcjJCLEVBQXpCLEVBQTZCb1EsQ0FBN0IsQ0FRTCxHQUpJcEQsV0FBVyxDQUFDOEIsS0FBRCxDQUFYLElBQXNCNlMsRUFBRSxDQUFDN04sSUFBSCxDQUFRbWlCLEVBQVIsQ0FBV2oyQixFQUFYLEVBQWU0TixNQUFmLElBQXlCd0MsQ0FJbkQsTUFIQzlRLENBQUMsR0FBRzhDLFNBR0wsR0FBTztBQUFDOUMsYUFBQyxFQUFEQSxDQUFEO0FBQUl3UCxpQkFBSyxFQUFMQSxLQUFKO0FBQVc5TyxjQUFFLEVBQUV5MkI7QUFBZixXQUFQO0FBQ0EsU0E5Qk8sRUE4Qkx4aUIsTUE5QkssQ0E4QkUsVUFBQXJILENBQUM7QUFBQSxpQkFBSUssU0FBUyxDQUFDTCxDQUFDLENBQUN0TixDQUFILENBQWI7QUFBQSxTQTlCSDtBQUhGLE9BQVA7QUFtQ0EsS0ExQ2UsQ0FBaEIsQ0EvQ29DLENBMkZwQzs7QUFnQ0EsV0EvQkFraUIsT0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBbWEsQ0FBQyxFQUFJO0FBRWhCN1IsWUFBTSxDQUFDNVEsVUFGUyxLQUduQnlpQixDQUFDLENBQUN0SCxNQUFGLEdBQVdzSCxDQUFDLENBQUN0SCxNQUFGLENBQVNuTixJQUFULENBQWMsVUFBQ2lpQixFQUFELEVBQUtDLEVBQUwsRUFBWTtBQUFBLFlBQzlCLzBCLEVBQUUsR0FBRzgwQixFQUFFLENBQUNyM0IsQ0FBSCxJQUFRcTNCLEVBQUUsQ0FBQ3IzQixDQUFILEtBQVMsQ0FBakIsR0FBcUJxM0IsRUFBRSxDQUFDcjNCLENBQXhCLEdBQTRCMHBCLFFBREg7QUFBQSxZQUU5QmxuQixFQUFFLEdBQUc4MEIsRUFBRSxDQUFDdDNCLENBQUgsSUFBUXMzQixFQUFFLENBQUN0M0IsQ0FBSCxLQUFTLENBQWpCLEdBQXFCczNCLEVBQUUsQ0FBQ3QzQixDQUF4QixHQUE0QjBwQixRQUZIO0FBSXBDLGVBQU9ubkIsRUFBRSxHQUFHQyxFQUFaO0FBQ0EsT0FMVSxDQUhRLEdBWXBCcW5CLENBQUMsQ0FBQ3RILE1BQUYsQ0FBUzdTLE9BQVQsQ0FBaUIsVUFBQ3BDLENBQUQsRUFBSXdELENBQUo7QUFBQSxlQUFXeEQsQ0FBQyxDQUFDb2EsS0FBRixHQUFVNVcsQ0FBckI7QUFBQSxPQUFqQixDQVpvQixFQWVwQnVSLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUW1pQixFQUFSLENBQVc5TSxDQUFDLENBQUNucEIsRUFBYixFQUFpQjBVLElBQWpCLENBQXNCLFVBQUNpaUIsRUFBRCxFQUFLQyxFQUFMO0FBQUEsZUFBWUQsRUFBRSxHQUFHQyxFQUFqQjtBQUFBLE9BQXRCLENBZm9CO0FBZ0JwQixLQWhCRCxDQStCQSxFQVpBLzRCLEtBQUssQ0FBQ21ELGdCQUFOLEdBQXlCMmdCLEVBQUUsQ0FBQ2tWLHlCQUFILENBQTZCclYsT0FBN0IsQ0FZekIsRUFYQTNqQixLQUFLLENBQUNvRCxnQkFBTixHQUF5QjBnQixFQUFFLENBQUNtVix5QkFBSCxDQUE2QnRWLE9BQTdCLENBV3pCLEVBUklsSyxNQUFNLENBQUNuVixTQVFYLElBUEN3ZixFQUFFLENBQUNvVixhQUFILENBQWlCcFYsRUFBRSxDQUFDcVYsUUFBSCxDQUFZeFYsT0FBWixFQUNmdk4sTUFEZSxDQUNSLFVBQUFqVSxFQUFFO0FBQUEsYUFBSSxFQUFFQSxFQUFFLElBQUlzWCxNQUFNLENBQUNqVixVQUFmLENBQUo7QUFBQSxLQURNLENBQWpCLEVBQzRDaVYsTUFBTSxDQUFDblYsU0FEbkQsQ0FPRCxFQUZBcWYsT0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBdkIsQ0FBQztBQUFBLGFBQUlrVSxFQUFFLENBQUNQLEtBQUgsQ0FBU0YsR0FBVCxDQUFhelQsQ0FBQyxDQUFDbVUsTUFBZixFQUF1Qm5VLENBQXZCLEtBQUo7QUFBQSxLQUFqQixDQUVBLEVBQU8rVCxPQUFQO0FBQ0E7QUFsV2EsQ0FBZixFOztBQ2pCQTs7OztBQUlBO0FBQ0E7QUFtQmU7QUFDZDRKLEtBRGMsZUFDVjFjLEdBRFUsRUFDTDtBQUNGLFFBQUFpVCxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQTJmLE9BRkEsR0FFVTNmLE1BQU0sQ0FBQ2hSLE1BQVAsSUFBaUJvSSxHQUFHLEtBQUs0SSxNQUFNLENBQUNoUixNQUYxQztBQUFBLFFBR0E0d0IsVUFIQSxHQUdhanBCLFFBQVEsQ0FBQ3FKLE1BQU0sQ0FBQy9RLE9BQVIsQ0FBUixJQUE0QnFJLGFBQVEsQ0FBQzBJLE1BQU0sQ0FBQy9RLE9BQVIsRUFBaUJtSSxHQUFqQixDQUhqRDtBQUtOLFdBQU91b0IsT0FBTyxJQUFJQyxVQUFsQjtBQUNBLEdBUmE7QUFVZGxCLFFBVmMsa0JBVVB0bkIsR0FWTyxFQVVGO0FBQ1gsV0FBTyxDQUFDLEtBQUswYyxHQUFMLENBQVMxYyxHQUFULENBQVI7QUFDQSxHQVphO0FBY2RpZCxtQkFkYywrQkFjZTtBQUFBLFFBQ3JCclUsTUFEcUIsR0FDWCxJQURXLENBQ3JCQSxNQURxQjtBQUc1QixXQUFPLENBQUMsRUFBRUEsTUFBTSxDQUFDclEsb0JBQVAsSUFBK0JxUSxNQUFNLENBQUMzUSxXQUFQLENBQW1CaUgsTUFBcEQsQ0FBUjtBQUNBLEdBbEJhO0FBb0JkdXBCLFdBcEJjLHFCQW9CSm4zQixFQXBCSSxFQW9CQTtBQUNiLFdBQU8sS0FBS3NYLE1BQUwsQ0FBWTNRLFdBQVosQ0FDTG9KLEdBREssQ0FDRCxVQUFBbkQsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ2lELE9BQUYsQ0FBVTdQLEVBQVYsS0FBaUIsQ0FBckI7QUFBQSxLQURBLEVBQ3dCLENBRHhCLENBQVA7QUFFQSxHQXZCYTtBQXlCZG0yQixTQXpCYyxtQkF5Qk5uMkIsRUF6Qk0sRUF5QkY7QUFDTCxRQUFBMmhCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFHTixXQUFPQSxNQUFNLENBQUNoUixNQUFQLEdBQ05nUixNQUFNLENBQUNoUixNQURELEdBQ1cySCxRQUFRLENBQUNxSixNQUFNLENBQUMvUSxPQUFSLENBQVIsR0FBMkIrUSxNQUFNLENBQUMvUSxPQUFQLENBQWV2RyxFQUFmLENBQTNCLEdBQWdELElBRGxFO0FBRUEsR0EvQmE7QUFpQ2R3MkIsa0JBakNjLDRCQWlDRzluQixHQWpDSCxFQWlDUThTLE9BakNSLEVBaUNpQjtBQUFBLFFBRzFCNFYsT0FIMEI7QUFBQSxRQUN4QnpWLEVBQUUsR0FBRyxJQURtQjtBQUFBLFFBRXhCb1UsR0FBRyxHQUFHdlUsT0FBTyxJQUFJdlQsUUFBUSxDQUFDdVQsT0FBRCxDQUFuQixHQUErQkcsRUFBRSxDQUFDcVYsUUFBSCxDQUFZeFYsT0FBWixDQUEvQixHQUFzRCxFQUZwQztBQVc5QixXQU5BdVUsR0FBRyxDQUFDL21CLE9BQUosQ0FBWSxVQUFBaFAsRUFBRSxFQUFJO0FBQ2IyaEIsUUFBRSxDQUFDd1UsT0FBSCxDQUFXbjJCLEVBQVgsTUFBbUIwTyxHQUROLEtBRWhCMG9CLE9BQU8sR0FBR3pWLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUW1pQixFQUFSLENBQVdqMkIsRUFBWCxDQUZNO0FBSWpCLEtBSkQsQ0FNQSxFQUFPbzNCLE9BQVA7QUFDQSxHQTdDYTs7QUErQ2Q7Ozs7Ozs7QUFPQUMsYUF0RGMsdUJBc0RGLzNCLENBdERFLEVBc0RDZzRCLE1BdERELEVBc0RTO0FBQ3RCLFFBQU0zVixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU8yVixNQUFNLEdBQ1pBLE1BQU0sQ0FBQ3puQixPQUFQLENBQWUvQyxRQUFRLENBQUN4TixDQUFELENBQVIsR0FBY0EsQ0FBZCxHQUFrQixDQUFDQSxDQUFsQyxDQURZLEdBRVosQ0FBQ3FpQixFQUFFLENBQUM0VixTQUFILENBQWE1VixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFyQixFQUE4QmxpQixDQUE5QixFQUFpQyxDQUFqQyxLQUF1QztBQUFDMG5CLFdBQUssRUFBRTtBQUFSLEtBQXhDLEVBQXVEQSxLQUZ4RDtBQUdBLEdBNURhO0FBOERkd1EsV0E5RGMscUJBOERKeDNCLEVBOURJLEVBOERBb1EsQ0E5REEsRUE4REc7QUFDaEIsUUFBTXVSLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBTzNoQixFQUFFLElBQUkyaEIsRUFBRSxDQUFDN04sSUFBSCxDQUFRbWlCLEVBQWQsSUFDTnRVLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUW1pQixFQUFSLENBQVdqMkIsRUFBWCxDQURNLElBRU4yTSxPQUFPLENBQUNnVixFQUFFLENBQUM3TixJQUFILENBQVFtaUIsRUFBUixDQUFXajJCLEVBQVgsRUFBZW9RLENBQWYsQ0FBRCxDQUZELEdBRXVCdVIsRUFBRSxDQUFDN04sSUFBSCxDQUFRbWlCLEVBQVIsQ0FBV2oyQixFQUFYLEVBQWVvUSxDQUFmLENBRnZCLEdBRTJDQSxDQUZsRDtBQUdBLEdBcEVhO0FBc0VkbW1CLGtCQXRFYyw4QkFzRUs7QUFBQSxRQUNaNVUsRUFBRSxHQUFHLElBRE87QUFBQSxRQUVaOFYsT0FBTyxHQUFHM3BCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZNFQsRUFBRSxDQUFDN04sSUFBSCxDQUFRbWlCLEVBQXBCLENBRkU7QUFJbEIsV0FBT3dCLE9BQU8sQ0FBQzdwQixNQUFSLEdBQWlCK1QsRUFBRSxDQUFDN04sSUFBSCxDQUFRbWlCLEVBQVIsQ0FBV3dCLE9BQU8sQ0FBQyxDQUFELENBQWxCLENBQWpCLEdBQTBDLElBQWpEO0FBQ0EsR0EzRWE7QUE2RWRDLGlCQTdFYywyQkE2RUUxUSxLQTdFRixFQTZFUztBQUN0QixRQUFNaVAsRUFBRSxHQUFHLEtBQUtNLGdCQUFMLEVBQVg7QUFFQSxXQUFPTixFQUFFLElBQUlqUCxLQUFLLEdBQUdpUCxFQUFFLENBQUNyb0IsTUFBakIsR0FBMEJxb0IsRUFBRSxDQUFDalAsS0FBRCxDQUE1QixHQUFzQyxJQUE3QztBQUNBLEdBakZhO0FBbUZkMlEsT0FuRmMsaUJBbUZSMUIsRUFuRlEsRUFtRko7QUFDSCxRQUFBdFUsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdOeEosVUFBTSxDQUFDQyxJQUFQLENBQVlrb0IsRUFBWixFQUFnQmpuQixPQUFoQixDQUF3QixVQUFBaFAsRUFBRSxFQUFJO0FBQzdCc1gsWUFBTSxDQUFDL1EsT0FBUCxDQUFldkcsRUFBZixJQUFxQmkyQixFQUFFLENBQUNqMkIsRUFBRCxDQURNO0FBRTdCLEtBRkQsQ0FKUztBQU9ULEdBMUZhO0FBNEZkNDNCLGFBNUZjLHlCQTRGQTtBQUNiLFdBQU8zcEIsUUFBUSxDQUFDLEtBQUtxSixNQUFMLENBQVkvUSxPQUFiLENBQVIsSUFDTixDQUFDLEtBQUsrUSxNQUFMLENBQVk1USxVQURQLElBRU4sS0FBS214QixPQUFMLENBQWEsUUFBYixDQUZNLElBR04sS0FBS0EsT0FBTCxDQUFhLFNBQWIsQ0FIRDtBQUlBLEdBakdhO0FBbUdkQyxTQW5HYyxtQkFtR05oa0IsSUFuR00sRUFtR0E7QUFHVCxRQUFBMFIsSUFBSTtBQUFBLFFBRkY3RCxFQUVFLEdBRkcsSUFFSDtBQUFBLFFBRERySyxNQUNDLEdBRFNxSyxFQUNULENBRERySyxNQUNDO0FBT1IsV0FMSXhELElBS0osS0FKQzBSLElBQUksR0FBR2xPLE1BQU0sQ0FBQ3JWLFVBQVAsQ0FBa0I2UixJQUFJLENBQUM5VCxFQUF2QixDQUlSLEVBSEM4VCxJQUFJLENBQUMwUixJQUFMLEdBQVlBLElBQUksS0FBS3BqQixTQUFULEdBQTRCMFIsSUFBSSxDQUFDOVQsRUFBakMsR0FBcUJ3bEIsSUFHbEMsR0FBTzFSLElBQVA7QUFDQSxHQTlHYTtBQWdIZGlrQixxQkFoSGMsK0JBZ0hNL1EsS0FoSE4sRUFnSGE7QUFDMUIsUUFBTXJGLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDNE4sbUJBQUgsQ0FBdUI1TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUEvQixFQUNMelIsR0FESyxDQUNELFVBQUFvWixDQUFDO0FBQUEsYUFBSXhILEVBQUUsQ0FBQ21XLE9BQUgsQ0FBV25XLEVBQUUsQ0FBQ3FXLGVBQUgsQ0FBbUI3TyxDQUFDLENBQUN0SCxNQUFyQixFQUE2Qm1GLEtBQTdCLENBQVgsQ0FBSjtBQUFBLEtBREEsQ0FBUDtBQUVBLEdBckhhO0FBdUhkZ1IsaUJBdkhjLDJCQXVIRW5XLE1BdkhGLEVBdUhVbUYsS0F2SFYsRUF1SGlCO0FBQzlCLFFBQU1pUixZQUFZLEdBQUdwVyxNQUFNLENBQUM1TixNQUFQLENBQWMsVUFBQXJILENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNvYSxLQUFGLEtBQVlBLEtBQWhCO0FBQUEsS0FBZixDQUFyQjtBQUVBLFdBQU9pUixZQUFZLENBQUNycUIsTUFBYixHQUFzQnFxQixZQUFZLENBQUMsQ0FBRCxDQUFsQyxHQUF3QyxJQUEvQztBQUNBLEdBM0hhO0FBNkhkQyxlQTdIYyx5QkE2SEExVyxPQTdIQSxFQTZIU2xpQixDQTdIVCxFQTZIWTtBQUN6QixRQUFNcWlCLEVBQUUsR0FBRyxJQUFYO0FBRUFILFdBQU8sQ0FBQ3hTLE9BQVIsQ0FBZ0IsVUFBQW1hLENBQUMsRUFBSTtBQUNwQkEsT0FBQyxDQUFDdEgsTUFBRixDQUFTN1MsT0FBVCxDQUFpQixVQUFDcEMsQ0FBRCxFQUFJd0QsQ0FBSixFQUFVO0FBQzFCeEQsU0FBQyxDQUFDdE4sQ0FBRixHQUFNcWlCLEVBQUUsQ0FBQzJVLGVBQUgsQ0FBbUJoM0IsQ0FBQyxDQUFDOFEsQ0FBRCxDQUFwQixFQUF5QitZLENBQUMsQ0FBQ25wQixFQUEzQixFQUErQm9RLENBQS9CLENBRG9CO0FBRTFCLE9BRkQsQ0FEb0IsRUFLcEJ1UixFQUFFLENBQUM3TixJQUFILENBQVFtaUIsRUFBUixDQUFXOU0sQ0FBQyxDQUFDbnBCLEVBQWIsSUFBbUJWLENBTEM7QUFNcEIsS0FORCxDQUh5QjtBQVV6QixHQXZJYTtBQXlJZDY0QixnQkF6SWMsMEJBeUlDM1csT0F6SUQsRUF5SVV5VSxFQXpJVixFQXlJYztBQUMzQixRQUFNdFUsRUFBRSxHQUFHLElBQVg7QUFFQUgsV0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBbWEsQ0FBQyxFQUFJO0FBQ3BCOE0sUUFBRSxDQUFDOU0sQ0FBQyxDQUFDbnBCLEVBQUgsQ0FBRixJQUFZMmhCLEVBQUUsQ0FBQ3VXLGFBQUgsQ0FBaUIsQ0FBQy9PLENBQUQsQ0FBakIsRUFBc0I4TSxFQUFFLENBQUM5TSxDQUFDLENBQUNucEIsRUFBSCxDQUF4QixDQURRO0FBRXBCLEtBRkQsQ0FIMkI7QUFNM0IsR0EvSWE7QUFpSmRzMkIsaUJBakpjLDJCQWlKRUQsSUFqSkYsRUFpSlFyMkIsRUFqSlIsRUFpSllnbkIsS0FqSlosRUFpSm1CO0FBQUEsUUFDMUJyRixFQUFFLEdBQUcsSUFEcUI7QUFBQSxRQUU1QnJpQixDQUFDLEdBQUdxaUIsRUFBRSxDQUFDMEosYUFBSCxLQUFxQnJFLEtBQXJCLEdBQThCcVAsSUFBSSxJQUFJclAsS0FGZDs7QUFJaEMsUUFBSXJGLEVBQUUsQ0FBQzhKLFlBQUgsRUFBSixFQUF1QjtBQUN0QixVQUFNdmMsRUFBRSxHQUFHaUksU0FBUyxDQUFDMk4sSUFBVixDQUFlbkQsRUFBZixDQUFYO0FBRUFyaUIsT0FBQyxHQUFHKzJCLElBQUksR0FBR25uQixFQUFFLENBQUNtbkIsSUFBRCxDQUFMLEdBQWNubkIsRUFBRSxDQUFDeVMsRUFBRSxDQUFDNlYsU0FBSCxDQUFheDNCLEVBQWIsRUFBaUJnbkIsS0FBakIsQ0FBRCxDQUhGO0FBSXRCLEtBSkQsTUFJV3JGLEVBQUUsQ0FBQ3lVLFNBQUgsTUFBa0IsQ0FBQ3pVLEVBQUUsQ0FBQzBKLGFBQUgsRUFKOUIsS0FLQy9yQixDQUFDLEdBQUdxTixPQUFPLENBQUMwcEIsSUFBRCxDQUFQLEdBQWdCLENBQUNBLElBQWpCLEdBQXdCMVUsRUFBRSxDQUFDNlYsU0FBSCxDQUFheDNCLEVBQWIsRUFBaUJnbkIsS0FBakIsQ0FMN0I7O0FBUUEsV0FBTzFuQixDQUFQO0FBQ0EsR0E5SmE7QUFnS2Q4NEIsVUFoS2Msb0JBZ0tMdlcsTUFoS0ssRUFnS0c7QUFDWkEsVUFBTSxDQUFDalUsTUFESyxLQUVmLEtBQUt6VixJQUFMLENBQVU4OUIsRUFBVixHQUFlcFUsTUFBTSxDQUFDOVIsR0FBUCxDQUFXLFVBQUFuRCxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDdE4sQ0FBTjtBQUFBLEtBQVosQ0FGQTtBQUloQixHQXBLYTtBQXNLZCs0QixVQXRLYyxvQkFzS0xqb0IsQ0F0S0ssRUFzS0Y7QUFDWCxRQUFNOVEsQ0FBQyxHQUFHLEtBQUtuSCxJQUFMLENBQVU4OUIsRUFBVixDQUFhN2xCLENBQUMsR0FBRyxDQUFqQixDQUFWO0FBRUEsV0FBT25ELFNBQVMsQ0FBQzNOLENBQUQsQ0FBVCxHQUFlQSxDQUFmLEdBQW1CLElBQTFCO0FBQ0EsR0ExS2E7QUE0S2RnNUIsVUE1S2Msb0JBNEtMbG9CLENBNUtLLEVBNEtGO0FBQ1gsUUFBTTlRLENBQUMsR0FBRyxLQUFLbkgsSUFBTCxDQUFVODlCLEVBQVYsQ0FBYTdsQixDQUFDLEdBQUcsQ0FBakIsQ0FBVjtBQUVBLFdBQU9uRCxTQUFTLENBQUMzTixDQUFELENBQVQsR0FBZUEsQ0FBZixHQUFtQixJQUExQjtBQUNBLEdBaExhOztBQWtMZDs7Ozs7O0FBTUFpNUIsY0F4TGMsd0JBd0xEemtCLElBeExDLEVBd0xLO0FBQUEsUUFDWjZOLEVBQUUsR0FBRyxJQURPO0FBQUEsUUFFZDdTLEtBQUssR0FBR2dGLElBQUksQ0FBQ2hGLEtBRkM7QUFhbEIsV0FQSUEsS0FBSyxJQUFJNlMsRUFBRSxDQUFDNlcsT0FPaEIsS0FOSzdXLEVBQUUsQ0FBQzhXLGVBQUgsQ0FBbUIza0IsSUFBbkIsQ0FNTCxHQUxFaEYsS0FBSyxHQUFHNlMsRUFBRSxDQUFDK1csZ0JBQUgsQ0FBb0I1a0IsSUFBcEIsRUFBMEIsS0FBMUIsQ0FLVixHQUpZNk4sRUFBRSxDQUFDZ1gsYUFBSCxDQUFpQjdrQixJQUFqQixDQUlaLEtBSEVoRixLQUFLLEdBQUc2UyxFQUFFLENBQUNpWCxjQUFILENBQWtCOXBCLEtBQWxCLEVBQXlCLEdBQXpCLENBR1YsSUFBT0EsS0FBUDtBQUNBLEdBdE1hOztBQXdNZDs7Ozs7O0FBTUErcEIsZ0JBOU1jLDBCQThNQy9rQixJQTlNRCxFQThNTztBQUFBLFFBRWhCbEQsR0FGZ0I7QUFBQSxRQUdoQjJULEdBSGdCO0FBQUEsUUFDZGdVLFlBQVksR0FBRyxLQUFLQSxZQUFMLENBQWtCelQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FERDtBQWFwQixXQVJBLENBQUNoUixJQUFJLElBQUksS0FBS0EsSUFBTCxDQUFVME4sT0FBVixDQUFrQnpSLEdBQWxCLENBQXNCLFVBQUFvWixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDdEgsTUFBTjtBQUFBLEtBQXZCLENBQVQsRUFDRTdTLE9BREYsQ0FDVSxVQUFDcEMsQ0FBRCxFQUFJd0QsQ0FBSixFQUFVO0FBQ2xCLFVBQU10QixLQUFLLEdBQUdsQyxDQUFDLENBQUNtRCxHQUFGLENBQU13b0IsWUFBTixFQUFvQnRrQixNQUFwQixDQUEyQmxILFFBQTNCLENBQWQ7QUFFQTZELFNBQUcsR0FBR3hELElBQUksQ0FBQ3dELEdBQUwsT0FBQXhELElBQUksR0FBS2dELENBQUMsR0FBR1EsR0FBSCxHQUFTb1ksUUFBZixTQUE0QmxhLEtBQTVCLEVBSFEsRUFJbEJ5VixHQUFHLEdBQUduWCxJQUFJLENBQUNtWCxHQUFMLE9BQUFuWCxJQUFJLEdBQUtnRCxDQUFDLEdBQUdtVSxHQUFILEdBQVMsQ0FBQ3lFLFFBQWhCLFNBQTZCbGEsS0FBN0IsRUFKUTtBQUtsQixLQU5GLENBUUEsRUFBTztBQUFDOEIsU0FBRyxFQUFIQSxHQUFEO0FBQU0yVCxTQUFHLEVBQUhBO0FBQU4sS0FBUDtBQUNBLEdBNU5hOztBQThOZDs7Ozs7QUFLQXVVLGVBbk9jLDJCQW1PRTtBQUFBLFFBQ1RuWCxFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRvWCxRQUFRLEdBQUcsYUFGRjtBQUFBLFFBR1hDLFVBQVUsR0FBR3JYLEVBQUUsQ0FBQ1AsS0FBSCxDQUFTRyxHQUFULENBQWF3WCxRQUFiLENBSEY7O0FBS2YsUUFBSSxDQUFDQyxVQUFMLEVBQWlCO0FBQUEsVUFDVmxsQixJQUFJLEdBQUc2TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCelIsR0FBaEIsQ0FBb0IsVUFBQW9aLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUN0SCxNQUFOO0FBQUEsT0FBckIsQ0FERztBQUFBLFVBRVZvWCxNQUFNLEdBQUd0WCxFQUFFLENBQUNrWCxjQUFILENBQWtCL2tCLElBQWxCLENBRkM7QUFBQSxVQUlabEQsR0FBRyxHQUFHLEVBSk07QUFBQSxVQUtaMlQsR0FBRyxHQUFHLEVBTE07QUFvQmhCO0FBYkF6USxVQUFJLENBQUM5RSxPQUFMLENBQWEsVUFBQXBDLENBQUMsRUFBSTtBQUFBLFlBQ1hzc0IsT0FBTyxHQUFHdlgsRUFBRSxDQUFDd1gsc0JBQUgsQ0FBMEJ2c0IsQ0FBMUIsRUFBNkJxc0IsTUFBTSxDQUFDcm9CLEdBQXBDLENBREM7QUFBQSxZQUVYd29CLE9BQU8sR0FBR3pYLEVBQUUsQ0FBQ3dYLHNCQUFILENBQTBCdnNCLENBQTFCLEVBQTZCcXNCLE1BQU0sQ0FBQzFVLEdBQXBDLENBRkM7QUFJYjJVLGVBQU8sQ0FBQ3RyQixNQUpLLEtBS2hCZ0QsR0FBRyxHQUFHQSxHQUFHLENBQUNrQyxNQUFKLENBQVdvbUIsT0FBWCxDQUxVLEdBUWJFLE9BQU8sQ0FBQ3hyQixNQVJLLEtBU2hCMlcsR0FBRyxHQUFHQSxHQUFHLENBQUN6UixNQUFKLENBQVdzbUIsT0FBWCxDQVRVO0FBV2pCLE9BWEQsQ0FQZ0IsRUFxQmhCelgsRUFBRSxDQUFDUCxLQUFILENBQVNGLEdBQVQsQ0FBYTZYLFFBQWIsRUFBdUJDLFVBQVUsR0FBRztBQUFDcG9CLFdBQUcsRUFBSEEsR0FBRDtBQUFNMlQsV0FBRyxFQUFIQTtBQUFOLE9BQXBDLENBckJnQjtBQXNCaEI7O0FBRUQsV0FBT3lVLFVBQVA7QUFDQSxHQWpRYTs7QUFtUWQ7Ozs7O0FBS0FLLGtCQXhRYyw4QkF3UUs7QUFBQSxRQUNaMVgsRUFBRSxHQUFHLElBRE87QUFBQSxRQUdkMlgsR0FBRyxHQUFHM1gsRUFBRSxDQUFDUCxLQUFILENBQVNHLEdBQVQsQ0FETyxnQkFDUCxDQUhRO0FBbUJsQixXQWRJSSxFQUFFLENBQUNnSyxpQkFBSCxNQUEwQixDQUFDMk4sR0FjL0IsS0FiQ0EsR0FBRyxHQUFHLEVBYVAsRUFYQzNYLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQVIsQ0FBZ0J4UyxPQUFoQixDQUF3QixVQUFBd21CLEdBQUcsRUFBSTtBQUM5QkEsU0FBRyxDQUFDM1QsTUFBSixDQUFXN1MsT0FBWCxDQUFtQixVQUFDcEMsQ0FBRCxFQUFJd0QsQ0FBSixFQUFVO0FBQ3ZCa3BCLFdBQUcsQ0FBQ2xwQixDQUFELENBRG9CLEtBRTNCa3BCLEdBQUcsQ0FBQ2xwQixDQUFELENBQUgsR0FBUyxDQUZrQixHQUs1QmtwQixHQUFHLENBQUNscEIsQ0FBRCxDQUFILElBQVVyRCxRQUFRLENBQUNILENBQUMsQ0FBQ2tDLEtBQUgsQ0FBUixHQUFvQmxDLENBQUMsQ0FBQ2tDLEtBQXRCLEdBQThCLENBTFo7QUFNNUIsT0FORCxDQUQ4QjtBQVE5QixLQVJELENBV0QsR0FBT3dxQixHQUFQO0FBQ0EsR0E1UmE7O0FBOFJkOzs7OztBQUtBQyxpQkFuU2MsNkJBbVNJO0FBQUEsUUFDWDVYLEVBQUUsR0FBRyxJQURNO0FBQUEsUUFFWG9YLFFBQVEsR0FBRyxlQUZBO0FBQUEsUUFHYlMsWUFBWSxHQUFHN1gsRUFBRSxDQUFDUCxLQUFILENBQVNHLEdBQVQsQ0FBYXdYLFFBQWIsQ0FIRjs7QUFLakIsUUFBSSxDQUFDUyxZQUFMLEVBQW1CO0FBQ2xCLFVBQU1DLEtBQUssR0FBR3ZsQixVQUFVLENBQUN5TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCelIsR0FBaEIsQ0FBb0IsVUFBQW9aLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUN0SCxNQUFOO0FBQUEsT0FBckIsQ0FBRCxDQUFWLENBQ1o5UixHQURZLENBQ1IsVUFBQW5ELENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNrQyxLQUFOO0FBQUEsT0FETyxFQUVacUYsTUFGWSxDQUVMLFVBQUNqQyxDQUFELEVBQUl5QixDQUFKO0FBQUEsZUFBVXpCLENBQUMsR0FBR3lCLENBQWQ7QUFBQSxPQUZLLENBQWQ7QUFJQWdPLFFBQUUsQ0FBQ1AsS0FBSCxDQUFTRixHQUFULENBQWE2WCxRQUFiLEVBQXVCUyxZQUFZLEdBQUdDLEtBQXRDLENBTGtCO0FBTWxCOztBQUVELFdBQU9ELFlBQVA7QUFDQSxHQWpUYTs7QUFtVGQ7Ozs7Ozs7QUFPQUwsd0JBMVRjLGtDQTBUU3JsQixJQTFUVCxFQTBUZWhGLEtBMVRmLEVBMFRzQjtBQUFBOztBQUNuQyxXQUFPZ0YsSUFBSSxDQUFDRyxNQUFMLENBQVksVUFBQWtWLENBQUM7QUFBQSxhQUFJLEtBQUksQ0FBQ29QLFlBQUwsQ0FBa0JwUCxDQUFsQixNQUF5QnJhLEtBQTdCO0FBQUEsS0FBYixDQUFQO0FBQ0EsR0E1VGE7O0FBOFRkOzs7OztBQUtBNHFCLGlCQW5VYyw2QkFtVUk7QUFDakIsV0FBT3RzQixJQUFJLENBQUNtWCxHQUFMLE9BQUFuWCxJQUFJLEVBQVEsS0FBSzBHLElBQUwsQ0FBVTBOLE9BQVYsQ0FBa0J6UixHQUFsQixDQUFzQixVQUFBb1osQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3RILE1BQUYsQ0FBU2pVLE1BQWI7QUFBQSxLQUF2QixDQUFSLENBQVg7QUFDQSxHQXJVYTtBQXVVZCtyQix1QkF2VWMsbUNBdVVVO0FBQUEsUUFDbkJyOUIsTUFBTSxHQUFHLEtBQUtpekIsbUJBQUwsTUFBOEIsRUFEcEI7QUFBQSxRQUVqQjNoQixNQUFNLEdBQUd0UixNQUFNLENBQUNzUixNQUZDO0FBZXZCLFdBWElBLE1BQU0sR0FBRyxDQVdiLElBVkN0UixNQUFNLEdBQUdBLE1BQU0sQ0FBQ3lULEdBQVAsQ0FBVyxVQUFBb1osQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3RILE1BQU47QUFBQSxLQUFaLEVBQ1AxTixNQURPLENBQ0EsVUFBQ1YsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsYUFBVUQsQ0FBQyxDQUFDWCxNQUFGLENBQVNZLENBQVQsQ0FBVjtBQUFBLEtBREEsRUFFUDNELEdBRk8sQ0FFSCxVQUFBbkQsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3ROLENBQU47QUFBQSxLQUZFLENBVVYsRUFOQ2hELE1BQU0sR0FBR2lZLGNBQVMsQ0FBQ1YsU0FBUyxDQUFDdlgsTUFBRCxDQUFWLENBQVQsQ0FDUHlULEdBRE8sQ0FDSCxVQUFDelEsQ0FBRCxFQUFJMG5CLEtBQUo7QUFBQSxhQUFlO0FBQUMxbkIsU0FBQyxFQUFEQSxDQUFEO0FBQUkwbkIsYUFBSyxFQUFMQTtBQUFKLE9BQWY7QUFBQSxLQURHLENBTVYsSUFKV3BaLE1BSVgsS0FIQ3RSLE1BQU0sR0FBR0EsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVdWxCLE1BR3BCLEdBQU92bEIsTUFBUDtBQUNBLEdBdlZhO0FBeVZkMDZCLFVBelZjLG9CQXlWTHhWLE9BelZLLEVBeVZJO0FBQ2pCLFdBQU9BLE9BQU8sQ0FBQ3pSLEdBQVIsQ0FBWSxVQUFBdEMsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3pOLEVBQU47QUFBQSxLQUFiLENBQVA7QUFDQSxHQTNWYTtBQTZWZDQ1QixnQkE3VmMsMEJBNlZDN0QsR0E3VkQsRUE2Vk07QUFDbkIsUUFBTXBVLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT29VLEdBQUcsR0FBSTduQixPQUFPLENBQUM2bkIsR0FBRCxDQUFQLEdBQWVBLEdBQUcsQ0FBQ2pqQixNQUFKLEVBQWYsR0FBOEIsQ0FBQ2lqQixHQUFELENBQWxDLEdBQTJDcFUsRUFBRSxDQUFDcVYsUUFBSCxDQUFZclYsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBcEIsQ0FBckQ7QUFDQSxHQWpXYTtBQW1XZHFZLFdBbldjLHFCQW1XSnJZLE9BbldJLEVBbVdLeGhCLEVBbldMLEVBbVdTO0FBQ3RCLFFBQU0rMUIsR0FBRyxHQUFHLEtBQUtpQixRQUFMLENBQWN4VixPQUFkLENBQVo7O0FBRUEsU0FBSyxJQUFXc1ksR0FBWCxFQUFJMXBCLENBQUMsR0FBRyxDQUFiLEVBQXNCMHBCLEdBQUcsR0FBRy9ELEdBQUcsQ0FBQzNsQixDQUFELENBQS9CLEVBQXFDQSxDQUFDLEVBQXRDLEVBQ0MsSUFBSTBwQixHQUFHLEtBQUs5NUIsRUFBWixFQUNDOztBQUlGO0FBQ0EsR0E3V2E7QUErV2QrNUIsZ0JBL1djLDBCQStXQ0MsUUEvV0QsRUErV1c7QUFDeEIsV0FBTyxLQUFLbjhCLEtBQUwsQ0FBV3NELGVBQVgsQ0FBMkIwTyxPQUEzQixDQUFtQ21xQixRQUFuQyxJQUErQyxDQUF0RDtBQUNBLEdBalhhO0FBbVhkQyxnQkFuWGMsMEJBbVhDRCxRQW5YRCxFQW1YVztBQUN4QixXQUFPLEtBQUtuOEIsS0FBTCxDQUFXdUQsZUFBWCxDQUEyQnlPLE9BQTNCLENBQW1DbXFCLFFBQW5DLElBQStDLENBQXREO0FBQ0EsR0FyWGE7QUF1WGR6SyxxQkF2WGMsK0JBdVhNL04sT0F2WE4sRUF1WGU7QUFDNUIsUUFBTUcsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPLENBQUNILE9BQU8sSUFBSUcsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBcEIsRUFBNkJ2TixNQUE3QixDQUFvQyxVQUFBa1YsQ0FBQztBQUFBLGFBQUl4SCxFQUFFLENBQUNvWSxjQUFILENBQWtCNVEsQ0FBQyxDQUFDbnBCLEVBQXBCLENBQUo7QUFBQSxLQUFyQyxDQUFQO0FBQ0EsR0EzWGE7QUE2WGQrckIsc0JBN1hjLGdDQTZYT3ZLLE9BN1hQLEVBNlhnQjtBQUFBLFFBQ3ZCRyxFQUFFLEdBQUcsSUFEa0I7QUFBQSxRQUV6QnNVLEVBQVMsR0FBRyxFQUZhO0FBWTdCLFdBUkl6VSxPQUFPLElBQUlBLE9BQU8sQ0FBQzVULE1BUXZCLEtBUENxb0IsRUFBRSxHQUFHcGlCLFNBQVMsQ0FDYkssVUFBVSxDQUFDc04sT0FBTyxDQUFDelIsR0FBUixDQUFZLFVBQUFvWixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDdEgsTUFBRixDQUFTOVIsR0FBVCxDQUFhLFVBQUFuRCxDQUFDO0FBQUEsZUFBSSxDQUFDQSxDQUFDLENBQUN0TixDQUFQO0FBQUEsT0FBZCxDQUFKO0FBQUEsS0FBYixDQUFELENBREcsQ0FPZixFQUhDMjJCLEVBQUUsR0FBR3RVLEVBQUUsQ0FBQzhKLFlBQUgsS0FBb0J3SyxFQUFFLENBQUNsbUIsR0FBSCxDQUFPLFVBQUF6USxDQUFDO0FBQUEsYUFBSSxJQUFJdU8sSUFBSixDQUFTLENBQUN2TyxDQUFWLENBQUo7QUFBQSxLQUFSLENBQXBCLEdBQWdEMjJCLEVBQUUsQ0FBQ2xtQixHQUFILENBQU8sVUFBQXpRLENBQUM7QUFBQSxhQUFJLENBQUNBLENBQUw7QUFBQSxLQUFSLENBR3RELEdBQU9pVixjQUFTLENBQUMwaEIsRUFBRCxDQUFoQjtBQUNBLEdBMVlhO0FBNFlkaUUsb0JBNVljLDhCQTRZS0MsU0E1WUwsRUE0WWdCO0FBQzdCLFNBQUt0OEIsS0FBTCxDQUFXc0QsZUFBWCxHQUE2QixLQUFLdEQsS0FBTCxDQUFXc0QsZUFBWCxDQUEyQjJSLE1BQTNCLENBQWtDcW5CLFNBQWxDLENBREE7QUFFN0IsR0E5WWE7QUFnWmRDLHVCQWhaYyxpQ0FnWlFELFNBaFpSLEVBZ1ptQjtBQUNoQyxTQUFLdDhCLEtBQUwsQ0FBV3NELGVBQVgsR0FBNkIsS0FBS3RELEtBQUwsQ0FBV3NELGVBQVgsQ0FBMkI4UyxNQUEzQixDQUFrQyxVQUFBalUsRUFBRTtBQUFBLGFBQUltNkIsU0FBUyxDQUFDdHFCLE9BQVYsQ0FBa0I3UCxFQUFsQixJQUF3QixDQUE1QjtBQUFBLEtBQXBDLENBREc7QUFFaEMsR0FsWmE7QUFvWmRxNkIsb0JBcFpjLDhCQW9aS0YsU0FwWkwsRUFvWmdCO0FBQzdCLFNBQUt0OEIsS0FBTCxDQUFXdUQsZUFBWCxHQUE2QixLQUFLdkQsS0FBTCxDQUFXdUQsZUFBWCxDQUEyQjBSLE1BQTNCLENBQWtDcW5CLFNBQWxDLENBREE7QUFFN0IsR0F0WmE7QUF3WmRHLHVCQXhaYyxpQ0F3WlFILFNBeFpSLEVBd1ptQjtBQUNoQyxTQUFLdDhCLEtBQUwsQ0FBV3VELGVBQVgsR0FBNkIsS0FBS3ZELEtBQUwsQ0FBV3VELGVBQVgsQ0FBMkI2UyxNQUEzQixDQUFrQyxVQUFBalUsRUFBRTtBQUFBLGFBQUltNkIsU0FBUyxDQUFDdHFCLE9BQVYsQ0FBa0I3UCxFQUFsQixJQUF3QixDQUE1QjtBQUFBLEtBQXBDLENBREc7QUFFaEMsR0ExWmE7QUE0WmR1NkIsb0JBNVpjLDhCQTRaSy9ZLE9BNVpMLEVBNFpjO0FBQUEsUUFDckJHLEVBQUUsR0FBRyxJQURnQjtBQUFBLFFBRXJCNlksRUFBRSxHQUFHLEVBRmdCO0FBQUEsUUFHckI1QyxXQUFXLEdBQUdqVyxFQUFFLENBQUNpVyxXQUFILEVBSE87QUFBQSxRQUlyQjNCLEVBQUUsR0FBRzJCLFdBQVcsR0FBR2pXLEVBQUUsQ0FBQ29LLG9CQUFILENBQXdCdkssT0FBeEIsRUFDdkJ6UixHQUR1QixDQUNuQixVQUFBbkQsQ0FBQztBQUFBLGFBQUtFLFFBQVEsQ0FBQ0YsQ0FBRCxDQUFSLEdBQWNBLENBQWQsR0FBa0IsQ0FBQ0EsQ0FBeEI7QUFBQSxLQURrQixDQUFILEdBQ2UsSUFMVjtBQStCM0IsV0F4QkE0VSxPQUFPLENBQUN4UyxPQUFSLENBQWdCLFVBQUFtYSxDQUFDLEVBQUk7QUFDcEIsVUFBTXJWLElBQVcsR0FBRyxFQUFwQjtBQUVBcVYsT0FBQyxDQUFDdEgsTUFBRixDQUFTN1MsT0FBVCxDQUFpQixVQUFBcEMsQ0FBQyxFQUFJO0FBQ3JCLFlBQU1rQyxLQUFLLEdBQUdsQyxDQUFDLENBQUNrQyxLQUFoQjtBQUVJWixlQUFPLENBQUNZLEtBQUQsQ0FIVSxHQUlwQmdGLElBQUksQ0FBQ2tCLElBQUwsT0FBQWxCLElBQUksRUFBU2hGLEtBQVQsQ0FKZ0IsR0FLVlQsUUFBUSxDQUFDUyxLQUFELENBQVIsSUFBbUIsVUFBVUEsS0FMbkIsR0FNcEJnRixJQUFJLENBQUNrQixJQUFMLE9BQUFsQixJQUFJLEVBQVNoRyxNQUFNLENBQUMrVCxNQUFQLENBQWMvUyxLQUFkLENBQVQsQ0FOZ0IsR0FPVjZTLEVBQUUsQ0FBQ2dYLGFBQUgsQ0FBaUIvckIsQ0FBakIsQ0FQVSxHQVFwQmtILElBQUksQ0FBQ2tCLElBQUwsQ0FBVTJNLEVBQUUsQ0FBQzZXLE9BQUgsSUFBYzdXLEVBQUUsQ0FBQ2lYLGNBQUgsQ0FBa0I5cEIsS0FBbEIsRUFBeUIsR0FBekIsQ0FBeEIsQ0FSb0IsR0FVaEI4b0IsV0FWZ0IsR0FXbkI5akIsSUFBSSxDQUFDNk4sRUFBRSxDQUFDMFYsV0FBSCxDQUFlenFCLENBQUMsQ0FBQ3ROLENBQWpCLEVBQW9CMjJCLEVBQXBCLENBQUQsQ0FBSixHQUFnQ25uQixLQVhiLEdBYW5CZ0YsSUFBSSxDQUFDa0IsSUFBTCxDQUFVbEcsS0FBVixDQWJtQjtBQWdCckIsT0FoQkQsQ0FIb0IsRUFxQnBCMHJCLEVBQUUsQ0FBQ3JSLENBQUMsQ0FBQ25wQixFQUFILENBQUYsR0FBVzhULElBckJTO0FBc0JwQixLQXRCRCxDQXdCQSxFQUFPMG1CLEVBQVA7QUFDQSxHQTViYTtBQThiZEMscUJBOWJjLCtCQThiTWpaLE9BOWJOLEVBOGJla1osT0E5YmYsRUE4YndCO0FBQUEsUUFFakM3WSxNQUZpQztBQUFBLFFBQy9Ca1UsR0FBRyxHQUFHam9CLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZeVQsT0FBWixDQUR5Qjs7QUFJckMsU0FBSyxJQUFJcFIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJsQixHQUFHLENBQUNub0IsTUFBeEIsRUFBZ0N3QyxDQUFDLEVBQWpDLEVBQXFDO0FBQ3BDeVIsWUFBTSxHQUFHTCxPQUFPLENBQUN1VSxHQUFHLENBQUMzbEIsQ0FBRCxDQUFKLENBQVAsQ0FBZ0J5UixNQURXOztBQUdwQyxXQUFLLElBQUk0VCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNVQsTUFBTSxDQUFDalUsTUFBM0IsRUFBbUM2bkIsQ0FBQyxFQUFwQyxFQUNDLElBQUlpRixPQUFPLENBQUM3WSxNQUFNLENBQUM0VCxDQUFELENBQU4sQ0FBVTNtQixLQUFYLENBQVgsRUFDQztBQUdGOztBQUVEO0FBQ0EsR0E3Y2E7QUErY2Q2ckIsaUJBL2NjLDZCQStjSTtBQUNqQixXQUFPLEtBQUtwTCxtQkFBTCxHQUEyQjNoQixNQUEzQixHQUFvQyxDQUEzQztBQUNBLEdBamRhO0FBbWRkaXBCLDJCQW5kYyxxQ0FtZFlyVixPQW5kWixFQW1kcUI7QUFDbEMsV0FBTyxLQUFLaVosbUJBQUwsQ0FBeUJqWixPQUF6QixFQUFrQyxVQUFBNVUsQ0FBQztBQUFBLGFBQUlBLENBQUMsR0FBRyxDQUFSO0FBQUEsS0FBbkMsQ0FBUDtBQUNBLEdBcmRhO0FBdWRka3FCLDJCQXZkYyxxQ0F1ZFl0VixPQXZkWixFQXVkcUI7QUFDbEMsV0FBTyxLQUFLaVosbUJBQUwsQ0FBeUJqWixPQUF6QixFQUFrQyxVQUFBNVUsQ0FBQztBQUFBLGFBQUlBLENBQUMsR0FBRyxDQUFSO0FBQUEsS0FBbkMsQ0FBUDtBQUNBLEdBemRhO0FBMmRkZ3VCLGFBM2RjLHVCQTJkRnhwQixJQTNkRSxFQTJkSTtBQUNYLFFBQUNrRyxNQUFELEdBQVcsSUFBWCxDQUFDQSxNQUFEO0FBQUEsUUFDQXVqQixLQURBLEdBQ1F2akIsTUFBTSxDQUFDaFYsVUFEZjtBQUdOLFdBQU93SyxRQUFRLENBQUMrdEIsS0FBRCxDQUFSLElBQW1CQSxLQUFLLENBQUNDLFdBQU4sT0FBd0IxcEIsSUFBbEQ7QUFDQSxHQWhlYTtBQWtlZDJwQixhQWxlYyx5QkFrZUE7QUFDYixXQUFPLEtBQUtILFdBQUwsQ0FBaUIsTUFBakIsQ0FBUDtBQUNBLEdBcGVhO0FBc2VkSSxZQXRlYyx3QkFzZUQ7QUFDWixXQUFPLEtBQUtKLFdBQUwsQ0FBaUIsS0FBakIsQ0FBUDtBQUNBLEdBeGVhOztBQTBlZDs7Ozs7O0FBTUFLLGNBaGZjLHdCQWdmREMsWUFoZkMsRUFnZmE7QUFDcEIsUUFBQXZaLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFBQSxRQUVBa0ssT0FGQSxhQUVjMFosWUFGZDtBQUFBLFFBR0FDLFFBSEEsR0FHV3haLEVBQUUsQ0FBQ3FaLFVBQUgsRUFIWDtBQUFBLFFBSUFJLFNBSkEsR0FJWXpaLEVBQUUsQ0FBQ29aLFdBQUgsRUFKWjtBQWdCSjtBQUVGLFdBWklJLFFBQVEsSUFBSUMsU0FZaEIsR0FYQzVaLE9BQU8sQ0FBQzlNLElBQVIsQ0FBYSxVQUFDMm1CLEVBQUQsRUFBS0MsRUFBTCxFQUFZO0FBQUEsVUFDbEJDLE9BQU8sR0FBRyxVQUFDcnBCLENBQUQsRUFBSXlCLENBQUo7QUFBQSxlQUFVekIsQ0FBQyxHQUFHOUUsSUFBSSxDQUFDb3VCLEdBQUwsQ0FBUzduQixDQUFDLENBQUM3RSxLQUFYLENBQWQ7QUFBQSxPQURRO0FBQUEsVUFFbEIyc0IsS0FBSyxHQUFHSixFQUFFLENBQUN4WixNQUFILENBQVUxTixNQUFWLENBQWlCb25CLE9BQWpCLEVBQTBCLENBQTFCLENBRlU7QUFBQSxVQUdsQkcsS0FBSyxHQUFHSixFQUFFLENBQUN6WixNQUFILENBQVUxTixNQUFWLENBQWlCb25CLE9BQWpCLEVBQTBCLENBQTFCLENBSFU7O0FBS3hCLGFBQU9KLFFBQVEsR0FBR08sS0FBSyxHQUFHRCxLQUFYLEdBQW1CQSxLQUFLLEdBQUdDLEtBQTFDO0FBQ0EsS0FORCxDQVdELEdBSlc3dUIsVUFBVSxDQUFDeUssTUFBTSxDQUFDaFYsVUFBUixDQUlyQixJQUhDa2YsT0FBTyxDQUFDOU0sSUFBUixDQUFhNEMsTUFBTSxDQUFDaFYsVUFBUCxDQUFrQndpQixJQUFsQixDQUF1Qm5ELEVBQUUsQ0FBQ2dKLEdBQTFCLENBQWIsQ0FHRCxFQUFPbkosT0FBUDtBQUNBLEdBcGdCYTtBQXNnQmQrVixXQXRnQmMscUJBc2dCSi9WLE9BdGdCSSxFQXNnQktsaUIsQ0F0Z0JMLEVBc2dCUTtBQUNyQixXQUFPNFUsVUFBVSxDQUFDc04sT0FBTyxDQUFDelIsR0FBUixDQUFZLFVBQUFvWixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDdEgsTUFBTjtBQUFBLEtBQWIsQ0FBRCxDQUFWLENBQXVDNU4sTUFBdkMsQ0FBOEMsVUFBQXJILENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUN0TixDQUFGLEdBQU1BLENBQU4sS0FBWSxDQUFoQjtBQUFBLEtBQS9DLENBQVA7QUFDQSxHQXhnQmE7QUEwZ0JkcThCLGtCQTFnQmMsNEJBMGdCRzduQixJQTFnQkgsRUEwZ0JTO0FBQUE7O0FBQ3RCLFdBQU9BLElBQUksQ0FBQ0csTUFBTCxDQUFZLFVBQUF4RyxDQUFDO0FBQUEsYUFBSWQsT0FBTyxDQUFDLE1BQUksQ0FBQzRyQixZQUFMLENBQWtCOXFCLENBQWxCLENBQUQsQ0FBWDtBQUFBLEtBQWIsQ0FBUDtBQUNBLEdBNWdCYTtBQThnQmRtdUIsaUJBOWdCYywyQkE4Z0JFcGEsT0E5Z0JGLEVBOGdCV3FhLE9BOWdCWCxFQThnQm9CO0FBQ2pDLFdBQU9yYSxPQUFPLENBQUN6UixHQUFSLENBQVksVUFBQW9aLENBQUM7QUFBQSxhQUFLO0FBQ3hCbnBCLFVBQUUsRUFBRW1wQixDQUFDLENBQUNucEIsRUFEa0I7QUFFeEI0aEIsY0FBTSxFQUFFdUgsQ0FBQyxDQUFDdkgsTUFGYztBQUd4QkMsY0FBTSxFQUFFc0gsQ0FBQyxDQUFDdEgsTUFBRixDQUFTNU4sTUFBVCxDQUFnQixVQUFBckgsQ0FBQztBQUFBLGlCQUFJaXZCLE9BQU8sQ0FBQyxDQUFELENBQVAsSUFBY2p2QixDQUFDLENBQUN0TixDQUFoQixJQUFxQnNOLENBQUMsQ0FBQ3ROLENBQUYsSUFBT3U4QixPQUFPLENBQUMsQ0FBRCxDQUF2QztBQUFBLFNBQWpCO0FBSGdCLE9BQUw7QUFBQSxLQUFiLENBQVA7QUFLQSxHQXBoQmE7QUFzaEJkQyxjQXRoQmMsMEJBc2hCQztBQUNkLFFBQU1DLFVBQVUsR0FBRyxLQUFLemtCLE1BQUwsQ0FBWXpRLFdBQS9CO0FBRUEsV0FBUXFHLFNBQVMsQ0FBQzZ1QixVQUFELENBQVQsSUFBeUJBLFVBQTFCLElBQ0xydUIsWUFBWSxDQUFDcXVCLFVBQUQsQ0FBWixJQUE0Qjl0QixRQUFRLENBQUM4dEIsVUFBRCxDQUR0QztBQUVBLEdBM2hCYTtBQTZoQmRDLG9CQTdoQmMsOEJBNmhCS3ByQixHQTdoQkwsRUE2aEJVMlQsR0E3aEJWLEVBNmhCZTdWLEdBN2hCZixFQTZoQm9CO0FBQUEsUUFDM0JpVCxFQUFFLEdBQUcsSUFEc0I7QUFBQSxRQUUzQnNhLE9BQU8sR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLENBRmlCO0FBZWpDLFdBVkF0YSxFQUFFLENBQUM1USxHQUFILENBQU9oWSxLQUFQLENBQWFzWSxNQUFiLENBQW9CLEtBQXBCLEVBQTJCK1UsU0FBM0IsQ0FBcUMsUUFBckMsRUFDRXRTLElBREYsQ0FDTyxDQUFDbEQsR0FBRCxFQUFNMlQsR0FBTixDQURQLEVBRUU4QixLQUZGLEdBR0VoVyxNQUhGLENBR1MsTUFIVCxFQUlFOVQsSUFKRixDQUlPLFVBQUFrUixDQUFDO0FBQUEsYUFBSWtVLEVBQUUsQ0FBQ3VhLGVBQUgsQ0FBbUJ6dUIsQ0FBQyxDQUFDek4sRUFBckIsRUFBeUJ5TixDQUF6QixDQUFKO0FBQUEsS0FKUixFQUtFcVksSUFMRixDQUtPLFVBQVNyWSxDQUFULEVBQVkyQyxDQUFaLEVBQWU7QUFDcEI2ckIsYUFBTyxDQUFDN3JCLENBQUQsQ0FBUCxHQUFhLEtBQUtNLHFCQUFMLEdBQTZCaEMsR0FBN0IsSUFSSyxHQU9FO0FBRXBCLEtBUEYsRUFRRTRTLE1BUkYsRUFVQSxFQUFPMmEsT0FBUDtBQUNBLEdBN2lCYTtBQStpQmRFLFdBL2lCYyxxQkEraUJKMXVCLENBL2lCSSxFQStpQkQ7QUFDWixXQUFPLEtBQUtvc0IsU0FBTCxDQUFlLEtBQUsvbEIsSUFBTCxDQUFVME4sT0FBekIsRUFBa0MvVCxDQUFDLENBQUN6TixFQUFwQyxDQUFQO0FBQ0EsR0FqakJhO0FBbWpCZG84QixPQW5qQmMsaUJBbWpCUjN1QixDQW5qQlEsRUFtakJMO0FBQ1IsV0FBTyxVQUFVQSxDQUFWLElBQWUsS0FBS29zQixTQUFMLENBQWUsS0FBSy9sQixJQUFMLENBQVUwTixPQUF6QixFQUFrQy9ULENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQXpDLENBQXRCO0FBQ0EsR0FyakJhO0FBdWpCZHE4QixtQkF2akJjLDZCQXVqQkl4YSxNQXZqQkosRUF1akJZbUYsS0F2akJaLEVBdWpCbUI7QUFBQSxRQUc1QjVXLENBSDRCO0FBQUEsUUFDMUJrc0IsT0FBTyxHQUFHemEsTUFBTSxDQUFDbUYsS0FBRCxDQUFOLENBQWMxbkIsQ0FERTtBQUFBLFFBRTFCaTlCLEtBQVksR0FBRyxFQUZXOztBQUtoQyxTQUFLbnNCLENBQUMsR0FBRzRXLEtBQUssR0FBRyxDQUFqQixFQUFvQjVXLENBQUMsSUFBSSxDQUF6QixNQUNLa3NCLE9BQU8sS0FBS3phLE1BQU0sQ0FBQ3pSLENBQUQsQ0FBTixDQUFVOVEsQ0FEM0IsR0FBNEI4USxDQUFDLEVBQTdCLEVBS0Ntc0IsS0FBSyxDQUFDdm5CLElBQU4sQ0FBVzZNLE1BQU0sQ0FBQ3pSLENBQUQsQ0FBakIsQ0FMRDs7QUFRQSxTQUFLQSxDQUFDLEdBQUc0VyxLQUFULEVBQWdCNVcsQ0FBQyxHQUFHeVIsTUFBTSxDQUFDalUsTUFBM0IsTUFDSzB1QixPQUFPLEtBQUt6YSxNQUFNLENBQUN6UixDQUFELENBQU4sQ0FBVTlRLENBRDNCLEdBQW1DOFEsQ0FBQyxFQUFwQyxFQUtDbXNCLEtBQUssQ0FBQ3ZuQixJQUFOLENBQVc2TSxNQUFNLENBQUN6UixDQUFELENBQWpCLENBTEQ7O0FBUUEsV0FBT21zQixLQUFQO0FBQ0EsR0E3a0JhO0FBK2tCZEMsd0JBL2tCYyxrQ0Era0JTaGIsT0Eva0JULEVBK2tCa0JtRyxHQS9rQmxCLEVBK2tCdUI7QUFBQSxRQUM5QmhHLEVBQUUsR0FBRyxJQUR5QjtBQUFBLFFBRTlCOGEsVUFBVSxHQUFHamIsT0FBTyxDQUFDelIsR0FBUixDQUFZLFVBQUF6VCxNQUFNO0FBQUEsYUFBSXFsQixFQUFFLENBQUMrYSxXQUFILENBQWVwZ0MsTUFBTSxDQUFDdWxCLE1BQXRCLEVBQThCOEYsR0FBOUIsQ0FBSjtBQUFBLEtBQWxCLENBRmlCO0FBRTBDO0FBRTlFO0FBQ0EsV0FBT2hHLEVBQUUsQ0FBQythLFdBQUgsQ0FBZUQsVUFBZixFQUEyQjlVLEdBQTNCLENBQVA7QUFDQSxHQXJsQmE7QUF1bEJkK1UsYUF2bEJjLHVCQXVsQkY3YSxNQXZsQkUsRUF1bEJNOEYsR0F2bEJOLEVBdWxCVztBQUtwQixRQUFBZ1YsT0FBTztBQUFBLFFBSkxoYixFQUlLLEdBSkEsSUFJQTtBQUFBLFFBSEpySyxNQUdJLEdBSG1CcUssRUFHbkIsQ0FISnJLLE1BR0k7QUFBQSxRQUhVcEcsSUFHVixHQUhtQnlRLEVBR25CLENBSEk1USxHQUdKLENBSFVHLElBR1Y7QUFBQSxRQUZMNEMsSUFFSyxHQUZFK04sTUFBTSxDQUFDNU4sTUFBUCxDQUFjLFVBQUFySCxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxJQUFJRCxPQUFPLENBQUNDLENBQUMsQ0FBQ2tDLEtBQUgsQ0FBaEI7QUFBQSxLQUFmLENBRUY7QUFBQSxRQURQOHRCLE9BQ08sR0FER3RsQixNQUFNLENBQUM0QixpQkFDVjtBQXlCWCxXQXRCQXBGLElBQUksQ0FDRkcsTUFERixDQUNTLFVBQUFySCxDQUFDO0FBQUEsYUFBSStVLEVBQUUsQ0FBQ2tiLFNBQUgsQ0FBYWp3QixDQUFDLENBQUM1TSxFQUFmLENBQUo7QUFBQSxLQURWLEVBRUVnUCxPQUZGLENBRVUsVUFBQXBDLENBQUMsRUFBSTtBQUNiLFVBQU03USxLQUFLLEdBQUdtVixJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQzNZLElBQXRCLEdBQTZCZ3BCLEVBQUUsQ0FBQ21iLHVCQUFILENBQTJCbHdCLENBQUMsQ0FBQzVNLEVBQTdCLENBQTdCLFVBQWtFc1IsY0FBSyxDQUFDNVksR0FBeEUsU0FBK0VrVSxDQUFDLENBQUNvYSxLQUFqRixFQUEwRnRYLElBQTFGLEVBQWQ7QUFFSSxPQUFDaXRCLE9BQUQsSUFBWWhiLEVBQUUsQ0FBQ29iLFdBQUgsQ0FBZWhoQyxLQUFmLENBSEgsS0FJWjRnQyxPQUFPLEdBQUcvdkIsQ0FKRTtBQU1iLEtBUkYsQ0FzQkEsRUFYQWtILElBQUksQ0FDRkcsTUFERixDQUNTLFVBQUFySCxDQUFDO0FBQUEsYUFBSSxDQUFDK1UsRUFBRSxDQUFDa2IsU0FBSCxDQUFhandCLENBQUMsQ0FBQzVNLEVBQWYsQ0FBTDtBQUFBLEtBRFYsRUFFRWdQLE9BRkYsQ0FFVSxVQUFBcEMsQ0FBQyxFQUFJO0FBQ2IsVUFBTWEsQ0FBQyxHQUFHa1UsRUFBRSxDQUFDcWIsSUFBSCxDQUFRcHdCLENBQVIsRUFBVythLEdBQVgsQ0FBVjtBQUVJbGEsT0FBQyxHQUFHbXZCLE9BSEssS0FJWkEsT0FBTyxHQUFHbnZCLENBSkUsRUFLWmt2QixPQUFPLEdBQUcvdkIsQ0FMRTtBQU9iLEtBVEYsQ0FXQSxFQUFPK3ZCLE9BQVA7QUFDQSxHQXRuQmE7QUF3bkJkSyxNQXhuQmMsZ0JBd25CVGxwQixJQXhuQlMsRUF3bkJINlQsR0F4bkJHLEVBd25CRTtBQUNULFFBQUFoRyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ3dCK0gsU0FEeEIsR0FDNkMvSCxFQUQ3QyxDQUNDckssTUFERCxDQUNVYyxZQURWO0FBQUEsUUFDb0M0SixLQURwQyxHQUM2Q0wsRUFEN0MsQ0FDb0NLLEtBRHBDO0FBQUEsUUFFQWliLE1BRkEsR0FFU3ZULFNBQVMsR0FBRyxDQUFILEdBQU8sQ0FGekI7QUFBQSxRQUdBd1QsTUFIQSxHQUdTeFQsU0FBUyxHQUFHLENBQUgsR0FBTyxDQUh6QjtBQUFBLFFBSUFqcUIsQ0FKQSxHQUlJa2lCLEVBQUUsQ0FBQ3diLE9BQUgsQ0FBV3JwQixJQUFYLEVBQWlCQSxJQUFJLENBQUNrVCxLQUF0QixDQUpKO0FBQUEsUUFLQTFuQixDQUxBLEdBS0ksQ0FBQzBpQixLQUFLLENBQUN6QyxJQUFOLElBQWN5QyxLQUFLLENBQUMxaUIsQ0FBckIsRUFBd0J3VSxJQUFJLENBQUN4VSxDQUE3QixDQUxKO0FBT04sV0FBTzhOLElBQUksQ0FBQ2d3QixJQUFMLENBQVVod0IsSUFBSSxDQUFDaXdCLEdBQUwsQ0FBUy85QixDQUFDLEdBQUdxb0IsR0FBRyxDQUFDc1YsTUFBRCxDQUFoQixFQUEwQixDQUExQixJQUErQjd2QixJQUFJLENBQUNpd0IsR0FBTCxDQUFTNTlCLENBQUMsR0FBR2tvQixHQUFHLENBQUN1VixNQUFELENBQWhCLEVBQTBCLENBQTFCLENBQXpDLENBQVA7QUFDQSxHQWpvQmE7O0FBbW9CZDs7Ozs7O0FBTUFJLHFCQXpvQmMsK0JBeW9CTXpiLE1Bem9CTixFQXlvQmM7QUFDckIsUUFBQUYsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBR0FvUyxTQUhBLEdBR1lwUyxNQUFNLENBQUNjLFlBSG5CO0FBQUEsUUFJQW1sQixRQUpBLEdBSVdqbUIsTUFBTSxDQUFDZ0UsY0FKbEI7QUFBQSxRQUtBK1AsYUFMQSxHQUtnQjFKLEVBQUUsQ0FBQzBKLGFBQUgsRUFMaEI7QUFBQSxRQU9BbVMsU0FQQSxHQU9ZdHZCLE9BQU8sQ0FBQzJULE1BQUQsQ0FBUCxHQUFrQkEsTUFBTSxDQUFDL08sTUFBUCxFQUFsQixHQUFvQyxDQUFDK08sTUFBRCxDQVBoRDtBQVNOLFFBQUksQ0FBQzZILFNBQUQsSUFBYyxDQUFDMkIsYUFBbkIsRUFDQyxPQUFPeEosTUFBUCxDQVgwQixDQWMzQjs7QUFkMkIsUUFlckI3aEIsRUFBRSxHQUFHdzlCLFNBQVMsQ0FBQyxDQUFELENBQVQsQ0FBYXg5QixFQWZHO0FBQUEsUUFrQnZCVixDQUFDLEdBQUdrK0IsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhbCtCLENBQWIsR0FBaUIsQ0FsQkU7QUFBQSxRQW1CdkJ3UCxLQUFLLEdBQUcwdUIsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhMXVCLEtBbkJFLEVBaUIzQjs7QUFrQkEsV0FkQXVjLGFBQWEsSUFBSW1TLFNBQVMsQ0FBQ3JhLE9BQVYsQ0FBa0I7QUFBQzdqQixPQUFDLEVBQURBLENBQUQ7QUFBSXdQLFdBQUssRUFBTEEsS0FBSjtBQUFXOU8sUUFBRSxFQUFGQTtBQUFYLEtBQWxCLENBY2pCLEVBWkF1OUIsUUFBUSxLQUFLLFlBQWIsSUFDQ0MsU0FBUyxDQUFDcmEsT0FBVixDQUFrQjtBQUFDN2pCLE9BQUMsRUFBRUEsQ0FBQyxHQUFHLENBQVI7QUFBV3dQLFdBQUssRUFBTEEsS0FBWDtBQUFrQjlPLFFBQUUsRUFBRkE7QUFBbEIsS0FBbEIsQ0FXRCxFQVJBVixDQUFDLEdBQUdrK0IsU0FBUyxDQUFDNXZCLE1BUWQsRUFQQWtCLEtBQUssR0FBRzB1QixTQUFTLENBQUNsK0IsQ0FBQyxHQUFHLENBQUwsQ0FBVCxDQUFpQndQLEtBT3pCLEVBTEF1YyxhQUFhLElBQUltUyxTQUFTLENBQUN4b0IsSUFBVixDQUFlO0FBQUMxVixPQUFDLEVBQURBLENBQUQ7QUFBSXdQLFdBQUssRUFBTEEsS0FBSjtBQUFXOU8sUUFBRSxFQUFGQTtBQUFYLEtBQWYsQ0FLakIsRUFIQXU5QixRQUFRLEtBQUssYUFBYixJQUNDQyxTQUFTLENBQUN4b0IsSUFBVixDQUFlO0FBQUMxVixPQUFDLEVBQUVBLENBQUMsR0FBRyxDQUFSO0FBQVd3UCxXQUFLLEVBQUxBLEtBQVg7QUFBa0I5TyxRQUFFLEVBQUZBO0FBQWxCLEtBQWYsQ0FFRCxFQUFPdzlCLFNBQVA7QUFDQSxHQTdxQmE7QUErcUJkQyxzQkEvcUJjLGdDQStxQk81YixNQS9xQlAsRUErcUJlO0FBQUEsUUFDdEIyYixTQUFTLEdBQUd0dkIsT0FBTyxDQUFDMlQsTUFBRCxDQUFQLEdBQWtCQSxNQUFNLENBQUMvTyxNQUFQLEVBQWxCLEdBQW9DLENBQUMrTyxNQUFELENBRDFCO0FBQUEsUUFFdEI2YixNQUF5RCxHQUFHLEVBRnRDO0FBb0I1QixXQWhCQUYsU0FBUyxDQUFDeHVCLE9BQVYsQ0FBa0IsVUFBQW9ULEtBQUssRUFBSTtBQUFBLFVBQ25COWlCLENBRG1CLEdBQ1Y4aUIsS0FEVSxDQUNuQjlpQixDQURtQjtBQUFBLFVBQ2hCVSxFQURnQixHQUNWb2lCLEtBRFUsQ0FDaEJwaUIsRUFEZ0I7QUFHMUIwOUIsWUFBTSxDQUFDMW9CLElBQVAsQ0FBWTtBQUNYMVYsU0FBQyxFQUFEQSxDQURXO0FBRVhVLFVBQUUsRUFBRkEsRUFGVztBQUdYOE8sYUFBSyxFQUFFc1QsS0FBSyxDQUFDdFQsS0FBTixDQUFZLENBQVo7QUFISSxPQUFaLENBSDBCLEVBUzFCNHVCLE1BQU0sQ0FBQzFvQixJQUFQLENBQVk7QUFDWDFWLFNBQUMsRUFBREEsQ0FEVztBQUVYVSxVQUFFLEVBQUZBLEVBRlc7QUFHWDhPLGFBQUssRUFBRXNULEtBQUssQ0FBQ3RULEtBQU4sQ0FBWSxDQUFaO0FBSEksT0FBWixDQVQwQjtBQWMxQixLQWRELENBZ0JBLEVBQU80dUIsTUFBUDtBQUNBLEdBcHNCYTtBQXNzQmRDLHNCQXRzQmMsZ0NBc3NCT25ZLElBdHNCUCxFQXNzQmFvWSxLQXRzQmIsRUFzc0JvQjtBQUMzQixRQUFBamMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUF1bUIsT0FGQSxHQUVVdm1CLE1BQU0sV0FBU2tPLElBQVQsQ0FGaEI7QUFEMkIsV0FLN0J4WSxXQUFXLENBQUM0d0IsS0FBRCxDQUxrQixHQU16QkMsT0FOeUIsSUFTakMvdkIsTUFBTSxDQUFDQyxJQUFQLENBQVk2dkIsS0FBWixFQUFtQjV1QixPQUFuQixDQUEyQixVQUFBaFAsRUFBRSxFQUFJO0FBQ2hDNjlCLGFBQU8sQ0FBQzc5QixFQUFELENBQVAsR0FBYzQ5QixLQUFLLENBQUM1OUIsRUFBRCxDQURhO0FBRWhDLEtBRkQsQ0FUaUMsRUFhakMyaEIsRUFBRSxDQUFDa1AsTUFBSCxDQUFVO0FBQUNpTixnQkFBVTtBQUFYLEtBQVYsQ0FiaUMsRUFlMUJELE9BZjBCO0FBZ0JqQyxHQXR0QmE7QUF3dEJkbkYsa0JBeHRCYyw0QkF3dEJHanJCLENBeHRCSCxFQXd0Qk0yRCxJQXh0Qk4sRUF3dEJZO0FBQ3pCLFFBQU10QyxLQUFLLEdBQUdyQixDQUFDLENBQUNxQixLQUFoQjs7QUFFQSxRQUFJWixPQUFPLENBQUNZLEtBQUQsQ0FBWCxFQUFvQjtBQUNuQixVQUFNa1ksS0FBSyxHQUFHLENBQUMsTUFBRCxFQUFTLEtBQVQsRUFBZ0IsS0FBaEIsRUFBdUJuWCxPQUF2QixDQUErQnVCLElBQS9CLENBQWQ7QUFFQSxhQUFPNFYsS0FBSyxLQUFLLENBQUMsQ0FBWCxHQUFlLElBQWYsR0FBc0JsWSxLQUFLLENBQUNrWSxLQUFELENBQWxDO0FBQ0E7O0FBRUQsV0FBT2xZLEtBQUssQ0FBQ3NDLElBQUQsQ0FBWjtBQUNBLEdBbHVCYTs7QUFvdUJkOzs7Ozs7OztBQVFBMnNCLFVBNXVCYyxvQkE0dUJMM3NCLElBNXVCSyxFQTR1QkMzRCxDQTV1QkQsRUE0dUJJdXdCLFNBNXVCSixFQTR1QmU7QUFDdEIsUUFBQXJjLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ2tCOGpCLEVBRGxCLENBQ1M5akIsS0FEVDtBQUFBLFFBRUE4c0IsR0FGQSxHQUVNaEosRUFBRSxDQUFDZ0osR0FGVDtBQUFBLFFBR0ZzVCxLQUhFLEdBR00sQ0FITjs7QUFLTixRQUFJeHdCLENBQUMsSUFBSWtkLEdBQUcsQ0FBQzdXLElBQUosQ0FBU29xQixLQUFULEdBQWlCdHdCLE1BQTFCLEVBQWtDO0FBQ2pDLFVBQU11d0IsVUFBVSxHQUFHeFQsR0FBRyxDQUFDN1csSUFBSixDQUFTK04sTUFBVCxDQUFnQmlELElBQWhCLENBQXFCNkYsR0FBckIsQ0FBbkI7QUFJQSxVQUZBc1QsS0FBSyxHQUFHeHdCLENBQUMsQ0FBQ3d3QixLQUFGLElBQVd4d0IsQ0FBQyxDQUFDcUIsS0FFckIsRUFBSXNDLElBQUksS0FBSyxLQUFiO0FBQ0M7QUFDQSxjQUFJdVEsRUFBRSxDQUFDekMsR0FBSCxDQUFPa2YsUUFBUCxJQUFKLEVBQXlCO0FBQ3hCLGdCQUFJM0UsS0FBSyxHQUFHOVgsRUFBRSxDQUFDNFgsZUFBSCxFQUFaO0FBRUkxN0IsaUJBQUssQ0FBQ3NELGVBQU4sQ0FBc0J5TSxNQUhGLEtBSXZCNnJCLEtBQUssSUFBSTBFLFVBQVUsQ0FBQ3RnQyxLQUFLLENBQUNzRCxlQUFQLENBQVYsQ0FBa0NnVCxNQUFsQyxDQUF5QyxVQUFDakMsQ0FBRCxFQUFJeUIsQ0FBSjtBQUFBLHFCQUFVekIsQ0FBQyxHQUFHeUIsQ0FBZDtBQUFBLGFBQXpDLENBSmMsR0FPeEJzcUIsS0FBSyxHQUFHeHdCLENBQUMsQ0FBQ3FCLEtBQUYsR0FBVTJxQixLQVBNO0FBVXhCLFdBVkQsTUFXQ3dFLEtBQUssR0FBRyxDQUFDeHdCLENBQUMsQ0FBQzR3QixRQUFGLEdBQWE1d0IsQ0FBQyxDQUFDNndCLFVBQWhCLEtBQ1BseEIsSUFBSSxDQUFDMFAsRUFBTCxJQUFXNkUsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsS0FBdUIsQ0FBQ3ZnQixNQUFNLENBQUNnRixnQkFBL0IsR0FBa0QsQ0FBbEQsR0FBc0QsQ0FBakUsQ0FETyxDQVhUO0FBRkQsYUFpQk8sSUFBSWxMLElBQUksS0FBSyxPQUFiLEVBQXNCO0FBQzVCLFlBQUlxb0IsTUFBSyxHQUFHLEtBQUtKLGdCQUFMLEVBQVo7O0FBRUEsWUFBSXg3QixLQUFLLENBQUNzRCxlQUFOLENBQXNCeU0sTUFBMUIsRUFBa0M7QUFDakMsY0FBSTJ3QixTQUFTLEdBQUdKLFVBQVUsQ0FBQ3RnQyxLQUFLLENBQUNzRCxlQUFQLEtBQTFCO0FBRUlvOUIsbUJBQVMsQ0FBQzN3QixNQUhtQixLQUloQzJ3QixTQUFTLEdBQUdBLFNBQVMsQ0FDbkJwcUIsTUFEVSxDQUNILFVBQUNxcUIsR0FBRCxFQUFNQyxJQUFOO0FBQUEsbUJBQWVELEdBQUcsQ0FBQ3p1QixHQUFKLENBQVEsVUFBQ25ELENBQUQsRUFBSXdELENBQUo7QUFBQSxxQkFBVSxDQUFDckQsUUFBUSxDQUFDSCxDQUFELENBQVIsR0FBY0EsQ0FBZCxHQUFrQixDQUFuQixJQUF3QjZ4QixJQUFJLENBQUNydUIsQ0FBRCxDQUF0QztBQUFBLGFBQVIsQ0FBZjtBQUFBLFdBREcsQ0FKb0IsRUFPaENxcEIsTUFBSyxHQUFHQSxNQUFLLENBQUMxcEIsR0FBTixDQUFVLFVBQUNuRCxDQUFELEVBQUl3RCxDQUFKO0FBQUEsbUJBQVV4RCxDQUFDLEdBQUcyeEIsU0FBUyxDQUFDbnVCLENBQUQsQ0FBdkI7QUFBQSxXQUFWLENBUHdCO0FBU2pDOztBQUVEM0MsU0FBQyxDQUFDd3dCLEtBQUYsR0FBVWx4QixRQUFRLENBQUNVLENBQUMsQ0FBQ3FCLEtBQUgsQ0FBUixJQUFxQjJxQixNQUFyQixJQUE4QkEsTUFBSyxDQUFDaHNCLENBQUMsQ0FBQ3VaLEtBQUgsQ0FBTCxHQUFpQixDQUEvQyxHQUNUdlosQ0FBQyxDQUFDcUIsS0FBRixHQUFVMnFCLE1BQUssQ0FBQ2hzQixDQUFDLENBQUN1WixLQUFILENBRE4sR0FDa0IsQ0FmQSxFQWlCNUJpWCxLQUFLLEdBQUd4d0IsQ0FBQyxDQUFDd3dCLEtBakJrQjtBQWtCNUIsT0FsQk0sTUFrQkk3c0IsSUFBSSxLQUFLLE9BbEJiLEtBbUJONnNCLEtBQUssR0FBSVMsVUFBVSxDQUFRdHhCLElBQUksQ0FBQ21YLEdBQUwsQ0FBUzlXLENBQUMsQ0FBQ3FCLEtBQVgsRUFBa0IsQ0FBbEIsQ0FBUixNQUFWLEdBQTJDNlMsRUFBRSxDQUFDZ2QsUUFBL0MsR0FBMkRybkIsTUFBTSxDQUFDb0gsZ0JBbkJwRTtBQXFCUDs7QUFFRCxXQUFPc2YsU0FBUyxJQUFJQyxLQUFiLEdBQXFCQSxLQUFLLEdBQUcsR0FBN0IsR0FBbUNBLEtBQTFDO0FBQ0EsR0FoeUJhOztBQWt5QmQ7Ozs7O0FBS0FXLG9CQXZ5QmMsOEJBdXlCS3RhLFVBdnlCTCxFQXV5QmlCO0FBQUEsUUFDeEIzQyxFQUFFLEdBQUcsSUFEbUI7QUFBQSxRQUd4QmtkLFlBQVksR0FBR3ZhLFVBQVUsQ0FBQ25RLE1BQVgsQ0FBa0IsVUFBQzJxQixHQUFELEVBQU1qWixJQUFOLEVBQVltQixLQUFaLEVBQXNCO0FBRTVELGFBREE4WCxHQUFHLEVBQVFqWixJQUFJLENBQUN2bUIsQ0FBYixDQUFILEdBQXNCMG5CLEtBQ3RCLEVBQU84WCxHQUFQO0FBQ0EsS0FIb0IsRUFHbEIsRUFIa0IsQ0FIUztBQVE5Qm5kLE1BQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQVIsQ0FBZ0J4UyxPQUFoQixDQUF3QixVQUFBbWEsQ0FBQyxFQUFJO0FBQzVCQSxPQUFDLENBQUN0SCxNQUFGLENBQVM3UyxPQUFULENBQWlCLFVBQUNGLEtBQUQsRUFBUWl3QixVQUFSLEVBQXVCO0FBQ3ZDLFlBQUkvWCxLQUFLLEdBQUc2WCxZQUFZLEVBQVEvdkIsS0FBSyxDQUFDeFAsQ0FBZCxDQUF4QjtBQUVJMG5CLGFBQUssS0FBSzVrQixTQUh5QixLQUl0QzRrQixLQUFLLEdBQUcrWCxVQUo4QixHQU12Q2p3QixLQUFLLENBQUNrWSxLQUFOLEdBQWNBLEtBTnlCO0FBT3ZDLE9BUEQsQ0FENEI7QUFTNUIsS0FURCxDQVI4QjtBQWtCOUI7QUF6ekJhLENBQWYsRTs7QUN4QkE7Ozs7QUFJQTtBQUVlO0FBQ2RnWSxNQURjLGdCQUNUQyxVQURTLEVBQ0c3dkIsSUFESCxFQUNTO0FBQUEsUUFDaEJ1UyxFQUFFLEdBQUcsSUFEVztBQUFBLFFBRWxCSCxPQUFPLEdBQUd5ZCxVQUZRO0FBaUN0QjtBQUdBO0FBaENJemQsV0FKa0IsS0FNakJwUyxJQUFJLENBQUM2RSxNQU5ZLEtBT3BCdU4sT0FBTyxHQUFHQSxPQUFPLENBQUN2TixNQUFSLENBQWU3RSxJQUFJLENBQUM2RSxNQUFwQixDQVBVLElBV2pCN0UsSUFBSSxDQUFDZ0MsSUFBTCxJQUFhaEMsSUFBSSxDQUFDOHZCLEtBWEQsS0FZcEIxZCxPQUFPLENBQUN4UyxPQUFSLENBQWdCLFVBQUFtYSxDQUFDLEVBQUk7QUFDcEIsVUFBTS9YLElBQUksR0FBSWhDLElBQUksQ0FBQzh2QixLQUFMLElBQWM5dkIsSUFBSSxDQUFDOHZCLEtBQUwsQ0FBVy9WLENBQUMsQ0FBQ25wQixFQUFiLENBQWYsSUFBb0NvUCxJQUFJLENBQUNnQyxJQUF0RDtBQUVBdVEsUUFBRSxDQUFDb1YsYUFBSCxDQUFpQjVOLENBQUMsQ0FBQ25wQixFQUFuQixFQUF1Qm9SLElBQXZCLENBSG9CO0FBSXBCLEtBSkQsQ0Fab0IsRUFvQnJCdVEsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQnhTLE9BQWhCLENBQXdCLFVBQUF2QixDQUFDLEVBQUk7QUFDNUIsV0FBSyxJQUFJMkMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29SLE9BQU8sQ0FBQzVULE1BQTVCLEVBQW9Dd0MsQ0FBQyxFQUFyQyxFQUNDLElBQUkzQyxDQUFDLENBQUN6TixFQUFGLEtBQVN3aEIsT0FBTyxDQUFDcFIsQ0FBRCxDQUFQLENBQVdwUSxFQUF4QixFQUE0QjtBQUMzQnlOLFNBQUMsQ0FBQ29VLE1BQUYsR0FBV0wsT0FBTyxDQUFDcFIsQ0FBRCxDQUFQLENBQVd5UixNQURLLEVBRTNCTCxPQUFPLENBQUMyZCxNQUFSLENBQWUvdUIsQ0FBZixFQUFrQixDQUFsQixDQUYyQjtBQUczQjtBQUNBO0FBRUYsS0FSRCxDQXBCcUIsRUE4QnJCdVIsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixHQUFrQkcsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQjFPLE1BQWhCLENBQXVCME8sT0FBdkIsQ0E5QkcsR0FrQ3RCRyxFQUFFLENBQUN5ZCxhQUFILENBQWlCemQsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBekIsQ0FsQ3NCLEVBcUN0QkcsRUFBRSxDQUFDa1AsTUFBSCxDQUFVO0FBQ1R3TywwQkFBb0IsSUFEWDtBQUVUQyx1QkFBaUIsSUFGUjtBQUdUeEIsZ0JBQVU7QUFIRCxLQUFWLENBckNzQixFQTJDdEIxdUIsSUFBSSxDQUFDa2tCLElBQUwsSUFBYWxrQixJQUFJLENBQUNra0IsSUFBTCxDQUFVamtCLElBQVYsQ0FBZXNTLEVBQUUsQ0FBQ2dKLEdBQWxCLENBM0NTO0FBNEN0QixHQTdDYTtBQStDZDRVLGNBL0NjLHdCQStDRG53QixJQS9DQyxFQStDSztBQUNsQixRQUFNdVMsRUFBRSxHQUFHLElBQVgsQ0FEa0IsQ0FHbEI7O0FBQ0EsUUFBS0EsRUFBRSxDQUFDckssTUFBUjtBQUtBcUssUUFBRSxDQUFDUCxLQUFILENBQVNLLEtBQVQsRUFMQTtBQU9BLFVBQU0zTixJQUFJLEdBQUcxRSxJQUFJLENBQUMwRSxJQUFMLElBQWE2TixFQUFFLENBQUM4USxXQUFILENBQWVyakIsSUFBZixFQUFxQixVQUFBM0IsQ0FBQztBQUFBLGVBQUlrVSxFQUFFLENBQUNxZCxJQUFILENBQVFyZCxFQUFFLENBQUNnVSxvQkFBSCxDQUF3QmxvQixDQUF4QixDQUFSLEVBQW9DMkIsSUFBcEMsQ0FBSjtBQUFBLE9BQXRCLENBQTFCO0FBRUEwRSxVQUFJLElBQUk2TixFQUFFLENBQUNxZCxJQUFILENBQVFyZCxFQUFFLENBQUNnVSxvQkFBSCxDQUF3QjdoQixJQUF4QixDQUFSLEVBQXVDMUUsSUFBdkMsQ0FUUjtBQUFBLEtBSmtCLENBUWxCOztBQU1BLEdBN0RhO0FBK0Rkb3dCLFFBL0RjLGtCQStEUEMsWUEvRE8sRUErRE9DLFlBL0RQLEVBK0RxQjtBQUM1QixRQUFBL2QsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDOWpCLEtBREQsR0FDZThqQixFQURmLENBQ0M5akIsS0FERDtBQUFBLFFBQ1FrVCxHQURSLEdBQ2U0USxFQURmLENBQ1E1USxHQURSO0FBQUEsUUFFRnVpQixJQUZFLEdBRUtvTSxZQUZMO0FBQUEsUUFHRnZGLFNBSEUsR0FHVXNGLFlBSFY7QUFlTjtBQWhCa0MsV0FPbEM5ZCxFQUFFLENBQUNQLEtBQUgsQ0FBU0ssS0FBVCxFQVBrQyxFQVM3QjZSLElBVDZCLEtBVWpDQSxJQUFJLEdBQUcsWUFBTSxDQUFFLENBVmtCLEdBY2xDNkcsU0FBUyxHQUFHQSxTQUFTLENBQUNsbUIsTUFBVixDQUFpQixVQUFBalUsRUFBRTtBQUFBLGFBQUkyaEIsRUFBRSxDQUFDa1ksU0FBSCxDQUFhbFksRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBckIsRUFBOEJ4aEIsRUFBOUIsQ0FBSjtBQUFBLEtBQW5CLENBZHNCLEVBaUI3Qm02QixTQUFELElBQWNBLFNBQVMsQ0FBQ3ZzQixNQUFWLEtBQXFCLENBakJMLFNBc0JsQ21ELEdBQUcsQ0FBQ21lLEdBQUosQ0FBUTlJLFNBQVIsQ0FBa0IrVCxTQUFTLENBQUNwcUIsR0FBVixDQUFjLFVBQUEvUCxFQUFFO0FBQUEsYUFBSTJoQixFQUFFLENBQUNnZSxjQUFILENBQWtCMy9CLEVBQWxCLENBQUo7QUFBQSxLQUFoQixDQUFsQixFQUNFNGpCLFVBREYsR0FFRThDLEtBRkYsQ0FFUSxTQUZSLEVBRW1CLEdBRm5CLEVBR0VwRixNQUhGLEdBSUVqUyxJQUpGLENBSU9zUyxFQUFFLENBQUNpZSxNQUpWLEVBSWtCdE0sSUFKbEIsQ0F0QmtDLEVBNEJsQzZHLFNBQVMsQ0FBQ25yQixPQUFWLENBQWtCLFVBQUFoUCxFQUFFLEVBQUk7QUFFdkJuQyxXQUFLLENBQUMrQixhQUFOLENBQW9CSSxFQUFwQixNQUZ1QixFQUluQitRLEdBQUcsQ0FBQ2dPLE1BSmUsSUFLdEJoTyxHQUFHLENBQUNnTyxNQUFKLENBQVdxSCxTQUFYLE9BQXlCOVUsY0FBSyxDQUFDclcsVUFBL0IsR0FBNEMwbUIsRUFBRSxDQUFDbWIsdUJBQUgsQ0FBMkI5OEIsRUFBM0IsQ0FBNUMsRUFBOEVzaEIsTUFBOUUsRUFMc0IsRUFRdkJLLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQVIsR0FBa0JHLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQVIsQ0FBZ0J2TixNQUFoQixDQUF1QixVQUFBa1YsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ25wQixFQUFGLEtBQVNBLEVBQWI7QUFBQSxPQUF4QixDQVJLO0FBU3ZCLEtBVEQsQ0E1QmtDLFNBa0JqQ3N6QixJQUFJLEVBbEI2QjtBQXNDbEM7QUFyR2EsQ0FBZixFOzs7OztBQ05BOzs7O0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFFZTtBQUNkOzs7Ozs7QUFNQXVNLFlBUGMsc0JBT0hDLE1BUEcsRUFPS3J5QixDQVBMLEVBT1E7QUFDZixRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN3QnFLLEVBRHhCLENBQ0NySyxNQUREO0FBQUEsUUFDZXBHLElBRGYsR0FDd0J5USxFQUR4QixDQUNTNVEsR0FEVCxDQUNlRyxJQURmO0FBQUEsUUFFQWtyQixLQUZBLEdBRVEvdEIsUUFBUSxDQUFDWixDQUFELENBRmhCOztBQUlOO0FBQ0EsUUFBSTJ1QixLQUFLLElBQUkzdUIsQ0FBQyxLQUFLLENBQUMsQ0FBcEIsRUFBdUI7QUFDdEIsVUFBSWlsQixRQUFRLEdBQUdwYixNQUFNLENBQUN3b0IsTUFBTSxHQUFHLGFBQUgsR0FBbUIsWUFBMUIsQ0FBTixDQUE4Q2hiLElBQTlDLENBQW1EbkQsRUFBRSxDQUFDZ0osR0FBdEQsQ0FBZjtBQUlBLFVBRkFyVCxNQUFNLENBQUMzVCxZQUFQLElBQXVCZ2UsRUFBRSxDQUFDb2UsWUFBSCxDQUFnQkQsTUFBaEIsRUFBd0JyeUIsQ0FBeEIsRUFBMkIydUIsS0FBM0IsQ0FFdkIsRUFBSUEsS0FBSixFQUNDMUosUUFBUSxDQUFDamxCLENBQUQsRUFBSXlELElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDeFosR0FBdEIsR0FBNEI2cEIsRUFBRSxDQUFDbWIsdUJBQUgsQ0FBMkJydkIsQ0FBQyxDQUFDek4sRUFBN0IsQ0FBNUIsRUFBZ0UwUCxJQUFoRSxFQUFKLENBRFQsTUFFTyxJQUFJLENBQUM0SCxNQUFNLENBQUNoUyxlQUFaLEVBQTZCO0FBQUEsWUFDN0IwNkIsTUFBTSxHQUFHcmUsRUFBRSxDQUFDa2UsVUFEaUI7QUFBQSxZQUUvQkksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQVAsSUFBZSxFQUZTO0FBQUEsWUFJN0Jsa0MsS0FBSyxHQUFHbVYsSUFBSSxDQUFDa1YsU0FBTCxPQUFtQjlVLGNBQUssQ0FBQ3ZWLEtBQXpCLFNBQWtDMFIsQ0FBbEMsRUFDWndHLE1BRFksQ0FDTCxVQUFTeEcsQ0FBVCxFQUFZO0FBQ25CLGlCQUFPa1UsRUFBRSxDQUFDdWUsYUFBSCxDQUFpQixJQUFqQixFQUF1Qnp5QixDQUF2QixDQUFQO0FBQ0EsU0FIWSxDQUpxQjtBQVNuQzFSLGFBQUssQ0FDSCtwQixJQURGLENBQ08sVUFBU3JZLENBQVQsRUFBWTtBQUFBOztBQUFBLFdBQ2J3eUIsSUFBSSxDQUFDcnlCLE1BQUwsS0FBZ0IsQ0FBaEIsSUFBcUJxeUIsSUFBSSxDQUFDeHJCLEtBQUwsQ0FBVyxVQUFBN0gsQ0FBQztBQUFBLG1CQUFJQSxDQUFDLEtBQUssS0FBVjtBQUFBLFdBQVosQ0FEUixNQUVoQjhsQixRQUFRLENBQUNqbEIsQ0FBRCxFQUFJLElBQUosQ0FGUSxFQUdoQnd5QixJQUFJLENBQUNqckIsSUFBTCxDQUFVLElBQVYsQ0FIZ0I7QUFLakIsU0FORixDQVRtQyxFQWlCL0JpckIsSUFBSSxDQUFDcnlCLE1BQUwsR0FBYyxDQUFkLElBQW1CN1IsS0FBSyxDQUFDeEIsS0FBTixFQWpCWSxLQWtCbENtNEIsUUFBUSxHQUFHcGIsTUFBTSxDQUFDelUsVUFBUCxDQUFrQmlpQixJQUFsQixDQUF1Qm5ELEVBQUUsQ0FBQ2dKLEdBQTFCLENBbEJ1QixFQW9CbENzVixJQUFJLENBQUNqeEIsT0FBTCxDQUFhLFVBQUFwQyxDQUFDO0FBQUEsaUJBQUk4bEIsUUFBUSxDQUFDM00saUdBQVEsQ0FBQ25aLENBQUQsQ0FBUixDQUFZdXpCLEtBQVosRUFBRCxFQUFzQnZ6QixDQUF0QixDQUFaO0FBQUEsU0FBZCxDQXBCa0MsRUFxQmxDcXpCLElBQUksR0FBRyxFQXJCMkIsR0F3Qm5DRCxNQUFNLENBQUNDLElBQVAsR0FBY0EsSUF4QnFCO0FBeUJuQyxPQXpCTSxNQTBCTkgsTUFBTSxJQUFJbmUsRUFBRSxDQUFDeWUsaUJBQUgsQ0FBcUIzeUIsQ0FBckIsRUFBd0IsSUFBeEIsS0ExQkosRUE0QkxrVSxFQUFFLENBQUNpVyxXQUFILEVBQUQsSUFBcUIxbUIsSUFBSSxDQUFDa1YsU0FBTCxPQUFtQjlVLGNBQUssQ0FBQ3ZWLEtBQXpCLFNBQWtDMFIsQ0FBbEMsRUFDbkJxWSxJQURtQixDQUNkLFVBQVNyWSxDQUFULEVBQVk7QUFDakJpbEIsZ0JBQVEsQ0FBQ2psQixDQUFELEVBQUksSUFBSixDQURTO0FBRWpCLE9BSG1CLENBNUJmO0FBaUNQO0FBQ0QsR0F0RGE7O0FBd0RkOzs7OztBQUtBNHlCLHFCQTdEYywrQkE2RE01eUIsQ0E3RE4sRUE2RFM7QUFDaEIsUUFBQWtVLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQXFlLE1BREEsR0FDU3JlLEVBQUUsQ0FBQzBlLG1CQURaO0FBQUEsUUFFQ0osSUFGRCxHQUVTRCxNQUZULENBRUNDLElBRkQ7QUFEZ0IsS0FLbEI1eEIsUUFBUSxDQUFDWixDQUFELENBQVIsSUFBZXd5QixJQUFmLEdBQXNCeHlCLENBQUMsQ0FBQ3pOLEVBQUYsS0FBU2lnQyxJQUFJLENBQUNqZ0MsRUFBcEMsR0FBMEN5TixDQUFDLEtBQUt3eUIsSUFMOUIsTUFNckIsQ0FBQ0EsSUFBSSxJQUFJbHpCLFFBQVEsQ0FBQ2t6QixJQUFELENBQWpCLEtBQTRCdGUsRUFBRSxDQUFDa2UsVUFBSCxLQUFxQkksSUFBckIsQ0FOUCxFQU9yQixDQUFDeHlCLENBQUMsSUFBSVYsUUFBUSxDQUFDVSxDQUFELENBQWQsS0FBc0JrVSxFQUFFLENBQUNrZSxVQUFILEtBQW9CcHlCLENBQXBCLENBUEQsRUFTckJ1eUIsTUFBTSxDQUFDQyxJQUFQLEdBQWN4eUIsQ0FUTztBQVd0QixHQXhFYTs7QUEwRWQ7Ozs7O0FBS0E2eUIsdUJBL0VjLG1DQStFVTtBQUNqQixRQUFBM2UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdOLFdBQU9BLE1BQU0sQ0FBQzFULG1CQUFQLElBQThCMFQsTUFBTSxDQUFDaFEsd0JBQXJDLElBQWlFcWEsRUFBRSxDQUFDNGUsSUFBcEUsR0FDTkMsZ0ZBQU0sR0FDSkMsRUFERixDQUNLLE1BREwsRUFDYSxZQUFXO0FBQ3RCO0FBQ0E5ZSxRQUFFLENBQUM0ZSxJQUFILENBQVFHLGdHQUFPLENBQUMsSUFBRCxDQUFmLENBRnNCO0FBR3RCLEtBSkYsRUFLRUQsRUFMRixDQUtLLE9BTEwsRUFLYyxZQUFXO0FBQ3ZCO0FBQ0E5ZSxRQUFFLENBQUNnZixTQUFILENBQWFELGdHQUFPLENBQUMsSUFBRCxDQUFwQixDQUZ1QjtBQUd2QixLQVJGLEVBU0VELEVBVEYsQ0FTSyxLQVRMLEVBU1ksWUFBTTtBQUFFOWUsUUFBRSxDQUFDaWYsT0FBSCxFQUFGO0FBQWlCLEtBVG5DLENBRE0sR0FVaUMsWUFBTSxDQUFFLENBVmhEO0FBV0EsR0E5RmE7O0FBZ0dkOzs7Ozs7O0FBT0E5cUIsZUF2R2MseUJBdUdBMUUsSUF2R0EsRUF1R000VixLQXZHTixFQXVHYTlSLEtBdkdiLEVBdUdvQjtBQUMzQixRQUFBeU0sRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNBaVcsV0FEQSxHQUNjalcsRUFBRSxDQUFDaVcsV0FBSCxFQURkO0FBQUEsUUFFQWlKLFFBRkEsVUFFZWpKLFdBQVcsR0FBR3RtQixjQUFLLENBQUM5VyxTQUFULEdBQXdCOFcsY0FBSyxDQUFDOVcsU0FBOUIsU0FBMkN3c0IsS0FGckU7QUFBQSxRQUdBeHNCLFNBSEEsR0FHWW1uQixFQUFFLENBQUM1USxHQUFILENBQU9HLElBQVAsQ0FBWUcsTUFBWixDQUFtQnd2QixRQUFuQixFQUE2Qm54QixJQUE3QixFQUhaO0FBQUEsZ0NBSXFCbFYsU0FBUyxDQUFDa1cscUJBQVYsRUFKckI7QUFBQSxRQUlDNVMsS0FKRCx5QkFJQ0EsS0FKRDtBQUFBLFFBSVFPLElBSlIseUJBSVFBLElBSlI7QUFBQSxRQUljRixHQUpkLHlCQUljQSxHQUpkO0FBQUEsUUFLQW1CLENBTEEsR0FLSWpCLElBQUksSUFBSTZXLEtBQUssR0FBR0EsS0FBSyxDQUFDLENBQUQsQ0FBUixHQUFjLENBQXZCLENBQUosSUFDVDBpQixXQUFXLElBQUlqVyxFQUFFLENBQUNySyxNQUFILENBQVVjLFlBQXpCLEdBQXdDLENBQXhDLEdBQTZDdGEsS0FBSyxHQUFHLENBRDVDLENBTEo7QUFBQSxRQVFBMkIsQ0FSQSxHQVFJdEIsR0FBRyxJQUFJK1csS0FBSyxHQUFHQSxLQUFLLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBdkIsQ0FSUDs7QUFnQk5ELGdCQUFZLENBQUMsaUJBQWlCOUMsSUFBakIsQ0FBc0JmLElBQXRCLElBQThCLE9BQTlCLEdBQXdDLE9BQXpDLENBQVosQ0FBOEQ1VyxTQUE5RCxFQUF5RTRXLElBQXpFLEVBUGU7QUFDZGtFLGFBQU8sRUFBRWhXLENBREs7QUFFZGlXLGFBQU8sRUFBRTlWLENBRks7QUFHZCtWLGFBQU8sRUFBRWxXLENBSEs7QUFJZG1XLGFBQU8sRUFBRWhXO0FBSkssS0FPZixDQWpCaUM7QUFrQmpDO0FBekhhLENBQWYsRTs7QUNaQTs7OztBQUlBO0FBRWU7QUFDZHFoQyxlQURjLHlCQUNBcGIsTUFEQSxFQUNRc1UsUUFEUixFQUNrQjtBQUMvQixpQkFBV3RVLE1BQVgsVUFBcUJBLE1BQU0sR0FBRyxLQUFLb1gsdUJBQUwsQ0FBNkI5QyxRQUE3QixDQUE5QjtBQUNBLEdBSGE7QUFLZCtHLFdBTGMscUJBS0p0ekIsQ0FMSSxFQUtEO0FBQ1osV0FBTyxLQUFLcXpCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDL1UsSUFBekIsRUFBK0JrUixDQUFDLENBQUN1WixLQUFqQyxDQUFQO0FBQ0EsR0FQYTtBQVNkZ2EsWUFUYyxzQkFTSHZ6QixDQVRHLEVBU0E7QUFDYixXQUFPLEtBQUtxekIsYUFBTCxDQUFtQnh2QixjQUFLLENBQUM5VSxLQUF6QixFQUFnQ2lSLENBQUMsQ0FBQ3pOLEVBQWxDLENBQVA7QUFDQSxHQVhhO0FBYWRpaEMsWUFiYyxzQkFhSHh6QixDQWJHLEVBYUE7QUFDYixXQUFPLEtBQUtxekIsYUFBTCxDQUFtQnh2QixjQUFLLENBQUN2VixLQUF6QixFQUFnQzBSLENBQUMsQ0FBQ3VaLEtBQWxDLENBQVA7QUFDQSxHQWZhO0FBaUJka2EsYUFqQmMsdUJBaUJGenpCLENBakJFLEVBaUJDO0FBQ2QsV0FBTyxLQUFLcXpCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDdFYsTUFBekIsRUFBaUN5UixDQUFDLENBQUN6TixFQUFuQyxDQUFQO0FBQ0EsR0FuQmE7QUFxQmRtaEMsd0JBckJjLG9DQXFCVztBQUFBLFFBQ2xCeGYsRUFBRSxHQUFHLElBRGE7QUFBQSxRQUVsQnlmLE9BQU8sR0FBR3pmLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWtFLFlBQVYsSUFBMEIsRUFGbEI7QUFBQSxRQUdsQnVhLEdBQWEsR0FBRyxFQUhFO0FBS3hCLFdBQU8sVUFBU3RvQixDQUFULEVBQVk7QUFDbEIsVUFBTXpOLEVBQVUsR0FBR3lOLENBQUMsQ0FBQ3pOLEVBQUYsSUFBU3lOLENBQUMsQ0FBQ3FHLElBQUYsSUFBVXJHLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQTFCLElBQWlDeU4sQ0FBcEQ7QUFNQSxhQUpJc29CLEdBQUcsQ0FBQ2xtQixPQUFKLENBQVk3UCxFQUFaLElBQWtCLENBSXRCLElBSEMrMUIsR0FBRyxDQUFDL2dCLElBQUosQ0FBU2hWLEVBQVQsQ0FHRCxFQUFPb2hDLE9BQU8sQ0FBQ3JMLEdBQUcsQ0FBQ2xtQixPQUFKLENBQVk3UCxFQUFaLElBQWtCb2hDLE9BQU8sQ0FBQ3h6QixNQUEzQixDQUFkO0FBQ0EsS0FSRDtBQVNBLEdBbkNhO0FBcUNkeXpCLFdBckNjLHFCQXFDSjV6QixDQXJDSSxFQXFDRDtBQUNaLFdBQU8sS0FBS3d6QixVQUFMLENBQWdCeHpCLENBQWhCLElBQXFCLEtBQUtxekIsYUFBTCxDQUFtQnh2QixjQUFLLENBQUM3VixJQUF6QixFQUErQmdTLENBQUMsQ0FBQ3pOLEVBQWpDLENBQTVCO0FBQ0EsR0F2Q2E7QUF5Q2RzaEMsWUF6Q2Msc0JBeUNIN3pCLENBekNHLEVBeUNBO0FBQ2IsV0FBTyxLQUFLeXpCLFdBQUwsQ0FBaUJ6ekIsQ0FBakIsSUFBc0IsS0FBS3F6QixhQUFMLENBQW1CeHZCLGNBQUssQ0FBQzVWLEtBQXpCLEVBQWdDK1IsQ0FBQyxDQUFDek4sRUFBbEMsQ0FBN0I7QUFDQSxHQTNDYTtBQTZDZHVoQyxhQTdDYyx1QkE2Q0Y5ekIsQ0E3Q0UsRUE2Q0M7QUFDZCxXQUFPLEtBQUt3ekIsVUFBTCxDQUFnQnh6QixDQUFoQixJQUFxQixLQUFLcXpCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDclgsTUFBekIsRUFBaUN3VCxDQUFDLENBQUN1WixLQUFuQyxDQUE1QjtBQUNBLEdBL0NhO0FBaURkd2EsY0FqRGMsd0JBaUREL3pCLENBakRDLEVBaURFO0FBQ2YsV0FBTyxLQUFLeXpCLFdBQUwsQ0FBaUJ6ekIsQ0FBakIsSUFBc0IsS0FBS3F6QixhQUFMLENBQW1CeHZCLGNBQUssQ0FBQ3BYLE9BQXpCLEVBQWtDdVQsQ0FBQyxDQUFDek4sRUFBcEMsQ0FBN0I7QUFDQSxHQW5EYTtBQXFEZHloQyxVQXJEYyxvQkFxRExoMEIsQ0FyREssRUFxREY7QUFDWCxXQUFPLEtBQUt3ekIsVUFBTCxDQUFnQnh6QixDQUFoQixJQUFxQixLQUFLcXpCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDNVksR0FBekIsRUFBOEIrVSxDQUFDLENBQUN1WixLQUFoQyxDQUE1QjtBQUNBLEdBdkRhO0FBeURkMGEsV0F6RGMscUJBeURKajBCLENBekRJLEVBeUREO0FBQ1osV0FBTyxLQUFLeXpCLFdBQUwsQ0FBaUJ6ekIsQ0FBakIsSUFBc0IsS0FBS3F6QixhQUFMLENBQW1CeHZCLGNBQUssQ0FBQzNZLElBQXpCLEVBQStCOFUsQ0FBQyxDQUFDek4sRUFBakMsQ0FBN0I7QUFDQSxHQTNEYTtBQTZEZDJoQyxVQTdEYyxvQkE2RExsMEIsQ0E3REssRUE2REY7QUFDWCxXQUFPLEtBQUt3ekIsVUFBTCxDQUFnQnh6QixDQUFDLENBQUNxRyxJQUFsQixJQUEwQixLQUFLZ3RCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDeFosR0FBekIsRUFBOEIyVixDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUFyQyxDQUFqQztBQUNBLEdBL0RhO0FBaUVkNGhDLFdBakVjLHFCQWlFSm4wQixDQWpFSSxFQWlFRDtBQUNaLFdBQU8sS0FBS3l6QixXQUFMLENBQWlCenpCLENBQUMsQ0FBQ3FHLElBQW5CLElBQTJCLEtBQUtndEIsYUFBTCxDQUFtQnh2QixjQUFLLENBQUN0WixJQUF6QixFQUErQnlWLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQXRDLENBQWxDO0FBQ0EsR0FuRWE7QUFxRWQ2aEMsV0FyRWMscUJBcUVKcDBCLENBckVJLEVBcUVEO0FBQ1osV0FBTyxLQUFLd3pCLFVBQUwsQ0FBZ0J4ekIsQ0FBaEIsSUFBcUIsS0FBS3F6QixhQUFMLENBQW1CeHZCLGNBQUssQ0FBQ3JaLElBQXpCLEVBQStCd1YsQ0FBQyxDQUFDek4sRUFBakMsQ0FBNUI7QUFDQSxHQXZFYTtBQXlFZDhoQyxZQXpFYyxzQkF5RUhyMEIsQ0F6RUcsRUF5RUE7QUFDYixXQUFPLEtBQUt5ekIsV0FBTCxDQUFpQnp6QixDQUFqQixJQUFzQixLQUFLcXpCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDcFosS0FBekIsRUFBZ0N1VixDQUFDLENBQUN6TixFQUFsQyxDQUE3QjtBQUNBLEdBM0VhO0FBNkVkK2hDLGFBN0VjLHVCQTZFRnQwQixDQTdFRSxFQTZFQzJDLENBN0VELEVBNkVJO0FBQ2pCLFdBQVUsS0FBSzB3QixhQUFMLENBQW1CeHZCLGNBQUssQ0FBQzNWLE1BQXpCLEVBQWlDeVUsQ0FBakMsQ0FBVixVQUFpRCxXQUFXM0MsQ0FBWCxHQUFlQSxDQUFDLENBQUN1MEIsS0FBakIsR0FBeUIsRUFBMUU7QUFDQSxHQS9FYTtBQWlGZEMsWUFqRmMsc0JBaUZIeDBCLENBakZHLEVBaUZBO0FBQ2IsV0FBTyxLQUFLcXpCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDOVcsU0FBekIsRUFBb0NpVCxDQUFDLENBQUN1WixLQUF0QyxDQUFQO0FBQ0EsR0FuRmE7QUFxRmRrYixhQXJGYyx1QkFxRkZsaUMsRUFyRkUsRUFxRkU7QUFBQSxRQUNUbWlDLHFCQUFxQixHQUFHLEtBQUs3cUIsTUFBTCxDQUFZcFYsWUFBWixDQUF5QmxDLEVBQXpCLENBRGY7QUFBQSxRQUVYb2lDLGVBQWUsR0FBRyxFQUZQO0FBUWYsV0FKSUQscUJBSUosS0FIQ0MsZUFBZSxTQUFPOXdCLGNBQUssQ0FBQ2hWLE1BQWIsU0FBdUI2bEMscUJBR3ZDLEdBQU8sS0FBS3JCLGFBQUwsQ0FBbUJ4dkIsY0FBSyxDQUFDaFYsTUFBekIsRUFBaUMwRCxFQUFqQyxJQUF1Q29pQyxlQUE5QztBQUNBLEdBOUZhO0FBZ0dkQyxZQWhHYyxzQkFnR0g1MEIsQ0FoR0csRUFnR0E7QUFDYixXQUFPLEtBQUs2MEIsWUFBTCxDQUFrQjcwQixDQUFsQixJQUF1QixLQUFLODBCLGNBQUwsQ0FBb0I5MEIsQ0FBcEIsQ0FBOUI7QUFDQSxHQWxHYTtBQW9HZDYwQixjQXBHYyx3QkFvR0Q3MEIsQ0FwR0MsRUFvR0U7QUFDZixrQkFBVyxLQUFLNVAsS0FBTCxDQUFXd0QsZ0JBQVgsQ0FBNEJ3TyxPQUE1QixDQUFvQ3BDLENBQUMsQ0FBQ3pOLEVBQXRDLEtBQTZDLENBQTdDLEdBQWlEc1IsY0FBSyxDQUFDMVcsT0FBdkQsR0FBaUUsRUFBNUU7QUFDQSxHQXRHYTtBQXdHZDJuQyxnQkF4R2MsMEJBd0dDOTBCLENBeEdELEVBd0dJO0FBQ2pCLGtCQUFXLEtBQUs1UCxLQUFMLENBQVd5RCxrQkFBWCxDQUE4QnVPLE9BQTlCLENBQXNDcEMsQ0FBQyxDQUFDek4sRUFBeEMsS0FBK0MsQ0FBL0MsR0FBbURzUixjQUFLLENBQUNqWCxTQUF6RCxHQUFxRSxFQUFoRjtBQUNBLEdBMUdhO0FBNEdkbW9DLGdCQTVHYywwQkE0R0MvMEIsQ0E1R0QsRUE0R0k7QUFDakIsV0FBTzZELGNBQUssQ0FBQ3ZYLFNBQU4sR0FBa0IsS0FBS21vQyxXQUFMLENBQWlCejBCLENBQUMsQ0FBQ3pOLEVBQW5CLENBQXpCO0FBQ0EsR0E5R2E7QUFnSGR5aUMsZ0JBaEhjLDBCQWdIQ2gxQixDQWhIRCxFQWdISTtBQUNqQixXQUFPNkQsY0FBSyxDQUFDM1gsU0FBTixHQUFrQixLQUFLdW9DLFdBQUwsQ0FBaUJ6MEIsQ0FBQyxDQUFDek4sRUFBbkIsQ0FBekI7QUFDQSxHQWxIYTtBQW9IZDBpQyxlQXBIYyx5QkFvSEFqMUIsQ0FwSEEsRUFvSEc7QUFDaEIsV0FBTzZELGNBQUssQ0FBQzlYLFFBQU4sR0FBaUIsS0FBSzBvQyxXQUFMLENBQWlCejBCLENBQUMsQ0FBQ3pOLEVBQW5CLENBQXhCO0FBQ0EsR0F0SGE7QUF3SGQyaUMsZUF4SGMseUJBd0hBbDFCLENBeEhBLEVBd0hHO0FBQ2hCLFdBQU82RCxjQUFLLENBQUN0WSxRQUFOLEdBQWlCLEtBQUtrcEMsV0FBTCxDQUFpQnowQixDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUF4QixDQUF4QjtBQUNBLEdBMUhhO0FBNEhkNGlDLGlCQTVIYywyQkE0SEVuMUIsQ0E1SEYsRUE0SEs7QUFDbEIsV0FBTzZELGNBQUssQ0FBQ3pYLFVBQU4sR0FBbUIsS0FBS3FvQyxXQUFMLENBQWlCejBCLENBQUMsQ0FBQ3pOLEVBQW5CLENBQTFCO0FBQ0EsR0E5SGE7QUFnSWQ4OEIseUJBaEljLG1DQWdJVTlDLFFBaElWLEVBZ0lvQjtBQUNqQyxXQUFPQSxRQUFRLElBQUlBLFFBQVEsS0FBSyxDQUF6QixHQUNOLE9BQUlBLFFBQUosRUFBZXhxQixPQUFmLENBQXVCLDBDQUF2QixFQUFtRSxHQUFuRSxDQURNLEdBQ29FLEVBRDNFO0FBRUEsR0FuSWE7QUFxSWRtd0IsZ0JBckljLDBCQXFJQzMvQixFQXJJRCxFQXFJSzBsQixNQXJJTCxFQXFJYTtBQUFBLFFBQ3BCbWQsR0FBRyxHQUFHbmQsTUFBTSxJQUFJLEVBREk7QUFBQSxRQUVwQnBwQixNQUFNLEdBQUcsS0FBS3dnQyx1QkFBTCxDQUE2Qjk4QixFQUE3QixDQUZXO0FBSTFCO0FBQ0EsV0FBVTZpQyxHQUFWLFVBQWlCdnhCLGNBQUssQ0FBQ2hWLE1BQU4sR0FBZUEsTUFBaEMsV0FBMkN1bUMsR0FBM0MsVUFBa0R2eEIsY0FBSyxDQUFDcFgsT0FBTixHQUFnQm9DLE1BQWxFO0FBQ0EsR0EzSWE7QUE2SWR3bUMsaUJBN0ljLDJCQTZJRUMsUUE3SUYsRUE2SVlyZCxNQTdJWixFQTZJb0I7QUFBQSxRQUMzQi9ELEVBQUUsR0FBRyxJQURzQjtBQUFBLFFBRTNCb1UsR0FBRyxHQUFHZ04sUUFBUSxJQUFJLEVBRlM7QUFJakMsV0FBT2hOLEdBQUcsQ0FBQ25vQixNQUFKLEdBQ05tb0IsR0FBRyxDQUFDaG1CLEdBQUosQ0FBUSxVQUFBL1AsRUFBRTtBQUFBLGFBQUkyaEIsRUFBRSxDQUFDZ2UsY0FBSCxDQUFrQjMvQixFQUFsQixFQUFzQjBsQixNQUF0QixDQUFKO0FBQUEsS0FBVixDQURNLEdBQ3lDLElBRGhEO0FBRUEsR0FuSmE7QUFxSmRzZCxnQkFySmMsMEJBcUpDaGpDLEVBckpELEVBcUpLO0FBQ2xCLGtCQUFXc1IsY0FBSyxDQUFDclcsVUFBTixHQUFtQixLQUFLNmhDLHVCQUFMLENBQTZCOThCLEVBQTdCLENBQTlCO0FBQ0EsR0F2SmE7QUF5SmRpakMsaUJBekpjLDJCQXlKRWxOLEdBekpGLEVBeUpPO0FBQ3BCLFFBQU1wVSxFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9vVSxHQUFHLElBQUlBLEdBQUcsQ0FBQ25vQixNQUFYLEdBQ05tb0IsR0FBRyxDQUFDaG1CLEdBQUosQ0FBUSxVQUFBL1AsRUFBRTtBQUFBLGFBQUkyaEIsRUFBRSxDQUFDcWhCLGNBQUgsQ0FBa0JoakMsRUFBbEIsQ0FBSjtBQUFBLEtBQVYsQ0FETSxHQUNpQyxJQUR4QztBQUVBO0FBOUphLENBQWYsRTs7QUNOQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztJQVNNa2pDLGVBQWUsR0FBRyxVQUFDQyxPQUFELEVBQVV0a0IsS0FBVixFQUFpQjdlLEVBQWpCLEVBQWdDO0FBQ3ZELE1BQU0wUCxJQUFJLEdBQUdxVyxpR0FBUSxDQUFDb2QsT0FBTyxDQUFDQyxTQUFSLElBQUQsQ0FBckI7QUFTQSxTQVBBMXpCLElBQUksQ0FDRlksSUFERixDQUNPLElBRFAsRUFDYXRRLEVBRGIsRUFFRXltQixNQUZGLENBRVMsTUFGVCxFQUVpQixjQUZqQixFQUdFblcsSUFIRixDQUdPLE9BSFAsRUFHZ0JaLElBQUksQ0FBQ1ksSUFBTCxDQUFVLE9BQVYsQ0FIaEIsRUFJRUEsSUFKRixDQUlPLFFBSlAsRUFJaUJaLElBQUksQ0FBQ1ksSUFBTCxDQUFVLFFBQVYsQ0FKakIsRUFLRW9XLEtBTEYsQ0FLUSxNQUxSLEVBS2dCN0gsS0FMaEIsQ0FPQSxFQUFPO0FBQ043ZSxNQUFFLEVBQUZBLEVBRE07QUFFTjBQLFFBQUksRUFBRUEsSUFBSSxDQUFDQSxJQUFMO0FBRkEsR0FBUDtBQUlBLEM7SUFJSzJ6QixnQkFBZ0IsR0FBRyxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLEVBQWtDLFNBQWxDLEVBQTZDLFNBQTdDLEVBQXdELFNBQXhELEVBQW1FLFNBQW5FLEVBQThFLFNBQTlFLEVBQXlGLFNBQXpGLEVBQW9HLFNBQXBHLEMsRUFGekI7QUFDQTs7O0FBR2U7QUFDZDs7Ozs7O0FBTUFDLGlCQVBjLDZCQU9JO0FBQ1gsUUFDQ0MsSUFERCxHQUNTNzJCLFdBRFQsQ0FDQzYyQixJQUREO0FBQUEsUUFFRkosT0FGRSxHQUVRSSxJQUFJLG9CQUZaOztBQUlOLFFBQUksQ0FBQ0osT0FBTCxFQUFjO0FBQUEsVUFFUEssSUFBSSxHQUFHOTJCLFdBQVEsQ0FBQysyQixhQUFULENBQXVCLE1BQXZCLENBRkE7QUFJYkQsVUFBSSxDQUFDdlksU0FBTCxHQUFpQjNaLGNBQUssQ0FBQ25YLFlBSlYsRUFLYnFwQyxJQUFJLENBQUM5YyxLQUFMLENBQVc4TCxPQUFYLEdBQXFCLE1BTFIsRUFNYitRLElBQUksQ0FBQ0csV0FBTCxDQUFpQkYsSUFBakIsQ0FOYTtBQVFiLFVBQU1HLE9BQU8sR0FBR3QzQixHQUFNLENBQUN1M0IsZ0JBQVAsQ0FBd0JKLElBQXhCLEVBQThCSyxlQUE5QztBQUVBTCxVQUFJLENBQUNNLFVBQUwsQ0FBZ0JDLFdBQWhCLENBQTRCUCxJQUE1QixDQVZhLEVBWVRHLE9BQU8sQ0FBQzl6QixPQUFSLFFBQTZCLENBQUMsQ0FackIsS0FhWnN6QixPQUFPLEdBQUdRLE9BQU8sQ0FDZm4wQixPQURRLENBQ0EsMkJBREEsRUFDNkIsRUFEN0IsRUFFUlMsS0FGUSxNQUdSRixHQUhRLENBR0osVUFBQW5ELENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNvM0IsSUFBRixHQUFTeDBCLE9BQVQsQ0FBaUIsVUFBakIsRUFBNkIsRUFBN0IsQ0FBSjtBQUFBLE9BSEcsRUFJUnlFLE1BSlEsQ0FJRGd3QixPQUpDLENBYkUsRUFtQlpWLElBQUksb0JBQUosR0FBaUJKLE9BbkJMO0FBcUJiOztBQUVELFdBQU9BLE9BQVA7QUFDQSxHQXBDYTtBQXNDZGUsZUF0Q2MsMkJBc0NFO0FBQ1QsUUFBQXZpQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQTZzQixNQUZBLEdBRVM3c0IsTUFBTSxDQUFDOVUsV0FGaEI7QUFBQSxRQUdBa3dCLFFBSEEsR0FHV3BiLE1BQU0sQ0FBQy9VLFVBSGxCO0FBQUEsUUFJQXd6QixHQUpBLEdBSWdCLEVBSmhCO0FBQUEsUUFNRm9OLE9BTkUsR0FNUWwxQixRQUFRLENBQUNxSixNQUFNLENBQUM5VCxhQUFSLENBQVIsR0FBaUM4VCxNQUFNLENBQUM5VCxhQUF4QyxHQUNiNGdDLDJGQUFjLENBQUN6aUIsRUFBRSxDQUFDMmhCLGVBQUgsTUFBd0JELGdCQUF6QixDQUFkLENBQXlEamhCLEtBQXpELEVBUEs7QUFBQSxRQVNBaWlCLG9CQVRBLEdBU3VCbEIsT0FUdkI7O0FBV04sUUFBSXQyQixVQUFVLENBQUN5SyxNQUFNLENBQUM3VCxXQUFSLENBQWQsRUFBb0M7QUFBQSxVQUM3QjZnQyxLQUFLLEdBQUdodEIsTUFBTSxDQUFDN1QsV0FBUCxDQUFtQnFoQixJQUFuQixDQUF3Qm5ELEVBQUUsQ0FBQ2dKLEdBQTNCLEdBRHFCO0FBQUEsVUFJN0I0WixpQkFBaUIsR0FBR3BCLE9BQU8sQ0FBQ3B6QixHQUFSLENBQVksVUFBQ21DLENBQUQsRUFBSThVLEtBQUosRUFBYztBQUFBLFlBQzdDbkksS0FBSyxHQUFHM00sQ0FBQyxDQUFDMUMsT0FBRixDQUFVLGFBQVYsRUFBeUIsRUFBekIsQ0FEcUM7QUFBQSxZQUU3Q3hQLEVBQUUsR0FBTTJoQixFQUFFLENBQUM5akIsS0FBSCxDQUFTaUMsVUFBZixpQkFBcUMrZSxLQUFyQyxTQUE4Q21JLEtBRkg7QUFJbkQsZUFBT2tjLGVBQWUsQ0FBQ29CLEtBQUssQ0FBQ3RkLEtBQUssR0FBR3NkLEtBQUssQ0FBQzEyQixNQUFmLENBQU4sRUFBOEJzRSxDQUE5QixFQUFpQ2xTLEVBQWpDLENBQXRCO0FBQ0EsT0FMeUIsQ0FKUyxFQUduQzs7QUFRQW1qQyxhQUFPLEdBQUdvQixpQkFBaUIsQ0FBQ3gwQixHQUFsQixDQUFzQixVQUFBbUMsQ0FBQztBQUFBLHlCQUFZQSxDQUFDLENBQUNsUyxFQUFkO0FBQUEsT0FBdkIsQ0FYeUIsRUFZbkMyaEIsRUFBRSxDQUFDNmlCLFFBQUgsR0FBY0QsaUJBWnFCO0FBYW5DOztBQUVELFdBQU8sVUFBUzkyQixDQUFULEVBQVk7QUFBQSxVQUdkb1IsS0FIYztBQUFBLFVBQ1o3ZSxFQUFVLEdBQUd5TixDQUFDLENBQUN6TixFQUFGLElBQVN5TixDQUFDLENBQUNxRyxJQUFGLElBQVVyRyxDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUExQixJQUFpQ3lOLENBRGxDO0FBQUEsVUFFWmczQixNQUFNLEdBQUc5aUIsRUFBRSxDQUFDK2lCLFFBQUgsQ0FBWTFrQyxFQUFaLEVBQWdCLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUIsTUFBbkIsQ0FBaEIsS0FBK0MsQ0FBQ3NYLE1BQU0sQ0FBQ2pWLFVBQVAsQ0FBa0JyQyxFQUFsQixDQUY3QztBQXlCbEIsYUFuQkk2TSxVQUFVLENBQUNzM0IsTUFBTSxDQUFDbmtDLEVBQUQsQ0FBUCxDQW1CZCxHQWxCQzZlLEtBQUssR0FBR3NsQixNQUFNLENBQUNua0MsRUFBRCxDQUFOLENBQVc4a0IsSUFBWCxDQUFnQm5ELEVBQUUsQ0FBQ2dKLEdBQW5CLEVBQXdCbGQsQ0FBeEIsQ0FrQlQsR0FmVzAyQixNQUFNLENBQUNua0MsRUFBRCxDQWVqQixHQWRDNmUsS0FBSyxHQUFHc2xCLE1BQU0sQ0FBQ25rQyxFQUFELENBY2YsSUFWSysxQixHQUFHLENBQUNsbUIsT0FBSixDQUFZN1AsRUFBWixJQUFrQixDQVV2QixJQVRFKzFCLEdBQUcsQ0FBQy9nQixJQUFKLENBQVNoVixFQUFULENBU0YsRUFOQzZlLEtBQUssR0FBRzRsQixNQUFNLEdBQUdKLG9CQUFvQixDQUFDdE8sR0FBRyxDQUFDbG1CLE9BQUosQ0FBWTdQLEVBQVosSUFBa0Jxa0Msb0JBQW9CLENBQUN6MkIsTUFBeEMsQ0FBdkIsR0FDYnUxQixPQUFPLENBQUNwTixHQUFHLENBQUNsbUIsT0FBSixDQUFZN1AsRUFBWixJQUFrQm1qQyxPQUFPLENBQUN2MUIsTUFBM0IsQ0FLVCxFQUhDdTJCLE1BQU0sQ0FBQ25rQyxFQUFELENBQU4sR0FBYTZlLEtBR2QsR0FBT2hTLFVBQVUsQ0FBQzZsQixRQUFELENBQVYsR0FDTkEsUUFBUSxDQUFDNU4sSUFBVCxDQUFjbkQsRUFBRSxDQUFDZ0osR0FBakIsRUFBc0I5TCxLQUF0QixFQUE2QnBSLENBQTdCLENBRE0sR0FDNEJvUixLQURuQztBQUVBLEtBM0JEO0FBNEJBLEdBN0ZhO0FBK0ZkOGxCLG9CQS9GYyxnQ0ErRk87QUFDZCxRQUFBaGpCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFBQSxRQUVBNnNCLE1BRkEsR0FFUzdzQixNQUFNLENBQUM5VCxhQUZoQjtBQUFBLFFBR0FvaEMsU0FIQSxHQUdZdHRCLE1BQU0sQ0FBQzVULGVBSG5CO0FBQUEsUUFJQW1oQyxPQUpBLEdBSVVELFNBQVMsQ0FBQ0UsSUFBVixLQUFtQixPQUo3QjtBQUFBLFFBS0F2Z0IsR0FMQSxHQUtNcWdCLFNBQVMsQ0FBQ3JnQixHQUFWLElBQWlCLEdBTHZCO0FBQUEsUUFNQTFDLE1BTkEsR0FNUytpQixTQUFTLENBQUMvaUIsTUFBVixJQUNkK2lCLFNBQVMsQ0FBQy9pQixNQUFWLENBQWlCalUsTUFESCxHQUNZZzNCLFNBQVMsQ0FBQy9pQixNQUR0QixHQUMrQixFQVB4QztBQVNOLFdBQU81VCxRQUFRLENBQUMyMkIsU0FBRCxDQUFSLEdBQXNCLFVBQVM5MUIsS0FBVCxFQUFnQjtBQUFBLFVBQ3RDbEMsQ0FBQyxHQUFHaTRCLE9BQU8sR0FBRy8xQixLQUFILEdBQVlBLEtBQUssR0FBRyxHQUFSLEdBQWN5VixHQURDO0FBQUEsVUFFeEMxRixLQUFLLEdBQUdzbEIsTUFBTSxDQUFDQSxNQUFNLENBQUN2MkIsTUFBUCxHQUFnQixDQUFqQixDQUYwQjs7QUFJNUMsV0FBSyxJQUFJd0MsQ0FBQyxHQUFHLENBQVIsRUFBVzIwQixDQUFDLEdBQUdsakIsTUFBTSxDQUFDalUsTUFBM0IsRUFBbUN3QyxDQUFDLEdBQUcyMEIsQ0FBdkMsRUFBMEMzMEIsQ0FBQyxFQUEzQyxFQUNDLElBQUl4RCxDQUFDLElBQUlpVixNQUFNLENBQUN6UixDQUFELENBQWYsRUFBb0I7QUFDbkJ5TyxhQUFLLEdBQUdzbEIsTUFBTSxDQUFDL3pCLENBQUQsQ0FESztBQUVuQjtBQUNBOztBQUdGLGFBQU95TyxLQUFQO0FBQ0EsS0FaTSxHQVlILElBWko7QUFhQSxHQXRIYTs7QUF3SGQ7Ozs7Ozs7QUFPQWtoQixjQS9IYyx3QkErSERELE1BL0hDLEVBK0hPcnlCLENBL0hQLEVBK0hVO0FBQ2pCLFFBQUFrVSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3dCcUssRUFEeEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNlcEcsSUFEZixHQUN3QnlRLEVBRHhCLENBQ1M1USxHQURULENBQ2VHLElBRGY7QUFBQSxRQUVBbVAsTUFGQSxHQUVTL0ksTUFBTSxDQUFDM1QsWUFGaEI7QUFBQSxRQUdGa2IsS0FIRSxHQUdNaWhCLE1BQU0sR0FBR3pmLE1BQUgsR0FBWXNCLEVBQUUsQ0FBQzlDLEtBSDNCO0FBS0Z4USxZQUFRLENBQUN3USxLQUFELENBTlcsR0FPdEJBLEtBQUssR0FBRztBQUFBLFVBQUU3ZSxFQUFGLFFBQUVBLEVBQUY7QUFBQSxhQUFXQSxFQUFFLElBQUlxZ0IsTUFBTixHQUFlQSxNQUFNLENBQUNyZ0IsRUFBRCxDQUFyQixHQUE0QjJoQixFQUFFLENBQUM5QyxLQUFILENBQVM3ZSxFQUFULENBQXZDO0FBQUEsS0FQYyxHQVFaOE0sUUFBUSxDQUFDK1IsS0FBRCxDQVJJLEdBU3RCQSxLQUFLLEdBQUc7QUFBQSxhQUFNd0IsTUFBTjtBQUFBLEtBVGMsR0FVWnhULFVBQVUsQ0FBQ3dULE1BQUQsQ0FWRSxLQVd0QnhCLEtBQUssR0FBR0EsS0FBSyxDQUFDaUcsSUFBTixDQUFXbkQsRUFBRSxDQUFDZ0osR0FBZCxDQVhjLEdBZW5CdGMsUUFBUSxDQUFDWixDQUFELENBZlcsR0FnQnRCeUQsSUFBSSxDQUFDa1YsU0FBTCxPQUFtQjlVLGNBQUssQ0FBQ3haLEdBQXpCLEdBQStCNnBCLEVBQUUsQ0FBQ21iLHVCQUFILENBQTJCcnZCLENBQUMsQ0FBQ3pOLEVBQTdCLENBQS9CLEVBQ0UwbUIsS0FERixDQUNRLE1BRFIsRUFDZ0I3SCxLQUFLLENBQUNwUixDQUFELENBRHJCLENBaEJzQixHQW1CdEJ5RCxJQUFJLENBQUNrVixTQUFMLE9BQW1COVUsY0FBSyxDQUFDdlYsS0FBekIsU0FBa0MwUixDQUFsQyxFQUNFaVosS0FERixDQUNRLE1BRFIsRUFDZ0I3SCxLQURoQixDQW5Cc0I7QUFzQnZCO0FBckphLENBQWYsRTs7QUN2Q0E7Ozs7QUFJQTtBQUVlO0FBQ2RtbUIsa0JBRGMsNEJBQ0d4akIsT0FESCxFQUNZcFEsSUFEWixFQUNrQjtBQUN6QixRQUFBdVEsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUEydEIsS0FGQSxHQUVRN3pCLElBQUksS0FBSyxLQUZqQjtBQUFBLFFBSUE4ekIsVUFKQSxHQUlhNXRCLE1BQU0sQ0FBQzNRLFdBSnBCO0FBQUEsUUFLQW92QixHQUxBLEdBS01wVSxFQUFFLENBQUNxVixRQUFILENBQVl4VixPQUFaLENBTE47QUFBQSxRQU1BZ1osRUFOQSxHQU1LN1ksRUFBRSxDQUFDNFksa0JBQUgsQ0FBc0IvWSxPQUF0QixDQU5MO0FBZ0ROLFdBeENJMGpCLFVBQVUsQ0FBQ3QzQixNQUFYLEdBQW9CLENBd0N4QjtBQXJDQyxlQUFnQnUzQixVQUFoQixRQUZNdjJCLFFBQVEsR0FBRytTLEVBQUUsVUFBT3NqQixLQUFLLEdBQUcsVUFBSCxHQUFnQixVQUE1QixxQkFBRixDQUEwRHpqQixPQUExRCxDQUVqQixvQkFBU2lVLENBQVQ7QUFJQyxZQUZBMFAsV0FBVSxHQUFHQSxXQUFVLENBQUNseEIsTUFBWCxDQUFrQixVQUFBckgsQ0FBQztBQUFBLGlCQUFJbXBCLEdBQUcsQ0FBQ2xtQixPQUFKLENBQVlqRCxDQUFaLEtBQWtCLENBQXRCO0FBQUEsU0FBbkIsQ0FFYixFQUFJdTRCLFdBQVUsQ0FBQ3YzQixNQUFYLEtBQXNCLENBQTFCLEVBQ0M7QUFMRixZQVFPdzNCLE1BQU0sR0FBR0QsV0FBVSxDQUFDLENBQUQsQ0FSMUI7QUFBQSxZQVNPRSxVQUFVLEdBQUcxakIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUTZ6QixLQUFSLENBQWNvWixNQUFkLENBVHBCO0FBWUt4MkIsZ0JBQVEsSUFBSTRyQixFQUFFLENBQUM0SyxNQUFELENBWm5CLEtBYUU1SyxFQUFFLENBQUM0SyxNQUFELENBQUYsR0FBYTVLLEVBQUUsQ0FBQzRLLE1BQUQsQ0FBRixDQUFXcjFCLEdBQVgsQ0FBZSxVQUFBbkQsQ0FBQztBQUFBLGlCQUM1QixDQUFDcTRCLEtBQUssR0FBR3I0QixDQUFDLEdBQUcsQ0FBUCxHQUFXQSxDQUFDLEdBQUcsQ0FBckIsSUFBMEJBLENBQTFCLEdBQThCLENBREY7QUFBQSxTQUFoQixDQWJmOztBQWtCQyxpQkFBZ0I1TSxFQUFoQiw0QkFBU3UxQixDQUFULEVBQWdCdjFCLEVBQWhCO0FBQ0MsY0FBSSxDQUFDdzZCLEVBQUUsQ0FBQ3g2QixFQUFELENBQVAsRUFDQztBQUdELGNBQU02cEIsTUFBTSxHQUFHbEksRUFBRSxDQUFDeHBCLElBQUgsQ0FBUTZ6QixLQUFSLENBQWNoc0IsRUFBZCxDQUFmO0FBRUF3NkIsWUFBRSxDQUFDeDZCLEVBQUQsQ0FBRixDQUFPZ1AsT0FBUCxDQUFlLFVBQUNwQyxDQUFELEVBQUl3RCxDQUFKLEVBQVU7QUFBQSxnQkFDbEIwcEIsR0FBRyxHQUFHLENBQUNsdEIsQ0FEVztBQUFBLGdCQUVsQjA0QixhQUFhLEdBQUdMLEtBQUssR0FBR25MLEdBQUcsR0FBRyxDQUFULEdBQWFBLEdBQUcsR0FBRyxDQUZ0QjtBQUlwQmpRLGtCQUFNLEtBQUt3YixVQUFYLElBQTJCejJCLFFBQVEsSUFBSTAyQixhQUpuQixLQUt2QjlLLEVBQUUsQ0FBQzRLLE1BQUQsQ0FBRixDQUFXaDFCLENBQVgsS0FBaUIwcEIsR0FMTTtBQU94QixXQVBELENBUEQ7QUFBQSxXQUFTdkUsQ0FBQyxHQUFHLENBQWIsRUFBcUJ2MUIsRUFBRSxHQUFHbWxDLFdBQVUsQ0FBQzVQLENBQUQsQ0FBcEMsRUFBMENBLENBQUMsRUFBM0MsaUJBQVNBLENBQVQsRUFBZ0J2MUIsRUFBaEI7O0FBbEJEO0FBQUEsU0FBU3kxQixDQUFDLEdBQUcsQ0FBYixFQUE2QjBQLFVBQVUsR0FBR0QsVUFBVSxDQUFDelAsQ0FBRCxDQUFwRCxFQUEwREEsQ0FBQyxFQUEzRCxlQUFTQSxDQUFULEVBQWdCMFAsVUFBaEI7QUFxQ0QsU0FBT3h3QixTQUFTLENBQUN2RCxJQUFELEVBQU90RCxNQUFNLENBQUNDLElBQVAsQ0FBWXlzQixFQUFaLEVBQWdCenFCLEdBQWhCLENBQW9CLFVBQUFyQixHQUFHO0FBQUEsYUFBSWlHLFNBQVMsQ0FBQ3ZELElBQUQsRUFBT29wQixFQUFFLENBQUM5ckIsR0FBRCxDQUFULENBQWI7QUFBQSxLQUF2QixDQUFQLENBQWhCO0FBQ0EsR0FuRGE7QUFxRGQ2MkIsZUFyRGMseUJBcURBL2pCLE9BckRBLEVBcURTO0FBQ3RCLFdBQU8sS0FBS3dqQixnQkFBTCxDQUFzQnhqQixPQUF0QixFQUErQixLQUEvQixDQUFQO0FBQ0EsR0F2RGE7QUF5RGRna0IsZUF6RGMseUJBeURBaGtCLE9BekRBLEVBeURTO0FBQ3RCLFdBQU8sS0FBS3dqQixnQkFBTCxDQUFzQnhqQixPQUF0QixFQUErQixLQUEvQixDQUFQO0FBQ0EsR0EzRGE7QUE2RGRxUSxZQTdEYyxzQkE2REhyUSxPQTdERyxFQTZETXFJLE1BN0ROLEVBNkRjZ1MsT0E3RGQsRUE2RHVCO0FBQzlCLFFBQUFsYSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2tCcUssRUFEbEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTMEssS0FEVCxHQUNrQkwsRUFEbEIsQ0FDU0ssS0FEVDtBQUdOLFFBQUlMLEVBQUUsQ0FBQ2dLLGlCQUFILEVBQUosRUFDQyxPQUFPLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FBUDtBQUxtQyxRQVE5QjhaLGVBQWUsR0FBR2prQixPQUFPLENBQUN2TixNQUFSLENBQWUsVUFBQWtWLENBQUM7QUFBQSxhQUFJeEgsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUTZ6QixLQUFSLENBQWM3QyxDQUFDLENBQUNucEIsRUFBaEIsTUFBd0I2cEIsTUFBNUI7QUFBQSxLQUFoQixDQVJZO0FBQUEsUUFTOUI2YixRQUFRLEdBQUc3SixPQUFPLEdBQUdsYSxFQUFFLENBQUNpYSxlQUFILENBQW1CNkosZUFBbkIsRUFBb0M1SixPQUFwQyxDQUFILEdBQWtENEosZUFUdEM7QUFXcEMsUUFBSUMsUUFBUSxDQUFDOTNCLE1BQVQsS0FBb0IsQ0FBeEIsRUFBNkI7QUFDNUIsYUFBT2ljLE1BQU0sS0FBSyxJQUFYLEdBQ043SCxLQUFLLENBQUN2aUIsQ0FBTixDQUFRRCxNQUFSLEVBRE0sR0FFTjtBQUNBO0FBQ0FtaUIsUUFBRSxDQUFDa1EsVUFBSCxDQUFjclEsT0FBZCxFQUF1QixJQUF2QixFQUE2QnFhLE9BQTdCLENBSkQ7QUFabUMsUUFtQjlCOEosSUFBSSxHQUFHcnVCLE1BQU0sV0FBU3VTLE1BQVQsVUFuQmlCO0FBQUEsUUFvQjlCK2IsSUFBSSxHQUFHdHVCLE1BQU0sV0FBU3VTLE1BQVQsVUFwQmlCO0FBQUEsUUFxQmhDZ2MsVUFBVSxHQUFHbGtCLEVBQUUsQ0FBQzRqQixhQUFILENBQWlCRyxRQUFqQixDQXJCbUI7QUFBQSxRQXNCaENJLFVBQVUsR0FBR25rQixFQUFFLENBQUM2akIsYUFBSCxDQUFpQkUsUUFBakIsQ0F0Qm1CO0FBQUEsUUF3QjlCSyxNQUFNLEdBQUd6dUIsTUFBTSxXQUFTdVMsTUFBVCxhQXhCZTtBQUFBLFFBeUJoQ21jLFdBQVcsR0FBRyxDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCLFFBQWhCLEVBQTBCLE1BQTFCLEVBQWtDLFNBQWxDLEVBQ2hCMVEsSUFEZ0IsQ0FDWCxVQUFBMW9CLENBQUM7QUFBQSxhQUFJK1UsRUFBRSxDQUFDa1csT0FBSCxDQUFXanJCLENBQVgsRUFBYzg0QixRQUFkLEtBQTJCcHVCLE1BQU0sQ0FBSTFLLENBQUosZ0JBQXJDO0FBQUEsS0FEVSxDQXpCa0I7QUFBQSxRQTJCOUJxNUIsVUFBVSxHQUFHM3VCLE1BQU0sV0FBU3VTLE1BQVQsZUEzQlc7QUFBQSxRQTRCOUJxYyx1QkFBdUIsR0FBR3ZrQixFQUFFLENBQUNtYSxZQUFILE1BQXFCeGtCLE1BQU0sQ0FBQ2MsWUE1QnhCO0FBQUEsUUE2QjlCK3RCLHFCQUFxQixHQUFHeGtCLEVBQUUsQ0FBQ21hLFlBQUgsTUFBcUIsQ0FBQ3hrQixNQUFNLENBQUNjLFlBN0J2QjtBQWdDcEN5dEIsY0FBVSxHQUFHbDVCLE9BQU8sQ0FBQ2c1QixJQUFELENBQVAsR0FBZ0JBLElBQWhCLEdBQ1hoNUIsT0FBTyxDQUFDaTVCLElBQUQsQ0FBUCxHQUFpQkMsVUFBVSxHQUFHRCxJQUFiLEdBQW9CQyxVQUFwQixHQUFpQ0QsSUFBSSxHQUFHLEVBQXpELEdBQStEQyxVQWpDN0IsRUFrQ3BDQyxVQUFVLEdBQUduNUIsT0FBTyxDQUFDaTVCLElBQUQsQ0FBUCxHQUFnQkEsSUFBaEIsR0FDWGo1QixPQUFPLENBQUNnNUIsSUFBRCxDQUFQLEdBQWlCQSxJQUFJLEdBQUdHLFVBQVAsR0FBb0JBLFVBQXBCLEdBQWlDSCxJQUFJLEdBQUcsRUFBekQsR0FBK0RHLFVBbkM3QixFQXFDaEM5M0IsS0FBSyxDQUFDNjNCLFVBQUQsQ0FyQzJCLEtBc0NuQ0EsVUFBVSxHQUFHLENBdENzQixHQXlDaEM3M0IsS0FBSyxDQUFDODNCLFVBQUQsQ0F6QzJCLEtBMENuQ0EsVUFBVSxHQUFHRCxVQTFDc0IsR0E2Q2hDQSxVQUFVLEtBQUtDLFVBN0NpQixLQThDbkNELFVBQVUsR0FBRyxDQUFiLEdBQWlCQyxVQUFVLEdBQUcsQ0FBOUIsR0FBa0NELFVBQVUsR0FBRyxDQTlDWjtBQUFBLFFBaUQ5Qk8sYUFBYSxHQUFHUCxVQUFVLElBQUksQ0FBZCxJQUFtQkMsVUFBVSxJQUFJLENBakRuQjtBQUFBLFFBa0Q5Qk8sYUFBYSxHQUFHUixVQUFVLElBQUksQ0FBZCxJQUFtQkMsVUFBVSxJQUFJLENBbERuQjtBQUFBLEtBcUQvQm41QixPQUFPLENBQUNnNUIsSUFBRCxDQUFQLElBQWlCUyxhQUFsQixJQUFxQ3o1QixPQUFPLENBQUNpNUIsSUFBRCxDQUFQLElBQWlCUyxhQXJEdEIsTUFzRG5DTCxXQUFXLEtBdER3QixHQTBEaENBLFdBMURnQyxLQTJEbkNJLGFBQWEsS0FBS1AsVUFBVSxHQUFHLENBQWxCLENBM0RzQixFQTREbkNRLGFBQWEsS0FBS1AsVUFBVSxHQUFHLENBQWxCLENBNURzQjtBQUFBLFFBK0Q5QjNWLFlBQVksR0FBRy9pQixJQUFJLENBQUNvdUIsR0FBTCxDQUFTc0ssVUFBVSxHQUFHRCxVQUF0QixDQS9EZTtBQUFBLFFBZ0U5QjNWLE9BQU8sR0FBRztBQUFDL3hCLFNBQUcsRUFBRWd5QixZQUFZLEdBQUcsRUFBckI7QUFBMEIveEIsWUFBTSxFQUFFK3hCLFlBQVksR0FBRztBQUFqRCxLQWhFb0I7O0FBa0VwQyxRQUFJbGpCLFNBQVMsQ0FBQzg0QixNQUFELENBQWIsRUFBdUI7QUFDdEIsVUFBTU8sVUFBVSxHQUFHbDVCLElBQUksQ0FBQ21YLEdBQUwsQ0FBU25YLElBQUksQ0FBQ291QixHQUFMLENBQVNxSyxVQUFULENBQVQsRUFBK0J6NEIsSUFBSSxDQUFDb3VCLEdBQUwsQ0FBU3NLLFVBQVQsQ0FBL0IsQ0FBbkI7QUFFQUEsZ0JBQVUsR0FBR0MsTUFBTSxHQUFHTyxVQUhBLEVBSXRCVCxVQUFVLEdBQUdFLE1BQU0sR0FBR08sVUFKQTtBQUt0QixLQXZFbUMsQ0F5RXBDOzs7QUFDQSxRQUFJSix1QkFBSixFQUE2QjtBQUFBLFVBQ3RCcDJCLElBQUksR0FBR3RDLFVBQVUsQ0FBQ3dVLEtBQUssQ0FBQ3ZpQixDQUFOLENBQVEyaUIsS0FBUixFQUFELENBREs7QUFBQSxVQUV0QjZiLEtBQUssR0FBR3RjLEVBQUUsQ0FBQ3FhLGtCQUFILENBQXNCNkosVUFBdEIsRUFBa0NDLFVBQWxDLEVBQThDLE9BQTlDLEVBQ1ovMUIsR0FEWSxDQUNSLFVBQUFuRCxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxHQUFHa0QsSUFBUjtBQUFBLE9BRE8sQ0FGYztBQUs1QixPQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCZCxPQUFsQixDQUEwQixVQUFDcEMsQ0FBRCxFQUFJd0QsQ0FBSixFQUFVO0FBQ25DOGYsZUFBTyxDQUFDdGpCLENBQUQsQ0FBUCxJQUFjdWpCLFlBQVksSUFBSThOLEtBQUssQ0FBQzd0QixDQUFELENBQUwsSUFBWSxJQUFJNnRCLEtBQUssQ0FBQyxDQUFELENBQVQsR0FBZUEsS0FBSyxDQUFDLENBQUQsQ0FBaEMsQ0FBSixDQURTO0FBRW5DLE9BRkQsQ0FMNEI7QUFRNUIsS0FSRCxNQVFPLElBQUlrSSxxQkFBSixFQUEyQjtBQUNqQyxVQUFNbEssT0FBTyxHQUFHdGEsRUFBRSxDQUFDcWEsa0JBQUgsQ0FBc0I2SixVQUF0QixFQUFrQ0MsVUFBbEMsRUFBOEMsUUFBOUMsQ0FBaEI7QUFFQSxPQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCOTJCLE9BQWxCLENBQTBCLFVBQUNwQyxDQUFELEVBQUl3RCxDQUFKLEVBQVU7QUFDbkM4ZixlQUFPLENBQUN0akIsQ0FBRCxDQUFQLElBQWMrVSxFQUFFLENBQUN4cEIsSUFBSCxDQUFRaTRCLDBCQUFSLENBQW1DNkwsT0FBTyxDQUFDN3JCLENBQUQsQ0FBMUMsRUFBK0MrZixZQUEvQyxDQURxQjtBQUVuQyxPQUZELENBSGlDO0FBTWpDOztBQUVELFFBQUksUUFBUWhlLElBQVIsQ0FBYTBYLE1BQWIsQ0FBSixFQUEwQjtBQUN6QixVQUFNM1gsQ0FBQyxHQUFHb0YsTUFBTSxXQUFTdVMsTUFBVCxjQUFoQjtBQUVJNWIsY0FBUSxDQUFDaUUsQ0FBRCxDQUhhLElBSXhCLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0JsRCxPQUFsQixDQUEwQixVQUFBcEMsQ0FBQyxFQUFJO0FBQzlCc2pCLGVBQU8sQ0FBQ3RqQixDQUFELENBQVAsR0FBYStVLEVBQUUsQ0FBQ3hwQixJQUFILENBQVE4M0IsVUFBUixDQUFtQi9kLENBQW5CLEVBQXNCdEYsQ0FBdEIsRUFBeUJzakIsT0FBTyxDQUFDdGpCLENBQUQsQ0FBaEMsRUFBcUN1akIsWUFBckMsQ0FEaUI7QUFFOUIsT0FGRCxDQUp3QjtBQVF6QixLQWxHbUMsQ0FvR3BDOzs7QUFDSTZWLGVBckdnQyxLQXNHbkNJLGFBQWEsS0FBS2xXLE9BQU8sQ0FBQzl4QixNQUFSLEdBQWlCeW5DLFVBQXRCLENBdEdzQixFQXVHbkNRLGFBQWEsS0FBS25XLE9BQU8sQ0FBQy94QixHQUFSLEdBQWMsQ0FBQzJuQyxVQUFwQixDQXZHc0I7QUEwR3BDLFFBQU10bUMsTUFBTSxHQUFHLENBQUNxbUMsVUFBVSxHQUFHM1YsT0FBTyxDQUFDOXhCLE1BQXRCLEVBQThCMG5DLFVBQVUsR0FBRzVWLE9BQU8sQ0FBQy94QixHQUFuRCxDQUFmO0FBRUEsV0FBTzhuQyxVQUFVLEdBQUd6bUMsTUFBTSxDQUFDeW9CLE9BQVAsRUFBSCxHQUFzQnpvQixNQUF2QztBQUNBLEdBMUthO0FBNEtkK21DLGtCQTVLYyw0QkE0S0cva0IsT0E1S0gsRUE0S1lwUSxJQTVLWixFQTRLa0I7QUFBQSxRQUN6QnVRLEVBQUUsR0FBRyxJQURvQjtBQUFBLFFBRXpCN1MsS0FBSyxHQUFHNlMsRUFBRSxDQUFDckssTUFBSCxhQUFvQmxHLElBQXBCLENBRmlCO0FBSS9CLFdBQU9uRSxTQUFTLENBQUM2QixLQUFELENBQVQsR0FDTDZTLEVBQUUsQ0FBQzhKLFlBQUgsS0FBb0J0VSxTQUFTLENBQUM5SCxJQUFWLENBQWVzUyxFQUFmLEVBQW1CN1MsS0FBbkIsQ0FBcEIsR0FBZ0RBLEtBRDNDLEdBRU42RixTQUFTLENBQUN2RCxJQUFELEVBQU9vUSxPQUFPLENBQUN6UixHQUFSLENBQVksVUFBQW9aLENBQUM7QUFBQSxhQUFJeFUsU0FBUyxDQUFDdkQsSUFBRCxFQUFPK1gsQ0FBQyxDQUFDdEgsTUFBRixDQUFTOVIsR0FBVCxDQUFhLFVBQUFuRCxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDdE4sQ0FBTjtBQUFBLE9BQWQsQ0FBUCxDQUFiO0FBQUEsS0FBYixDQUFQLENBRlY7QUFHQSxHQW5MYTtBQXFMZGtuQyxlQXJMYyx5QkFxTEFobEIsT0FyTEEsRUFxTFM7QUFDdEIsV0FBTyxLQUFLK2tCLGdCQUFMLENBQXNCL2tCLE9BQXRCLEVBQStCLEtBQS9CLENBQVA7QUFDQSxHQXZMYTtBQXlMZGlsQixlQXpMYyx5QkF5TEFqbEIsT0F6TEEsRUF5TFM7QUFDdEIsV0FBTyxLQUFLK2tCLGdCQUFMLENBQXNCL2tCLE9BQXRCLEVBQStCLEtBQS9CLENBQVA7QUFDQSxHQTNMYTtBQTZMZGtsQixtQkE3TGMsNkJBNkxJbG5DLE1BN0xKLEVBNkxZO0FBS3JCLFFBQUFtbkMsWUFBWTtBQUFBLFFBQ1p6VyxPQURZO0FBQUEsUUFKVnZPLEVBSVUsR0FKTCxJQUlLO0FBQUEsUUFIVHJLLE1BR1MsR0FIQ3FLLEVBR0QsQ0FIVHJLLE1BR1M7QUFBQSxRQUZWeEgsSUFFVSxHQUZIdFEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUVmO0FBQUEsUUFEVm9uQyxRQUNVLEdBREN0dkIsTUFBTSxDQUFDdk8sY0FDUjtBQUdaNFksTUFBRSxDQUFDMEosYUFBSCxFQVJxQixHQVN4QjZFLE9BQU8sR0FBRyxDQVRjLEdBVWR2TyxFQUFFLENBQUNrVyxPQUFILENBQVcsS0FBWCxDQVZjLElBV3hCOE8sWUFBWSxHQUFHaGxCLEVBQUUsQ0FBQytYLGVBQUgsRUFYUyxFQVl4QnhKLE9BQU8sR0FBR3lXLFlBQVksR0FBRyxDQUFmLEdBQW9CNzJCLElBQUksSUFBSTYyQixZQUFZLEdBQUcsQ0FBbkIsQ0FBTCxHQUE4QixDQUFqRCxHQUFxRCxFQVp2QyxJQWN4QnpXLE9BQU8sR0FBR3BnQixJQUFJLEdBQUcsR0FkTztBQUFBLFFBaUJyQnpSLElBQUksR0FBRzZ4QixPQWpCYztBQUFBLFFBa0JyQjV4QixLQUFLLEdBQUc0eEIsT0FsQmE7QUE0QnpCLFdBUkk3aEIsUUFBUSxDQUFDdTRCLFFBQUQsQ0FBUixJQUFzQjM0QixRQUFRLENBQUMyNEIsUUFBRCxDQVFsQyxJQVBDdm9DLElBQUksR0FBR3NPLE9BQU8sQ0FBQ2k2QixRQUFRLENBQUN2b0MsSUFBVixDQUFQLEdBQXlCdW9DLFFBQVEsQ0FBQ3ZvQyxJQUFsQyxHQUF5QzZ4QixPQU9qRCxFQU5DNXhCLEtBQUssR0FBR3FPLE9BQU8sQ0FBQ2k2QixRQUFRLENBQUN0b0MsS0FBVixDQUFQLEdBQTBCc29DLFFBQVEsQ0FBQ3RvQyxLQUFuQyxHQUEyQzR4QixPQU1wRCxJQUxXbmpCLFFBQVEsQ0FBQ3VLLE1BQU0sQ0FBQ3ZPLGNBQVIsQ0FLbkIsS0FKQzFLLElBQUksR0FBR3VvQyxRQUlSLEVBSEN0b0MsS0FBSyxHQUFHc29DLFFBR1QsR0FBTztBQUFDdm9DLFVBQUksRUFBSkEsSUFBRDtBQUFPQyxXQUFLLEVBQUxBO0FBQVAsS0FBUDtBQUNBLEdBMU5hO0FBNE5kdW9DLFlBNU5jLHNCQTROSHJsQixPQTVORyxFQTROTTtBQUNiLFFBQUFHLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQWthLE9BREEsR0FDVSxDQUFDbGEsRUFBRSxDQUFDNmtCLGFBQUgsQ0FBaUJobEIsT0FBakIsQ0FBRCxFQUE0QkcsRUFBRSxDQUFDOGtCLGFBQUgsQ0FBaUJqbEIsT0FBakIsQ0FBNUIsQ0FEVjtBQUFBLG1CQUVnQnFhLE9BRmhCO0FBQUEsUUFFRGlMLE1BRkM7QUFBQSxRQUVPQyxLQUZQO0FBQUEsUUFHQTdXLE9BSEEsR0FHVXZPLEVBQUUsQ0FBQytrQixpQkFBSCxDQUFxQjdLLE9BQXJCLENBSFY7QUFBQSxRQUlGanJCLEdBSkUsR0FJbUIsQ0FKbkI7QUFBQSxRQUtGMlQsR0FMRSxHQUttQixDQUxuQjtBQTBCTixXQWxCS3VpQixNQUFNLEdBQUdDLEtBQVYsS0FBcUIsQ0FBckIsSUFBMkJwbEIsRUFBRSxDQUFDMEosYUFBSCxFQWtCL0IsS0FqQksxSixFQUFFLENBQUM4SixZQUFILEVBaUJMLElBaEJFcWIsTUFBTSxHQUFHLElBQUlqNUIsSUFBSixDQUFTaTVCLE1BQU0sQ0FBQ0UsT0FBUCxLQUFtQixFQUE1QixDQWdCWCxFQWZFRCxLQUFLLEdBQUcsSUFBSWw1QixJQUFKLENBQVNrNUIsS0FBSyxDQUFDQyxPQUFOLEtBQWtCLEdBQTNCLENBZVYsS0FiRUYsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBWCxHQUFlLENBQWYsR0FBb0JBLE1BQU0sR0FBRyxFQWF4QyxFQVpFQyxLQUFLLEdBQUdBLEtBQUssS0FBSyxDQUFWLEdBQWMsQ0FBQyxDQUFmLEdBQW9CQSxLQUFLLEdBQUcsR0FZdEMsS0FSSUQsTUFBTSxJQUFJQSxNQUFNLEtBQUssQ0FRekIsTUFQQ2wyQixHQUFHLEdBQUcrUSxFQUFFLENBQUM4SixZQUFILEtBQW9CLElBQUk1ZCxJQUFKLENBQVNpNUIsTUFBTSxDQUFDRSxPQUFQLEtBQW1COVcsT0FBTyxDQUFDN3hCLElBQXBDLENBQXBCLEdBQWdFeW9DLE1BQU0sR0FBRzVXLE9BQU8sQ0FBQzd4QixJQU94RixJQUpJMG9DLEtBQUssSUFBSUEsS0FBSyxLQUFLLENBSXZCLE1BSEN4aUIsR0FBRyxHQUFHNUMsRUFBRSxDQUFDOEosWUFBSCxLQUFvQixJQUFJNWQsSUFBSixDQUFTazVCLEtBQUssQ0FBQ0MsT0FBTixLQUFrQjlXLE9BQU8sQ0FBQzV4QixLQUFuQyxDQUFwQixHQUFnRXlvQyxLQUFLLEdBQUc3VyxPQUFPLENBQUM1eEIsS0FHdkYsR0FBTyxDQUFDc1MsR0FBRCxFQUFNMlQsR0FBTixDQUFQO0FBQ0EsR0F4UGE7QUEwUGRpTixlQTFQYyx5QkEwUEFoUSxPQTFQQSxFQTBQUzhkLGlCQTFQVCxFQTBQNEJELG9CQTFQNUIsRUEwUGtENEgsUUExUGxELEVBMFA0RHpuQyxNQTFQNUQsRUEwUG9FO0FBQzNFLFFBQUFtaUIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNrQ3FLLEVBRGxDLENBQ0NySyxNQUREO0FBQUEsUUFDUzR2QixHQURULEdBQ2tDdmxCLEVBRGxDLENBQ1N1bEIsR0FEVDtBQUFBLG9CQUNrQ3ZsQixFQURsQyxDQUNjSyxLQURkO0FBQUEsUUFDc0IxaUIsQ0FEdEIsYUFDc0JBLENBRHRCO0FBQUEsUUFDeUIrcEIsSUFEekIsYUFDeUJBLElBRHpCO0FBQUEsUUFFQThkLFdBRkEsR0FFYzd2QixNQUFNLENBQUN3QyxZQUZyQjs7QUFjTixRQVZJdWxCLG9CQVVKLEtBVEMvL0IsQ0FBQyxDQUFDRSxNQUFGLENBQVNBLE1BQU0sSUFBSStVLGNBQVMsQ0FBQ29OLEVBQUUsQ0FBQ2tsQixVQUFILENBQWNybEIsT0FBZCxDQUFELENBQTVCLENBU0QsRUFSQzBsQixHQUFHLENBQUNyTCxPQUFKLEdBQWN2OEIsQ0FBQyxDQUFDRSxNQUFGLEVBUWYsRUFOQzJuQyxXQUFXLElBQUl4bEIsRUFBRSxDQUFDcEMsSUFBSCxDQUFRNm5CLGlCQUFSLEVBTWhCLEVBSkMvZCxJQUFJLENBQUM3cEIsTUFBTCxDQUFZRixDQUFDLENBQUNFLE1BQUYsRUFBWixDQUlELEVBSENtaUIsRUFBRSxDQUFDL29CLEtBQUgsSUFBWStvQixFQUFFLENBQUMvb0IsS0FBSCxDQUFTb3BCLEtBQVQsQ0FBZXFILElBQWYsQ0FHYixHQUFJaVcsaUJBQUosRUFBdUI7QUFDdEIsVUFBTStILFdBQVcsR0FBRzduQyxNQUFNLElBQUssQ0FBQ21pQixFQUFFLENBQUMvb0IsS0FBSixJQUFha1osVUFBVSxDQUFDNlAsRUFBRCxDQUFsQyxHQUNuQnVsQixHQUFHLENBQUNyTCxPQURlLEdBQ0xockIsaUJBQWlCLENBQUM4USxFQUFELENBQWpCLENBQXNCNVIsR0FBdEIsQ0FBMEJzWixJQUFJLENBQUNpZSxNQUEvQixDQURmO0FBR0Fob0MsT0FBQyxDQUFDRSxNQUFGLENBQVM2bkMsV0FBVCxDQUpzQixFQUt0QkYsV0FBVyxJQUFJeGxCLEVBQUUsQ0FBQ3BDLElBQUgsQ0FBUTZuQixpQkFBUixFQUxPO0FBTXRCLEtBckJnRixDQXVCakY7OztBQUdBLFdBRkFILFFBQVEsSUFBSTNuQyxDQUFDLENBQUNFLE1BQUYsQ0FBU21pQixFQUFFLENBQUM0bEIsV0FBSCxDQUFlam9DLENBQUMsQ0FBQ3N5QixTQUFGLEVBQWYsQ0FBVCxDQUVaLEVBQU90eUIsQ0FBQyxDQUFDRSxNQUFGLEVBQVA7QUFDQSxHQXJSYTtBQXVSZCtuQyxhQXZSYyx1QkF1UkYvbkMsTUF2UkUsRUF1Uk07QUFDYixRQUFBZ29DLFVBQVUsR0FBRyxLQUFLQyxhQUFMLEVBQWI7QUFBQSxRQUNDNzJCLEdBREQsR0FDYTQyQixVQURiO0FBQUEsUUFDTWpqQixHQUROLEdBQ2FpakIsVUFEYjtBQWFOLFdBVklob0MsTUFBTSxDQUFDLENBQUQsQ0FBTixJQUFhb1IsR0FVakIsS0FUQ3BSLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUFDQSxNQUFNLENBQUMsQ0FBRCxDQUFQLElBQWNvUixHQUFHLEdBQUdwUixNQUFNLENBQUMsQ0FBRCxDQUExQixDQVNiLEVBUkNBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWW9SLEdBUWIsR0FMSTJULEdBQUcsSUFBSS9rQixNQUFNLENBQUMsQ0FBRCxDQUtqQixLQUpDQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVksQ0FBQ0EsTUFBTSxDQUFDLENBQUQsQ0FBUCxJQUFjQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVkra0IsR0FBMUIsQ0FJYixFQUhDL2tCLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWStrQixHQUdiLEdBQU8va0IsTUFBUDtBQUNBO0FBdFNhLENBQWYsRTs7QUNOQTs7OztBQUlBOztBQUVBLFNBQVNrb0MsU0FBVCxDQUFtQi9sQixFQUFuQixFQUF1QmdtQixTQUF2QixFQUFrQy82QixDQUFsQyxFQUFxQztBQUM5QixNQUFDMEssTUFBRCxHQUFXcUssRUFBWCxDQUFDckssTUFBRDtBQUFBLE1BQ0FsRyxJQURBLGFBQ2V1MkIsU0FEZjtBQUFBLE1BRUFwd0IsTUFGQSxHQUVTRCxNQUFNLENBQUNsRyxJQUFELENBQU4sR0FDZGtHLE1BQU0sQ0FBQ2xHLElBQUQsQ0FEUSxHQUNDdVEsRUFBRSxDQUFDaW1CLGtCQUhiO0FBS04sU0FBT3J3QixNQUFNLENBQUMzSyxDQUFELENBQWI7QUFDQTs7QUFFYztBQUNkaTdCLFlBRGMsc0JBQ0hDLE1BREcsRUFDSztBQUNaLFFBQUFubUIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNEb21CLE9BREMsR0FDb0JwbUIsRUFEcEIsQ0FDRG9tQixPQURDO0FBQUEsUUFDUUMsUUFEUixHQUNvQnJtQixFQURwQixDQUNRcW1CLFFBRFI7QUFRTixXQUxJRixNQUFNLElBQUksQ0FBQ25tQixFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxDQUtmLEtBSkNrUSxPQUFPLEdBQUdwbUIsRUFBRSxDQUFDc21CLHFCQUlkLEVBSENELFFBQVEsR0FBR3JtQixFQUFFLENBQUNzbUIscUJBR2YsR0FBTyxVQUFTcjdCLENBQVQsRUFBWXF4QixLQUFaLEVBQW1CaitCLEVBQW5CLEVBQXVCO0FBQzdCLFVBQU11WCxNQUFNLEdBQUdvSyxFQUFFLENBQUN4cEIsSUFBSCxJQUFXd3BCLEVBQUUsQ0FBQ3hwQixJQUFILENBQVE2ekIsS0FBUixDQUFjaHNCLEVBQWQsTUFBc0IsSUFBakMsR0FDZGdvQyxRQURjLEdBQ0hELE9BRFo7QUFHQSxhQUFPeHdCLE1BQU0sQ0FBQ2xJLElBQVAsQ0FBWXNTLEVBQVosRUFBZ0IvVSxDQUFoQixFQUFtQnF4QixLQUFuQixDQUFQO0FBQ0EsS0FMRDtBQU1BLEdBaEJhO0FBa0JkOEosU0FsQmMsbUJBa0JObjdCLENBbEJNLEVBa0JIO0FBQ1YsV0FBTzg2QixTQUFTLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWTk2QixDQUFaLENBQWhCO0FBQ0EsR0FwQmE7QUFzQmRvN0IsVUF0QmMsb0JBc0JMcDdCLENBdEJLLEVBc0JGO0FBQ1gsV0FBTzg2QixTQUFTLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYTk2QixDQUFiLENBQWhCO0FBQ0EsR0F4QmE7QUEwQmRnN0Isb0JBMUJjLDhCQTBCS2g3QixDQTFCTCxFQTBCUTtBQUNyQixXQUFPRCxPQUFPLENBQUNDLENBQUQsQ0FBUCxHQUFhLENBQUNBLENBQWQsR0FBa0IsRUFBekI7QUFDQSxHQTVCYTtBQThCZHE3Qix1QkE5QmMsaUNBOEJRcjdCLENBOUJSLEVBOEJXcXhCLEtBOUJYLEVBOEJrQjtBQUMvQixXQUFVLENBQUNBLEtBQUssR0FBRyxHQUFULEVBQWN6ZixPQUFkLENBQXNCLENBQXRCLENBQVY7QUFDQSxHQWhDYTtBQWtDZDBkLGlCQWxDYywyQkFrQ0VsQyxRQWxDRixFQWtDWTtBQUFBLFFBQ25CclksRUFBRSxHQUFHLElBRGM7QUFBQSxRQUVuQm9hLFVBQVUsR0FBR3BhLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXpRLFdBRko7QUFBQSxRQUduQnFoQyxhQUFhLEdBQUcsVUFBQXQ3QixDQUFDO0FBQUEsYUFBS0QsT0FBTyxDQUFDQyxDQUFELENBQVAsR0FBYSxDQUFDQSxDQUFkLEdBQWtCLEVBQXZCO0FBQUEsS0FIRTtBQUFBLFFBSXJCMkssTUFBTSxHQUFHMndCLGFBSlk7O0FBa0J6QixXQVhJcjdCLFVBQVUsQ0FBQ2t2QixVQUFVLENBQUN4a0IsTUFBWixDQVdkLEdBVkNBLE1BQU0sR0FBR3drQixVQUFVLENBQUN4a0IsTUFVckIsR0FUVzdKLFlBQVksQ0FBQ3F1QixVQUFVLENBQUN4a0IsTUFBWixDQVN2QixLQVJLd2tCLFVBQVUsQ0FBQ3hrQixNQUFYLENBQWtCeWlCLFFBQWxCLENBUUwsR0FQRXppQixNQUFNLEdBQUd3a0IsVUFBVSxDQUFDeGtCLE1BQVgsQ0FBa0J5aUIsUUFBbEIsV0FDUmtPLGFBRFEsR0FDUW5NLFVBQVUsQ0FBQ3hrQixNQUFYLENBQWtCeWlCLFFBQWxCLENBTW5CLEdBSkV6aUIsTUFBTSxHQUFHO0FBQUEsYUFBTSxFQUFOO0FBQUEsS0FJWCxHQUFPQSxNQUFNLENBQUN1TixJQUFQLENBQVluRCxFQUFFLENBQUNnSixHQUFmLENBQVA7QUFDQTtBQXJEYSxDQUFmLEU7O0FDZkE7Ozs7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUVlO0FBQ2Q7Ozs7QUFJQXdkLFlBTGMsd0JBS0Q7QUFDTixRQUFBeG1CLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDZ0JxSyxFQURoQixDQUNDckssTUFERDtBQUFBLFFBQ1N2RyxHQURULEdBQ2dCNFEsRUFEaEIsQ0FDUzVRLEdBRFQ7QUFHTjRRLE1BQUUsQ0FBQzlqQixLQUFILENBQVN1QixpQkFBVCxLQUpZLEVBS1oyUixHQUFHLENBQUNnTyxNQUFKLEdBQWE0QyxFQUFFLENBQUM1USxHQUFILENBQU9tZSxHQUFQLENBQVc3ZSxNQUFYLENBQWtCLEdBQWxCLENBTEQsRUFPUmlILE1BQU0sQ0FBQ3RULFdBUEMsSUFRWCtNLEdBQUcsQ0FBQ2dPLE1BQUosQ0FBV3pPLElBQVgsQ0FBZ0IsV0FBaEIsRUFBNkJxUixFQUFFLENBQUNvSSxZQUFILENBQWdCLFFBQWhCLENBQTdCLENBUlcsRUFZWHBJLEVBQUUsQ0FBQ3ltQixZQUFILEVBWlcsS0FjWHptQixFQUFFLENBQUM1USxHQUFILENBQU9nTyxNQUFQLENBQWMySCxLQUFkLENBQW9CLFlBQXBCLEVBQWtDLFFBQWxDLENBZFcsRUFlWC9FLEVBQUUsQ0FBQzlqQixLQUFILENBQVN1RCxlQUFULEdBQTJCdWdCLEVBQUUsQ0FBQ3FWLFFBQUgsQ0FBWXJWLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXBCLENBZmhCO0FBaUJaLEdBdEJhOztBQXdCZDs7Ozs7OztBQU9BNG1CLGNBL0JjLHdCQStCRGpPLFNBL0JDLEVBK0JVMXJCLE9BL0JWLEVBK0JtQnFpQixXQS9CbkIsRUErQmdDO0FBQ3ZDLFFBQUFuUCxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQzhCcUssRUFEOUIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTelosS0FEVCxHQUM4QjhqQixFQUQ5QixDQUNTOWpCLEtBRFQ7QUFBQSxRQUNnQm1rQixLQURoQixHQUM4QkwsRUFEOUIsQ0FDZ0JLLEtBRGhCO0FBQUEsUUFDdUJqUixHQUR2QixHQUM4QjRRLEVBRDlCLENBQ3VCNVEsR0FEdkI7QUFBQSxRQUVBczNCLE9BRkEsR0FFVTU1QixPQUFPLElBQUk7QUFDMUI2NUIsbUJBQWEsSUFEYTtBQUUxQkMsZ0NBQTBCLElBRkE7QUFHMUI1WSxvQkFBYztBQUhZLEtBRnJCO0FBcUJOO0FBSUE7QUFJQTtBQXJCQTBZLFdBQU8sQ0FBQzFZLGNBQVIsR0FBeUJuaEIsU0FBUyxDQUFDNjVCLE9BQUQsRUFBVSxnQkFBVixLQVRXLEVBVTdDQSxPQUFPLENBQUNFLDBCQUFSLEdBQXFDLzVCLFNBQVMsQ0FBQzY1QixPQUFELEVBQVUsNEJBQVYsS0FWRCxFQVl6Qy93QixNQUFNLENBQUNwVCxzQkFBUCxJQUFpQ29ULE1BQU0sQ0FBQ25ULHdCQVpDLEdBYTVDd2QsRUFBRSxDQUFDNm1CLG9CQUFILEVBYjRDLEdBZTVDN21CLEVBQUUsQ0FBQzhtQixtQkFBSCxDQUNDdE8sU0FBUyxJQUFJeFksRUFBRSxDQUFDcVYsUUFBSCxDQUFZclYsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBcEIsQ0FEZCxFQUVDNm1CLE9BRkQsRUFHQ3ZYLFdBSEQsQ0FmNEMsRUF1QjdDL2YsR0FBRyxDQUFDZ08sTUFBSixDQUFXcUgsU0FBWCxPQUF5QjlVLGNBQUssQ0FBQ3JXLFVBQS9CLEVBQ0V5dEMsT0FERixDQUNVcDNCLGNBQUssQ0FBQ2xXLGdCQURoQixFQUNrQyxVQUFBNEUsRUFBRTtBQUFBLGFBQUksQ0FBQzJoQixFQUFFLENBQUNvWSxjQUFILENBQWtCLzVCLEVBQWxCLENBQUw7QUFBQSxLQURwQyxDQXZCNkMsRUEyQjdDMmhCLEVBQUUsQ0FBQ2duQixZQUFILEtBQXVCLENBQUMzbUIsS0FBSyxDQUFDekMsSUFBOUIsQ0EzQjZDLEVBNEI3Q29DLEVBQUUsQ0FBQ2luQixhQUFILEVBNUI2QyxFQStCN0NqbkIsRUFBRSxDQUFDa25CLFlBQUgsQ0FBZ0JSLE9BQU8sQ0FBQ0UsMEJBQXhCLEVBQW9EelgsV0FBcEQsQ0EvQjZDLEVBaUM3Q2p6QixLQUFLLENBQUN1QixpQkFBTixLQWpDNkM7QUFrQzdDLEdBakVhOztBQW1FZDs7OztBQUlBb3BDLHNCQXZFYyxrQ0F1RVM7QUFDaEIsUUFBQTdtQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBQUEsUUFFQSszQixPQUZBLEdBRVUvaUIsaUdBQVEsQ0FBQ3pPLE1BQU0sQ0FBQ3BULHNCQUFSLENBRmxCO0FBQUEsUUFHQTZrQyxRQUhBLEdBR1d6eEIsTUFBTSxDQUFDblQsd0JBSGxCOztBQUtOLFFBQUksQ0FBQzJrQyxPQUFPLENBQUN2dUMsS0FBUixFQUFMLEVBQXNCO0FBQUEsVUFDZmluQixPQUFPLEdBQUdHLEVBQUUsQ0FBQ3FWLFFBQUgsQ0FBWXJWLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXBCLENBREs7QUFBQSxVQUVmdVUsR0FBVSxHQUFHLEVBRkU7QUFBQSxVQUdqQjVsQixJQUFJLEdBQUcsRUFIVTtBQUtyQnFSLGFBQU8sQ0FBQ3hTLE9BQVIsQ0FBZ0IsVUFBQXBDLENBQUMsRUFBSTtBQUNwQixZQUFNKzJCLE9BQU8sR0FBRzkyQixVQUFVLENBQUNrOEIsUUFBRCxDQUFWLEdBQ2ZBLFFBQVEsQ0FBQ2prQixJQUFULENBQWNuRCxFQUFFLENBQUNnSixHQUFqQixFQUFzQi9kLENBQXRCLEVBQXlCK1UsRUFBRSxDQUFDOUMsS0FBSCxDQUFTalMsQ0FBVCxDQUF6QixFQUFzQytVLEVBQUUsQ0FBQ2dKLEdBQUgsQ0FBTzdXLElBQVAsQ0FBWWxILENBQVosRUFBZSxDQUFmLEVBQWtCaVYsTUFBeEQsQ0FEZSxHQUVmN0ssVUFBVSxDQUFDK3hCLFFBQUQsRUFBVztBQUNwQkMsZUFBSyxFQUFFcm5CLEVBQUUsQ0FBQzlDLEtBQUgsQ0FBU2pTLENBQVQsQ0FEYTtBQUVwQnE4QixlQUFLLEVBQUVyOEI7QUFGYSxTQUFYLENBRlg7QUFPSSsyQixlQVJnQixLQVNuQjVOLEdBQUcsQ0FBQy9nQixJQUFKLENBQVNwSSxDQUFULENBVG1CLEVBVW5CdUQsSUFBSSxJQUFJd3pCLE9BVlc7QUFZcEIsT0FaRCxDQUxxQjtBQW1CckIsVUFBTTFvQyxVQUFVLEdBQUc2dEMsT0FBTyxDQUFDMzRCLElBQVIsQ0FBYUEsSUFBYixFQUNqQmlXLFNBRGlCLENBQ1AsWUFBVztBQUFFLGVBQU8sS0FBSzhpQixVQUFaO0FBQXlCLE9BRC9CLEVBRWpCcDFCLElBRmlCLENBRVppaUIsR0FGWSxDQUFuQjtBQUlBcFUsUUFBRSxDQUFDd25CLGFBQUgsQ0FBaUJsdUMsVUFBakIsQ0F2QnFCLEVBeUJyQjhWLEdBQUcsQ0FBQ2dPLE1BQUosR0FBYStwQixPQXpCUTtBQTBCckI7QUFDRCxHQXhHYTs7QUEwR2Q7Ozs7O0FBS0FNLHFCQS9HYywrQkErR003cEMsSUEvR04sRUErR1k7QUFDbkIsUUFBQW9pQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBR0RxSyxFQUhDLENBQ0NySyxNQUREO0FBQUEsb0JBR0RxSyxFQUhDLENBQ1M5akIsS0FEVDtBQUFBLFFBRUxrQixXQUZLLGFBRUxBLFdBRks7QUFBQSxRQUVRQyxZQUZSLGFBRVFBLFlBRlI7QUFBQSxRQUVzQkgsYUFGdEIsYUFFc0JBLGFBRnRCO0FBQUEsUUFFcUNDLGFBRnJDLGFBRXFDQSxhQUZyQztBQUFBLFFBRW9ESCxZQUZwRCxhQUVvREEsWUFGcEQ7QUFBQSxRQUVrRUMsYUFGbEUsYUFFa0VBLGFBRmxFO0FBQUEsUUFJQ2QsS0FKRCxHQUlrQnlCLElBSmxCLENBSUN6QixLQUpEO0FBQUEsUUFJUUUsTUFKUixHQUlrQnVCLElBSmxCLENBSVF2QixNQUpSO0FBQUEsUUFNQXFyQyxtQkFOQSxHQU1zQjtBQUMzQmxyQyxTQUFHLEVBQUVZLFdBQVcsR0FDZjRpQixFQUFFLENBQUMybkIsb0JBQUgsS0FBNEJoeUIsTUFBTSxDQUFDL1MsY0FBbkMsR0FBb0QsR0FEckMsR0FFZjNGLGFBQWEsR0FBR1osTUFBaEIsR0FBeUIyakIsRUFBRSxDQUFDNG5CLHVCQUFILEVBQXpCLEdBQXdEanlCLE1BQU0sQ0FBQy9TLGNBSHJDO0FBSTNCbEcsVUFBSSxFQUFFVyxZQUFZLEdBQ2pCMmlCLEVBQUUsQ0FBQzZuQixxQkFBSCxLQUE2Qmx5QixNQUFNLENBQUNoVCxjQUFwQyxHQUFxRCxFQURwQyxHQUVqQjNGLFlBQVksR0FBR2IsS0FBZixHQUF1QjZqQixFQUFFLENBQUM4bkIsc0JBQUgsRUFBdkIsR0FBcURueUIsTUFBTSxDQUFDaFQsY0FBNUQsR0FBNkU7QUFObkQsS0FOdEI7QUFlTnFkLE1BQUUsQ0FBQzlqQixLQUFILENBQVNXLE9BQVQsR0FBbUI7QUFDbEJMLFNBQUcsRUFBRVUsYUFBYSxHQUNqQixDQURpQixHQUNiQyxhQUFhLEdBQUd1cUMsbUJBQW1CLENBQUNsckMsR0FBdkIsR0FBNkJTLGFBQWEsR0FBR1osTUFGN0M7QUFHbEJNLFdBQUssRUFBRW9yQyxHQUhXO0FBSWxCdHJDLFlBQU0sRUFBRSxDQUpVO0FBS2xCQyxVQUFJLEVBQUVRLGFBQWEsR0FDbEJGLFlBQVksR0FBR2IsS0FERyxHQUNLZ0IsYUFBYSxHQUFHdXFDLG1CQUFtQixDQUFDaHJDLElBQXZCLEdBQThCO0FBTmpELEtBaEJNO0FBd0J6QixHQXZJYTs7QUF5SWQ7Ozs7O0FBS0FzckMsaUJBOUljLDJCQThJRWhhLGNBOUlGLEVBOElrQjtBQUN6QixRQUFBaE8sRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDNUMsTUFERCxHQUNXNEMsRUFBRSxDQUFDNVEsR0FEZCxDQUNDZ08sTUFERDtBQUdOLEtBQUM0USxjQUFjLEdBQUc1USxNQUFNLENBQUM2RSxVQUFQLEVBQUgsR0FBeUI3RSxNQUF4QyxFQUNFek8sSUFERixDQUNPLFdBRFAsRUFDb0JxUixFQUFFLENBQUNvSSxZQUFILENBQWdCLFFBQWhCLENBRHBCLENBSitCO0FBTS9CLEdBcEphOztBQXNKZDs7Ozs7QUFLQTZmLGtCQTNKYyw0QkEySkdDLElBM0pILEVBMkpTO0FBQ3RCLFNBQUtoc0MsS0FBTCxDQUFXb0IsVUFBWCxHQUF3QjRxQyxJQURGO0FBRXRCLEdBN0phOztBQStKZDs7Ozs7QUFLQUMsdUJBcEtjLGlDQW9LUXRuQixDQXBLUixFQW9LVztBQUN4QixTQUFLM2tCLEtBQUwsQ0FBV3FCLGVBQVgsR0FBNkJzakIsQ0FETDtBQUV4QixHQXRLYTs7QUF3S2Q7Ozs7O0FBS0F1bkIsd0JBN0tjLGtDQTZLU3RuQixDQTdLVCxFQTZLWTtBQUN6QixTQUFLNWtCLEtBQUwsQ0FBV3NCLGdCQUFYLEdBQThCc2pCLENBREw7QUFFekIsR0EvS2E7O0FBaUxkOzs7Ozs7QUFNQXVuQix1QkF2TGMsaUNBdUxRaHFDLEVBdkxSLEVBdUxZNmUsS0F2TFosRUF1TG1CO0FBQ2hDLFNBQUs5TixHQUFMLENBQVNnTyxNQUFULENBQWdCMU4sTUFBaEIsT0FBMkJDLGNBQUssQ0FBQ3JXLFVBQWpDLFNBQStDK0UsRUFBL0MsWUFDRTBtQixLQURGLENBQ1EsUUFEUixFQUNrQjdILEtBRGxCLENBRGdDO0FBR2hDLEdBMUxhOztBQTRMZDs7Ozs7QUFLQW9yQixnQkFqTWMsNEJBaU1HO0FBQ1YsUUFBQXRvQixFQUFFLEdBQUcsSUFBTDtBQUFBLHFCQUM0RUEsRUFBRSxDQUFDOWpCLEtBRC9FO0FBQUEsUUFDQ2MsWUFERCxjQUNDQSxZQUREO0FBQUEsUUFDZUUsYUFEZixjQUNlQSxhQURmO0FBQUEsUUFDOEJDLGFBRDlCLGNBQzhCQSxhQUQ5QjtBQUFBLFFBQzZDSSxlQUQ3QyxjQUM2Q0EsZUFEN0M7QUFBQSxRQUM4REQsVUFEOUQsY0FDOERBLFVBRDlEO0FBR04sV0FBTzBpQixFQUFFLENBQUNySyxNQUFILENBQVV0VCxXQUFWLEdBQ05uRixhQUFhLElBQUlDLGFBQWpCLEdBQ0NJLGVBQWUsSUFBSUQsVUFBVSxHQUFHLENBQWpCLENBRGhCLEdBQ3NDTixZQUZoQyxHQUdILENBSEo7QUFJQSxHQXpNYTs7QUEyTWQ7Ozs7O0FBS0F1ckMsaUJBaE5jLDZCQWdOSTtBQUNYLFFBQUF2b0IsRUFBRSxHQUFHLElBQUw7QUFBQSxxQkFDK0RBLEVBQUUsQ0FBQzlqQixLQURsRTtBQUFBLFFBQ0NlLGFBREQsY0FDQ0EsYUFERDtBQUFBLFFBQ2dCQyxhQURoQixjQUNnQkEsYUFEaEI7QUFBQSxRQUMrQk0sZ0JBRC9CLGNBQytCQSxnQkFEL0I7QUFBQSxRQUNpREYsVUFEakQsY0FDaURBLFVBRGpEO0FBR04sV0FBTzBpQixFQUFFLENBQUNySyxNQUFILENBQVV0VCxXQUFWLEdBQ05uRixhQUFhLEdBQ1pELGFBRFksR0FDSXdPLElBQUksQ0FBQ21YLEdBQUwsQ0FBUyxFQUFULEVBQWFwbEIsZ0JBQWIsS0FBa0NGLFVBQVUsR0FBRyxDQUEvQyxDQUZYLEdBR0gsQ0FISjtBQUlBLEdBeE5hOztBQTBOZDs7Ozs7O0FBTUFrckMsa0JBaE9jLDRCQWdPR2x2QyxVQWhPSCxFQWdPZTtBQUM1QixXQUFPQSxVQUFVLENBQUN5dEMsT0FBWCxDQUFtQnAzQixjQUFLLENBQUNsVyxnQkFBekIsSUFBNkMsSUFBN0MsR0FBb0QsR0FBM0Q7QUFDQSxHQWxPYTs7QUFvT2Q7Ozs7OztBQU1BZ3ZDLDJCQTFPYyxxQ0EwT1ludkMsVUExT1osRUEwT3dCO0FBQ3JDLFdBQU9BLFVBQVUsQ0FBQ3l0QyxPQUFYLENBQW1CcDNCLGNBQUssQ0FBQ2xXLGdCQUF6QixJQUE2QyxJQUE3QyxHQUFvRCxLQUEzRDtBQUNBLEdBNU9hOztBQThPZDs7Ozs7O0FBTUFpdkMsbUJBcFBjLDZCQW9QSWxRLFNBcFBKLEVBb1BlbVEsS0FwUGYsRUFvUHNCO0FBQUEsUUFDN0Izb0IsRUFBRSxHQUFHLElBRHdCO0FBQUEsUUFFN0I0b0IsU0FBUyxHQUFHNW9CLEVBQUUsQ0FBQ2lZLGNBQUgsQ0FBa0JPLFNBQWxCLENBRmlCO0FBSW5DeFksTUFBRSxDQUFDNVEsR0FBSCxDQUFPZ08sTUFBUCxDQUFjcUgsU0FBZCxPQUE0QjlVLGNBQUssQ0FBQ3JXLFVBQWxDLEVBQ0VnWixNQURGLENBQ1MsVUFBQWpVLEVBQUU7QUFBQSxhQUFJdXFDLFNBQVMsQ0FBQzE2QixPQUFWLENBQWtCN1AsRUFBbEIsS0FBeUIsQ0FBN0I7QUFBQSxLQURYLEVBRUUwb0MsT0FGRixDQUVVcDNCLGNBQUssQ0FBQ25XLGlCQUZoQixFQUVtQ212QyxLQUZuQyxFQUdFMW1CLFVBSEYsR0FJRThNLFFBSkYsQ0FJVyxHQUpYLEVBS0VoSyxLQUxGLENBS1EsU0FMUixFQUttQixZQUFXO0FBQzVCLGFBQU8sQ0FBQzRqQixLQUFLLEdBQUczb0IsRUFBRSxDQUFDd29CLGdCQUFOLEdBQXlCeG9CLEVBQUUsQ0FBQ3lvQix5QkFBbEMsRUFDTC82QixJQURLLENBQ0FzUyxFQURBLEVBQ0lvRSxpR0FBUSxDQUFDLElBQUQsQ0FEWixDQUFQO0FBRUEsS0FSRixDQUptQztBQWFuQyxHQWpRYTs7QUFtUWQ7Ozs7QUFJQXlrQixjQXZRYywwQkF1UUM7QUFDZCxRQUFNN29CLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQzVRLEdBQUgsQ0FBT2dPLE1BQVAsQ0FBY3FILFNBQWQsT0FBNEI5VSxjQUFLLENBQUNyVyxVQUFsQyxFQUNFeXRDLE9BREYsQ0FDVXAzQixjQUFLLENBQUNuVyxpQkFEaEIsTUFFRXlvQixVQUZGLEdBR0U4TSxRQUhGLENBR1csR0FIWCxFQUlFaEssS0FKRixDQUlRLFNBSlIsRUFJbUIsWUFBVztBQUM1QixhQUFPL0UsRUFBRSxDQUFDd29CLGdCQUFILENBQW9CcGtCLGlHQUFRLENBQUMsSUFBRCxDQUE1QixDQUFQO0FBQ0EsS0FORixDQUhjO0FBVWQsR0FqUmE7O0FBbVJkOzs7OztBQUtBMGtCLFlBeFJjLHNCQXdSSHRRLFNBeFJHLEVBd1JRO0FBQ2YsUUFBQXhZLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDMEJxSyxFQUQxQixDQUNDckssTUFERDtBQUFBLFFBQ2V5SCxNQURmLEdBQzBCNEMsRUFEMUIsQ0FDUzVRLEdBRFQsQ0FDZWdPLE1BRGY7QUFHRHpILFVBQU0sQ0FBQ3RULFdBSlMsS0FLcEJzVCxNQUFNLENBQUN0VCxXQUFQLEtBTG9CLEVBTXBCK2EsTUFBTSxDQUFDMkgsS0FBUCxDQUFhLFlBQWIsRUFBMkIsU0FBM0IsQ0FOb0IsRUFRcEIsQ0FBQy9FLEVBQUUsQ0FBQzlqQixLQUFILENBQVN1QixpQkFBVixJQUErQnVpQixFQUFFLENBQUN5bUIsWUFBSCxFQVJYLEdBVXJCem1CLEVBQUUsQ0FBQzJZLHFCQUFILENBQXlCSCxTQUF6QixDQVZxQixFQVlyQnBiLE1BQU0sQ0FBQ3FILFNBQVAsQ0FBaUJ6RSxFQUFFLENBQUNzaEIsZUFBSCxDQUFtQjlJLFNBQW5CLENBQWpCLEVBQ0V6VCxLQURGLENBQ1EsWUFEUixFQUNzQixTQUR0QixFQUVFOUMsVUFGRixHQUdFOEMsS0FIRixDQUdRLFNBSFIsRUFHbUIsWUFBVztBQUM1QixhQUFPL0UsRUFBRSxDQUFDd29CLGdCQUFILENBQW9CcGtCLGlHQUFRLENBQUMsSUFBRCxDQUE1QixDQUFQO0FBQ0EsS0FMRixDQVpxQjtBQWtCckIsR0ExU2E7O0FBNFNkOzs7OztBQUtBMmtCLFlBalRjLHNCQWlUSHZRLFNBalRHLEVBaVRRO0FBQ2YsUUFBQXhZLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDMEJxSyxFQUQxQixDQUNDckssTUFERDtBQUFBLFFBQ2V5SCxNQURmLEdBQzBCNEMsRUFEMUIsQ0FDUzVRLEdBRFQsQ0FDZWdPLE1BRGY7QUFHRnpILFVBQU0sQ0FBQ3RULFdBQVAsSUFBc0IySixPQUFPLENBQUN3c0IsU0FBRCxDQUpaLEtBS3BCN2lCLE1BQU0sQ0FBQ3RULFdBQVAsS0FMb0IsRUFNcEIrYSxNQUFNLENBQUMySCxLQUFQLENBQWEsWUFBYixFQUEyQixRQUEzQixDQU5vQixHQVNyQi9FLEVBQUUsQ0FBQzBZLGtCQUFILENBQXNCRixTQUF0QixDQVRxQixFQVVyQnBiLE1BQU0sQ0FBQ3FILFNBQVAsQ0FBaUJ6RSxFQUFFLENBQUNzaEIsZUFBSCxDQUFtQjlJLFNBQW5CLENBQWpCLEVBQ0V6VCxLQURGLENBQ1EsU0FEUixFQUNtQixHQURuQixFQUVFQSxLQUZGLENBRVEsWUFGUixFQUVzQixRQUZ0QixDQVZxQjtBQWFyQixHQTlUYTs7QUFnVWQ7Ozs7O0FBS0Fpa0Isc0JBclVjLGdDQXFVTzNxQyxFQXJVUCxFQXFVb0I0cUMsV0FyVXBCLEVBcVVrQztBQUN6QyxRQUFBanBCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ1AsS0FERCxHQUNVTyxFQURWLENBQ0NQLEtBREQ7QUFBQSxRQUVBMlgsUUFGQSxHQUVXLG9CQUZYOztBQUlOLFFBQUkvNEIsRUFBSixFQUFRO0FBQ1AsVUFBSThULElBQUksR0FBR3NOLEtBQUssQ0FBQ0csR0FBTixDQUFVd1gsUUFBVixDQUFYO0FBV0EsYUFUS2psQixJQVNMLEtBUkNBLElBQUksR0FBRyxFQVFSLEdBTEtBLElBQUksQ0FBQzlULEVBQUQsQ0FLVCxLQUpDOFQsSUFBSSxDQUFDOVQsRUFBRCxDQUFKLEdBQVcyaEIsRUFBRSxDQUFDa3BCLFdBQUgsQ0FBZUQsV0FBZixFQUE0QnQ1QixjQUFLLENBQUNyVyxVQUFsQyxDQUlaLEVBSENtbUIsS0FBSyxDQUFDRixHQUFOLENBQVU2WCxRQUFWLEVBQW9CamxCLElBQXBCLENBR0QsR0FBT0EsSUFBSSxDQUFDOVQsRUFBRCxDQUFYO0FBQ0E7O0FBQ0FvaEIsU0FBSyxDQUFDRSxNQUFOLENBQWF5WCxRQUFiLENBbkI4QztBQXFCL0MsR0ExVmE7O0FBNFZkOzs7OztBQUtBb1EsZUFqV2MseUJBaVdBMkIsSUFqV0EsRUFpV007QUFDYixRQUFBbnBCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ2dKLEdBREQsR0FDdUJoSixFQUR2QixDQUNDZ0osR0FERDtBQUFBLFFBQ01yVCxNQUROLEdBQ3VCcUssRUFEdkIsQ0FDTXJLLE1BRE47QUFBQSxRQUNjelosS0FEZCxHQUN1QjhqQixFQUR2QixDQUNjOWpCLEtBRGQ7QUFBQSxRQUVBa3RDLE9BRkEsR0FFVWx0QyxLQUFLLENBQUNnQyxTQUFOLEtBQW9CLE9BRjlCO0FBQUEsUUFHQW1yQyxRQUhBLEdBR1dycEIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsQ0FIWDtBQUtOaVQsUUFBSSxDQUNGeDZCLElBREYsQ0FDTyxPQURQLEVBQ2dCLFVBQVN0USxFQUFULEVBQWE7QUFBQSxVQUNyQjBQLElBQUksR0FBR3FXLGlHQUFRLENBQUMsSUFBRCxDQURNO0FBQUEsVUFFckJrbEIsU0FBUyxHQUFJLENBQUN2N0IsSUFBSSxDQUFDblYsS0FBTCxFQUFELElBQWlCbVYsSUFBSSxDQUFDWSxJQUFMLENBQVUsT0FBVixDQUFsQixJQUF5QyxFQUZoQztBQUkzQixhQUFPMjZCLFNBQVMsR0FBR3RwQixFQUFFLENBQUNtZixhQUFILENBQWlCeHZCLGNBQUssQ0FBQ3JXLFVBQXZCLEVBQW1DK0UsRUFBbkMsQ0FBbkI7QUFDQSxLQU5GLEVBT0UwbUIsS0FQRixDQU9RLFlBUFIsRUFPc0IsVUFBQTFtQixFQUFFO0FBQUEsYUFBSzJoQixFQUFFLENBQUNzWSxjQUFILENBQWtCajZCLEVBQWxCLElBQXdCLFNBQXhCLEdBQW9DLFFBQXpDO0FBQUEsS0FQeEIsRUFRRTBtQixLQVJGLENBUVEsUUFSUixFQVFrQixTQVJsQixFQVNFK1osRUFURixDQVNLLE9BVEwsRUFTYyxVQUFBemdDLEVBQUUsRUFBSTtBQUNiaVAsWUFBTSxDQUFDcUksTUFBTSxDQUFDN1MsbUJBQVIsRUFBNkJrbUIsR0FBN0IsRUFBa0MzcUIsRUFBbEMsQ0FETyxLQUViaVIsd0ZBQU8sQ0FBQ2k2QixNQUZLLElBR2hCdmdCLEdBQUcsQ0FBQ3dnQixJQUFKLEVBSGdCLEVBSWhCeGdCLEdBQUcsQ0FBQ3lnQixJQUFKLENBQVNwckMsRUFBVCxDQUpnQixLQU1oQjJxQixHQUFHLENBQUMwZ0IsTUFBSixDQUFXcnJDLEVBQVgsQ0FOZ0IsRUFPaEIsQ0FBQytxQyxPQUFELElBQVlwcEIsRUFBRSxDQUFDb1ksY0FBSCxDQUFrQi81QixFQUFsQixDQUFaLEdBQW9DMnFCLEdBQUcsQ0FBQzJmLEtBQUosQ0FBVXRxQyxFQUFWLENBQXBDLEdBQW9EMnFCLEdBQUcsQ0FBQzJnQixNQUFKLEVBUHBDLElBV2xCUCxPQUFPLElBQUlwcEIsRUFBRSxDQUFDNHBCLFdBQUgsRUFYTztBQVlsQixLQXJCRixDQU5tQixFQTZCZFIsT0E3QmMsSUE4QmxCRCxJQUFJLENBQ0ZySyxFQURGLENBQ0ssVUFETCxFQUNpQixVQUFTemdDLEVBQVQsRUFBYTtBQUN2QmlQLFlBQU0sQ0FBQ3FJLE1BQU0sQ0FBQzNTLGlCQUFSLEVBQTJCZ21CLEdBQTNCLEVBQWdDM3FCLEVBQWhDLENBRGlCLEtBRTNCK2xCLGlHQUFRLENBQUMsSUFBRCxDQUFSLENBQWUyaUIsT0FBZixDQUF1QnAzQixjQUFLLENBQUNuVyxpQkFBN0IsS0FGMkIsRUFJdkI2dkMsUUFKdUIsSUFLMUJycEIsRUFBRSxDQUFDNnBCLGtCQUFILENBQXNCN3BCLEVBQXRCLFFBQThCclEsY0FBSyxDQUFDelcsVUFBcEMsQ0FMMEIsRUFRM0I4bUIsRUFBRSxDQUFDZ0osR0FBSCxDQUFPMmdCLE1BQVAsRUFSMkI7QUFVNUIsS0FYRixFQVlFN0ssRUFaRixDQVlLLFdBWkwsRUFZa0IsVUFBU3pnQyxFQUFULEVBQWE7QUFDeEJpUCxZQUFNLENBQUNxSSxNQUFNLENBQUM1UyxrQkFBUixFQUE0QmltQixHQUE1QixFQUFpQzNxQixFQUFqQyxDQURrQixLQUU1QitsQixpR0FBUSxDQUFDLElBQUQsQ0FBUixDQUFlMmlCLE9BQWYsQ0FBdUJwM0IsY0FBSyxDQUFDblcsaUJBQTdCLEtBRjRCLEVBSXhCNnZDLFFBSndCLElBSzNCcnBCLEVBQUUsQ0FBQzhwQixjQUFILENBQWtCenJDLEVBQWxCLEVBQXNCMmhCLEVBQXRCLFFBQThCclEsY0FBSyxDQUFDelcsVUFBcEMsQ0FMMkIsRUFReEIsQ0FBQ2dELEtBQUssQ0FBQ2tELFVBQVAsSUFBcUI0Z0IsRUFBRSxDQUFDb1ksY0FBSCxDQUFrQi81QixFQUFsQixDQVJHLElBUzNCMnFCLEdBQUcsQ0FBQzJmLEtBQUosQ0FBVXRxQyxFQUFWLENBVDJCO0FBWTdCLEtBeEJGLENBOUJrQjtBQXdEbkIsR0F6WmE7O0FBMlpkOzs7Ozs7QUFNQXlvQyxxQkFqYWMsK0JBaWFNdE8sU0FqYU4sRUFpYWlCMXJCLE9BamFqQixFQWlhMEI7QUFTbkMsUUFBQWk5QixVQUFVO0FBQUEsUUFDVkMsVUFEVTtBQUFBLFFBU1Zoc0IsVUFUVTtBQUFBLFFBUlJnQyxFQVFRLEdBUkgsSUFRRztBQUFBLFFBUFBySyxNQU9PLEdBUFVxSyxFQU9WLENBUFBySyxNQU9PO0FBQUEsUUFQQ3paLEtBT0QsR0FQVThqQixFQU9WLENBUEM5akIsS0FPRDtBQUFBLFFBSlIrdEMsTUFJUSxHQUpDLEVBSUQ7QUFBQSxRQUhSQyxTQUdRLEdBSEl2MEIsTUFBTSxDQUFDeFMsc0JBQVAsR0FBZ0MsQ0FHcEM7QUFBQSxRQUZWc3FCLFFBRVUsR0FGQyxDQUVEO0FBQUEsUUFEVjBjLFNBQ1UsR0FERSxDQUNGO0FBQUEsUUFFVkMsV0FGVSxHQUVJLENBRko7QUFBQSxRQUdSQyxPQUhRLEdBR0UsRUFIRjtBQUFBLFFBSVJDLE1BSlEsR0FJQyxFQUpEO0FBQUEsUUFLUkMsT0FMUSxHQUtFLEVBTEY7QUFBQSxRQU1SQyxPQU5RLEdBTUUsQ0FBQyxDQUFELENBTkY7QUFBQSxRQU9SQyxLQVBRLEdBT0EsRUFQQTtBQUFBLFFBUVZ2QyxJQVJVLEdBUUgsQ0FSRztBQUFBLFFBVVJ3QyxvQkFWUSxHQVVleHVDLEtBQUssQ0FBQ2dCLGFBQU4sSUFBdUJoQixLQUFLLENBQUNpQixhQVY1QztBQUFBLFFBYVJ5ckMsU0FiUSxHQWFJcFEsU0FBUyxDQUN6QmxtQixNQURnQixDQUNULFVBQUFqVSxFQUFFO0FBQUEsYUFBSSxDQUFDaU4sU0FBUyxDQUFDcUssTUFBTSxDQUFDclYsVUFBUCxDQUFrQmpDLEVBQWxCLENBQUQsQ0FBVixJQUFxQ3NYLE1BQU0sQ0FBQ3JWLFVBQVAsQ0FBa0JqQyxFQUFsQixNQUEwQixJQUFuRTtBQUFBLEtBRE8sQ0FiSjtBQUFBLFFBZ0JSMnZCLGNBaEJRLEdBZ0JTbGhCLE9BQU8sQ0FBQ2toQixjQWhCakI7QUFBQSxRQWtCUjJjLGVBbEJRLEdBa0JVLFVBQVMxQixXQUFULEVBQXNCNXFDLEVBQXRCLEVBQTBCZ25CLEtBQTFCLEVBQWlDO0FBQUEsVUFTcEQ5b0IsTUFUb0Q7QUFBQSxVQUVsRHF1QyxNQUFNLEdBQUd2bEIsS0FBSyxLQUFLdWpCLFNBQVMsQ0FBQzM4QixNQUFWLEdBQW1CLENBRlk7QUFBQSxVQUdsRDQrQixHQUFHLEdBQUc3cUIsRUFBRSxDQUFDZ3BCLG9CQUFILENBQXdCM3FDLEVBQXhCLEVBQTRCNHFDLFdBQTVCLENBSDRDO0FBQUEsVUFJbEQ2QixTQUFTLEdBQUdELEdBQUcsQ0FBQzF1QyxLQUFKLEdBQVkrdEMsU0FBWixJQUNoQlUsTUFBTSxJQUFJLENBQUNGLG9CQUFYLEdBQWtDLENBQWxDLEdBNUJrQixFQTJCRixJQUNzQy8wQixNQUFNLENBQUN6UyxjQUxQO0FBQUEsVUFNbEQ2bkMsVUFBVSxHQUFHRixHQUFHLENBQUN4dUMsTUFBSixHQTlCRCxDQXdCc0M7QUFBQSxVQU9sRDJ1QyxVQUFVLEdBQUdOLG9CQUFvQixHQUFHSyxVQUFILEdBQWdCRCxTQVBDO0FBQUEsVUFRbERHLFVBQVUsR0FBR1Asb0JBQW9CLEdBQUcxcUIsRUFBRSxDQUFDdW9CLGVBQUgsRUFBSCxHQUEwQnZvQixFQUFFLENBQUNzb0IsY0FBSCxFQVJUO0FBQUEsVUFZbEQ0QyxZQUFZLEdBQUcsVUFBU0MsR0FBVCxFQUFjQyxXQUFkLEVBQXFDO0FBQ3BEQSxtQkFEb0QsS0FFeEQ3dUMsTUFBTSxHQUFHLENBQUMwdUMsVUFBVSxHQUFHYixXQUFiLEdBQTJCWSxVQUE1QixJQUEwQyxDQUZLLEVBSXBEenVDLE1BQU0sR0FBRzB0QyxNQUoyQyxLQUt2RDF0QyxNQUFNLEdBQUcsQ0FBQzB1QyxVQUFVLEdBQUdELFVBQWQsSUFBNEIsQ0FMa0IsRUFNdkRaLFdBQVcsR0FBRyxDQU55QyxFQU92RGxDLElBQUksRUFQbUQsSUFXekR1QyxLQUFLLENBQUNVLEdBQUQsQ0FBTCxHQUFhakQsSUFYNEMsRUFZekRzQyxPQUFPLENBQUN0QyxJQUFELENBQVAsR0FBZ0Joc0MsS0FBSyxDQUFDaUIsYUFBTixHQUFzQixFQUF0QixHQUEyQlosTUFaYyxFQWF6RDh0QyxPQUFPLENBQUNjLEdBQUQsQ0FBUCxHQUFlZixXQWIwQyxFQWN6REEsV0FBVyxJQUFJWSxVQWQwQztBQWV6RCxPQTNCdUQ7O0FBb0N4RCxVQW5DYzNsQixLQUFLLEtBQUssQ0FtQ3hCLEtBTkMra0IsV0FBVyxHQUFHLENBTWYsRUFMQ2xDLElBQUksR0FBRyxDQUtSLEVBSkN6YSxRQUFRLEdBQUcsQ0FJWixFQUhDMGMsU0FBUyxHQUFHLENBR2IsR0FBSXgwQixNQUFNLENBQUN0VCxXQUFQLElBQXNCLENBQUMyZCxFQUFFLENBQUNzWSxjQUFILENBQWtCajZCLEVBQWxCLENBQTNCLEVBTUMsT0FMQWlzQyxNQUFNLENBQUNqc0MsRUFBRCxDQUFOLEdBQWEsQ0FLYixFQUpBa3NDLE9BQU8sQ0FBQ2xzQyxFQUFELENBQVAsR0FBYyxDQUlkLEVBSEFvc0MsS0FBSyxDQUFDcHNDLEVBQUQsQ0FBTCxHQUFZLENBR1osUUFGQWdzQyxPQUFPLENBQUNoc0MsRUFBRCxDQUFQLEdBQWMsQ0FFZDtBQUdEaXNDLFlBQU0sQ0FBQ2pzQyxFQUFELENBQU4sR0FBYXlzQyxTQTdDMkMsRUE4Q3hEUCxPQUFPLENBQUNsc0MsRUFBRCxDQUFQLEdBQWMwc0MsVUE5QzBDLEdBZ0RwRCxDQUFDdGQsUUFBRCxJQUFhcWQsU0FBUyxJQUFJcmQsUUFoRDBCLE1BaUR2REEsUUFBUSxHQUFHcWQsU0FqRDRDLElBb0RwRCxDQUFDWCxTQUFELElBQWNZLFVBQVUsSUFBSVosU0FwRHdCLE1BcUR2REEsU0FBUyxHQUFHWSxVQXJEMkM7QUF3RHhELFVBQU1NLFNBQVMsR0FBR1gsb0JBQW9CLEdBQUdQLFNBQUgsR0FBZTFjLFFBQXJEO0FBRUk5WCxZQUFNLENBQUMxUyxjQTFENkMsSUEyRHZEa0osTUFBTSxDQUFDQyxJQUFQLENBQVlrK0IsTUFBWixFQUFvQmo5QixPQUFwQixDQUE0QixVQUFBODlCLEdBQUc7QUFBQSxlQUFLYixNQUFNLENBQUNhLEdBQUQsQ0FBTixHQUFjMWQsUUFBbkI7QUFBQSxPQUEvQixDQTNEdUQsRUE0RHZEdGhCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZbStCLE9BQVosRUFBcUJsOUIsT0FBckIsQ0FBNkIsVUFBQTg5QixHQUFHO0FBQUEsZUFBS1osT0FBTyxDQUFDWSxHQUFELENBQVAsR0FBZWhCLFNBQXBCO0FBQUEsT0FBaEMsQ0E1RHVELEVBNkR2RDV0QyxNQUFNLEdBQUcsQ0FBQzB1QyxVQUFVLEdBQUdJLFNBQVMsR0FBR3pDLFNBQVMsQ0FBQzM4QixNQUFwQyxJQUE4QyxDQTdEQSxFQStEbkQxUCxNQUFNLEdBQUcwdEMsTUEvRDBDLElBZ0V0REcsV0FBVyxHQUFHLENBaEV3QyxFQWlFdERsQyxJQUFJLEdBQUcsQ0FqRStDLEVBa0V0RFUsU0FBUyxDQUFDdjdCLE9BQVYsQ0FBa0IsVUFBQTg5QixHQUFHO0FBQUEsZUFBSUQsWUFBWSxDQUFDQyxHQUFELENBQWhCO0FBQUEsT0FBckIsQ0FsRXNELElBb0V0REQsWUFBWSxDQUFDN3NDLEVBQUQsS0FwRTBDLElBdUV2RDZzQyxZQUFZLENBQUM3c0MsRUFBRCxDQXZFMkM7QUF5RXhELEtBM0ZhOztBQTZGVm5DLFNBQUssQ0FBQ2lCLGFBdEc2QixLQXVHdEMrcUMsSUFBSSxHQUFHdnlCLE1BQU0sQ0FBQzlTLGlCQUFQLEdBQTJCOFMsTUFBTSxDQUFDOVMsaUJBQWxDLEdBQXNEK2xDLFNBQVMsQ0FBQzM4QixNQXZHakMsRUF3R3RDK1QsRUFBRSxDQUFDaW9CLGdCQUFILENBQW9CQyxJQUFwQixDQXhHc0MsR0EyR25DaHNDLEtBQUssQ0FBQ2dCLGFBM0c2QixJQTRHdEM2c0MsVUFBVSxHQUFHLFVBQUExckMsRUFBRTtBQUFBLGFBQUlvdkIsUUFBUSxHQUFHZ2QsS0FBSyxDQUFDcHNDLEVBQUQsQ0FBcEI7QUFBQSxLQTVHdUIsRUE2R3RDMnJDLFVBQVUsR0FBRyxVQUFBM3JDLEVBQUU7QUFBQSxhQUFJbXNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDcHNDLEVBQUQsQ0FBTixDQUFQLEdBQXFCZ3NDLE9BQU8sQ0FBQ2hzQyxFQUFELENBQWhDO0FBQUEsS0E3R3VCLElBOEc1Qm5DLEtBQUssQ0FBQ2lCLGFBOUdzQixJQStHdEM0c0MsVUFBVSxHQUFHLFVBQUExckMsRUFBRTtBQUFBLGFBQUlvdkIsUUFBUSxHQUFHZ2QsS0FBSyxDQUFDcHNDLEVBQUQsQ0FBaEIsR0FBdUIsRUFBM0I7QUFBQSxLQS9HdUIsRUFnSHRDMnJDLFVBQVUsR0FBRyxVQUFBM3JDLEVBQUU7QUFBQSxhQUFJbXNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDcHNDLEVBQUQsQ0FBTixDQUFQLEdBQXFCZ3NDLE9BQU8sQ0FBQ2hzQyxFQUFELENBQWhDO0FBQUEsS0FoSHVCLEtBa0h0QzByQyxVQUFVLEdBQUcsVUFBQTFyQyxFQUFFO0FBQUEsYUFBSW1zQyxPQUFPLENBQUNDLEtBQUssQ0FBQ3BzQyxFQUFELENBQU4sQ0FBUCxHQUFxQmdzQyxPQUFPLENBQUNoc0MsRUFBRCxDQUFoQztBQUFBLEtBbEh1QixFQW1IdEMyckMsVUFBVSxHQUFHLFVBQUEzckMsRUFBRTtBQUFBLGFBQUk4ckMsU0FBUyxHQUFHTSxLQUFLLENBQUNwc0MsRUFBRCxDQUFyQjtBQUFBLEtBbkh1Qjs7QUFzSGpDLFFBQUFpdEMsY0FBYyxHQUFHLFVBQUNqdEMsRUFBRCxFQUFLb1EsQ0FBTDtBQUFBLGFBQW9CczdCLFVBQVUsQ0FBQzFyQyxFQUFELEVBQUtvUSxDQUFMLENBQVYsR0FBb0IsQ0FBcEIsR0FBd0JrSCxNQUFNLENBQUN4UyxzQkFBbkQ7QUFBQSxLQUFqQjtBQUFBLFFBQ0Fvb0MsY0FEQSxHQUNpQixVQUFDbHRDLEVBQUQsRUFBS29RLENBQUw7QUFBQSxhQUFvQnM3QixVQUFVLENBQUMxckMsRUFBRCxFQUFLb1EsQ0FBTCxDQUE5QjtBQUFBLEtBRGpCO0FBQUEsUUFFQSs4QixlQUZBLEdBRWtCLFVBQUNudEMsRUFBRCxFQUFLb1EsQ0FBTDtBQUFBLGFBQW9CczdCLFVBQVUsQ0FBQzFyQyxFQUFELEVBQUtvUSxDQUFMLENBQVYsR0FBb0IsQ0FBeEM7QUFBQSxLQUZsQjtBQUFBLFFBR0FnOUIsZUFIQSxHQUdrQixVQUFDcHRDLEVBQUQsRUFBS29RLENBQUw7QUFBQSxhQUFvQnM3QixVQUFVLENBQUMxckMsRUFBRCxFQUFLb1EsQ0FBTCxDQUFWLEdBQW9CLENBQXBCLEdBQXdCa0gsTUFBTSxDQUFDeFMsc0JBQW5EO0FBQUEsS0FIbEI7QUFBQSxRQUtBdW9DLGNBTEEsR0FLaUIsVUFBQ3J0QyxFQUFELEVBQUtvUSxDQUFMO0FBQUEsYUFBb0J1N0IsVUFBVSxDQUFDM3JDLEVBQUQsRUFBS29RLENBQUwsQ0FBVixHQUFvQixDQUF4QztBQUFBLEtBTGpCO0FBQUEsUUFNQWs5QixjQU5BLEdBTWlCLFVBQUN0dEMsRUFBRCxFQUFLb1EsQ0FBTDtBQUFBLGFBQW9CdTdCLFVBQVUsQ0FBQzNyQyxFQUFELEVBQUtvUSxDQUFMLENBQVYsR0FBb0IsQ0FBeEM7QUFBQSxLQU5qQjtBQUFBLFFBT0FtOUIsY0FQQSxHQU9pQixVQUFDdnRDLEVBQUQsRUFBS29RLENBQUw7QUFBQSxhQUFvQnU3QixVQUFVLENBQUMzckMsRUFBRCxFQUFLb1EsQ0FBTCxDQUFWLEdBQW9CLENBQXhDO0FBQUEsS0FQakI7QUFBQSxRQVNBdVgsR0FUQSxHQVNNLENBQUMsR0FUUDtBQUFBLFFBV0M1SSxNQVhELEdBV1c0QyxFQUFFLENBQUM1USxHQVhkLENBV0NnTyxNQVhEO0FBQUEsUUFjQWdtQixDQWRBLEdBY0lobUIsTUFBTSxDQUFDcUgsU0FBUCxPQUFxQjlVLGNBQUssQ0FBQ3JXLFVBQTNCLEVBQ1I2WSxJQURRLENBQ0h5MkIsU0FERyxFQUVSbGtCLEtBRlEsR0FHUmhXLE1BSFEsQ0FHRCxHQUhDLENBZEo7O0FBbUJOc1IsTUFBRSxDQUFDd25CLGFBQUgsQ0FBaUJwRSxDQUFqQixDQXpJdUMsRUEySXZDQSxDQUFDLENBQUMxMEIsTUFBRixDQUFTLE1BQVQsRUFDRTlULElBREYsQ0FDTyxVQUFBeUQsRUFBRTtBQUFBLGFBQUtpTixTQUFTLENBQUNxSyxNQUFNLENBQUNyVixVQUFQLENBQWtCakMsRUFBbEIsQ0FBRCxDQUFULEdBQW1Dc1gsTUFBTSxDQUFDclYsVUFBUCxDQUFrQmpDLEVBQWxCLENBQW5DLEdBQTJEQSxFQUFoRTtBQUFBLEtBRFQsRUFFRThsQixJQUZGLENBRU8sVUFBUzlsQixFQUFULEVBQWFvUSxDQUFiLEVBQWdCO0FBQ3JCazhCLHFCQUFlLENBQUMsSUFBRCxFQUFPdHNDLEVBQVAsRUFBV29RLENBQVgsQ0FETTtBQUVyQixLQUpGLEVBS0VzVyxLQUxGLENBS1EsZ0JBTFIsRUFLMEIsTUFMMUIsRUFNRXBXLElBTkYsQ0FNTyxHQU5QLEVBTVkrN0Isb0JBQW9CLEdBQUdZLGNBQUgsR0FBb0J0bEIsR0FOcEQsRUFPRXJYLElBUEYsQ0FPTyxHQVBQLEVBT1krN0Isb0JBQW9CLEdBQUcxa0IsR0FBSCxHQUFTMGxCLGNBUHpDLENBM0l1QyxFQW9KdkN0SSxDQUFDLENBQUMxMEIsTUFBRixDQUFTLE1BQVQsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JnQixjQUFLLENBQUNwVyxlQUR0QixFQUVFd3JCLEtBRkYsQ0FFUSxjQUZSLEVBRXdCLEdBRnhCLEVBR0VwVyxJQUhGLENBR08sR0FIUCxFQUdZKzdCLG9CQUFvQixHQUFHYSxjQUFILEdBQW9CdmxCLEdBSHBELEVBSUVyWCxJQUpGLENBSU8sR0FKUCxFQUlZKzdCLG9CQUFvQixHQUFHMWtCLEdBQUgsR0FBUzJsQixjQUp6QyxDQXBKdUM7QUEwSnZDLFFBQU1FLFFBQVEsR0FBR2wyQixNQUFNLENBQUN0UyxlQUF4Qjs7QUFFQSxRQUFJd29DLFFBQUosRUFBYztBQUNiLFVBQU16WCxHQUFVLEdBQUcsRUFBbkI7QUFFQWdQLE9BQUMsQ0FBQzEwQixNQUFGLENBQVMsVUFBQTVDLENBQUMsRUFBSTtBQUNiLFlBQU0wMUIsT0FBTyxHQUFHbDFCLFFBQVEsQ0FBQ3FKLE1BQU0sQ0FBQytCLGFBQVIsQ0FBUixHQUNmL0IsTUFBTSxDQUFDK0IsYUFEUSxHQUNRLENBQUMvQixNQUFNLENBQUNpQyxVQUFSLENBRHhCO0FBR0F3YyxXQUFHLENBQUNsbUIsT0FBSixDQUFZcEMsQ0FBWixNQUFtQixDQUFDLENBQXBCLElBQXlCc29CLEdBQUcsQ0FBQy9nQixJQUFKLENBQVN2SCxDQUFULENBSlo7QUFNYixZQUFJNlIsS0FBSyxHQUFHNmpCLE9BQU8sQ0FBQ3BOLEdBQUcsQ0FBQ2xtQixPQUFKLENBQVlwQyxDQUFaLElBQWlCMDFCLE9BQU8sQ0FBQ3YxQixNQUExQixDQUFuQjtBQU1BLGVBSkkwUixLQUFLLEtBQUssV0FJZCxLQUhDQSxLQUFLLEdBQUcsTUFHVCxHQUFPNVMsV0FBUSxDQUFDK2dDLGVBQVQsQ0FBeUJDLDZGQUFZLENBQUN4ZSxHQUF0QyxFQUEyQ3ZOLEVBQUUsQ0FBQ2dzQixpQkFBSCxDQUFxQnJ1QixLQUFyQixJQUE4QkEsS0FBOUIsR0FBc0MsS0FBakYsQ0FBUDtBQUNBLE9BYkQsRUFjRWhQLElBZEYsQ0FjTyxPQWRQLEVBY2dCZ0IsY0FBSyxDQUFDalcsZUFkdEIsRUFlRXFyQixLQWZGLENBZVEsTUFmUixFQWVnQixVQUFBalosQ0FBQztBQUFBLGVBQUlrVSxFQUFFLENBQUM5QyxLQUFILENBQVNwUixDQUFULENBQUo7QUFBQSxPQWZqQixFQWdCRWlaLEtBaEJGLENBZ0JRLGdCQWhCUixFQWdCMEIsTUFoQjFCLEVBaUJFcFcsSUFqQkYsQ0FpQk8sTUFqQlAsRUFpQmUsVUFBQ3dELElBQUQsRUFBTzg1QixHQUFQLEVBQVk5OEIsU0FBWixFQUEwQjtBQUFBLFlBQ2pDcEIsSUFBSSxHQUFHb0IsU0FBUyxDQUFDODhCLEdBQUQsQ0FEaUI7QUFBQSxZQUVqQ0MsUUFBUSxHQUFHbitCLElBQUksQ0FBQ20rQixRQUFMLENBQWMvUyxXQUFkLEVBRnNCO0FBSXZDLGVBQU8rUyxRQUFRLEtBQUssS0FBYixTQUF5Qmh3QyxLQUFLLENBQUNpQyxVQUEvQixlQUFtRGdVLElBQW5ELEdBQTREMVIsU0FBbkU7QUFDQSxPQXRCRixDQUhhO0FBMEJiLEtBMUJELE1BMkJDMmlDLENBQUMsQ0FBQzEwQixNQUFGLENBQVMsTUFBVCxFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQmdCLGNBQUssQ0FBQ2hXLGNBRHRCLEVBRUVvckIsS0FGRixDQUVRLFFBRlIsRUFFa0IvRSxFQUFFLENBQUM5QyxLQUZyQixFQUdFNkgsS0FIRixDQUdRLGdCQUhSLEVBRzBCLE1BSDFCLEVBSUVwVyxJQUpGLENBSU8sSUFKUCxFQUlhKzdCLG9CQUFvQixHQUFHYyxlQUFILEdBQXFCeGxCLEdBSnRELEVBS0VyWCxJQUxGLENBS08sSUFMUCxFQUthKzdCLG9CQUFvQixHQUFHMWtCLEdBQUgsR0FBUzRsQixjQUwxQyxFQU1FajlCLElBTkYsQ0FNTyxJQU5QLEVBTWErN0Isb0JBQW9CLEdBQUdlLGVBQUgsR0FBcUJ6bEIsR0FOdEQsRUFPRXJYLElBUEYsQ0FPTyxJQVBQLEVBT2ErN0Isb0JBQW9CLEdBQUcxa0IsR0FBSCxHQUFTNGxCLGNBUDFDLEVBUUVqOUIsSUFSRixDQVFPLGNBUlAsRUFRdUJnSCxNQUFNLENBQUN2Uyx1QkFSOUIsQ0EzQkQsQ0E1SnVDLENBa012Qzs7O0FBQ0E0YSxjQUFVLEdBQUdaLE1BQU0sQ0FBQzFOLE1BQVAsT0FBa0JDLGNBQUssQ0FBQ3RXLGdCQUF4QixXQW5NMEIsRUFxTW5DNkMsS0FBSyxDQUFDaUIsYUFBTixJQUF1QnN3QixRQUFRLEdBQUcsQ0FBbEMsSUFBdUN6UCxVQUFVLENBQUNwZ0IsSUFBWCxPQUFzQixDQXJNMUIsS0FzTXRDb2dCLFVBQVUsR0FBR1osTUFBTSxDQUFDMEgsTUFBUCxDQUFjLEdBQWQsUUFBdUJuVixjQUFLLENBQUNyVyxVQUE3QixFQUNYcVYsSUFEVyxDQUNOLE9BRE0sRUFDR2dCLGNBQUssQ0FBQ3RXLGdCQURULEVBRVhxVixNQUZXLENBRUosTUFGSSxDQXRNeUI7QUEyTXZDLFFBQU03VCxLQUFLLEdBQUd1aUIsTUFBTSxDQUFDcUgsU0FBUCxDQUFpQixNQUFqQixFQUNadFMsSUFEWSxDQUNQeTJCLFNBRE8sRUFFWmh1QyxJQUZZLENBRVAsVUFBQXlELEVBQUU7QUFBQSxhQUFLaU4sU0FBUyxDQUFDcUssTUFBTSxDQUFDclYsVUFBUCxDQUFrQmpDLEVBQWxCLENBQUQsQ0FBVCxHQUFtQ3NYLE1BQU0sQ0FBQ3JWLFVBQVAsQ0FBa0JqQyxFQUFsQixDQUFuQyxHQUEyREEsRUFBaEU7QUFBQSxLQUZLLEVBRWdFO0FBRmhFLEtBR1o4bEIsSUFIWSxDQUdQLFVBQVM5bEIsRUFBVCxFQUFhb1EsQ0FBYixFQUFnQjtBQUNyQms4QixxQkFBZSxDQUFDLElBQUQsRUFBT3RzQyxFQUFQLEVBQVdvUSxDQUFYLENBRE07QUFFckIsS0FMWSxDQUFkO0FBT0EsS0FBQ3VmLGNBQWMsR0FBR256QixLQUFLLENBQUNvbkIsVUFBTixFQUFILEdBQXdCcG5CLEtBQXZDLEVBQ0U4VCxJQURGLENBQ08sR0FEUCxFQUNZMjhCLGNBRFosRUFFRTM4QixJQUZGLENBRU8sR0FGUCxFQUVZKzhCLGNBRlosQ0FsTnVDO0FBc052QyxRQUFNUyxLQUFLLEdBQUcvdUIsTUFBTSxDQUFDcUgsU0FBUCxXQUF5QjlVLGNBQUssQ0FBQ3BXLGVBQS9CLEVBQ1o0WSxJQURZLENBQ1B5MkIsU0FETyxDQUFkOztBQVVBLFFBUEEsQ0FBQzVhLGNBQWMsR0FBR21lLEtBQUssQ0FBQ2xxQixVQUFOLEVBQUgsR0FBd0JrcUIsS0FBdkMsRUFDRXg5QixJQURGLENBQ08sT0FEUCxFQUNnQixVQUFBdFEsRUFBRTtBQUFBLGFBQUlpc0MsTUFBTSxDQUFDanNDLEVBQUQsQ0FBVjtBQUFBLEtBRGxCLEVBRUVzUSxJQUZGLENBRU8sUUFGUCxFQUVpQixVQUFBdFEsRUFBRTtBQUFBLGFBQUlrc0MsT0FBTyxDQUFDbHNDLEVBQUQsQ0FBWDtBQUFBLEtBRm5CLEVBR0VzUSxJQUhGLENBR08sR0FIUCxFQUdZNDhCLGNBSFosRUFJRTU4QixJQUpGLENBSU8sR0FKUCxFQUlZZzlCLGNBSlosQ0FPQSxFQUFJRSxRQUFKLEVBQWM7QUFDYixVQUFNbEosS0FBSyxHQUFHdmxCLE1BQU0sQ0FBQ3FILFNBQVAsT0FBcUI5VSxjQUFLLENBQUNqVyxlQUEzQixFQUNaeVksSUFEWSxDQUNQeTJCLFNBRE8sQ0FBZDtBQUdBLE9BQUM1YSxjQUFjLEdBQUcyVSxLQUFLLENBQUMxZ0IsVUFBTixFQUFILEdBQXdCMGdCLEtBQXZDLEVBQ0V4ZSxJQURGLENBQ08sWUFBVztBQUFBLFlBT1p2a0IsTUFQWTtBQUFBLFlBUVp6RCxLQVJZO0FBQUEsWUFTWkUsTUFUWTtBQUFBLFlBQ1Y2dkMsUUFBUSxHQUFHLEtBQUtBLFFBQUwsQ0FBYy9TLFdBQWQsRUFERDtBQUFBLFlBRVZpVCxNQUFNLEdBQUd6MkIsTUFBTSxDQUFDMkIsT0FGTjtBQUFBLFlBR1ozWixDQUFDLEdBQUcsR0FIUTtBQUFBLFlBSVpHLENBQUMsR0FBRyxHQUpRO0FBQUEsWUFLWnV1QyxPQUFPLEdBQUcsQ0FMRTtBQUFBLFlBTVpDLE9BQU8sR0FBRyxHQU5FOztBQVdoQixZQUFJSixRQUFRLEtBQUssUUFBakIsRUFBMkI7QUFDMUIsY0FBTXR1QyxJQUFJLEdBQUd3dUMsTUFBTSxHQUFHLEVBQXRCO0FBRUF6dUMsV0FBQyxHQUFHLElBSHNCLEVBSTFCRyxDQUFDLEdBQUcsSUFKc0IsRUFLMUI4QixNQUFNLEdBQUd3c0MsTUFBTSxHQUFHeHVDLElBTFEsRUFNMUJ5dUMsT0FBTyxHQUFHRCxNQUFNLEdBQUcsQ0FOTyxFQU8xQkUsT0FBTyxHQUFHLENBQUMxdUMsSUFQZTtBQVExQixTQVJELE1BUU8sSUFBSXN1QyxRQUFRLEtBQUssTUFBakIsRUFBeUI7QUFDL0IsY0FBTXR1QyxLQUFJLEdBQUd3dUMsTUFBTSxHQUFHLEdBQXRCOztBQUVBandDLGVBQUssR0FBR3lCLEtBSHVCLEVBSS9CdkIsTUFBTSxHQUFHdUIsS0FKc0IsRUFLL0IwdUMsT0FBTyxHQUFHLENBTHFCO0FBTS9COztBQUVEbG9CLHlHQUFRLENBQUMsSUFBRCxDQUFSLENBQ0V6VixJQURGLENBQ09oUixDQURQLEVBQ1UsVUFBQW1PLENBQUM7QUFBQSxpQkFBSTAvQixlQUFlLENBQUMxL0IsQ0FBRCxDQUFmLEdBQXFCdWdDLE9BQXpCO0FBQUEsU0FEWCxFQUVFMTlCLElBRkYsQ0FFTzdRLENBRlAsRUFFVSxVQUFBZ08sQ0FBQztBQUFBLGlCQUFJOC9CLGNBQWMsQ0FBQzkvQixDQUFELENBQWQsR0FBb0J3Z0MsT0FBeEI7QUFBQSxTQUZYLEVBR0UzOUIsSUFIRixDQUdPLEdBSFAsRUFHWS9PLE1BSFosRUFJRStPLElBSkYsQ0FJTyxPQUpQLEVBSWdCeFMsS0FKaEIsRUFLRXdTLElBTEYsQ0FLTyxRQUxQLEVBS2lCdFMsTUFMakIsQ0EzQmdCO0FBaUNoQixPQWxDRixDQUphO0FBdUNiLEtBdkNELE1BdUNPO0FBQ04sVUFBTXNtQyxNQUFLLEdBQUd2bEIsTUFBTSxDQUFDcUgsU0FBUCxXQUF5QjlVLGNBQUssQ0FBQ2hXLGNBQS9CLEVBQ1p3WSxJQURZLENBQ1B5MkIsU0FETyxDQUFkOztBQUdBLE9BQUM1YSxjQUFjLEdBQUcyVSxNQUFLLENBQUMxZ0IsVUFBTixFQUFILEdBQXdCMGdCLE1BQXZDLEVBQ0U1ZCxLQURGLENBQ1EsUUFEUixFQUNrQi9FLEVBQUUsQ0FBQ3VzQixVQUFILEdBQWdCLFVBQUFsdUMsRUFBRTtBQUFBLGVBQUkyaEIsRUFBRSxDQUFDdXNCLFVBQUgsQ0FBY3ZzQixFQUFFLENBQUNQLEtBQUgsQ0FBU0csR0FBVCxDQUFhdmhCLEVBQWIsRUFBaUI2aEIsTUFBakIsQ0FBd0IsQ0FBeEIsRUFBMkIvUyxLQUF6QyxDQUFKO0FBQUEsT0FBbEIsR0FBd0U2UyxFQUFFLENBQUM5QyxLQUQ3RixFQUVFdk8sSUFGRixDQUVPLElBRlAsRUFFYTY4QixlQUZiLEVBR0U3OEIsSUFIRixDQUdPLElBSFAsRUFHYWk5QixjQUhiLEVBSUVqOUIsSUFKRixDQUlPLElBSlAsRUFJYTg4QixlQUpiLEVBS0U5OEIsSUFMRixDQUtPLElBTFAsRUFLYWk5QixjQUxiLENBSk07QUFVTjs7QUFFRzV0QixjQW5SbUMsSUFvUnRDLENBQUNnUSxjQUFjLEdBQUdoUSxVQUFVLENBQUNpRSxVQUFYLEVBQUgsR0FBNkJqRSxVQUE1QyxFQUNFclAsSUFERixDQUNPLFFBRFAsRUFDaUJxUixFQUFFLENBQUN1b0IsZUFBSCxLQUF1QixFQUR4QyxFQUVFNTVCLElBRkYsQ0FFTyxPQUZQLEVBRWdCOGUsUUFBUSxJQUFJeWEsSUFBSSxHQUFHLENBQVgsQ0FBUixHQUF3QixFQUZ4QyxDQXBSc0MsRUEwUnZDbG9CLEVBQUUsQ0FBQ21vQixxQkFBSCxDQUF5QjFhLFFBQXpCLENBMVJ1QyxFQTJSdkN6TixFQUFFLENBQUNvb0Isc0JBQUgsQ0FBMEIrQixTQUExQixDQTNSdUMsRUE0UnZDbnFCLEVBQUUsQ0FBQ2lvQixnQkFBSCxDQUFvQkMsSUFBcEIsQ0E1UnVDO0FBNlJ2QztBQTlyQmEsQ0FBZixFOztBQ2JBOzs7O0FBSUE7QUFLZTtBQUNkc0UsVUFEYyxvQkFDTHY5QixHQURLLEVBQ0EyVCxHQURBLEVBQ0s2cEIsYUFETCxFQUNvQjtBQUNqQyxXQUFPLENBQUNBLGFBQWEsR0FDcEJDLHdGQUFXLEVBRFMsR0FDSnBzQiwwRkFBYSxFQUR2QixFQUVMRyxLQUZLLENBRUMsQ0FBQ3hSLEdBQUQsRUFBTTJULEdBQU4sQ0FGRCxDQUFQO0FBR0EsR0FMYTs7QUFPZDs7Ozs7Ozs7O0FBU0ErcEIsTUFoQmMsZ0JBZ0JUMTlCLEdBaEJTLEVBZ0JKMlQsR0FoQkksRUFnQkMva0IsTUFoQkQsRUFnQlMrdUMsTUFoQlQsRUFnQmlCO0FBQUEsUUFDeEI1c0IsRUFBRSxHQUFHLElBRG1CO0FBQUEsUUFFeEJLLEtBQUssR0FBR0wsRUFBRSxDQUFDSyxLQUFILENBQVN6QyxJQUFULElBQWlCb0MsRUFBRSxDQUFDd3NCLFFBQUgsQ0FBWXY5QixHQUFaLEVBQWlCMlQsR0FBakIsRUFBc0I1QyxFQUFFLENBQUM4SixZQUFILEVBQXRCLENBRkQ7QUFJOUIsV0FBTzlKLEVBQUUsQ0FBQzZzQixrQkFBSCxDQUNOaHZDLE1BQU0sR0FBR3dpQixLQUFLLENBQUN4aUIsTUFBTixDQUFhQSxNQUFiLENBQUgsR0FBMEJ3aUIsS0FEMUIsRUFFTnVzQixNQUZNLENBQVA7QUFJQSxHQXhCYTs7QUEwQmQ7Ozs7Ozs7O0FBUUFFLE1BbENjLGdCQWtDVDc5QixHQWxDUyxFQWtDSjJULEdBbENJLEVBa0NDL2tCLE1BbENELEVBa0NTO0FBQ3RCLFFBQU13aUIsS0FBSyxHQUFHLEtBQUttc0IsUUFBTCxDQUFjdjlCLEdBQWQsRUFBbUIyVCxHQUFuQixFQUF3QixLQUFLbUgsYUFBTCxFQUF4QixDQUFkO0FBSUEsV0FGQWxzQixNQUFNLElBQUl3aUIsS0FBSyxDQUFDeGlCLE1BQU4sQ0FBYUEsTUFBYixDQUVWLEVBQU93aUIsS0FBUDtBQUNBLEdBeENhOztBQTBDZDs7Ozs7OztBQU9Bd3NCLG9CQWpEYyw4QkFpREtFLFVBakRMLEVBaURpQkMsV0FqRGpCLEVBaUQ4QjtBQUFBLFFBQ3JDaHRCLEVBQUUsR0FBRyxJQURnQztBQUFBLFFBRXJDNHNCLE1BQU0sR0FBR0ksV0FBVyxJQUFLO0FBQUEsYUFBTWh0QixFQUFFLENBQUN4cEIsSUFBSCxDQUFRbUgsQ0FBUixDQUFVb2pCLFVBQVYsRUFBTjtBQUFBLEtBRlk7QUFBQSxRQUdyQ1YsS0FBSyxHQUFHLFVBQVN2VSxDQUFULEVBQVltaEMsR0FBWixFQUFpQjtBQUM5QixVQUFNaGlDLENBQUMsR0FBRzhoQyxVQUFVLENBQUNqaEMsQ0FBRCxDQUFWLEdBQWdCOGdDLE1BQU0sRUFBaEM7QUFFQSxhQUFPSyxHQUFHLEdBQUdoaUMsQ0FBSCxHQUFPUSxJQUFJLENBQUNDLElBQUwsQ0FBVVQsQ0FBVixDQUFqQjtBQUNBLEtBUDBDOztBQVMzQztBQUNBLFNBQUssSUFBTThCLEdBQVgsSUFBa0JnZ0MsVUFBbEIsRUFDQzFzQixLQUFLLENBQUN0VCxHQUFELENBQUwsR0FBYWdnQyxVQUFVLENBQUNoZ0MsR0FBRCxDQUR4Qjs7QUF3QkEsV0FwQkFzVCxLQUFLLENBQUM0UCxTQUFOLEdBQWtCO0FBQUEsYUFBTThjLFVBQVUsQ0FBQ2x2QyxNQUFYLEVBQU47QUFBQSxLQW9CbEIsRUFuQkF3aUIsS0FBSyxDQUFDNnNCLFFBQU4sR0FBaUI7QUFBQSxhQUFNSCxVQUFOO0FBQUEsS0FtQmpCLEVBaEJJL3NCLEVBQUUsQ0FBQzBKLGFBQUgsRUFnQkosS0FmQ3JKLEtBQUssQ0FBQ3hpQixNQUFOLEdBQWUsVUFBUzZuQyxXQUFULEVBQXNCO0FBQ3BDLFVBQUk3bkMsTUFBTSxHQUFHNm5DLFdBQWI7QUFEb0MsYUFHL0J6ZSxTQUFTLENBQUNoYixNQUhxQixJQVNwQzhnQyxVQUFVLENBQUNsdkMsTUFBWCxDQUFrQkEsTUFBbEIsQ0FUb0MsRUFXN0J3aUIsS0FYNkIsS0FJbkN4aUIsTUFBTSxHQUFHLEtBQUtveUIsU0FBTCxFQUowQixFQU01QixDQUFDcHlCLE1BQU0sQ0FBQyxDQUFELENBQVAsRUFBWUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZLENBQXhCLENBTjRCO0FBWXBDLEtBR0YsR0FBT3dpQixLQUFQO0FBQ0EsR0FwRmE7QUFzRmQ4c0IsV0F0RmMscUJBc0ZKOXVDLEVBdEZJLEVBc0ZBO0FBQUEsc0JBQ0csS0FBS2dpQixLQURSO0FBQUEsUUFDTnZpQixDQURNLGVBQ05BLENBRE07QUFBQSxRQUNIQyxFQURHLGVBQ0hBLEVBREc7QUFFYixXQUFPLEtBQUt2SCxJQUFMLENBQVU2ekIsS0FBVixDQUFnQmhzQixFQUFoQixNQUF3QixJQUF4QixHQUErQk4sRUFBL0IsR0FBb0NELENBQTNDO0FBQ0EsR0F6RmE7QUEyRmRzdkMsY0EzRmMsd0JBMkZEL3VDLEVBM0ZDLEVBMkZHO0FBQUEsdUJBQ00sS0FBS2dpQixLQURYO0FBQUEsUUFDVGtRLElBRFMsZ0JBQ1RBLElBRFM7QUFBQSxRQUNIQyxLQURHLGdCQUNIQSxLQURHO0FBRWhCLFdBQU8sS0FBS2g2QixJQUFMLENBQVU2ekIsS0FBVixDQUFnQmhzQixFQUFoQixNQUF3QixJQUF4QixHQUErQm15QixLQUEvQixHQUF1Q0QsSUFBOUM7QUFDQSxHQTlGYTs7QUFnR2Q7Ozs7O0FBS0F5VyxjQXJHYyx3QkFxR0QzWCxNQXJHQyxFQXFHT1EsYUFyR1AsRUFxRzZCO0FBQXRCQSxpQkFBc0IsZ0JBQXRCQSxhQUFzQjtBQUNwQyxRQUFBN1AsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDeHBCLElBREQsR0FHRndwQixFQUhFLENBQ0N4cEIsSUFERDtBQUFBLFFBQ09tZixNQURQLEdBR0ZxSyxFQUhFLENBQ09ySyxNQURQO0FBQUEsUUFDZUMsTUFEZixHQUdGb0ssRUFIRSxDQUNlcEssTUFEZjtBQUFBLFFBQ3VCMnZCLEdBRHZCLEdBR0Z2bEIsRUFIRSxDQUN1QnVsQixHQUR2QjtBQUFBLFFBQzRCbGxCLEtBRDVCLEdBR0ZMLEVBSEUsQ0FDNEJLLEtBRDVCO0FBQUEsb0JBR0ZMLEVBSEUsQ0FFTDlqQixLQUZLO0FBQUEsUUFFR0MsS0FGSCxhQUVHQSxLQUZIO0FBQUEsUUFFVUUsTUFGVixhQUVVQSxNQUZWO0FBQUEsUUFFa0JELE1BRmxCLGFBRWtCQSxNQUZsQjtBQUFBLFFBRTBCRSxPQUYxQixhQUUwQkEsT0FGMUI7O0FBS04sUUFBSTBqQixFQUFFLENBQUM2VyxPQUFQLEVBQWdCO0FBQUEsVUFDVDlPLFNBQVMsR0FBR3BTLE1BQU0sQ0FBQ2MsWUFEVjtBQUFBLFVBSVR4SCxHQUFHLEdBQUc7QUFDWHRSLFNBQUMsRUFBRW9xQixTQUFTLEdBQUcsQ0FBSCxHQUFPLENBRFI7QUFFWGpxQixTQUFDLEVBQUVpcUIsU0FBUyxHQUFHLENBQUgsR0FBTzFyQixNQUZSO0FBR1hxckIsWUFBSSxFQUFFSyxTQUFTLEdBQUcsQ0FBSCxHQUFPLENBSFg7QUFJWHdJLFlBQUksRUFBRXhJLFNBQVMsR0FBRyxDQUFILEdBQU96ckI7QUFKWCxPQUpHO0FBQUEsVUFXVHNtQixHQUFHLEdBQUc7QUFDWGpsQixTQUFDLEVBQUVvcUIsU0FBUyxHQUFHMXJCLE1BQUgsR0FBWUYsS0FEYjtBQUVYMkIsU0FBQyxFQUFFaXFCLFNBQVMsR0FBRzVyQixLQUFILEdBQVcsQ0FGWjtBQUdYdXJCLFlBQUksRUFBRUssU0FBUyxHQUFHMXJCLE1BQUgsR0FBWUYsS0FIaEI7QUFJWG8wQixZQUFJLEVBQUV4SSxTQUFTLEdBQUczckIsTUFBSCxHQUFZO0FBSmhCLE9BWEc7QUFBQSxVQW9CVDg5QixPQUFPLEdBQUdySyxhQUFhLElBQUl4UCxLQUFLLENBQUMxaUIsQ0FBdkIsSUFBNEIwaUIsS0FBSyxDQUFDMWlCLENBQU4sQ0FBUXN5QixTQUFSLEVBcEI3QjtBQUFBLFVBcUJUb2QsVUFBVSxHQUFHeGQsYUFBYSxJQUFJMFYsR0FBRyxDQUFDckwsT0FyQnpCLEVBR2Y7O0FBZ0NBO0FBWkE3WixXQUFLLENBQUMxaUIsQ0FBTixHQUFVcWlCLEVBQUUsQ0FBQzJzQixJQUFILENBQVExOUIsR0FBRyxDQUFDdFIsQ0FBWixFQUFlaWxCLEdBQUcsQ0FBQ2psQixDQUFuQixFQUFzQnU4QixPQUF0QixFQUErQjtBQUFBLGVBQU0xakMsSUFBSSxDQUFDbUgsQ0FBTCxDQUFPb2pCLFVBQVAsRUFBTjtBQUFBLE9BQS9CLENBdkJLLEVBd0JmVixLQUFLLENBQUNxSCxJQUFOLEdBQWExSCxFQUFFLENBQUMyc0IsSUFBSCxDQUFRMTlCLEdBQUcsQ0FBQ3RSLENBQVosRUFBZWlsQixHQUFHLENBQUNqbEIsQ0FBbkIsRUFBc0IwdkMsVUFBdEIsRUFBa0MsVUFBQXZoQyxDQUFDO0FBQUEsZUFBS0EsQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFSLEdBQVl0VixJQUFJLENBQUNreEIsSUFBTCxDQUFVM0csVUFBVixFQUFqQjtBQUFBLE9BQW5DLENBeEJFLEVBMEJmbkwsTUFBTSxDQUFDK1QsU0FBUCxHQUFtQm56QixJQUFJLENBQUM4ekIsa0JBQUwsRUExQkosRUEyQmY5ekIsSUFBSSxDQUFDMHRCLElBQUwsQ0FBVXZtQixDQUFWLEdBQWNuSCxJQUFJLENBQUNvMEIsYUFBTCxDQUFtQixHQUFuQixDQTNCQyxFQTZCZnAwQixJQUFJLENBQUNtSCxDQUFMLEdBQVNuSCxJQUFJLENBQUMreUIsT0FBTCxDQUFhLEdBQWIsRUFBa0JsSixLQUFLLENBQUMxaUIsQ0FBeEIsRUFBMkJnWSxNQUFNLENBQUM3TyxpQkFBbEMsRUFBcUR1b0IsTUFBckQsQ0E3Qk0sRUErQlgxWixNQUFNLENBQUNrQyxhQS9CSSxLQWdDZHJoQixJQUFJLENBQUNreEIsSUFBTCxHQUFZbHhCLElBQUksQ0FBQyt5QixPQUFMLENBQWEsTUFBYixFQUFxQmxKLEtBQUssQ0FBQ3FILElBQTNCLEVBQWlDL1IsTUFBTSxDQUFDN08saUJBQXhDLEVBQTJEdW9CLE1BQTNELENBaENFLEdBb0NmaFAsS0FBSyxDQUFDdmlCLENBQU4sR0FBVWtpQixFQUFFLENBQUM4c0IsSUFBSCxDQUFRNzlCLEdBQUcsQ0FBQ25SLENBQVosRUFBZThrQixHQUFHLENBQUM5a0IsQ0FBbkIsRUFBc0J1aUIsS0FBSyxDQUFDdmlCLENBQU4sR0FBVXVpQixLQUFLLENBQUN2aUIsQ0FBTixDQUFRRCxNQUFSLEVBQVYsR0FBNkI4WCxNQUFNLENBQUM1TSxjQUExRCxDQXBDSyxFQXFDZnNYLEtBQUssQ0FBQ2tRLElBQU4sR0FBYXZRLEVBQUUsQ0FBQzhzQixJQUFILENBQVE3OUIsR0FBRyxDQUFDc2hCLElBQVosRUFBa0IzTixHQUFHLENBQUMyTixJQUF0QixFQUE0QmxRLEtBQUssQ0FBQ2tRLElBQU4sR0FBYWxRLEtBQUssQ0FBQ2tRLElBQU4sQ0FBVzF5QixNQUFYLEVBQWIsR0FBbUM4WCxNQUFNLENBQUM1TSxjQUF0RSxDQXJDRSxFQXVDZnZTLElBQUksQ0FBQzB0QixJQUFMLENBQVVwbUIsQ0FBVixHQUFjdEgsSUFBSSxDQUFDbzBCLGFBQUwsQ0FBbUIsR0FBbkIsQ0F2Q0MsRUF3Q2ZwMEIsSUFBSSxDQUFDc0gsQ0FBTCxHQUFTdEgsSUFBSSxDQUFDK3lCLE9BQUwsQ0FBYSxHQUFiLEVBQWtCbEosS0FBSyxDQUFDdmlCLENBQXhCLEVBQTJCNlgsTUFBTSxDQUFDdE4saUJBQWxDLEVBQXFEZ25CLE1BQXJELENBeENNLEVBMkNYMVosTUFBTSxDQUFDMU0sWUEzQ0ksS0E0Q2RvWCxLQUFLLENBQUN0aUIsRUFBTixHQUFXaWlCLEVBQUUsQ0FBQzhzQixJQUFILENBQVE3OUIsR0FBRyxDQUFDblIsQ0FBWixFQUFlOGtCLEdBQUcsQ0FBQzlrQixDQUFuQixFQUFzQnVpQixLQUFLLENBQUN0aUIsRUFBTixHQUFXc2lCLEtBQUssQ0FBQ3RpQixFQUFOLENBQVNGLE1BQVQsRUFBWCxHQUErQjhYLE1BQU0sQ0FBQ3ZMLGVBQTVELENBNUNHLEVBNkNkaVcsS0FBSyxDQUFDbVEsS0FBTixHQUFjeFEsRUFBRSxDQUFDOHNCLElBQUgsQ0FBUTc5QixHQUFHLENBQUNzaEIsSUFBWixFQUFrQjNOLEdBQUcsQ0FBQzJOLElBQXRCLEVBQ2JsUSxLQUFLLENBQUNtUSxLQUFOLEdBQWNuUSxLQUFLLENBQUNtUSxLQUFOLENBQVkzeUIsTUFBWixFQUFkLEdBQXFDOFgsTUFBTSxDQUFDdkwsZUFEL0IsQ0E3Q0EsRUFnRGQ1VCxJQUFJLENBQUMwdEIsSUFBTCxDQUFVbm1CLEVBQVYsR0FBZXZILElBQUksQ0FBQ28wQixhQUFMLENBQW1CLElBQW5CLENBaERELEVBaURkcDBCLElBQUksQ0FBQ3VILEVBQUwsR0FBVXZILElBQUksQ0FBQyt5QixPQUFMLENBQWEsSUFBYixFQUFtQmxKLEtBQUssQ0FBQ3RpQixFQUF6QixFQUE2QjRYLE1BQU0sQ0FBQ2hNLGtCQUFwQyxFQUF3RDBsQixNQUF4RCxDQWpESTtBQW1EZixLQW5ERCxNQW9EQztBQUNBclAsTUFBRSxDQUFDc3RCLFNBQUgsSUFBZ0J0dEIsRUFBRSxDQUFDc3RCLFNBQUgsRUFyRGpCO0FBdURBO0FBbEthLENBQWYsRTs7QUNUQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVlO0FBQ2Q7Ozs7QUFJQUMsa0JBTGMsOEJBS0s7QUFDWixRQUFBdnRCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQzlqQixLQURELEdBQ1U4akIsRUFEVixDQUNDOWpCLEtBREQ7QUFHTkEsU0FBSyxDQUFDYyxZQUFOLEdBQXFCZ2pCLEVBQUUsQ0FBQ3d0QixlQUFILEVBSkgsRUFLbEJ0eEMsS0FBSyxDQUFDZSxhQUFOLEdBQXNCK2lCLEVBQUUsQ0FBQ3l0QixnQkFBSCxFQUxKO0FBTWxCLEdBWGE7QUFhZEQsaUJBYmMsNkJBYUk7QUFDakIsUUFBTXh0QixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXdJLFVBQVYsSUFBd0I2QixFQUFFLENBQUMwdEIsY0FBSCxFQUEvQjtBQUNBLEdBakJhO0FBbUJkRCxrQkFuQmMsOEJBbUJLO0FBQ1osUUFBQXp0QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQW1MLENBRkEsR0FFSW5MLE1BQU0sQ0FBQ3lJLFdBQVAsSUFBc0I0QixFQUFFLENBQUMydEIsZUFBSCxFQUYxQjtBQUlOLFdBQU83c0IsQ0FBQyxHQUFHLENBQUosR0FBUUEsQ0FBUixHQUFZLE9BQU9kLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLEtBQXVCLENBQUN2Z0IsTUFBTSxDQUFDZ0YsZ0JBQS9CLEdBQWtELENBQWxELEdBQXNELENBQTdELENBQW5CO0FBQ0EsR0F6QmE7O0FBMkJkOzs7Ozs7QUFNQWl6QixhQWpDYyx1QkFpQ0Z2dkMsRUFqQ0UsRUFpQ0U7QUFBQSxRQUNUMmhCLEVBQUUsR0FBRyxJQURJO0FBQUEsUUFFVCtILFNBQVMsR0FBRy9ILEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWMsWUFGYjtBQUlmLFdBQVFzUixTQUFTLElBQUkxcEIsRUFBRSxLQUFLLEdBQXJCLElBQThCLENBQUMwcEIsU0FBRCxJQUFjLE1BQU12WCxJQUFOLENBQVduUyxFQUFYLENBQTVDLEdBQ04yaEIsRUFBRSxDQUFDNnRCLG9CQUFILENBQXdCeHZDLEVBQXhCLEtBRE0sR0FFTjJoQixFQUFFLENBQUM4dEIsdUJBQUgsQ0FBMkJ6dkMsRUFBM0IsQ0FGRDtBQUdBLEdBeENhO0FBMENkc3BDLHNCQTFDYyxrQ0EwQ1M7QUFDaEIsUUFBQTNuQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBQUEsUUFFQTIrQixPQUZBLEdBRVVwNEIsTUFBTSxDQUFDdEwsWUFBUCxDQUFvQjRCLE1BRjlCO0FBQUEsUUFJRnNpQixPQUpFLEdBSVF2akIsT0FBTyxDQUFDMkssTUFBTSxDQUFDNEksV0FBUixDQUFQLEdBQ2I1SSxNQUFNLENBQUM0SSxXQURNLEdBQ1EsQ0FMaEI7QUFlTixXQVJJblAsR0FBRyxDQUFDdFUsS0FBSixJQUFhc1UsR0FBRyxDQUFDdFUsS0FBSixDQUFVaVQsSUFBVixFQVFqQixLQVBDd2dCLE9BQU8sSUFBSXZPLEVBQUUsQ0FBQ2d1QixlQUFILEVBT1osR0FKSUQsT0FBTyxJQUFJcDRCLE1BQU0sQ0FBQ2MsWUFJdEIsS0FIQzhYLE9BQU8sSUFBSXZPLEVBQUUsQ0FBQzh0Qix1QkFBSCxDQUEyQixJQUEzQixJQUFtQ0MsT0FHL0MsR0FBT3hmLE9BQVA7QUFDQSxHQTNEYTtBQTZEZHFaLHlCQTdEYyxxQ0E2RFk7QUFDbkIsUUFBQTVuQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQXVTLE1BRkEsR0FFU3ZTLE1BQU0sQ0FBQ2MsWUFBUCxHQUFzQixHQUF0QixHQUE0QixHQUZyQztBQUFBLFFBR0FzM0IsT0FIQSxHQUdVcDRCLE1BQU0sV0FBU3VTLE1BQVQsV0FBTixDQUE4QmpjLE1BSHhDO0FBQUEsUUFJQXNpQixPQUpBLEdBSVV2akIsT0FBTyxDQUFDMkssTUFBTSxDQUFDNkksY0FBUixDQUFQLEdBQ2Y3SSxNQUFNLENBQUM2SSxjQURRLEdBQ1MsQ0FMbkI7QUFPTixXQUFPK1AsT0FBTyxJQUNid2YsT0FBTyxHQUFHL3RCLEVBQUUsQ0FBQzh0Qix1QkFBSCxDQUEyQjVsQixNQUEzQixJQUFxQzZsQixPQUF4QyxHQUFrRCxDQUQ1QyxDQUFkO0FBR0EsR0F4RWE7QUEwRWRsRyx1QkExRWMsaUNBMEVRdmEsZ0JBMUVSLEVBMEUwQjtBQU9uQyxRQUFBaUIsT0FBTztBQUFBLFFBTkx2TyxFQU1LLEdBTkEsSUFNQTtBQUFBLFFBTEpySyxNQUtJLEdBTE1xSyxFQUtOLENBTEpySyxNQUtJO0FBQUEsUUFKTG9TLFNBSUssR0FKT3BTLE1BQU0sQ0FBQ2MsWUFJZDtBQUFBLFFBSEx5UixNQUdLLEdBSElILFNBQVMsR0FBRyxHQUFILEdBQVMsR0FHdEI7QUFBQSxRQUZMZ21CLE9BRUssR0FGS3A0QixNQUFNLFdBQVN1UyxNQUFULFdBQU4sQ0FBOEJqYyxNQUVuQztBQUFBLFFBRExnaUMsU0FDSyxHQURPanVCLEVBQUUsQ0FBQzZXLE9BQUgsR0FBYTdXLEVBQUUsQ0FBQzZ0QixvQkFBSCxDQUF3QjNsQixNQUF4QixFQUFnQ29GLGdCQUFoQyxDQUFiLEdBQWlFLENBQ3hFO0FBYVgsV0FWQ2lCLE9BVUQsR0FYSXZqQixPQUFPLENBQUMySyxNQUFNLENBQUMwSSxZQUFSLENBV1gsR0FWVzFJLE1BQU0sQ0FBQzBJLFlBVWxCLEdBVFcwSixTQVNYLEdBUllwUyxNQUFNLENBQUM1UCxXQUFSLEdBQ0wwRixJQUFJLENBQUNtWCxHQUFMLENBQVNwWCxNQUFNLENBQUN5aUMsU0FBRCxDQUFmLEVBQTRCLEVBQTVCLENBREssR0FDVCxDQU9GLEdBTlcsQ0FBQ3Q0QixNQUFNLENBQUNqTyxXQUFSLElBQXVCaU8sTUFBTSxDQUFDM04sWUFNekMsR0FMV2dZLEVBQUUsQ0FBQ3hwQixJQUFILENBQVFzMUIscUJBQVIsR0FBZ0NSLE9BQWhDLEdBQTBDLEVBQTFDLEdBQStDLENBSzFELEdBSFc5ZixNQUFNLENBQUN5aUMsU0FBRCxDQUdqQixFQUFPMWYsT0FBTyxHQUFJMGYsU0FBUyxHQUFHRixPQUE5QjtBQUNBLEdBL0ZhO0FBaUdkakcsd0JBakdjLG9DQWlHVztBQU9wQixRQUFBdlosT0FBTztBQUFBLFFBTkx2TyxFQU1LLEdBTkEsSUFNQTtBQUFBLFFBTEpySyxNQUtJLEdBTE1xSyxFQUtOLENBTEpySyxNQUtJO0FBQUEsUUFITHU0QixrQkFHSyxHQUhnQmx1QixFQUFFLENBQUM5akIsS0FBSCxDQUFTZ0IsYUFBVCxHQUF5QjhpQixFQUFFLENBQUNzb0IsY0FBSCxLQUFzQixFQUEvQyxHQUFvRCxDQUdwRTtBQUFBLFFBRkx5RixPQUVLLEdBRktwNEIsTUFBTSxDQUFDdEwsWUFBUCxDQUFvQjRCLE1BRXpCO0FBQUEsUUFETGdpQyxTQUNLLEdBRE9qdUIsRUFBRSxDQUFDNnRCLG9CQUFILENBQXdCLElBQXhCLENBQ1A7QUFhWCxXQVZDdGYsT0FVRCxHQVhJdmpCLE9BQU8sQ0FBQzJLLE1BQU0sQ0FBQzJJLGFBQVIsQ0FXWCxHQVZXM0ksTUFBTSxDQUFDMkksYUFBUCxHQUF1QixDQVVsQyxHQVRXMEIsRUFBRSxDQUFDeHBCLElBQUgsSUFBV21mLE1BQU0sQ0FBQ2MsWUFTN0IsR0FqQnVCLEVBU1osR0FBaUJ5M0Isa0JBUTVCLEdBUFdsdUIsRUFBRSxDQUFDeHBCLElBQUgsS0FBWSxDQUFDbWYsTUFBTSxDQUFDMU0sWUFBUixJQUF3QjBNLE1BQU0sQ0FBQ3JNLGFBQTNDLENBT1gsR0FOVyxJQUFJNGtDLGtCQUFKLElBQ1JsdUIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXUxQixzQkFBUixHQUFpQ1QsT0FBakMsR0FBMkMsRUFBM0MsR0FBZ0QsQ0FEeEMsQ0FNWCxHQUhXOWYsTUFBTSxDQUFDeWlDLFNBQUQsQ0FBTixHQUFvQkMsa0JBRy9CLEVBQU8zZixPQUFPLEdBQUkwZixTQUFTLEdBQUdGLE9BQTlCO0FBQ0EsR0F0SGE7O0FBd0hkOzs7OztBQUtBSSxvQkE3SGMsOEJBNkhLcGhDLEdBN0hMLEVBNkhVO0FBQUEsYUFHbkI5QixDQUhtQixFQUNqQm1qQyxVQUFVLGNBQVkzOUIsVUFBVSxDQUFDMUQsR0FBRCxDQURmLEVBRW5Cc2hDLE1BQU0sR0FBRyxLQUFLai9CLEdBQUwsQ0FBU2hZLEtBQVQsQ0FBZTJXLElBQWYsRUFGVSxFQUtoQixDQUFDOUMsQ0FBRCxJQUFNb2pDLE1BQU4sSUFBZ0JBLE1BQU0sQ0FBQ0MsT0FBUCxLQUFtQixNQUxuQixHQUsyQjtBQUNqRCxVQUFJO0FBQ0hyakMsU0FBQyxHQUFHb2pDLE1BQU0sQ0FBQ3QvQixxQkFBUCxHQUErQmhDLEdBQS9CLENBREQ7QUFFSCxPQUZELENBRUUsT0FBT3FFLENBQVAsRUFBVTtBQUNQZzlCLGtCQUFVLElBQUlDLE1BRFAsS0FJVnBqQyxDQUFDLEdBQUdvakMsTUFBTSxDQUFDRCxVQUFELENBSkE7QUFNWDs7QUFFREMsWUFBTSxHQUFHQSxNQUFNLENBQUNsTSxVQVhpQztBQVlqRDs7QUFFRCxRQUFJcDFCLEdBQUcsS0FBSyxPQUFaLEVBQXFCO0FBQ3BCO0FBQ0E7QUFDQSxVQUFNd2hDLFNBQVMsR0FBR3hqQyxXQUFRLENBQUM2MkIsSUFBVCxDQUFjNE0sV0FBaEM7QUFFQXZqQyxPQUFDLEdBQUdzakMsU0FBSixLQUFrQnRqQyxDQUFDLEdBQUdzakMsU0FBdEIsQ0FMb0I7QUFNcEI7O0FBRUQsV0FBT3RqQyxDQUFQO0FBQ0EsR0F6SmE7QUEySmR5aUMsZ0JBM0pjLDRCQTJKRztBQUNoQixXQUFPLEtBQUtTLGtCQUFMLENBQXdCLE9BQXhCLENBQVA7QUFDQSxHQTdKYTtBQStKZFIsaUJBL0pjLDZCQStKSTtBQUNqQixRQUFNN3NCLENBQUMsR0FBRyxLQUFLMVIsR0FBTCxDQUFTaFksS0FBVCxDQUFlMnRCLEtBQWYsQ0FBcUIsUUFBckIsQ0FBVjtBQUVBLFdBQU9qRSxDQUFDLENBQUM1UyxPQUFGLENBQVUsSUFBVixJQUFrQixDQUFsQixHQUFzQnVnQyxRQUFRLENBQUMzdEIsQ0FBRCxFQUFJLEVBQUosQ0FBOUIsR0FBd0MsQ0FBL0M7QUFDQSxHQW5LYTtBQXFLZDR0QixZQXJLYyxzQkFxS0hwaEIsZ0JBcktHLEVBcUtlO0FBQ3RCLFFBQUF0TixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBQUEsUUFFQXUvQixlQUZBLEdBRWtCaDVCLE1BQU0sQ0FBQ2MsWUFBUCxJQUF3QixDQUFDZCxNQUFNLENBQUNjLFlBQVIsSUFBd0IsQ0FBQ2QsTUFBTSxDQUFDM04sWUFGMUU7QUFBQSxRQUdBNG1DLGFBSEEsR0FHZ0JqNUIsTUFBTSxDQUFDYyxZQUFQLEdBQXNCOUcsY0FBSyxDQUFDbFosS0FBNUIsR0FBb0NrWixjQUFLLENBQUNoWixLQUgxRDtBQUFBLFFBSUFrNEMsUUFKQSxHQUlXei9CLEdBQUcsQ0FBQ0csSUFBSixDQUFTRyxNQUFULE9BQW9Cay9CLGFBQXBCLEVBQXFDN2dDLElBQXJDLEVBSlg7QUFBQSxRQUtBK2dDLE9BTEEsR0FLVUQsUUFBUSxJQUFJRixlQUFaLEdBQThCRSxRQUFRLENBQUM5L0IscUJBQVQsRUFBOUIsR0FBaUU7QUFBQ3BTLFdBQUssRUFBRTtBQUFSLEtBTDNFO0FBQUEsUUFNQW95QyxTQU5BLEdBTVkzL0IsR0FBRyxDQUFDaFksS0FBSixDQUFVMlcsSUFBVixHQUFpQmdCLHFCQUFqQixFQU5aO0FBQUEsUUFPQWlnQyxNQVBBLEdBT1NodkIsRUFBRSxDQUFDbVEsVUFBSCxFQVBUO0FBQUEsUUFRQThlLE9BUkEsR0FRVUgsT0FBTyxDQUFDbnlDLEtBQVIsR0FBZ0JveUMsU0FBUyxDQUFDcnlDLElBQTFCLElBQ2RzeUMsTUFBTSxHQUFHLENBQUgsR0FBT2h2QixFQUFFLENBQUM2bkIscUJBQUgsQ0FBeUJ2YSxnQkFBekIsQ0FEQyxDQVJWO0FBV04sV0FBTzJoQixPQUFPLEdBQUcsQ0FBVixHQUFjQSxPQUFkLEdBQXdCLENBQS9CO0FBQ0EsR0FsTGE7QUFvTGRwQixzQkFwTGMsZ0NBb0xPeHZDLEVBcExQLEVBb0xXaXZCLGdCQXBMWCxFQW9MNkI7QUFDMUMsUUFBTXROLEVBQUUsR0FBRyxJQUFYOztBQUVBLFFBQUlBLEVBQUUsQ0FBQ3hwQixJQUFQLEVBQWE7QUFDWixVQUFNMjBCLFFBQVEsR0FBR25MLEVBQUUsQ0FBQ3hwQixJQUFILElBQVd3cEIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXcxQixvQkFBUixDQUE2QjN0QixFQUE3QixDQUE1QjtBQUVBLGFBQU8yaEIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXcyQixlQUFSLENBQXdCM3VCLEVBQXhCLEVBQTRCaXZCLGdCQUE1QixLQUNMbkMsUUFBUSxDQUFDRSxPQUFULEdBQW1CLEVBQW5CLEdBQXdCLEVBRG5CLENBQVA7QUFFQTs7QUFDQSxXQUFPLEVBQVA7QUFFRCxHQS9MYTtBQWlNZHlpQix5QkFqTWMsbUNBaU1VenZDLEVBak1WLEVBaU1jO0FBQ3JCLFFBQUEyaEIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLG9CQUVpRHFLLEVBQUUsQ0FBQzlqQixLQUZwRDtBQUFBLFFBRUM4QixjQUZELGFBRUNBLGNBRkQ7QUFBQSxRQUVpQmQsYUFGakIsYUFFaUJBLGFBRmpCO0FBQUEsUUFFZ0NDLGFBRmhDLGFBRWdDQSxhQUZoQztBQUFBLFFBR0E0cUIsU0FIQSxHQUdZcFMsTUFBTSxDQUFDYyxZQUhuQjtBQUFBLFFBSUZxSyxDQUpFLEdBSUUsRUFKRjtBQU1OLFFBQUl6aUIsRUFBRSxLQUFLLEdBQVAsSUFBYyxDQUFDc1gsTUFBTSxDQUFDNVAsV0FBMUIsRUFDQyxPQUFPLENBQVA7QUFHRCxRQUFJMUgsRUFBRSxLQUFLLEdBQVAsSUFBY3NYLE1BQU0sQ0FBQ3RPLGFBQXpCLEVBQ0MsT0FBT3NPLE1BQU0sQ0FBQ3RPLGFBQWQ7QUFHRCxRQUFJaEosRUFBRSxLQUFLLEdBQVAsSUFBYyxDQUFDc1gsTUFBTSxDQUFDak8sV0FBMUIsRUFDQyxPQUFPLENBQUFpTyxNQUFNLENBQUN0VCxXQUFQLElBQ0xuRixhQURLLElBRUxDLGFBRkssR0FFZ0IsQ0FGaEIsR0FFVyxFQUZsQjtBQUtELFFBQUlrQixFQUFFLEtBQUssSUFBUCxJQUFlLENBQUNzWCxNQUFNLENBQUMxTSxZQUEzQixFQUNDLE9BQU9qTCxjQUFjLENBQUN4QixHQUF0QjtBQUdELFFBQU1pbkIsTUFBTSxHQUFHOU4sTUFBTSxXQUFTdFgsRUFBVCxrQkFBckIsQ0F6QjJCLENBMkIzQjs7QUFTQSxXQVBDLENBQUVBLEVBQUUsS0FBSyxHQUFQLElBQWMsQ0FBQzBwQixTQUFoQixJQUErQixNQUFNdlgsSUFBTixDQUFXblMsRUFBWCxLQUFrQjBwQixTQUFsRCxLQUFpRXRFLE1BT2xFLEtBTEMzQyxDQUFDLEdBQUcsS0FDSGQsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXcyQixlQUFSLENBQXdCM3VCLEVBQXhCLElBQ0FvTixJQUFJLENBQUN5akMsR0FBTCxDQUFTempDLElBQUksQ0FBQzBQLEVBQUwsSUFBVyxLQUFLc0ksTUFBaEIsSUFBMEIsR0FBbkMsQ0FHRixHQUFPM0MsQ0FBQyxJQUNOZCxFQUFFLENBQUN4cEIsSUFBSCxDQUFRdzFCLG9CQUFSLENBQTZCM3RCLEVBQTdCLEVBQWlDZ3RCLE9BQWpDLEdBQTJDLENBQTNDLEdBQStDLEVBRHpDLENBQUQsSUFFTGh0QixFQUFFLEtBQUssSUFBUCxJQUFnQjBwQixTQUFoQixHQUFrQyxDQUFsQyxHQUE0QixDQUFDLEVBRnhCLENBQVA7QUFHQSxHQXhPYTtBQTBPZG9uQixtQkExT2MsK0JBME9NO0FBQ25CLFdBQU8xakMsSUFBSSxDQUFDbVgsR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLcHNCLElBQUwsQ0FBVW1ILENBQVYsQ0FBWXdwQixZQUFaLEVBQVosQ0FBUDtBQUNBLEdBNU9hO0FBOE9kaW9CLGlCQTlPYywyQkE4T0VDLFdBOU9GLEVBOE9lO0FBQ3RCLFFBQUFydkIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN3QnFLLEVBRHhCLENBQ0NySyxNQUREO0FBQUEsUUFDZW5mLElBRGYsR0FDd0J3cEIsRUFEeEIsQ0FDUzVRLEdBRFQsQ0FDZTVZLElBRGY7QUFhTjtBQVZJd3BCLE1BQUUsQ0FBQzZXLE9BQUgsSUFBYyxDQUFDd1ksV0FKUyxLQUt2QnJ2QixFQUFFLENBQUN4cEIsSUFBSCxDQUFRbUgsQ0FBUixJQUFhZ1ksTUFBTSxDQUFDYyxZQUxHLElBTTFCdUosRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBQVIsQ0FBVW9sQixNQUFWLENBQWlCdnNCLElBQUksQ0FBQ21ILENBQXRCLENBTjBCLEVBTzFCcWlCLEVBQUUsQ0FBQ3hwQixJQUFILENBQVFreEIsSUFBUixJQUFnQjFILEVBQUUsQ0FBQ3hwQixJQUFILENBQVFreEIsSUFBUixDQUFhM0UsTUFBYixDQUFvQnZzQixJQUFJLENBQUNreEIsSUFBekIsQ0FQVSxLQVMxQjFILEVBQUUsQ0FBQ3hwQixJQUFILENBQVFzSCxDQUFSLElBQWFraUIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXNILENBQVIsQ0FBVWlsQixNQUFWLENBQWlCdnNCLElBQUksQ0FBQ3NILENBQXRCLENBVGEsRUFVMUJraUIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXVILEVBQVIsSUFBY2lpQixFQUFFLENBQUN4cEIsSUFBSCxDQUFRdUgsRUFBUixDQUFXZ2xCLE1BQVgsQ0FBa0J2c0IsSUFBSSxDQUFDdUgsRUFBdkIsQ0FWWSxJQWU1QmlpQixFQUFFLENBQUNnbkIsWUFBSCxDQUFnQnFJLFdBQWhCLENBZjRCLEVBZ0I1QnJ2QixFQUFFLENBQUNpbkIsYUFBSCxFQWhCNEIsRUFpQjVCam5CLEVBQUUsQ0FBQ2tuQixZQUFILElBakI0QjtBQWtCNUIsR0FoUWE7QUFrUWRELGVBbFFjLDJCQWtRRTtBQUNULFFBQUFqbkIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDOWpCLEtBREQsR0FDc0I4akIsRUFEdEIsQ0FDQzlqQixLQUREO0FBQUEsUUFDY3F4QixHQURkLEdBQ3NCdk4sRUFEdEIsQ0FDUTVRLEdBRFIsQ0FDY21lLEdBRGQ7O0FBT04sUUFKQUEsR0FBRyxDQUNENWUsSUFERixDQUNPLE9BRFAsRUFDZ0J6UyxLQUFLLENBQUNjLFlBRHRCLEVBRUUyUixJQUZGLENBRU8sUUFGUCxFQUVpQnpTLEtBQUssQ0FBQ2UsYUFGdkIsQ0FJQSxFQUFJK2lCLEVBQUUsQ0FBQzZXLE9BQVAsRUFBZ0I7QUFBQSxVQUNUNS9CLEtBQUssR0FBR3MyQixHQUFHLENBQUM3ZCxNQUFKLE9BQWVDLGNBQUssQ0FBQzFZLEtBQXJCLGVBREM7QUFBQSxVQUVUcTRDLFNBQVMsR0FBRztBQUFDbnpDLGFBQUssRUFBRSxDQUFSO0FBQVdFLGNBQU0sRUFBRTtBQUFuQixPQUZIO0FBSVhwRixXQUFLLENBQUMyRyxJQUFOLEVBSlcsS0FLZDB4QyxTQUFTLENBQUNuekMsS0FBVixHQUFrQixDQUFDbEYsS0FBSyxDQUFDMFgsSUFBTixDQUFXLE9BQVgsQ0FMTCxFQU1kMmdDLFNBQVMsQ0FBQ2p6QyxNQUFWLEdBQW1CLENBQUNwRixLQUFLLENBQUMwWCxJQUFOLENBQVcsUUFBWCxDQU5OLEdBU2Y0ZSxHQUFHLENBQUM5SSxTQUFKLENBQWMsT0FBS3ZvQixLQUFLLENBQUNrQyxJQUFOLENBQVdDLEVBQWhCLFFBQTBCbkMsS0FBSyxDQUFDa0MsSUFBTixDQUFXSSxNQUFyQyxDQUFkLEVBQ0VrUixNQURGLENBQ1MsTUFEVCxFQUVFZixJQUZGLENBRU8sT0FGUCxFQUVnQnpTLEtBQUssQ0FBQ0MsS0FGdEIsRUFHRXdTLElBSEYsQ0FHTyxRQUhQLEVBR2lCelMsS0FBSyxDQUFDRyxNQUh2QixDQVRlLEVBY2ZreEIsR0FBRyxDQUFDN2QsTUFBSixPQUFleFQsS0FBSyxDQUFDa0MsSUFBTixDQUFXRSxPQUExQixFQUNFb1IsTUFERixDQUNTLE1BRFQsRUFFRWYsSUFGRixDQUVPLEdBRlAsRUFFWXFSLEVBQUUsQ0FBQ3V2QixhQUFILENBQWlCcHNCLElBQWpCLENBQXNCbkQsRUFBdEIsQ0FGWixFQUdFclIsSUFIRixDQUdPLEdBSFAsRUFHWXFSLEVBQUUsQ0FBQ3d2QixhQUFILENBQWlCcnNCLElBQWpCLENBQXNCbkQsRUFBdEIsQ0FIWixFQUlFclIsSUFKRixDQUlPLE9BSlAsRUFJZ0JxUixFQUFFLENBQUN5dkIsaUJBQUgsQ0FBcUJ0c0IsSUFBckIsQ0FBMEJuRCxFQUExQixDQUpoQixFQUtFclIsSUFMRixDQUtPLFFBTFAsRUFLaUJxUixFQUFFLENBQUMwdkIsa0JBQUgsQ0FBc0J2c0IsSUFBdEIsQ0FBMkJuRCxFQUEzQixDQUxqQixDQWRlLEVBcUJmdU4sR0FBRyxDQUFDN2QsTUFBSixPQUFleFQsS0FBSyxDQUFDa0MsSUFBTixDQUFXRyxPQUExQixFQUNFbVIsTUFERixDQUNTLE1BRFQsRUFFRWYsSUFGRixDQUVPLEdBRlAsRUFFWXFSLEVBQUUsQ0FBQzJ2QixhQUFILENBQWlCeHNCLElBQWpCLENBQXNCbkQsRUFBdEIsQ0FGWixFQUdFclIsSUFIRixDQUdPLEdBSFAsRUFHWXFSLEVBQUUsQ0FBQzR2QixhQUFILENBQWlCenNCLElBQWpCLENBQXNCbkQsRUFBdEIsQ0FIWixFQUlFclIsSUFKRixDQUlPLE9BSlAsRUFJZ0JxUixFQUFFLENBQUM2dkIsaUJBQUgsQ0FBcUIxc0IsSUFBckIsQ0FBMEJuRCxFQUExQixDQUpoQixFQUtFclIsSUFMRixDQUtPLFFBTFAsRUFLaUJxUixFQUFFLENBQUM4dkIsa0JBQUgsQ0FBc0Izc0IsSUFBdEIsQ0FBMkJuRCxFQUEzQixDQUxqQixDQXJCZSxFQTRCZjlqQixLQUFLLENBQUNrQyxJQUFOLENBQVdLLFVBQVgsSUFBeUI4dUIsR0FBRyxDQUFDN2QsTUFBSixPQUFleFQsS0FBSyxDQUFDa0MsSUFBTixDQUFXSyxVQUExQixFQUN2QmlSLE1BRHVCLENBQ2hCLE1BRGdCLEVBRXZCZixJQUZ1QixDQUVsQixPQUZrQixFQUVUelMsS0FBSyxDQUFDQyxLQUZHLEVBR3ZCd1MsSUFIdUIsQ0FHbEIsUUFIa0IsRUFHUjJnQyxTQUFTLENBQUNqekMsTUFIRixDQTVCVixFQWlDZmt4QixHQUFHLENBQUM3ZCxNQUFKLE9BQWVDLGNBQUssQ0FBQzlULFFBQXJCLEVBQ0U4UyxJQURGLENBQ08sT0FEUCxFQUNnQnpTLEtBQUssQ0FBQ0MsS0FEdEIsRUFFRXdTLElBRkYsQ0FFTyxRQUZQLEVBRWlCelMsS0FBSyxDQUFDRyxNQUZ2QixDQWpDZTtBQW9DZjtBQUNELEdBL1NhOztBQWlUZDs7Ozs7QUFLQTB6QyxhQXRUYyx1QkFzVEYxZ0IsTUF0VEUsRUFzVE07QUFDYixRQUFBclAsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNpQ3FLLEVBRGpDLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDaUM4akIsRUFEakMsQ0FDUzlqQixLQURUO0FBQUEsUUFDc0JraEIsTUFEdEIsR0FDaUM0QyxFQURqQyxDQUNnQjVRLEdBRGhCLENBQ3NCZ08sTUFEdEI7QUFBQSxRQUVBMkssU0FGQSxHQUVZcFMsTUFBTSxDQUFDYyxZQUZuQjtBQUFBLFFBR0F1NEIsTUFIQSxHQUdTaHZCLEVBQUUsQ0FBQ21RLFVBQUgsRUFIVDtBQUFBLFFBS0E2ZixVQUxBLEdBS2E7QUFDbEI3ekMsV0FBSyxFQUFFaWhCLE1BQU0sR0FBRzRDLEVBQUUsQ0FBQ3NvQixjQUFILEVBQUgsR0FBeUIsQ0FEcEI7QUFFbEJqc0MsWUFBTSxFQUFFK2dCLE1BQU0sR0FBRzRDLEVBQUUsQ0FBQ3VvQixlQUFILEVBQUgsR0FBMEI7QUFGdEIsS0FMYjtBQUFBLFFBVUEwSCxxQkFWQSxHQVV3Qi96QyxLQUFLLENBQUNnQixhQUFOLElBQXVCaEIsS0FBSyxDQUFDaUIsYUFBN0IsR0FBNkMsQ0FBN0MsR0FBaUQ2eUMsVUFBVSxDQUFDM3pDLE1BVnBGO0FBQUEsUUFXQTZ6QyxXQVhBLEdBV2Nub0IsU0FBUyxJQUFJaW5CLE1BQWIsR0FBc0IsQ0FBdEIsR0FBMEJodkIsRUFBRSxDQUFDOHRCLHVCQUFILENBQTJCLEdBQTNCLENBWHhDO0FBQUEsUUFhQXFDLG1CQWJBLEdBYXNCeDZCLE1BQU0sQ0FBQ29DLG9CQUFQLElBQStCcEMsTUFBTSxDQUFDc0MsOEJBQXRDLEdBQzNCaTRCLFdBRDJCLEdBQ2IsRUFkVDtBQUFBLFFBZUFFLGNBZkEsR0FlaUJ6NkIsTUFBTSxDQUFDa0MsYUFBUCxJQUF3QixDQUFDbTNCLE1BQXpCLEdBQ3JCcjVCLE1BQU0sQ0FBQ21DLG9CQUFQLEdBQThCcTRCLG1CQURULEdBQ2dDLENBaEJqRDtBQW9CTjtBQWFBO0FBYUE7QUFtQ0E7QUEvREM5Z0IsVUFBRCxJQUFXclAsRUFBRSxDQUFDdXRCLGdCQUFILEVBbkJRLEVBc0JuQnJ4QyxLQUFLLENBQUNLLE1BQU4sR0FBZXdyQixTQUFTLEdBQUc7QUFDMUJ2ckIsU0FBRyxFQUFFd2pCLEVBQUUsQ0FBQzh0Qix1QkFBSCxDQUEyQixJQUEzQixJQUFtQzl0QixFQUFFLENBQUMybkIsb0JBQUgsRUFEZDtBQUUxQmhyQyxXQUFLLEVBQUVxeUMsTUFBTSxHQUFHLENBQUgsR0FBT2h2QixFQUFFLENBQUM4bkIsc0JBQUgsRUFGTTtBQUcxQnJyQyxZQUFNLEVBQUV1akIsRUFBRSxDQUFDOHRCLHVCQUFILENBQTJCLEdBQTNCLElBQWtDbUMscUJBQWxDLEdBQTBEandCLEVBQUUsQ0FBQzRuQix1QkFBSCxFQUh4QztBQUkxQmxyQyxVQUFJLEVBQUUwekMsY0FBYyxJQUFJcEIsTUFBTSxHQUFHLENBQUgsR0FBT2h2QixFQUFFLENBQUM2bkIscUJBQUgsRUFBakI7QUFKTSxLQUFILEdBS3BCO0FBQ0hyckMsU0FBRyxFQUFFLElBQUl3akIsRUFBRSxDQUFDMm5CLG9CQUFILEVBRE47QUFDaUM7QUFDcENockMsV0FBSyxFQUFFcXlDLE1BQU0sR0FBRyxDQUFILEdBQU9odkIsRUFBRSxDQUFDOG5CLHNCQUFILEVBRmpCO0FBR0hyckMsWUFBTSxFQUFFeXpDLFdBQVcsR0FBR0UsY0FBZCxHQUErQkgscUJBQS9CLEdBQXVEandCLEVBQUUsQ0FBQzRuQix1QkFBSCxFQUg1RDtBQUlIbHJDLFVBQUksRUFBRXN5QyxNQUFNLEdBQUcsQ0FBSCxHQUFPaHZCLEVBQUUsQ0FBQzZuQixxQkFBSDtBQUpoQixLQTNCZSxFQW1DbkIzckMsS0FBSyxDQUFDVSxPQUFOLEdBQWdCbXJCLFNBQVMsR0FBRztBQUMzQnZyQixTQUFHLEVBQUVOLEtBQUssQ0FBQ0ssTUFBTixDQUFhQyxHQURTO0FBRTNCRyxXQUFLLEVBQUVvckMsR0FGb0I7QUFHM0J0ckMsWUFBTSxFQUFFLEtBQUt3ekMscUJBSGM7QUFJM0J2ekMsVUFBSSxFQUFFc2pCLEVBQUUsQ0FBQzlqQixLQUFILENBQVM4QixjQUFULENBQXdCdEI7QUFKSCxLQUFILEdBS3JCO0FBQ0hGLFNBQUcsRUFBRU4sS0FBSyxDQUFDZSxhQUFOLEdBQXNCbXpDLGNBQXRCLEdBQXVDSCxxQkFEekM7QUFFSHR6QyxXQUFLLEVBQUVvckMsR0FGSjtBQUdIdHJDLFlBQU0sRUFBRTB6QyxtQkFBbUIsR0FBR0YscUJBSDNCO0FBSUh2ekMsVUFBSSxFQUFFUixLQUFLLENBQUNLLE1BQU4sQ0FBYUc7QUFKaEIsS0F4Q2UsRUFnRG5CUixLQUFLLENBQUNXLE9BQU4sR0FBZ0I7QUFDZkwsU0FBRyxFQUFFLENBRFU7QUFFZkcsV0FBSyxFQUFFb3JDLEdBRlE7QUFHZnRyQyxZQUFNLEVBQUUsQ0FITztBQUlmQyxVQUFJLEVBQUU7QUFKUyxLQWhERyxFQXVEbkJzakIsRUFBRSxDQUFDeW5CLG1CQUFILElBQTBCem5CLEVBQUUsQ0FBQ3luQixtQkFBSCxDQUF1QnVJLFVBQXZCLENBdkRQLEVBeURuQjl6QyxLQUFLLENBQUNDLEtBQU4sR0FBY0QsS0FBSyxDQUFDYyxZQUFOLEdBQXFCZCxLQUFLLENBQUNLLE1BQU4sQ0FBYUcsSUFBbEMsR0FBeUNSLEtBQUssQ0FBQ0ssTUFBTixDQUFhSSxLQXpEakQsRUEwRG5CVCxLQUFLLENBQUNHLE1BQU4sR0FBZUgsS0FBSyxDQUFDZSxhQUFOLEdBQXNCZixLQUFLLENBQUNLLE1BQU4sQ0FBYUMsR0FBbkMsR0FBeUNOLEtBQUssQ0FBQ0ssTUFBTixDQUFhRSxNQTFEbEQsRUE0RGZQLEtBQUssQ0FBQ0MsS0FBTixHQUFjLENBNURDLEtBNkRsQkQsS0FBSyxDQUFDQyxLQUFOLEdBQWMsQ0E3REksR0FnRWZELEtBQUssQ0FBQ0csTUFBTixHQUFlLENBaEVBLEtBaUVsQkgsS0FBSyxDQUFDRyxNQUFOLEdBQWUsQ0FqRUcsR0FvRW5CSCxLQUFLLENBQUNFLE1BQU4sR0FBZTJyQixTQUFTLEdBQ3ZCN3JCLEtBQUssQ0FBQ0ssTUFBTixDQUFhRyxJQUFiLEdBQW9CUixLQUFLLENBQUM4QixjQUFOLENBQXFCdEIsSUFBekMsR0FBZ0RSLEtBQUssQ0FBQzhCLGNBQU4sQ0FBcUJyQixLQUQ5QyxHQUNzRFQsS0FBSyxDQUFDQyxLQXJFakUsRUF1RW5CRCxLQUFLLENBQUNJLE9BQU4sR0FBZ0J5ckIsU0FBUyxHQUN4QjdyQixLQUFLLENBQUNHLE1BRGtCLEdBQ1RILEtBQUssQ0FBQ2UsYUFBTixHQUFzQmYsS0FBSyxDQUFDVSxPQUFOLENBQWNKLEdBQXBDLEdBQTBDTixLQUFLLENBQUNVLE9BQU4sQ0FBY0gsTUF4RXJELEVBMEVmUCxLQUFLLENBQUNFLE1BQU4sR0FBZSxDQTFFQSxLQTJFbEJGLEtBQUssQ0FBQ0UsTUFBTixHQUFlLENBM0VHLEdBOEVmRixLQUFLLENBQUNJLE9BQU4sR0FBZ0IsQ0E5RUQsS0ErRWxCSixLQUFLLENBQUNJLE9BQU4sR0FBZ0IsQ0EvRUUsR0FtRm5CSixLQUFLLENBQUNZLFFBQU4sR0FBaUJaLEtBQUssQ0FBQ0MsS0FBTixJQUFlRCxLQUFLLENBQUNnQixhQUFOLEdBQXNCOHlDLFVBQVUsQ0FBQzd6QyxLQUFYLEdBQW1CLEVBQXpDLEdBQThDLENBQTdELENBbkZFLEVBb0ZuQkQsS0FBSyxDQUFDYSxTQUFOLEdBQWtCYixLQUFLLENBQUNHLE1BQU4sSUFBZ0JILEtBQUssQ0FBQ2dCLGFBQU4sR0FBc0IsQ0FBdEIsR0FBMEIsRUFBMUMsQ0FwRkMsRUFzRmY4aUIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsS0FBdUIsQ0FBQ3ZnQixNQUFNLENBQUNnRixnQkF0RmhCLEtBdUZsQnplLEtBQUssQ0FBQ2EsU0FBTixJQUFtQmIsS0FBSyxDQUFDRyxNQUFOLEdBQWUyakIsRUFBRSxDQUFDcXdCLG1CQUFILEVBdkZoQixHQTBGbkJyd0IsRUFBRSxDQUFDc3dCLFlBQUgsSUFBbUJ0d0IsRUFBRSxDQUFDc3dCLFlBQUgsRUExRkEsRUE0RmZwMEMsS0FBSyxDQUFDZ0IsYUFBTixJQUF1Qjh4QyxNQTVGUixLQTZGbEI5eUMsS0FBSyxDQUFDVyxPQUFOLENBQWNILElBQWQsR0FBcUJSLEtBQUssQ0FBQ1ksUUFBTixHQUFpQixDQUFqQixHQUFxQlosS0FBSyxDQUFDOEQsY0FBTixHQUF1QixHQTdGL0M7QUErRm5CO0FBclphLENBQWYsRTs7QUNSQTs7OztBQUlBO0FBSUE7QUFDQTtBQUVlO0FBQ2R1d0MsZ0JBRGMsNEJBQ0c7QUFDaEIsV0FBTyxLQUFLcFcsWUFBTCxLQUFzQixHQUF0QixHQUE0QixHQUFuQztBQUNBLEdBSGE7O0FBS2Q7Ozs7QUFJQXFXLFVBVGMsc0JBU0g7QUFBQSxRQUNIcGhDLEdBREcsR0FDSSxJQURKLENBQ0hBLEdBREc7QUFHVkEsT0FBRyxDQUFDRyxJQUFKLENBQVNHLE1BQVQsT0FBb0JDLGNBQUssQ0FBQ3ZZLEtBQTFCLEVBQW1Dc1gsTUFBbkMsQ0FBMEMsR0FBMUMsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JnQixjQUFLLENBQUN0WCxVQUR0QixDQUhVO0FBS1YsR0FkYTs7QUFnQmQ7Ozs7O0FBS0FvNEMsc0JBckJjLGdDQXFCTzV3QixPQXJCUCxFQXFCZ0I7QUFBQSxRQUN2QkcsRUFBRSxHQUFHLElBRGtCO0FBQUEsUUFFdkI2Z0IsY0FBYyxHQUFHN2dCLEVBQUUsQ0FBQzZnQixjQUFILENBQWtCMWQsSUFBbEIsQ0FBdUJuRCxFQUF2QixDQUZNO0FBQUEsUUFHdkJxZixVQUFVLEdBQUdyZixFQUFFLENBQUNxZixVQUFILENBQWNsYyxJQUFkLENBQW1CbkQsRUFBbkIsQ0FIVTtBQUFBLFFBSXZCMGdCLFVBQVUsR0FBRzFnQixFQUFFLENBQUMwZ0IsVUFBSCxDQUFjdmQsSUFBZCxDQUFtQm5ELEVBQW5CLENBSlU7QUFBQSxRQUt2QjB3QixjQUFjLEdBQUcxd0IsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlHLE1BQVosT0FBdUJDLGNBQUssQ0FBQ3RYLFVBQTdCLEVBQTJDb3NCLFNBQTNDLE9BQXlEOVUsY0FBSyxDQUFDdlgsU0FBL0QsRUFDckIrWixJQURxQixDQUNoQjBOLE9BRGdCLEVBRXJCbFIsSUFGcUIsQ0FFaEIsT0FGZ0IsRUFFUCxVQUFBN0MsQ0FBQztBQUFBLGFBQUkrMEIsY0FBYyxDQUFDLzBCLENBQUQsQ0FBZCxHQUFvQjQwQixVQUFVLENBQUM1MEIsQ0FBRCxDQUFsQztBQUFBLEtBRk0sQ0FMTTtBQUFBLFFBU3ZCNmtDLGFBQWEsR0FBR0QsY0FBYyxDQUFDaHNCLEtBQWYsR0FBdUJoVyxNQUF2QixDQUE4QixHQUE5QixFQUNwQnFXLEtBRG9CLENBQ2QsU0FEYyxFQUNILEdBREcsRUFFcEJwVyxJQUZvQixDQUVmLE9BRmUsRUFFTmt5QixjQUZNLEVBR3BCOWIsS0FIb0IsQ0FHZCxnQkFIYyxFQUdJLE1BSEosQ0FUTztBQWM3QjRyQixpQkFBYSxDQUFDamlDLE1BQWQsQ0FBcUIsR0FBckIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0Iwd0IsVUFEaEIsQ0FkNkI7QUFnQjdCLEdBckNhOztBQXVDZDs7Ozs7QUFLQXVSLFlBNUNjLHNCQTRDSEMsZUE1Q0csRUE0Q2M7QUFBQTtBQUFBLFFBQ3JCN3dCLEVBRHFCLEdBQ2hCLElBRGdCO0FBQUEsUUFFcEJySyxNQUZvQixHQUVMcUssRUFGSyxDQUVwQnJLLE1BRm9CO0FBQUEsUUFFWnZHLEdBRlksR0FFTDRRLEVBRkssQ0FFWjVRLEdBRlk7QUFBQSxRQUdyQjBoQyxNQUhxQixHQUdaOXdCLEVBQUUsQ0FBQyt3QixZQUFILENBQWdCNXRCLElBQWhCLENBQXFCbkQsRUFBckIsQ0FIWTtBQUFBLFFBSXJCb2YsU0FKcUIsR0FJVHBmLEVBQUUsQ0FBQ29mLFNBQUgsQ0FBYWpjLElBQWIsQ0FBa0JuRCxFQUFsQixDQUpTOztBQU0zQjVRLE9BQUcsQ0FBQ3hVLElBQUosR0FBV3dVLEdBQUcsQ0FBQ0csSUFBSixDQUFTa1YsU0FBVCxPQUF1QjlVLGNBQUssQ0FBQzlVLEtBQTdCLEVBQXNDNHBCLFNBQXRDLE9BQW9EOVUsY0FBSyxDQUFDL1UsSUFBMUQsRUFDVHVYLElBRFMsQ0FDSixVQUFBckcsQ0FBQztBQUFBLGFBQUssS0FBSSxDQUFDa2xDLFdBQUwsQ0FBaUJsbEMsQ0FBakIsSUFBc0JBLENBQUMsQ0FBQ29VLE1BQXhCLEdBQWlDNHdCLE1BQU0sQ0FBQ2hsQyxDQUFELENBQTVDO0FBQUEsS0FERyxDQU5nQixFQVMzQnNELEdBQUcsQ0FBQ3hVLElBQUosQ0FBU3FxQixJQUFULEdBQ0VoRCxVQURGLEdBRUU4TSxRQUZGLENBRVc4aEIsZUFGWCxFQUdFOXJCLEtBSEYsQ0FHUSxjQUhSLEVBR3dCLEdBSHhCLEVBSUVwRixNQUpGLEVBVDJCLEVBZTNCdlEsR0FBRyxDQUFDeFUsSUFBSixHQUFXd1UsR0FBRyxDQUFDeFUsSUFBSixDQUFTOHBCLEtBQVQsR0FDVGhXLE1BRFMsQ0FDRixNQURFLEVBRVRpVyxLQUZTLENBRUgzRSxFQUFFLENBQUM1USxHQUFILENBQU94VSxJQUZKLEVBR1QrVCxJQUhTLENBR0osT0FISSxFQUdLeXdCLFNBSEwsRUFJVHp3QixJQUpTLENBSUosYUFKSSxFQUlXLFVBQUE3QyxDQUFDO0FBQUEsYUFBSzZKLE1BQU0sQ0FBQ2MsWUFBUCxHQUF1QjNLLENBQUMsQ0FBQ3FCLEtBQUYsR0FBVSxDQUFWLEdBQWMsS0FBZCxHQUFzQixPQUE3QyxHQUF3RCxRQUE3RDtBQUFBLEtBSlosRUFLVDRYLEtBTFMsQ0FLSCxNQUxHLEVBS0svRSxFQUFFLENBQUNpeEIsZUFBSCxDQUFtQjl0QixJQUFuQixDQUF3Qm5ELEVBQXhCLENBTEwsRUFNVCtFLEtBTlMsQ0FNSCxjQU5HLEVBTWEsR0FOYixFQU9UbnFCLElBUFMsQ0FPSixVQUFDa1IsQ0FBRCxFQUFJMkMsQ0FBSixFQUFPcWxCLENBQVAsRUFBYTtBQUNsQixVQUFNM21CLEtBQUssR0FBRzZTLEVBQUUsQ0FBQ2dYLGFBQUgsQ0FBaUJsckIsQ0FBakIsSUFBc0JrVSxFQUFFLENBQUNpWCxjQUFILENBQWtCbnJCLENBQUMsQ0FBQ3FCLEtBQXBCLEVBQTJCLEdBQTNCLENBQXRCLEdBQXdEckIsQ0FBQyxDQUFDcUIsS0FBeEU7QUFFQSxhQUFPNlMsRUFBRSxDQUFDdWEsZUFBSCxDQUFtQnp1QixDQUFDLENBQUN6TixFQUFyQixFQUF5QjhPLEtBQXpCLEVBQWdDckIsQ0FBQyxDQUFDek4sRUFBbEMsRUFBc0NvUSxDQUF0QyxFQUF5Q3FsQixDQUF6QyxDQUFQO0FBQ0EsS0FYUyxDQWZnQjtBQTJCM0IsR0F2RWE7QUF5RWRtZCxpQkF6RWMsMkJBeUVFbmxDLENBekVGLEVBeUVLO0FBQUEsUUFHZG9SLEtBSGM7QUFBQSxRQUNaOEMsRUFBRSxHQUFHLElBRE87QUFBQSxRQUVaa3hCLFdBQVcsR0FBR2x4QixFQUFFLENBQUNySyxNQUFILENBQVV4USxrQkFGWjtBQVdsQixXQU5JZ0csUUFBUSxDQUFDK2xDLFdBQUQsQ0FNWixHQUxDaDBCLEtBQUssR0FBR2cwQixXQUtULEdBSld4a0MsUUFBUSxDQUFDd2tDLFdBQUQsQ0FJbkIsS0FIQ2gwQixLQUFLLEdBQUdnMEIsV0FBVyxDQUFDcGxDLENBQUMsQ0FBQ3pOLEVBQUgsQ0FHcEIsR0FBTzZlLEtBQUssSUFBSThDLEVBQUUsQ0FBQzlDLEtBQUgsQ0FBU3BSLENBQVQsQ0FBaEI7QUFDQSxHQXJGYTs7QUF1RmQ7Ozs7Ozs7O0FBUUFxbEMsWUEvRmMsc0JBK0ZIeHpDLENBL0ZHLEVBK0ZBRyxDQS9GQSxFQStGR3N6QyxPQS9GSCxFQStGWXBqQixjQS9GWixFQStGNEI7QUFBQSxRQUNuQ2hPLEVBQUUsR0FBRyxJQUQ4QjtBQUFBLFFBRW5Dd0gsQ0FBQyxHQUFHelgsU0FBUyxFQUZzQjtBQUFBLFFBR25Dd2dDLGNBQWMsR0FBR2EsT0FBTyxHQUFHLENBQUgsR0FBT3B4QixFQUFFLENBQUN1d0IsY0FBSCxDQUFrQnB0QixJQUFsQixDQUF1Qm5ELEVBQXZCLENBSEk7QUFLekMsV0FBTyxDQUNOQSxFQUFFLENBQUM1USxHQUFILENBQU94VSxJQUFQLENBQVl1cEIsSUFBWixDQUFpQixVQUFTclksQ0FBVCxFQUFZMkMsQ0FBWixFQUFlO0FBQy9CLFVBQU03VCxJQUFJLEdBQUd3cEIsaUdBQVEsQ0FBQyxJQUFELENBQXJCLENBRCtCLENBRy9COztBQUNBLE9BQUM0SixjQUFjLElBQUlwekIsSUFBSSxDQUFDK1QsSUFBTCxDQUFVLEdBQVYsQ0FBbEIsR0FBbUMvVCxJQUFJLENBQUNxbkIsVUFBTCxDQUFnQnVGLENBQWhCLENBQW5DLEdBQXdENXNCLElBQXpELEVBQ0UrVCxJQURGLENBQ08sR0FEUCxFQUNZaFIsQ0FBQyxDQUFDd2xCLElBQUYsQ0FBTyxJQUFQLEVBQWFyWCxDQUFiLEVBQWdCMkMsQ0FBaEIsQ0FEWixFQUVFRSxJQUZGLENBRU8sR0FGUCxFQUVZN1EsQ0FBQyxDQUFDcWxCLElBQUYsQ0FBTyxJQUFQLEVBQWFyWCxDQUFiLEVBQWdCMkMsQ0FBaEIsQ0FGWixFQUdFc1csS0FIRixDQUdRLE1BSFIsRUFHZ0IvRSxFQUFFLENBQUNpeEIsZUFBSCxDQUFtQjl0QixJQUFuQixDQUF3Qm5ELEVBQXhCLENBSGhCLEVBSUUrRSxLQUpGLENBSVEsY0FKUixFQUl3QndyQixjQUp4QixDQUorQjtBQVMvQixLQVRELENBRE0sQ0FBUDtBQVlBLEdBaEhhOztBQWtIZDs7Ozs7OztBQU9BckgsYUF6SGMsdUJBeUhGbUksT0F6SEUsRUF5SE8vbkIsU0F6SFAsRUF5SDBCO0FBQUEsUUFDakN0SixFQUFFLEdBQUcsSUFENEI7QUFBQSxRQUVuQ3N4QixJQUFJLEdBQUlELE9BQU8sQ0FBQ3RqQyxJQUFSLEdBQWVzakMsT0FBTyxDQUFDdGpDLElBQVIsRUFBZixHQUFnQ3NqQyxPQUZMO0FBSWxDLFlBQVE3Z0MsSUFBUixDQUFhOGdDLElBQUksQ0FBQ2hELE9BQWxCLENBSmtDLEtBS3RDZ0QsSUFBSSxHQUFHQSxJQUFJLENBQUNDLGFBQUwsQ0FBbUIsTUFBbkIsQ0FMK0I7QUFBQSxRQVFqQzMyQyxJQUFJLEdBQUcwMkMsSUFBSSxDQUFDRSxXQVJxQjtBQUFBLFFBU2pDcGEsUUFBUSxTQUFPeDhCLElBQUksQ0FBQ2lULE9BQUwsQ0FBYSxLQUFiLEVBQW9CLEdBQXBCLENBVGtCO0FBQUEsUUFVbkNpQyxJQUFJLEdBQUdrUSxFQUFFLENBQUNQLEtBQUgsQ0FBU0csR0FBVCxDQUFhd1gsUUFBYixDQVY0QjtBQTBCdkMsV0FkS3RuQixJQWNMLEtBYkNrUSxFQUFFLENBQUM1USxHQUFILENBQU9tZSxHQUFQLENBQVc3ZSxNQUFYLENBQWtCLE1BQWxCLEVBQ0VxVyxLQURGLENBQ1EsWUFEUixFQUNzQixRQUR0QixFQUVFQSxLQUZGLENBRVEsTUFGUixFQUVnQlgsaUdBQVEsQ0FBQ2t0QixJQUFELENBQVIsQ0FBZXZzQixLQUFmLENBQXFCLE1BQXJCLENBRmhCLEVBR0VnaUIsT0FIRixDQUdVemQsU0FIVixNQUlFMXVCLElBSkYsQ0FJT0EsSUFKUCxFQUtFOFMsSUFMRixDQUtPLFVBQUF6QyxDQUFDLEVBQUk7QUFDVjZFLFVBQUksR0FBR0QsZUFBZSxDQUFDNUUsQ0FBQyxDQUFDOEMsSUFBRixFQUFELENBRFo7QUFFVixLQVBGLEVBUUU0UixNQVJGLEVBYUQsRUFIQ0ssRUFBRSxDQUFDUCxLQUFILENBQVNGLEdBQVQsQ0FBYTZYLFFBQWIsRUFBdUJ0bkIsSUFBdkIsQ0FHRCxHQUFPQSxJQUFQO0FBQ0EsR0FwSmE7O0FBc0pkOzs7Ozs7O0FBT0EyaEMsbUJBN0pjLDZCQTZKSUMsT0E3SkosRUE2SmFDLElBN0piLEVBNkptQjtBQUFBLFFBQzFCM3hCLEVBQUUsR0FBRyxJQURxQjtBQUFBLFFBRTFCdWQsS0FBSyxHQUFHcHhCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZc2xDLE9BQVosQ0FGa0I7QUFBQSxRQUcxQkUsTUFBTSxHQUFHLEVBSGlCO0FBQUEsUUFJMUJDLE1BQU0sR0FBR0YsSUFBSSxHQUFHM3hCLEVBQUUsQ0FBQzh4QixXQUFOLEdBQW9COXhCLEVBQUUsQ0FBQyt4QixXQUpWO0FBWWhDLFdBTkEveEIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsS0FBdUJxSCxLQUFLLENBQUNscUIsSUFBTixDQUFXLE9BQVgsQ0FNdkIsRUFKQWtxQixLQUFLLENBQUNsd0IsT0FBTixDQUFjLFVBQUFwQyxDQUFDLEVBQUk7QUFDbEIybUMsWUFBTSxDQUFDM21DLENBQUQsQ0FBTixHQUFZK1UsRUFBRSxpQkFBZXZQLFVBQVUsQ0FBQ3hGLENBQUQsQ0FBekIsWUFBRixDQUF3Q3ltQyxPQUFPLENBQUN6bUMsQ0FBRCxDQUEvQyxLQURNO0FBRWxCLEtBRkQsQ0FJQSxFQUFPLFVBQVNhLENBQVQsRUFBWTJDLENBQVosRUFBZTtBQUNyQixVQUFNZ0IsSUFBSSxHQUFJdVEsRUFBRSxDQUFDZ3lCLFVBQUgsQ0FBY2xtQyxDQUFkLEtBQW9CLE1BQXJCLElBQ1hrVSxFQUFFLENBQUNrYixTQUFILENBQWFwdkIsQ0FBYixLQUFtQixLQURSLElBRVhrVSxFQUFFLENBQUNneEIsV0FBSCxDQUFlbGxDLENBQWYsS0FBcUIsT0FGVixJQUVzQixNQUZuQztBQUlBLGFBQU8rbEMsTUFBTSxDQUFDbmtDLElBQVAsQ0FBWXNTLEVBQVosRUFBZ0I0eEIsTUFBTSxDQUFDbmlDLElBQUQsQ0FBTixDQUFhM0QsQ0FBYixFQUFnQjJDLENBQWhCLENBQWhCLEVBQW9DM0MsQ0FBcEMsRUFBdUMsSUFBdkMsQ0FBUDtBQUNBLEtBTkQ7QUFPQSxHQWhMYTs7QUFrTGQ7Ozs7Ozs7O0FBUUFtbUMsb0JBMUxjLDhCQTBMS25tQyxDQTFMTCxFQTBMUThsQyxNQTFMUixFQTBMZ0IzSSxXQTFMaEIsRUEwTDZCO0FBQ3BDLFFBQUFqcEIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUFvUyxTQUZBLEdBRVlwUyxNQUFNLENBQUNjLFlBRm5COztBQUlOLFFBQUlkLE1BQU0sQ0FBQ3pRLFdBQVAsQ0FBbUJndEMsUUFBbkIsSUFBK0JseUIsRUFBRSxDQUFDa2IsU0FBSCxDQUFhcHZCLENBQWIsQ0FBbkMsRUFBb0Q7QUFBQSxVQUM3Q2dFLElBQUksR0FBR0QsZUFBZSxDQUFDbzVCLFdBQUQsQ0FEdUI7QUFBQSxVQUU3Q2tKLFVBQVUsR0FBR3JtQyxDQUFDLENBQUNxQixLQUFGLElBQVcsQ0FGcUI7O0FBSW5ELFVBQUk0YSxTQUFKLEVBQWU7QUFDZCxZQUFNbEgsQ0FBQyxHQUFHLENBQ1RzeEIsVUFBVSxHQUNUUCxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixJQUFlQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUROLEdBRVRBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLElBQWVBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLENBSFAsSUFJTixDQUpNLEdBSUQ5aEMsSUFBSSxDQUFDM1QsS0FBTCxHQUFhLENBSnRCO0FBTUEsZUFBT2cyQyxVQUFVLEdBQUcsQ0FBQ3R4QixDQUFELEdBQUssQ0FBUixHQUFZQSxDQUFDLEdBQUcsQ0FBakM7QUFDQTs7QUFDQSxVQUFNQyxDQUFDLEdBQUcsQ0FDVHF4QixVQUFVLEdBQ1RQLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLElBQWVBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLENBRE4sR0FFVEEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsSUFBZUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FIUCxJQUlOLENBSk0sR0FJRDloQyxJQUFJLENBQUN6VCxNQUFMLEdBQWMsQ0FKdkI7QUFNQSxhQUFPODFDLFVBQVUsR0FBR3J4QixDQUFILEdBQU8sQ0FBQ0EsQ0FBRCxHQUFLLENBQTdCO0FBRUQ7O0FBRUQsV0FBTyxDQUFQO0FBQ0EsR0F2TmE7O0FBeU5kOzs7Ozs7O0FBT0FzeEIsWUFoT2Msc0JBZ09IL3pDLEVBaE9HLEVBZ09Db1IsSUFoT0QsRUFnT087QUFDcEIsUUFBTXVXLEdBQUcsR0FBRyxLQUFLclEsTUFBTCxDQUFZdlEsb0JBQXhCO0FBRUEsV0FBTyxDQUFDL0csRUFBRSxJQUFJMm5CLEdBQU4sR0FBWUEsR0FBRyxDQUFDM25CLEVBQUQsQ0FBZixHQUFzQjJuQixHQUF2QixFQUE0QnZXLElBQTVCLEtBQXFDLENBQTVDO0FBQ0EsR0FwT2E7O0FBc09kOzs7Ozs7OztBQVFBcWlDLGFBOU9jLHVCQThPRkYsTUE5T0UsRUE4T005bEMsQ0E5T04sRUE4T1NtOUIsV0E5T1QsRUE4T3NCO0FBSS9CLFFBQUFvSixJQUFJO0FBQUEsUUFDSjlqQixPQURJO0FBQUEsUUFIRnZPLEVBR0UsR0FIRyxJQUdIO0FBQUEsUUFGRHJLLE1BRUMsR0FGZ0JxSyxFQUVoQixDQUZEckssTUFFQztBQUFBLFFBRk96WixLQUVQLEdBRmdCOGpCLEVBRWhCLENBRk85akIsS0FFUDtBQUFBLFFBREY2ckIsU0FDRSxHQURVcFMsTUFBTSxDQUFDYyxZQUNqQjtBQVNSO0FBQ0EsUUFQSXNSLFNBT0osSUFOQ3dHLE9BQU8sR0FBR3ZPLEVBQUUsQ0FBQ2tiLFNBQUgsQ0FBYXB2QixDQUFiLElBQWtCLENBQWxCLEdBQXNCLENBTWpDLEVBTEN1bUMsSUFBSSxHQUFHVCxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixJQUFlcmpCLE9BQU8sSUFBSXppQixDQUFDLENBQUNxQixLQUFGLEdBQVUsQ0FBVixHQUFjLENBQUMsQ0FBZixHQUFtQixDQUF2QixDQUs5QixJQUhDa2xDLElBQUksR0FBR3J5QixFQUFFLENBQUNrVyxPQUFILENBQVcsS0FBWCxJQUFvQixDQUFDMGIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsSUFBZUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FBaEIsSUFBZ0MsQ0FBcEQsR0FBd0RBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLENBR2hFLEVBQUk5bEMsQ0FBQyxDQUFDcUIsS0FBRixLQUFZLElBQWhCLEVBQ0MsSUFBSWtsQyxJQUFJLEdBQUduMkMsS0FBSyxDQUFDQyxLQUFqQixFQUF3QjtBQUFBLDZCQUNQMFQsZUFBZSxDQUFDbzVCLFdBQUQsQ0FEUjtBQUFBLFVBQ2hCOXNDLEtBRGdCLG9CQUNoQkEsS0FEZ0I7O0FBR3ZCazJDLFVBQUksR0FBR24yQyxLQUFLLENBQUNDLEtBQU4sR0FBY0EsS0FIRTtBQUl2QixLQUpELE1BSVdrMkMsSUFBSSxHQUFHLENBSmxCLEtBS0NBLElBQUksR0FBRyxDQUxSO0FBYUQsV0FKSXRxQixTQUlKLEtBSENzcUIsSUFBSSxJQUFJcnlCLEVBQUUsQ0FBQ2l5QixrQkFBSCxDQUFzQm5tQyxDQUF0QixFQUF5QjhsQyxNQUF6QixFQUFpQzNJLFdBQWpDLENBR1QsR0FBT29KLElBQUksR0FBR3J5QixFQUFFLENBQUNveUIsVUFBSCxDQUFjdG1DLENBQUMsQ0FBQ3pOLEVBQWhCLEVBQW9CLEdBQXBCLENBQWQ7QUFDQSxHQTNRYTs7QUE2UWQ7Ozs7Ozs7O0FBUUEwekMsYUFyUmMsdUJBcVJGSCxNQXJSRSxFQXFSTTlsQyxDQXJSTixFQXFSU205QixXQXJSVCxFQXFSc0I7QUFPL0IsUUFBQXFKLElBQUk7QUFBQSxRQU5GdHlCLEVBTUUsR0FORyxJQU1IO0FBQUEsUUFMRHJLLE1BS0MsR0FMZ0JxSyxFQUtoQixDQUxEckssTUFLQztBQUFBLFFBTE96WixLQUtQLEdBTGdCOGpCLEVBS2hCLENBTE85akIsS0FLUDtBQUFBLFFBSkY2ckIsU0FJRSxHQUpVcFMsTUFBTSxDQUFDYyxZQUlqQjtBQUFBLFFBSEY0UCxDQUdFLEdBSEUxUSxNQUFNLENBQUMyQixPQUdUO0FBQUEsUUFGRnhILElBRUUsR0FGS0QsZUFBZSxDQUFDbzVCLFdBQUQsQ0FFcEI7QUFBQSxRQURKc0osS0FDSSxHQURJLENBQ0o7QUFFUixRQUFJeHFCLFNBQUosRUFDQ3VxQixJQUFJLEdBQUcsQ0FBQ1YsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsSUFBZUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FBZixHQUE4QjloQyxJQUFJLENBQUN6VCxNQUFMLEdBQWMsRUFBN0MsSUFBb0QsQ0FENUQsTUFTQyxJQU5BaTJDLElBQUksR0FBR1YsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FNUCxFQUpJeG1DLFFBQVEsQ0FBQ2liLENBQUQsQ0FBUixJQUFlQSxDQUFDLEdBQUcsQ0FBbkIsS0FBeUJyRyxFQUFFLENBQUN3eUIsVUFBSCxDQUFjMW1DLENBQWQsS0FBb0JrVSxFQUFFLENBQUN5eUIsYUFBSCxDQUFpQjNtQyxDQUFqQixDQUE3QyxDQUlKLEtBSEN5bUMsS0FBSyxJQUFJNThCLE1BQU0sQ0FBQzJCLE9BQVAsR0FBaUIsR0FHM0IsR0FBSXhMLENBQUMsQ0FBQ3FCLEtBQUYsR0FBVSxDQUFWLElBQWdCckIsQ0FBQyxDQUFDcUIsS0FBRixLQUFZLENBQVosSUFBaUIsQ0FBQ2pSLEtBQUssQ0FBQ29ELGdCQUF4QixJQUE0Q3BELEtBQUssQ0FBQ21ELGdCQUF0RSxFQUNDaXpDLElBQUksSUFBSXhpQyxJQUFJLENBQUN6VCxNQUFMLElBQWUyakIsRUFBRSxDQUFDa2IsU0FBSCxDQUFhcHZCLENBQWIsSUFBa0IsQ0FBQ3ltQyxLQUFuQixHQUEyQkEsS0FBMUMsQ0FEVCxNQUVPO0FBQ04sVUFBSXBrQyxJQUFJLEdBQUcsQ0FBQ29rQyxLQUFELEdBQVMsQ0FBcEI7QUFFSXZ5QixRQUFFLENBQUNrYixTQUFILENBQWFwdkIsQ0FBYixDQUhFLEdBSUxxQyxJQUFJLEdBQUcsQ0FBQ29rQyxLQUpILEdBS0t2eUIsRUFBRSxDQUFDMHlCLFlBQUgsQ0FBZ0I1bUMsQ0FBaEIsQ0FMTCxLQU1McUMsSUFBSSxHQUFHb2tDLEtBTkYsR0FTTkQsSUFBSSxJQUFJbmtDLElBVEY7QUFVTixLQTlCaUMsQ0FpQ25DOztBQUNBLFFBQUlyQyxDQUFDLENBQUNxQixLQUFGLEtBQVksSUFBWixJQUFvQixDQUFDNGEsU0FBekIsRUFBb0M7QUFDbkMsVUFBTTRxQixTQUFTLEdBQUc3aUMsSUFBSSxDQUFDelQsTUFBdkI7QUFFSWkyQyxVQUFJLEdBQUdLLFNBSHdCLEdBSWxDTCxJQUFJLEdBQUdLLFNBSjJCLEdBS3hCTCxJQUFJLEdBQUcsS0FBS2oyQyxNQUxZLEtBTWxDaTJDLElBQUksR0FBRyxLQUFLajJDLE1BQUwsR0FBYyxDQU5hO0FBUW5DOztBQU1ELFdBSkswckIsU0FJTCxLQUhDdXFCLElBQUksSUFBSXR5QixFQUFFLENBQUNpeUIsa0JBQUgsQ0FBc0JubUMsQ0FBdEIsRUFBeUI4bEMsTUFBekIsRUFBaUMzSSxXQUFqQyxDQUdULEdBQU9xSixJQUFJLEdBQUd0eUIsRUFBRSxDQUFDb3lCLFVBQUgsQ0FBY3RtQyxDQUFDLENBQUN6TixFQUFoQixFQUFvQixHQUFwQixDQUFkO0FBQ0EsR0F0VWE7O0FBd1VkOzs7Ozs7OztBQVFBeXJDLGdCQWhWYywwQkFnVkN6ckMsRUFoVkQsRUFnVksyaEIsRUFoVkwsRUFnVlNrZixRQWhWVCxFQWdWbUI7QUFBQSxRQUMxQjBULFNBQVMsR0FBRzV5QixFQUFFLENBQUM1USxHQUFILENBQU8vWSxJQUFQLENBQVlvdUIsU0FBWixDQUFzQnlhLFFBQXRCLENBRGM7QUFBQSxRQUUxQjJULGlCQUFpQixHQUFHRCxTQUFTLENBQUN0Z0MsTUFBVixDQUFpQixVQUFBdkUsSUFBSTtBQUFBLGFBQUlBLElBQUksQ0FBQ29FLElBQUwsQ0FBVTlULEVBQVYsS0FBaUJBLEVBQXJCO0FBQUEsS0FBckIsQ0FGTTtBQUFBLFFBRzFCeTBDLFFBQVEsR0FBR0YsU0FBUyxDQUFDdGdDLE1BQVYsQ0FBaUIsVUFBQXZFLElBQUk7QUFBQSxhQUFJQSxJQUFJLENBQUNvRSxJQUFMLENBQVU5VCxFQUFWLEtBQWlCQSxFQUFyQjtBQUFBLEtBQXJCLENBSGU7QUFBQSxRQUkxQjAwQyxTQUFTLEdBQUd0aEMsY0FBYyxDQUFDcWhDLFFBQVEsQ0FBQy9rQyxJQUFULEVBQUQsQ0FKQTtBQUFBLFFBTzFCaWxDLFFBQVEsR0FBRyxVQUFDcjFDLENBQUQsRUFBSUcsQ0FBSjtBQUFBLGFBQVUyTixJQUFJLENBQUNnd0IsSUFBTCxDQUFVaHdCLElBQUksQ0FBQ2l3QixHQUFMLENBQVMvOUIsQ0FBVCxFQUFZLENBQVosSUFBaUI4TixJQUFJLENBQUNpd0IsR0FBTCxDQUFTNTlCLENBQVQsRUFBWSxDQUFaLENBQTNCLENBQVY7QUFBQSxLQVBlOztBQVNoQ2cxQyxZQUFRLENBQUMva0MsSUFBVCxNQUFtQjhrQyxpQkFBaUIsQ0FBQzF1QixJQUFsQixDQUF1QixZQUFXO0FBQUEsVUFDOUM4dUIsVUFBVSxHQUFHeGhDLGNBQWMsQ0FBQyxJQUFELENBRG1CO0FBQUEsVUFFOUN5aEMsZ0JBQWdCLEdBQUc5dUIsaUdBQVEsQ0FBQyxJQUFELENBRm1CO0FBQUEsVUFHOUMrdUIsWUFBWSxHQUFHSCxRQUFRLENBQUNELFNBQVMsQ0FBQzNoQyxDQUFYLEVBQWMyaEMsU0FBUyxDQUFDOWdDLENBQXhCLENBQVIsR0FBcUMrZ0MsUUFBUSxDQUFDQyxVQUFVLENBQUM3aEMsQ0FBWixFQUFlNmhDLFVBQVUsQ0FBQ2hoQyxDQUExQixDQUE3QyxHQUNwQjZnQyxRQURvQixHQUNUSSxnQkFKd0M7QUFBQSxVQU05Q0UsU0FBUyxHQUFHM25DLElBQUksQ0FBQ0MsSUFBTCxDQUFVRCxJQUFJLENBQUNvdUIsR0FBTCxDQUFTa1osU0FBUyxDQUFDM2hDLENBQVYsR0FBYzZoQyxVQUFVLENBQUM3aEMsQ0FBbEMsQ0FBVixJQUNqQjNGLElBQUksQ0FBQ0MsSUFBTCxDQUFVeW5DLFlBQVksQ0FBQ3BsQyxJQUFiLEdBQW9Cc2xDLHFCQUFwQixFQUFWLENBUG1EO0FBQUEsVUFROUNDLFNBQVMsR0FBRzduQyxJQUFJLENBQUNDLElBQUwsQ0FBVUQsSUFBSSxDQUFDb3VCLEdBQUwsQ0FBU2taLFNBQVMsQ0FBQzlnQyxDQUFWLEdBQWNnaEMsVUFBVSxDQUFDaGhDLENBQWxDLENBQVYsSUFDakJ3OEIsUUFBUSxDQUFDcUUsUUFBUSxDQUFDL3RCLEtBQVQsQ0FBZSxXQUFmLENBQUQsRUFBOEIsQ0FBOUIsQ0FUMkM7QUFXcERtdUIsc0JBQWdCLENBQUNuTSxPQUFqQixDQUF5QnAzQixjQUFLLENBQUMxVCxlQUEvQixFQUFnRG0zQyxTQUFTLElBQUlFLFNBQTdELENBWG9EO0FBWXBELEtBWmtCLENBVGE7QUFzQmhDLEdBdFdhOztBQXdXZDs7Ozs7OztBQU9Bekosb0JBL1djLDhCQStXSzdwQixFQS9XTCxFQStXU2tmLFFBL1dULEVBK1dtQjtBQUNoQ2xmLE1BQUUsQ0FBQzVRLEdBQUgsQ0FBTy9ZLElBQVAsQ0FBWW91QixTQUFaLENBQXNCeWEsUUFBdEIsRUFDRS9hLElBREYsQ0FDTyxZQUFXO0FBQ2hCb3ZCLDBHQUFXLENBQUMsQ0FBQyxJQUFELEVBQU8sS0FBS0MsZUFBWixDQUFELENBQVgsQ0FDRXpNLE9BREYsQ0FDVXAzQixjQUFLLENBQUMxVCxlQURoQixLQURnQjtBQUdoQixLQUpGLENBRGdDO0FBTWhDO0FBclhhLENBQWYsRTs7QUNYQTs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFPQSxTQUFTbTJDLFVBQVQsQ0FBb0Jwc0IsR0FBcEIsRUFBa0M3cEIsS0FBbEMsRUFBa0Q7QUFBOUI2cEIsS0FBOEIsZ0JBQTlCQSxHQUE4QixHQUF4QixNQUF3QjtBQUFBLE1BRTdDbUYsUUFGNkM7QUFBQSxNQUMzQ3NvQixLQUFLLEdBQUdyb0MsUUFBUSxDQUFDalAsS0FBRCxDQUQyQjtBQWFqRCxTQVBDZ3ZCLFFBT0QsR0FUSW5GLEdBQUcsQ0FBQzlYLE9BQUosQ0FBWSxRQUFaLElBQXdCLENBQUMsQ0FTN0IsR0FQWXVsQyxLQUFLLEdBQUd0M0MsS0FBSyxHQUFHLENBQVgsR0FBZSxRQU9oQyxHQU5XNnBCLEdBQUcsQ0FBQzlYLE9BQUosQ0FBWSxPQUFaLElBQXVCLENBQUMsQ0FNbkMsR0FMWXVsQyxLQUFLLEdBQUd0M0MsS0FBSCxHQUFXLEtBSzVCLEdBSFlzM0MsS0FBSyxHQUFHLENBQUgsR0FBTyxPQUd4QixFQUFPdG9CLFFBQVA7QUFDQTs7QUFFYztBQUNkOzs7O0FBSUF1b0IsV0FMYyx1QkFLRjtBQUNMLFFBQUExekIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNnQnFLLEVBRGhCLENBQ0NySyxNQUREO0FBQUEsUUFDU3ZHLEdBRFQsR0FDZ0I0USxFQURoQixDQUNTNVEsR0FEVDs7QUFHTixRQUFJdUcsTUFBTSxDQUFDclMsVUFBWCxFQUF1QjtBQUN0QjhMLFNBQUcsQ0FBQ3RVLEtBQUosR0FBWXNVLEdBQUcsQ0FBQ21lLEdBQUosQ0FBUTdlLE1BQVIsQ0FBZSxHQUFmLENBRFU7QUFHdEIsVUFBTTlULElBQUksR0FBR3dVLEdBQUcsQ0FBQ3RVLEtBQUosQ0FDWDRULE1BRFcsQ0FDSixNQURJLEVBRVhxVyxLQUZXLENBRUwsYUFGSyxFQUVVcXRCLFVBQVUsQ0FBQ3o4QixNQUFNLENBQUNuUyxjQUFSLENBRnBCLEVBR1htTCxJQUhXLENBR04sT0FITSxFQUdHZ0IsY0FBSyxDQUFDN1UsS0FIVCxDQUFiO0FBS0FnVCxrQkFBWSxDQUFDbFQsSUFBRCxFQUFPK2EsTUFBTSxDQUFDclMsVUFBZCxFQUEwQixDQUFDLEVBQUQsRUFBTSxHQUFOLENBQTFCLENBUlU7QUFTdEI7QUFDRCxHQW5CYTs7QUFxQmQ7Ozs7QUFJQXF3QyxhQXpCYyx5QkF5QkE7QUFDUCxRQUFBM3pCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDZ0RxSyxFQURoRCxDQUNDckssTUFERDtBQUFBLFFBQ2lCM1ksWUFEakIsR0FDZ0RnakIsRUFEaEQsQ0FDUzlqQixLQURULENBQ2lCYyxZQURqQjtBQUFBLFFBQ3NDbEMsS0FEdEMsR0FDZ0RrbEIsRUFEaEQsQ0FDZ0M1USxHQURoQyxDQUNzQ3RVLEtBRHRDOztBQUdOLFFBQUlBLEtBQUosRUFBVztBQUNWLFVBQU1nRCxDQUFDLEdBQUdraUIsRUFBRSxDQUFDNHpCLFNBQUgsQ0FBYWxtQyxJQUFiLENBQWtCc1MsRUFBbEIsQ0FBVjtBQUVJLFdBQUt4UCxJQUFMLENBQVUxVixLQUFLLENBQUNpVCxJQUFOLEdBQWF1Z0MsT0FBdkIsQ0FITSxHQUlUeHpDLEtBQUssQ0FBQzZULElBQU4sQ0FBVyxXQUFYLGlCQUFxQ3lqQyxVQUFVLENBQUN6OEIsTUFBTSxDQUFDblMsY0FBUixFQUF3QnhHLFlBQXhCLENBQS9DLFVBQXlGYyxDQUF6RixPQUpTLEdBTVRoRCxLQUFLLENBQUM2VCxJQUFOLENBQVcsR0FBWCxFQUFnQnFSLEVBQUUsQ0FBQzZ6QixTQUFILENBQWFubUMsSUFBYixDQUFrQnNTLEVBQWxCLENBQWhCLEVBQXVDclIsSUFBdkMsQ0FBNEMsR0FBNUMsRUFBaUQ3USxDQUFqRCxDQU5TO0FBUVY7QUFDRCxHQXRDYTs7QUF3Q2Q7Ozs7O0FBS0ErMUMsV0E3Q2MsdUJBNkNGO0FBS1AsUUFBQWwyQyxDQUFDO0FBQUEsUUFKQ3FpQixFQUlELEdBSk0sSUFJTjtBQUFBLFFBSEVySyxNQUdGLEdBSG1DcUssRUFHbkMsQ0FIRXJLLE1BR0Y7QUFBQSxRQUhrQjNZLFlBR2xCLEdBSG1DZ2pCLEVBR25DLENBSFU5akIsS0FHVixDQUhrQmMsWUFHbEI7QUFBQSxRQUZDbXVCLFFBRUQsR0FGWXhWLE1BQU0sQ0FBQ25TLGNBQVAsSUFBeUIsTUFFckM7QUFBQSxRQURDc3dDLGFBQ0QsR0FEaUI5ekIsRUFBRSxDQUFDa3BCLFdBQUgsQ0FBZWxwQixFQUFFLENBQUM1USxHQUFILENBQU90VSxLQUF0QixFQUE2QjZVLGNBQUssQ0FBQzdVLEtBQW5DLEVBQTBDcUIsS0FDM0Q7QUFjTCxXQVpJLGlCQUFpQnFVLElBQWpCLENBQXNCMmEsUUFBdEIsQ0FZSixJQVhDeHRCLENBQUMsR0FBR1gsWUFBWSxHQUFHODJDLGFBV3BCLEVBVEszb0IsUUFBUSxDQUFDamQsT0FBVCxDQUFpQixPQUFqQixLQUE2QixDQVNsQyxHQVJFdlEsQ0FBQyxHQUFHWCxZQUFZLEdBQUc4MkMsYUFBZixHQUErQm4rQixNQUFNLENBQUNwUyxhQUFQLENBQXFCNUcsS0FRMUQsR0FQWXd1QixRQUFRLENBQUNqZCxPQUFULENBQWlCLFFBQWpCLEtBQThCLENBTzFDLEtBTkV2USxDQUFDLEdBQUcsQ0FBQ1gsWUFBWSxHQUFHODJDLGFBQWhCLElBQWlDLENBTXZDLEtBSENuMkMsQ0FBQyxHQUFJZ1ksTUFBTSxDQUFDcFMsYUFBUCxDQUFxQjdHLElBQXJCLElBQTZCLENBR25DLEVBQU9pQixDQUFQO0FBQ0EsR0FqRWE7O0FBbUVkOzs7OztBQUtBaTJDLFdBeEVjLHVCQXdFRjtBQUNYLFFBQU01ekIsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPLENBQUNBLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXBTLGFBQVYsQ0FBd0IvRyxHQUF4QixJQUErQixDQUFoQyxJQUNOd2pCLEVBQUUsQ0FBQ2twQixXQUFILENBQWVscEIsRUFBRSxDQUFDNVEsR0FBSCxDQUFPdFUsS0FBdEIsRUFBNkI2VSxjQUFLLENBQUM3VSxLQUFuQyxFQUEwQ3VCLE1BRDNDO0FBRUEsR0E3RWE7O0FBK0VkOzs7OztBQUtBMnhDLGlCQXBGYyw2QkFvRkk7QUFDakIsUUFBTWh1QixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQzR6QixTQUFILE1BQWtCNXpCLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXBTLGFBQVYsQ0FBd0I5RyxNQUF4QixJQUFrQyxDQUFwRCxDQUFQO0FBQ0E7QUF4RmEsQ0FBZixFOztBQzlCQTs7OztBQUlBO0FBSUE7QUFDQTtBQUNBO0FBRWU7QUFDZDs7OztBQUlBczNDLGFBTGMseUJBS0E7QUFDUCxRQUFBL3pCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDZ0JxSyxFQURoQixDQUNDckssTUFERDtBQUFBLFFBQ1N2RyxHQURULEdBQ2dCNFEsRUFEaEIsQ0FDUzVRLEdBRFQ7QUFBQSxRQUVDMk8sTUFGRCxHQUVXcEksTUFBTSxDQUFDM1IsZ0JBRmxCLENBRUMrWixNQUZEOztBQWdCTjtBQUNBLFFBYkEzTyxHQUFHLENBQUNyVSxPQUFKLEdBQWNxcEIsaUdBQVEsQ0FBQ3JHLE1BQUQsQ0FhdEIsRUFYSTNPLEdBQUcsQ0FBQ3JVLE9BQUosQ0FBWW5DLEtBQVosRUFXSixLQVZDd1csR0FBRyxDQUFDclUsT0FBSixHQUFjcVUsR0FBRyxDQUFDaFksS0FBSixDQUNaMnRCLEtBRFksQ0FDTixVQURNLEVBQ00sVUFETixFQUVaclcsTUFGWSxDQUVMLEtBRkssRUFHWkMsSUFIWSxDQUdQLE9BSE8sRUFHRWdCLGNBQUssQ0FBQzNVLGdCQUhSLEVBSVorcEIsS0FKWSxDQUlOLFVBSk0sRUFJTSxVQUpOLEVBS1pBLEtBTFksQ0FLTixnQkFMTSxFQUtZLE1BTFosRUFNWkEsS0FOWSxDQU1OLFNBTk0sRUFNSyxNQU5MLENBVWYsR0FBSXBQLE1BQU0sQ0FBQzFSLGlCQUFYLEVBQThCO0FBQzdCLFVBQUkrYixFQUFFLENBQUM4SixZQUFILE1BQXFCM2UsUUFBUSxDQUFDd0ssTUFBTSxDQUFDelIsY0FBUixDQUFqQyxFQUEwRDtBQUFBLFlBRXJEdUssQ0FGcUQ7QUFBQSxZQUdyRDBwQixHQUhxRDtBQUFBLFlBQ25EdFksT0FBTyxHQUFHRyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCLENBQWhCLENBRHlDOztBQU96RCxhQUZBbEssTUFBTSxDQUFDelIsY0FBUCxHQUF3QnNSLFNBQVMsQ0FBQzlILElBQVYsQ0FBZXNTLEVBQWYsRUFBbUJySyxNQUFNLENBQUN6UixjQUExQixDQUV4QixFQUFLdUssQ0FBQyxHQUFHLENBQVQsR0FBYTBwQixHQUFHLEdBQUd0WSxPQUFPLENBQUNLLE1BQVIsQ0FBZXpSLENBQWYsQ0FBbkIsS0FDTTBwQixHQUFHLENBQUN4NkIsQ0FBSixHQUFRZ1ksTUFBTSxDQUFDelIsY0FBaEIsS0FBb0MsQ0FEekMsRUFBdUN1SyxDQUFDLEVBQXhDOztBQU1Ba0gsY0FBTSxDQUFDelIsY0FBUCxHQUF3QnVLLENBYmlDO0FBY3pEOztBQUVEVyxTQUFHLENBQUNyVSxPQUFKLENBQVl5VCxJQUFaLENBQWlCd1IsRUFBRSxDQUFDZzBCLGNBQUgsQ0FDaEJoMEIsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQnpSLEdBQWhCLENBQW9CLFVBQUF0QyxDQUFDO0FBQUEsZUFBSWtVLEVBQUUsQ0FBQ21XLE9BQUgsQ0FBV3JxQixDQUFDLENBQUNvVSxNQUFGLENBQVN2SyxNQUFNLENBQUN6UixjQUFoQixDQUFYLENBQUo7QUFBQSxPQUFyQixDQURnQixFQUVoQjhiLEVBQUUsQ0FBQ3hwQixJQUFILENBQVE4ekIsa0JBQVIsRUFGZ0IsRUFHaEJ0SyxFQUFFLENBQUNrbUIsVUFBSCxDQUFjbG1CLEVBQUUsQ0FBQ21RLFVBQUgsQ0FBYyxJQUFkLEVBQW9CLENBQUMsT0FBRCxDQUFwQixDQUFkLENBSGdCLEVBSWhCblEsRUFBRSxDQUFDOUMsS0FKYSxDQUFqQixDQWpCNkIsRUF3QnhCYSxNQXhCd0IsSUF5QjVCM08sR0FBRyxDQUFDclUsT0FBSixDQUFZZ3FCLEtBQVosQ0FBa0IsS0FBbEIsRUFBeUJwUCxNQUFNLENBQUN4UixxQkFBUCxDQUE2QjNILEdBQXRELEVBQ0V1b0IsS0FERixDQUNRLE1BRFIsRUFDZ0JwUCxNQUFNLENBQUN4UixxQkFBUCxDQUE2QnpILElBRDdDLEVBRUVxb0IsS0FGRixDQUVRLFNBRlIsRUFFbUIsT0FGbkIsQ0F6QjRCO0FBNkI3QjtBQUNELEdBckRhOztBQXVEZDs7Ozs7O0FBTUFpdkIsZ0JBN0RjLDRCQTZEVTtBQUNqQixRQUFBaDBCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFHTixXQUFPekssVUFBVSxDQUFDeUssTUFBTSxDQUFDM1IsZ0JBQVIsQ0FBVixHQUNOMlIsTUFBTSxDQUFDM1IsZ0JBQVAsQ0FBd0JtZixJQUF4QixDQUE2Qm5ELEVBQUUsQ0FBQ2dKLEdBQWhDLDBCQURNLEdBQzBDaEosRUFBRSxDQUFDaTBCLGlCQUFILE9BQUFqMEIsRUFBRSxZQURuRDtBQUVBLEdBbkVhOztBQXFFZDs7Ozs7Ozs7O0FBU0FpMEIsbUJBOUVjLDZCQThFSW5vQyxDQTlFSixFQThFT29vQyxrQkE5RVAsRUE4RTJCak8sa0JBOUUzQixFQThFK0Mvb0IsS0E5RS9DLEVBOEVzRDtBQUM3RCxRQUFBOEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDZ0osR0FERCxHQUNnQmhKLEVBRGhCLENBQ0NnSixHQUREO0FBQUEsUUFDTXJULE1BRE4sR0FDZ0JxSyxFQURoQixDQUNNckssTUFETjtBQUFBLGVBR3VDLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0IsT0FBbEIsRUFBMkJ2SCxHQUEzQixDQUErQixVQUFBbkQsQ0FBQyxFQUFJO0FBQ2hGLFVBQU1zQyxFQUFFLEdBQUdvSSxNQUFNLHFCQUFtQjFLLENBQW5CLENBQWpCO0FBRUEsYUFBT0MsVUFBVSxDQUFDcUMsRUFBRCxDQUFWLEdBQWlCQSxFQUFFLENBQUM0VixJQUFILENBQVE2RixHQUFSLENBQWpCLEdBQWdDemIsRUFBdkM7QUFDQSxLQUo0QyxDQUh2QztBQUFBLFFBR0Q0bUMsV0FIQztBQUFBLFFBR1lDLFVBSFo7QUFBQSxRQUd3QkMsV0FIeEI7O0FBU05GLGVBQVcsR0FBR0EsV0FBVyxJQUFJRCxrQkFWc0MsRUFXbkVFLFVBQVUsR0FBR0EsVUFBVSxJQUFLLFVBQUF2d0IsSUFBSTtBQUFBLGFBQUlBLElBQUo7QUFBQSxLQVhtQyxFQVluRXd3QixXQUFXLEdBQUdBLFdBQVcsS0FDdkJyMEIsRUFBRSxDQUFDZ0ssaUJBQUgsS0FBeUIsVUFBQy9lLENBQUQsRUFBSXF4QixLQUFKO0FBQUEsYUFBaUIsQ0FBQ0EsS0FBSyxHQUFHLEdBQVQsRUFBY3pmLE9BQWQsQ0FBc0IsQ0FBdEIsQ0FBakI7QUFBQSxLQUF6QixHQUF3RW9wQixrQkFEakQsQ0FaMEM7O0FBQUEsUUFnQjdEL00sS0FBSyxHQUFHdmpCLE1BQU0sQ0FBQ2pSLGFBaEI4QztBQUFBLFFBaUI3RDR2QyxXQUFXLEdBQUcsVUFBQXpnQixHQUFHO0FBQUEsYUFBSzdULEVBQUUsQ0FBQ3hwQixJQUFILElBQVd3cEIsRUFBRSxDQUFDZ1gsYUFBSCxDQUFpQm5ELEdBQWpCLENBQVgsR0FBbUM3VCxFQUFFLENBQUNpWCxjQUFILENBQWtCcEQsR0FBRyxDQUFDMW1CLEtBQXRCLEVBQTZCLEdBQTdCLENBQW5DLEdBQXVFNlMsRUFBRSxDQUFDNFcsWUFBSCxDQUFnQi9DLEdBQWhCLENBQTVFO0FBQUEsS0FqQjRDO0FBQUEsUUFrQjdEMGdCLFVBQVUsR0FBR3YwQixFQUFFLENBQUN1c0IsVUFBSCxHQUFnQixVQUFBMVksR0FBRztBQUFBLGFBQUk3VCxFQUFFLENBQUN1c0IsVUFBSCxDQUFjMVksR0FBRyxDQUFDMW1CLEtBQWxCLENBQUo7QUFBQSxLQUFuQixHQUFrRCxVQUFBMG1CLEdBQUc7QUFBQSxhQUFJM1csS0FBSyxDQUFDMlcsR0FBRCxDQUFUO0FBQUEsS0FsQkw7QUFBQSxRQW1CN0QyZ0IsUUFBUSxHQUFHNytCLE1BQU0sQ0FBQzNSLGdCQW5CMkM7QUFBQSxRQW9CN0R5d0MsTUFBTSxHQUFHRCxRQUFRLENBQUNwTixRQXBCMkM7QUFBQSxRQXFCN0Q1TyxTQUFTLEdBQUd4WSxFQUFFLENBQUNpWSxjQUFILEVBckJpRDs7QUF1Qm5FLFFBQUlpQixLQUFLLEtBQUssSUFBVixJQUFrQnZqQixNQUFNLENBQUMzUSxXQUFQLENBQW1CaUgsTUFBekMsRUFBaUQ7QUFDaEQ7QUFDQSxVQUFNbW9CLEdBQUcsR0FBR3BVLEVBQUUsQ0FBQ3NaLFlBQUgsQ0FBZ0J0WixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUF4QixFQUNWelIsR0FEVSxDQUNOLFVBQUFzbUMsRUFBRTtBQUFBLGVBQUlBLEVBQUUsQ0FBQ3IyQyxFQUFQO0FBQUEsT0FESSxFQUVWaW9CLE9BRlUsRUFBWjtBQUlBeGEsT0FBQyxDQUFDaUgsSUFBRixDQUFPLFVBQUNqQixDQUFELEVBQUlDLENBQUosRUFBVTtBQUFBLFlBQ1ppakIsRUFBRSxHQUFHbGpCLENBQUMsR0FBR0EsQ0FBQyxDQUFDM0UsS0FBTCxHQUFhLElBRFA7QUFBQSxZQUVaOG5CLEVBQUUsR0FBR2xqQixDQUFDLEdBQUdBLENBQUMsQ0FBQzVFLEtBQUwsR0FBYSxJQUZQO0FBU2hCLGVBTEk2bkIsRUFBRSxHQUFHLENBQUwsSUFBVUMsRUFBRSxHQUFHLENBS25CLEtBSkNELEVBQUUsR0FBR2xqQixDQUFDLENBQUN6VCxFQUFGLEdBQU8rMUIsR0FBRyxDQUFDbG1CLE9BQUosQ0FBWTRELENBQUMsQ0FBQ3pULEVBQWQsQ0FBUCxHQUEyQixJQUlqQyxFQUhDNDJCLEVBQUUsR0FBR2xqQixDQUFDLENBQUMxVCxFQUFGLEdBQU8rMUIsR0FBRyxDQUFDbG1CLE9BQUosQ0FBWTZELENBQUMsQ0FBQzFULEVBQWQsQ0FBUCxHQUEyQixJQUdqQyxHQUFPMjJCLEVBQUUsR0FBR0MsRUFBWjtBQUNBLE9BVkQsQ0FOZ0Q7QUFpQmhELEtBakJELE1BaUJPLElBQUksZUFBZXprQixJQUFmLENBQW9CMG9CLEtBQXBCLENBQUosRUFBZ0M7QUFHdENwdEIsT0FBQyxDQUFDaUgsSUFBRixDQUFPLFVBQUNqQixDQUFELEVBQUlDLENBQUosRUFBVTtBQUFBLFlBQ1ZpakIsRUFBRSxHQUFHbGpCLENBQUMsR0FBR3dpQyxXQUFXLENBQUN4aUMsQ0FBRCxDQUFkLEdBQW9CLElBRGhCO0FBQUEsWUFFVm1qQixFQUFFLEdBQUdsakIsQ0FBQyxHQUFHdWlDLFdBQVcsQ0FBQ3ZpQyxDQUFELENBQWQsR0FBb0IsSUFGaEI7QUFJaEIsZUFObUJtbkIsS0FBSyxLQUFLLEtBTXRCLEdBQWNsRSxFQUFFLEdBQUdDLEVBQW5CLEdBQXdCQSxFQUFFLEdBQUdELEVBQXBDO0FBQ0EsT0FMRCxDQUhzQztBQVN0QyxLQVRNLE1BU0k5cEIsVUFBVSxDQUFDZ3VCLEtBQUQsQ0FUZCxJQVVOcHRCLENBQUMsQ0FBQ2lILElBQUYsQ0FBT21tQixLQUFLLENBQUMvVixJQUFOLENBQVc2RixHQUFYLENBQVAsQ0FWTTs7QUF4QzRELFFBdUQvRHB1QixJQXZEK0Q7QUFBQSxRQXdEL0RpNUIsR0F4RCtEO0FBQUEsUUF5RC9EOGdCLEtBekQrRDtBQUFBLFFBMEQvRHhuQyxLQTFEK0Q7QUFBQSxRQTJEL0RzQixDQTNEK0Q7QUFBQSxRQXFEN0Q2RyxHQUFHLEdBQUcwSyxFQUFFLENBQUM0MEIseUJBQUgsQ0FBNkJILE1BQTdCLENBckR1RDtBQUFBLFFBc0Q3RGxtQyxHQUFHLEdBQUd6QyxDQUFDLENBQUNHLE1BdERxRDs7QUE2RG5FLFNBQUt3QyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdGLEdBQWhCLEVBQXFCRSxDQUFDLEVBQXRCLEVBR0MsSUFGQW9sQixHQUFHLEdBQUcvbkIsQ0FBQyxDQUFDMkMsQ0FBRCxDQUVQLEVBQUtvbEIsR0FBRCxLQUFVeWdCLFdBQVcsQ0FBQ3pnQixHQUFELENBQVgsSUFBb0J5Z0IsV0FBVyxDQUFDemdCLEdBQUQsQ0FBWCxLQUFxQixDQUFuRCxDQUFKO0FBSUEsVUFBSXhvQixXQUFXLENBQUN6USxJQUFELENBQWYsRUFBdUI7QUFDdEIsWUFBTUUsS0FBSyxHQUFHNlMsUUFBUSxDQUFDd21DLFdBQVcsR0FBR0EsV0FBVyxDQUFDdGdCLEdBQUcsQ0FBQ2wyQixDQUFMLENBQWQsR0FBd0JrMkIsR0FBRyxDQUFDbDJCLENBQXhDLENBQXRCO0FBRUEvQyxZQUFJLEdBQUd5YSxVQUFVLENBQUNDLEdBQUcsQ0FBQyxDQUFELENBQUosRUFBUztBQUN6QnUvQix1QkFBYSxFQUFFbGxDLGNBQUssQ0FBQzVVLE9BREk7QUFFekJ1c0MsZUFBSyxFQUFFdDhCLE9BQU8sQ0FBQ2xRLEtBQUQsQ0FBUCxHQUNOMjVDLE1BQU0sR0FBRzM1QyxLQUFILDhCQUFrQ0EsS0FBbEMsZUFEQSxHQUVIO0FBSnFCLFNBQVQsQ0FISztBQVN0Qjs7QUFLRCxVQUhBNjVDLEtBQUssR0FBRyxDQUFDOWdCLEdBQUcsQ0FBQ3lJLEtBQUwsRUFBWXpJLEdBQUcsQ0FBQ3gxQixFQUFoQixFQUFvQncxQixHQUFHLENBQUN4TyxLQUF4QixFQUErQnZaLENBQS9CLENBR1IsRUFGQXFCLEtBQUssR0FBR1EsUUFBUSxDQUFDMG1DLFdBQVcsTUFBWCxVQUFZQyxXQUFXLENBQUN6Z0IsR0FBRCxDQUF2QixTQUFpQzhnQixLQUFqQyxFQUFELENBRWhCLEVBQUkzMEIsRUFBRSxDQUFDOFcsZUFBSCxDQUFtQmpELEdBQW5CLENBQUosRUFBNkI7QUFBQSxvQkFDUixDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCemxCLEdBQWhCLENBQW9CLFVBQUFuRCxDQUFDO0FBQUEsaUJBQUkwQyxRQUFRLENBQ3BEMG1DLFdBQVcsTUFBWCxVQUFZcjBCLEVBQUUsQ0FBQytXLGdCQUFILENBQW9CbEQsR0FBcEIsRUFBeUI1b0IsQ0FBekIsQ0FBWixTQUE0QzBwQyxLQUE1QyxFQURvRCxDQUFaO0FBQUEsU0FBckIsQ0FEUTtBQUFBLFlBQ3JCRyxJQURxQjtBQUFBLFlBQ2ZDLEdBRGU7O0FBSzVCNW5DLGFBQUssb0JBQWtCQSxLQUFsQixzQkFBd0MybkMsSUFBeEMscUJBQTREQyxHQUxyQztBQU01Qjs7QUFFRCxVQUFJNW5DLEtBQUssS0FBSzFNLFNBQWQsRUFBeUI7QUFBQTtBQUN4QjtBQUNBLGNBQUlvekIsR0FBRyxDQUFDaFEsSUFBSixLQUFhLElBQWpCLEVBQ0M7QUFIdUIsY0FNbEJBLElBQUksR0FBR2xXLFFBQVEsQ0FBQ3ltQyxVQUFVLE1BQVYsVUFBV3ZnQixHQUFHLENBQUNoUSxJQUFmLFNBQXdCOHdCLEtBQXhCLEVBQUQsQ0FORztBQUFBLGNBT2xCejNCLEtBQUssR0FBR3EzQixVQUFVLENBQUMxZ0IsR0FBRCxDQVBBO0FBQUEsY0FRbEJtaEIsWUFBWSxHQUFHO0FBQ3BCQyw4QkFBa0IsRUFBRXRsQyxjQUFLLENBQUMxVSxXQUFOLEdBQW9CK2tCLEVBQUUsQ0FBQ21iLHVCQUFILENBQTJCdEgsR0FBRyxDQUFDeDFCLEVBQS9CLENBRHBCO0FBRXBCZ3BDLGlCQUFLLEVBQUdvTixNQUFNLElBQUksQ0FBQ3owQixFQUFFLENBQUM2aUIsUUFBZixHQUEyQjNsQixLQUEzQixnQ0FBNkRBLEtBQTdELGdEQUZhO0FBR3BCZzRCLGdCQUFJLEVBQUVyeEIsSUFIYztBQUlwQnN4QixpQkFBSyxFQUFFaG9DO0FBSmEsV0FSRzs7QUFleEIsY0FBSXNuQyxNQUFNLElBQUkvbkMsUUFBUSxDQUFDOG5DLFFBQVEsQ0FBQzU1QyxJQUFWLENBQXRCLEVBQXVDO0FBQ3RDLGdCQUFNeXFCLEtBQUssR0FBR21ULFNBQVMsQ0FBQ3RxQixPQUFWLENBQWtCMmxCLEdBQUcsQ0FBQ3gxQixFQUF0QixDQUFkO0FBRUE4TixrQkFBTSxDQUFDQyxJQUFQLENBQVlvb0MsUUFBUSxDQUFDNTVDLElBQXJCLEVBQTJCeVMsT0FBM0IsQ0FBbUMsVUFBQU4sR0FBRyxFQUFJO0FBQ3pDaW9DLDBCQUFZLENBQUNqb0MsR0FBRCxDQUFaLEdBQW9CeW5DLFFBQVEsQ0FBQzU1QyxJQUFULENBQWNtUyxHQUFkLEVBQW1Cc1ksS0FBbkIsQ0FEcUI7QUFFekMsYUFGRCxDQUhzQztBQU10Qzs7QUFFRHpxQixjQUFJLElBQUl5YSxVQUFVLENBQUNDLEdBQUcsQ0FBQyxDQUFELENBQUosRUFBUzAvQixZQUFULENBdkJNO0FBQUE7O0FBQUEsaUNBR3ZCO0FBcUJEO0FBbEREOztBQXFERCxXQUFVcDZDLElBQVY7QUFDQSxHQXBNYTs7QUFzTWQ7Ozs7OztBQU1BZzZDLDJCQTVNYyxxQ0E0TVlILE1BNU1aLEVBNE1vQjtBQUNqQyxXQUFPLENBQUNBLE1BQU0sb0pBR1EsS0FBSzVSLFFBQUwsbUVBSFIsd0dBQVAsRUFPTGgxQixPQVBLLENBT0csYUFQSCxFQU9rQixFQVBsQixFQVFMUyxLQVJLLENBUUMsVUFSRCxDQUFQO0FBU0EsR0F0TmE7O0FBd05kOzs7Ozs7Ozs7QUFTQThtQyxpQkFqT2MsMkJBaU9FQyxVQWpPRixFQWlPY0MsTUFqT2QsRUFpT3NCQyxPQWpPdEIsRUFpTytCbEUsT0FqTy9CLEVBaU93QztBQUMvQyxRQUFBcnhCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1MwSyxLQURULEdBQ2tCTCxFQURsQixDQUNTSyxLQURUO0FBQUEsb0JBRXlFTCxFQUFFLENBQUM5akIsS0FGNUU7QUFBQSxRQUVDQyxLQUZELGFBRUNBLEtBRkQ7QUFBQSxRQUVRRSxNQUZSLGFBRVFBLE1BRlI7QUFBQSxRQUVnQlcsWUFGaEIsYUFFZ0JBLFlBRmhCO0FBQUEsUUFFOEJDLGFBRjlCLGFBRThCQSxhQUY5QjtBQUFBLFFBRTZDQyxhQUY3QyxhQUU2Q0EsYUFGN0M7QUFBQSxRQUU0RGdCLFNBRjVELGFBRTREQSxTQUY1RDtBQUFBLFFBR0FtckMsUUFIQSxHQUdXcnBCLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLEtBQXVCLENBQUN2Z0IsTUFBTSxDQUFDZ0YsZ0JBSDFDO0FBQUEsUUFJQXMwQixPQUpBLEdBSVVqdkIsRUFBRSxDQUFDMHVCLFVBQUgsSUFKVjtBQUFBLG1CQUtZM1AsZ0dBQU8sQ0FBQ3NTLE9BQUQsQ0FMbkI7QUFBQSxRQUtEMzBDLElBTEM7QUFBQSxRQUtLRixHQUxMO0FBQUEsUUFNRmc1QyxVQU5FLEdBTVd2RyxPQUFPLEdBQUdqeUMsWUFBVixHQUF5QmdqQixFQUFFLENBQUM4bkIsc0JBQUgsRUFOcEM7O0FBVU47QUFDQSxRQUhBdHJDLEdBQUcsSUFBSSxFQUdQLEVBQUl3akIsRUFBRSxDQUFDbVEsVUFBSCxFQUFKLEVBQXFCO0FBQ3BCLFVBQU04YyxHQUFHLEdBQUcvdUMsU0FBUyxLQUFLLE9BQWQsSUFBeUI4aEIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsQ0FBckM7QUFFSytXLFNBSGUsS0FJbkJ6d0MsR0FBRyxJQUFJNnNDLFFBQVEsR0FBR2h0QyxNQUFILEdBQVlBLE1BQU0sR0FBRyxDQUpqQixFQUtuQkssSUFBSSxJQUFJLENBQUNQLEtBQUssSUFBSWUsYUFBYSxHQUFHOGlCLEVBQUUsQ0FBQ3NvQixjQUFILEVBQUgsR0FBeUIsQ0FBMUMsQ0FBTixJQUFzRCxDQUwzQztBQU9wQixLQVBELE1BT087QUFDTixVQUFNbU4sU0FBUyxHQUFHcDFCLEtBQUssQ0FBQzFpQixDQUFOLENBQVEwM0MsVUFBVSxDQUFDLENBQUQsQ0FBVixDQUFjMTNDLENBQXRCLENBQWxCO0FBRUlnWSxZQUFNLENBQUNjLFlBSEwsSUFJTGphLEdBQUcsR0FBR2k1QyxTQUFTLEdBQUcsRUFKYixFQUtMLzRDLElBQUksSUFBSXV5QyxPQUFPLEdBQUcsR0FMYixFQU1MdUcsVUFBVSxJQUFJdkcsT0FOVCxLQVFMenlDLEdBQUcsSUFBSSxDQVJGLEVBU0xFLElBQUksR0FBR3V5QyxPQUFPLEdBQUdqdkIsRUFBRSxDQUFDNm5CLHFCQUFILElBQVYsR0FBMkMsRUFBM0MsSUFBaUR4bkIsS0FBSyxDQUFDekMsSUFBTixHQUFhbGhCLElBQWIsR0FBb0IrNEMsU0FBckUsQ0FURjtBQVdOOztBQUVELFFBQU05NEMsS0FBSyxHQUFHRCxJQUFJLEdBQUc0NEMsTUFBckI7QUFlQSxXQWJJMzRDLEtBQUssR0FBRzY0QyxVQWFaLEtBWEM5NEMsSUFBSSxJQUFJQyxLQUFLLEdBQUc2NEMsVUFBUixHQUFxQixFQVc5QixHQVJJaDVDLEdBQUcsR0FBRys0QyxPQUFOLEdBQWdCdDRDLGFBUXBCLEtBUENULEdBQUcsSUFBSTZzQyxRQUFRLEdBQUdrTSxPQUFPLEdBQUcsQ0FBYixHQUFpQkEsT0FBTyxHQUFHLEVBTzNDLEdBSkkvNEMsR0FBRyxHQUFHLENBSVYsS0FIQ0EsR0FBRyxHQUFHLENBR1AsR0FBTztBQUFDQSxTQUFHLEVBQUhBLEdBQUQ7QUFBTUUsVUFBSSxFQUFKQTtBQUFOLEtBQVA7QUFDQSxHQWpSYTs7QUFtUmQ7Ozs7OztBQU1BZzVDLGFBelJjLHVCQXlSRkMsWUF6UkUsRUF5Ull0RSxPQXpSWixFQXlScUI7QUFDNUIsUUFBQXJ4QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2tDcUssRUFEbEMsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTelosS0FEVCxHQUNrQzhqQixFQURsQyxDQUNTOWpCLEtBRFQ7QUFBQSxRQUNzQm5CLE9BRHRCLEdBQ2tDaWxCLEVBRGxDLENBQ2dCNVEsR0FEaEIsQ0FDc0JyVSxPQUR0QjtBQUFBLFFBRUNnakIsTUFGRCxHQUVXcEksTUFBTSxDQUFDM1IsZ0JBRmxCLENBRUMrWixNQUZEO0FBQUEsUUFHQW9vQixNQUhBLEdBR1NubUIsRUFBRSxDQUFDbVEsVUFBSCxDQUFjLElBQWQsRUFBb0IsQ0FBQyxPQUFELENBQXBCLENBSFQ7QUFBQSxRQUlBa2xCLFVBSkEsR0FJYU0sWUFBWSxDQUFDcmpDLE1BQWIsQ0FBb0IsVUFBQXhHLENBQUM7QUFBQSxhQUFJQSxDQUFDLElBQUlkLE9BQU8sQ0FBQ2dWLEVBQUUsQ0FBQzRXLFlBQUgsQ0FBZ0I5cUIsQ0FBaEIsQ0FBRCxDQUFoQjtBQUFBLEtBQXJCLENBSmI7O0FBTU4sUUFBSXVwQyxVQUFVLENBQUNwcEMsTUFBWCxLQUFzQixDQUF0QixJQUE0QjBKLE1BQU0sQ0FBQ2xTLFlBQXZDO0FBSU0sVUFBQSs2QixLQUFLLEdBQUd6akMsT0FBTyxDQUFDeWpDLEtBQVIsRUFBUjtBQUFBLFVBQ0FvWCxPQURBLEdBQ1V2akIsSUFBSSxDQUFDd2pCLFNBQUwsQ0FBZUYsWUFBZixDQURWO0FBQUEsaUJBRXdCblgsS0FBSyxJQUFJLEVBRmpDO0FBQUEsNEJBRURyaUMsS0FGQztBQUFBLFVBRURBLEtBRkMsMkJBRU8sQ0FGUDtBQUFBLDZCQUVVRSxNQUZWO0FBQUEsVUFFVUEsTUFGViw0QkFFbUIsQ0FGbkI7O0FBSU4sVUFBSSxDQUFDbWlDLEtBQUQsSUFBVUEsS0FBSyxDQUFDdEMsT0FBTixLQUFrQjBaLE9BQWhDLEVBQXlDO0FBQ3hDLFlBQU12d0IsS0FBSyxHQUFHc3dCLFlBQVksQ0FBQ3hrQyxNQUFiLEdBQXNCNEIsSUFBdEIsR0FBNkIsQ0FBN0IsRUFBZ0NzUyxLQUE5QztBQUVBL1gsY0FBTSxDQUFDcUksTUFBTSxDQUFDclIsY0FBUixFQUF3QjBiLEVBQUUsQ0FBQ2dKLEdBQTNCLEVBQWdDMnNCLFlBQWhDLENBSGtDLEVBTXhDNTZDLE9BQU8sQ0FDTHlULElBREYsQ0FDT3dSLEVBQUUsQ0FBQ2cwQixjQUFILENBQ0wyQixZQURLLEVBRUwzMUIsRUFBRSxDQUFDeHBCLElBQUgsSUFBV3dwQixFQUFFLENBQUN4cEIsSUFBSCxDQUFROHpCLGtCQUFSLEVBRk4sRUFHTHRLLEVBQUUsQ0FBQ2ttQixVQUFILENBQWNDLE1BQWQsQ0FISyxFQUlMbm1CLEVBQUUsQ0FBQzlDLEtBSkUsQ0FEUCxFQU9FNkgsS0FQRixDQU9RLFNBUFIsRUFPbUIsSUFQbkIsRUFRRUEsS0FSRixDQVFRLFlBUlIsRUFRc0IsSUFSdEIsRUFRNEI7QUFSNUIsU0FTRXlaLEtBVEYsQ0FTUTtBQUNOblosZUFBSyxFQUFMQSxLQURNO0FBRU42VyxpQkFBTyxFQUFFMFosT0FGSDtBQUdOejVDLGVBQUssRUFBRUEsS0FBSyxHQUFHcEIsT0FBTyxDQUFDKzZDLFFBQVIsQ0FBaUIsYUFBakIsQ0FIVDtBQUlOejVDLGdCQUFNLEVBQUVBLE1BQU0sR0FBR3RCLE9BQU8sQ0FBQys2QyxRQUFSLENBQWlCLGNBQWpCO0FBSlgsU0FUUixDQU53QyxFQXNCeEN4b0MsTUFBTSxDQUFDcUksTUFBTSxDQUFDblIsZUFBUixFQUF5QndiLEVBQUUsQ0FBQ2dKLEdBQTVCLEVBQWlDMnNCLFlBQWpDLENBdEJrQyxFQXVCeEMzMUIsRUFBRSxDQUFDKzFCLG1CQUFILEtBQTZCMXdCLEtBQTdCLENBdkJ3QztBQXdCeEM7O0FBRUQsVUFBSSxDQUFDdEgsTUFBTCxFQUFhO0FBQUEsWUFFUm9sQixJQUZRO0FBQUEsWUFDUjUxQixFQUFFLEdBQUdvSSxNQUFNLENBQUM1UixnQkFESjtBQUlSbUgsa0JBQVUsQ0FBQ3FDLEVBQUQsQ0FKRixHQUtYQSxFQUFFLEdBQUdBLEVBQUUsQ0FBQzRWLElBQUgsQ0FBUW5ELEVBQUUsQ0FBQ2dKLEdBQVgsQ0FMTSxJQU9YbWEsSUFBSSxHQUFHNTFCLEVBQUUsSUFBSUEsRUFBRSxDQUFDNDFCLElBUEwsRUFRWDUxQixFQUFFLEdBQUd5UyxFQUFFLENBQUNvMUIsZUFBSCxDQUFtQmp5QixJQUFuQixDQUF3Qm5ELEVBQXhCLENBUk07QUFXWjtBQUNBLFlBQU1nRyxHQUFHLEdBQUd6WSxFQUFFLENBQUM4bkMsVUFBRCxFQUFhbDVDLEtBQWIsRUFBb0JFLE1BQXBCLEVBQTRCZzFDLE9BQTVCLENBQWQ7QUFFQSxTQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCaGtDLE9BQWhCLENBQXdCLFVBQUFwQyxDQUFDLEVBQUk7QUFDNUIsY0FBSWtDLEtBQUssR0FBRzZZLEdBQUcsQ0FBQy9hLENBQUQsQ0FBZixDQUQ0QixDQUc1Qjs7QUFDQSxjQUFJLGdCQUFnQnVGLElBQWhCLENBQXFCckQsS0FBckIsQ0FBSixFQUFpQztBQUNoQyxnQkFBSWcyQixJQUFJLEtBQUssR0FBYixFQUFrQjtBQUNqQixrQkFBTXZsQyxJQUFJLEdBQUcxQixLQUFLLENBQUMrTyxDQUFDLEtBQUssS0FBTixHQUFjLGVBQWQsR0FBZ0MsY0FBakMsQ0FBbEI7QUFFQWtDLG1CQUFLLEdBQUdBLEtBQUssR0FBR3ZQLElBQVIsR0FBZSxHQUhOO0FBSWpCLGFBSkQsTUFLQ3VsQyxJQUFJLEdBQUcsSUFMUjs7QUFRQWgyQixpQkFBSyxJQUFJZzJCLElBVHVCO0FBVWhDOztBQUVEcG9DLGlCQUFPLENBQUNncUIsS0FBUixDQUFjOVosQ0FBZCxFQUFpQmtDLEtBQWpCLENBaEI0QjtBQWlCNUIsU0FqQkQsQ0FkWTtBQWdDWjtBQWxFRDtBQW1FQSxHQW5XYTs7QUFxV2Q7Ozs7O0FBS0F5OEIsYUExV2MsdUJBMFdGNzBCLEtBMVdFLEVBMFdLO0FBQ1osUUFBQWlMLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDMkJxSyxFQUQzQixDQUNDckssTUFERDtBQUFBLFFBQ2U1YSxPQURmLEdBQzJCaWxCLEVBRDNCLENBQ1M1USxHQURULENBQ2VyVSxPQURmOztBQUdOLFFBQUlBLE9BQU8sQ0FBQ2dxQixLQUFSLENBQWMsU0FBZCxNQUE2QixNQUE3QixLQUF3QyxDQUFDcFAsTUFBTSxDQUFDalMsaUJBQVIsSUFBNkJxUixLQUFyRSxDQUFKLEVBQWlGO0FBQ2hGLFVBQU00Z0MsWUFBWSxHQUFHdGpCLElBQUksQ0FBQ0MsS0FBTCxDQUFXdjNCLE9BQU8sQ0FBQ3lqQyxLQUFSLEdBQWdCdEMsT0FBM0IsQ0FBckI7QUFJQTtBQUZBNXVCLFlBQU0sQ0FBQ3FJLE1BQU0sQ0FBQ3BSLGNBQVIsRUFBd0J5YixFQUFFLENBQUNnSixHQUEzQixFQUFnQzJzQixZQUFoQyxDQUgwRSxFQU1oRjU2QyxPQUFPLENBQ0xncUIsS0FERixDQUNRLFNBRFIsRUFDbUIsTUFEbkIsRUFFRUEsS0FGRixDQUVRLFlBRlIsRUFFc0IsUUFGdEIsRUFFZ0M7QUFGaEMsT0FHRXlaLEtBSEYsQ0FHUSxJQUhSLENBTmdGLEVBV2hGbHhCLE1BQU0sQ0FBQ3FJLE1BQU0sQ0FBQ2xSLGdCQUFSLEVBQTBCdWIsRUFBRSxDQUFDZ0osR0FBN0IsRUFBa0Myc0IsWUFBbEMsQ0FYMEU7QUFZaEY7QUFDRCxHQTNYYTs7QUE2WGQ7Ozs7OztBQU1BSSxxQkFuWWMsK0JBbVlNdE0sSUFuWU4sRUFtWVlwa0IsS0FuWVosRUFtWW1CO0FBQzFCLFFBQUFyRixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NnMkIsTUFERCxHQUNtQmgyQixFQURuQixDQUNDZzJCLE1BREQ7QUFBQSxRQUNTcmdDLE1BRFQsR0FDbUJxSyxFQURuQixDQUNTckssTUFEVDs7QUFHTixRQUFJQSxNQUFNLENBQUN2UixjQUFQLElBQXlCNHhDLE1BQU0sQ0FBQy9wQyxNQUFQLEdBQWdCLENBQTdDLEVBQWdEO0FBQy9DLFVBQU1ncUMsVUFBVSxHQUFHdGdDLE1BQU0sQ0FBQ3RSLG1CQUExQjtBQUVBMnhDLFlBQU0sQ0FBQzNvQyxPQUFQLENBQWUsVUFBQTJFLENBQUMsRUFBSTtBQUNuQixZQUFJQSxDQUFDLEtBQUtnTyxFQUFFLENBQUNnSixHQUFiLEVBQWtCO0FBQ1gsY0FBQ3JULE9BQUQsR0FBVzNELENBQUMsQ0FBQ2trQyxRQUFiLENBQUN2Z0MsTUFBRDtBQUFBLGNBQ0F3Z0MsUUFEQSxHQUNXeGdDLE9BQU0sQ0FBQ3ZSLGNBRGxCO0FBQUEsY0FFQXlmLElBRkEsR0FFT2xPLE9BQU0sQ0FBQ3RSLG1CQUZkO0FBQUEsY0FHQSt4QyxPQUhBLEdBR1VyckMsV0FBUSxDQUFDNjJCLElBQVQsQ0FBY3lVLFFBQWQsQ0FBdUJya0MsQ0FBQyxDQUFDcS9CLE9BQXpCLENBSFY7O0FBS04sY0FBSThFLFFBQVEsSUFBSUYsVUFBVSxLQUFLcHlCLElBQTNCLElBQW1DdXlCLE9BQXZDLEVBQWdEO0FBQUEsZ0JBQ3pDamtDLElBQUksR0FBR0gsQ0FBQyxDQUFDa2tDLFFBQUYsQ0FBVzltQyxHQUFYLENBQWVyVSxPQUFmLENBQXVCb1gsSUFBdkIsR0FBOEIsQ0FBOUIsQ0FEa0M7QUFBQSxnQkFFekNta0MsY0FBYyxHQUFHanhCLEtBQUssTUFBTWxULElBQUksSUFBSUEsSUFBSSxDQUFDa1QsS0FBbkIsQ0FGbUI7O0FBSS9DO0FBQ0EsZ0JBQUk7QUFDQ29rQixrQkFBSSxJQUFJNk0sY0FEVCxHQUVGdGtDLENBQUMsQ0FBQ2pYLE9BQUYsQ0FBVTB1QyxJQUFWLENBQWU7QUFBQ3BrQixxQkFBSyxFQUFMQTtBQUFELGVBQWYsQ0FGRSxHQUdRLENBQUNva0IsSUFIVCxJQUlGejNCLENBQUMsQ0FBQ2pYLE9BQUYsQ0FBVXl1QyxJQUFWLEVBSkU7QUFNSCxhQU5ELENBTUUsT0FBT3A0QixDQUFQLEVBQVUsQ0FBRTtBQUNkO0FBQ0Q7QUFDRCxPQXJCRCxDQUgrQztBQXlCL0M7QUFDRDtBQWphYSxDQUFmLEU7O0FDWkE7Ozs7QUFJQTtBQUNBO0FBRWU7QUFDZGdYLGNBRGMsd0JBQ0R6dEIsTUFEQyxFQUNPMHFCLEtBRFAsRUFDa0I7QUFBWEEsU0FBVyxnQkFBWEEsS0FBVyxHQUFILENBQUc7QUFNM0IsUUFBQTFuQixDQUFDO0FBQUEsUUFDREcsQ0FEQztBQUFBLFFBTENraUIsRUFLRCxHQUxNLElBS047QUFBQSxRQUpFckssTUFJRixHQUptQnFLLEVBSW5CLENBSkVySyxNQUlGO0FBQUEsUUFKVXpaLEtBSVYsR0FKbUI4akIsRUFJbkIsQ0FKVTlqQixLQUlWO0FBQUEsUUFIQzZyQixTQUdELEdBSGFwUyxNQUFNLENBQUNjLFlBR3BCO0FBQUEsUUFGQzR5QixRQUVELEdBRllycEIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsQ0FFWjtBQUFBLFFBREQzSCxPQUNDLEdBRFMsQ0FDVDtBQU9MLFFBSklsSixLQUFLLElBQUksWUFBWTdVLElBQVosQ0FBaUI3VixNQUFqQixDQUliLEtBSEM0ekIsT0FBTyxHQUFHdk8sRUFBRSxDQUFDNHRCLFdBQUgsQ0FBZWp6QyxNQUFmLElBQXlCMHFCLEtBR3BDLEdBQUkxcUIsTUFBTSxLQUFLLE1BQWYsRUFDQ2dELENBQUMsR0FBR2dPLFdBQVcsQ0FBQ3pQLEtBQUssQ0FBQ0ssTUFBTixDQUFhRyxJQUFkLENBRGhCLEVBRUNvQixDQUFDLEdBQUc2TixXQUFXLENBQUN6UCxLQUFLLENBQUNLLE1BQU4sQ0FBYUMsR0FBZCxDQUZoQixNQUdPLElBQUk3QixNQUFNLEtBQUssU0FBZixFQUNOZ0QsQ0FBQyxHQUFHZ08sV0FBVyxDQUFDelAsS0FBSyxDQUFDVSxPQUFOLENBQWNGLElBQWYsQ0FEVCxFQUVOb0IsQ0FBQyxHQUFHNk4sV0FBVyxDQUFDelAsS0FBSyxDQUFDVSxPQUFOLENBQWNKLEdBQWYsQ0FGVCxNQUdBLElBQUk3QixNQUFNLEtBQUssUUFBZixFQUNOZ0QsQ0FBQyxHQUFHekIsS0FBSyxDQUFDVyxPQUFOLENBQWNILElBRFosRUFFTm9CLENBQUMsR0FBRzVCLEtBQUssQ0FBQ1csT0FBTixDQUFjTCxHQUFkLElBQXFCNnNDLFFBQVEsR0FBRyxFQUFILEdBQVEsQ0FBckMsQ0FGRSxNQUdBLElBQUkxdUMsTUFBTSxLQUFLLEdBQWYsRUFDTmdELENBQUMsR0FBR29xQixTQUFTLEdBQUcsQ0FBQ3dHLE9BQUosR0FBYyxDQURyQixFQUVOendCLENBQUMsR0FBR2lxQixTQUFTLEdBQUcsQ0FBSCxHQUFPN3JCLEtBQUssQ0FBQ0csTUFBTixHQUFla3lCLE9BRjdCLE1BR0EsSUFBSTV6QixNQUFNLEtBQUssR0FBZixFQUNOZ0QsQ0FBQyxHQUFHb3FCLFNBQVMsR0FBRyxDQUFILEdBQU8sQ0FBQ3dHLE9BRGYsRUFFTnp3QixDQUFDLEdBQUdpcUIsU0FBUyxHQUFHN3JCLEtBQUssQ0FBQ0csTUFBTixHQUFla3lCLE9BQWxCLEdBQTRCLENBRm5DLE1BR0EsSUFBSTV6QixNQUFNLEtBQUssSUFBZixFQUNOZ0QsQ0FBQyxHQUFHb3FCLFNBQVMsR0FBRyxDQUFILEdBQU83ckIsS0FBSyxDQUFDQyxLQUFOLEdBQWNveUIsT0FENUIsRUFFTnp3QixDQUFDLEdBQUdpcUIsU0FBUyxHQUFHLElBQUl3RyxPQUFQLEdBQWlCLENBRnhCLE1BR0EsSUFBSTV6QixNQUFNLEtBQUssTUFBZixFQUNOZ0QsQ0FBQyxHQUFHLENBREUsRUFFTkcsQ0FBQyxHQUFHaXFCLFNBQVMsR0FBRyxDQUFILEdBQU83ckIsS0FBSyxDQUFDSSxPQUZwQixNQUdBLElBQUkzQixNQUFNLEtBQUssS0FBZixFQUNOZ0QsQ0FBQyxHQUFHekIsS0FBSyxDQUFDWSxRQUFOLEdBQWlCLENBRGYsRUFFTmdCLENBQUMsR0FBRzVCLEtBQUssQ0FBQ2EsU0FBTixHQUFrQixDQUZoQixNQUdBLElBQUlwQyxNQUFNLEtBQUssT0FBZixFQUF3QjtBQUFBLDZCQUNkcWxCLEVBQUUsQ0FBQ3UyQixZQUFILEVBRGM7QUFBQSxVQUN2QnA2QyxLQUR1Qjs7QUFHOUJ3QixPQUFDLEdBQUd6QixLQUFLLENBQUNDLEtBQU4sR0FBYyxDQUFkLEdBQWtCQSxLQUhRLEVBSTlCMkIsQ0FBQyxHQUFHNk4sV0FBVyxDQUFDelAsS0FBSyxDQUFDSyxNQUFOLENBQWFDLEdBQWQsQ0FKZTtBQUs5QjtBQUVELDBCQUFvQm1CLENBQXBCLFVBQTBCRyxDQUExQjtBQUNBLEdBOUNhO0FBZ0RkMDRDLGVBaERjLHlCQWdEQXhvQixjQWhEQSxFQWdEZ0JtQixXQWhEaEIsRUFnRDZCO0FBR3RDLFFBQUFzbkIsS0FBSztBQUFBLFFBQ0xDLEtBREs7QUFBQSxRQUVMQyxNQUZLO0FBQUEsUUFGSDMyQixFQUVHLEdBRkUsSUFFRjtBQUFBLFFBREZ6USxJQUNFLEdBRE15USxFQUFFLENBQUM1USxHQUNULENBREZHLElBQ0U7QUFJTDRmLGVBQVcsSUFBSUEsV0FBVyxDQUFDMTRCLEtBUFcsR0FRekNnZ0QsS0FBSyxHQUFHdG5CLFdBQVcsQ0FBQzE0QixLQVJxQixJQVV6Q2dnRCxLQUFLLEdBQUdsbkMsSUFBSSxDQUFDRyxNQUFMLE9BQWdCQyxjQUFLLENBQUNsWixLQUF0QixDQVZpQyxFQVlyQ3UzQixjQVpxQyxLQWF4Q3lvQixLQUFLLEdBQUdBLEtBQUssQ0FBQ3gwQixVQUFOLEVBYmdDLElBaUJ0Q2tOLFdBQVcsSUFBSUEsV0FBVyxDQUFDeDRCLEtBakJXLEdBa0J6QysvQyxLQUFLLEdBQUd2bkIsV0FBVyxDQUFDeDRCLEtBbEJxQixJQW9CekMrL0MsS0FBSyxHQUFHbm5DLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDaFosS0FBdEIsQ0FwQmlDLEVBc0JyQ3EzQixjQXRCcUMsS0F1QnhDMG9CLEtBQUssR0FBR0EsS0FBSyxDQUFDejBCLFVBQU4sRUF2QmdDLElBMkJ0Q2tOLFdBQVcsSUFBSUEsV0FBVyxDQUFDdjRCLE1BM0JXLEdBNEJ6QysvQyxNQUFNLEdBQUd4bkIsV0FBVyxDQUFDdjRCLE1BNUJvQixJQThCekMrL0MsTUFBTSxHQUFHcG5DLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDL1ksTUFBdEIsQ0E5QmdDLEVBZ0NyQ28zQixjQWhDcUMsS0FpQ3hDMm9CLE1BQU0sR0FBR0EsTUFBTSxDQUFDMTBCLFVBQVAsRUFqQytCLElBcUMxQyxDQUFDK0wsY0FBYyxHQUFHemUsSUFBSSxDQUFDMFMsVUFBTCxFQUFILEdBQXVCMVMsSUFBdEMsRUFDRVosSUFERixDQUNPLFdBRFAsRUFDb0JxUixFQUFFLENBQUNvSSxZQUFILENBQWdCLE1BQWhCLENBRHBCLENBckMwQyxFQXdDMUNxdUIsS0FBSyxDQUFDOW5DLElBQU4sQ0FBVyxXQUFYLEVBQXdCcVIsRUFBRSxDQUFDb0ksWUFBSCxDQUFnQixHQUFoQixDQUF4QixDQXhDMEMsRUF5QzFDc3VCLEtBQUssQ0FBQy9uQyxJQUFOLENBQVcsV0FBWCxFQUF3QnFSLEVBQUUsQ0FBQ29JLFlBQUgsQ0FBZ0IsR0FBaEIsQ0FBeEIsQ0F6QzBDLEVBMEMxQ3V1QixNQUFNLENBQUNob0MsSUFBUCxDQUFZLFdBQVosRUFBeUJxUixFQUFFLENBQUNvSSxZQUFILENBQWdCLElBQWhCLENBQXpCLENBMUMwQyxFQTRDMUM3WSxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ3JZLFNBQXRCLEVBQ0VxWCxJQURGLENBQ08sV0FEUCxFQUNvQnFSLEVBQUUsQ0FBQ29JLFlBQUgsQ0FBZ0IsS0FBaEIsQ0FEcEIsQ0E1QzBDO0FBOEMxQyxHQTlGYTtBQWdHZDhlLGNBaEdjLHdCQWdHRGxaLGNBaEdDLEVBZ0dlbUIsV0FoR2YsRUFnRzRCO0FBQ25DLFFBQUFuUCxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBR040USxNQUFFLENBQUN3MkIsYUFBSCxDQUFpQnhvQixjQUFqQixFQUFpQ21CLFdBQWpDLENBSnlDLEVBTXpDblAsRUFBRSxDQUFDNlcsT0FBSCxJQUFjbGhCLE1BQU0sQ0FBQ2tDLGFBQXJCLElBQ0NtSSxFQUFFLENBQUM0MkIsZ0JBQUgsQ0FBb0I1b0IsY0FBcEIsRUFBb0NtQixXQUFwQyxDQVB3QyxFQVN6Qy9mLEdBQUcsQ0FBQ2dPLE1BQUosSUFBYzRDLEVBQUUsQ0FBQ2dvQixlQUFILENBQW1CaGEsY0FBbkIsQ0FUMkI7QUFVekM7QUExR2EsQ0FBZixFOztBQ1BBOzs7O0FBS0E7QUFDTyxJQUFNNm9CLEtBQUssR0FBRztBQUNwQkMsTUFBSSxFQUFFLENBQUMsTUFBRCxFQUFTLGFBQVQsRUFBd0IsbUJBQXhCLEVBQTZDLGlCQUE3QyxFQUFnRSxXQUFoRSxDQURjO0FBRXBCQyxXQUFTLEVBQUUsQ0FBQyxtQkFBRCxFQUFzQixpQkFBdEIsQ0FGUztBQUdwQkMsS0FBRyxFQUFFLENBQUMsS0FBRCxFQUFRLE9BQVIsRUFBaUIsT0FBakIsRUFBMEIsT0FBMUIsQ0FIZTtBQUlwQkMsTUFBSSxFQUFFLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUIsTUFBbkIsRUFBMkIsYUFBM0IsRUFBMEMsbUJBQTFDLEVBQStELGlCQUEvRCxFQUFrRixNQUFsRixFQUEwRixXQUExRixDQUpjO0FBS3BCQyxNQUFJLEVBQUUsQ0FBQyxNQUFELEVBQVMsV0FBVCxDQUxjO0FBTXBCQyxRQUFNLEVBQUUsQ0FBQyxRQUFELEVBQVcsYUFBWCxFQUEwQixtQkFBMUI7QUFOWSxDQUFkLEM7O0FDTlA7Ozs7QUFJQTtBQUNBO0FBRWU7QUFDZC9oQixlQURjLHlCQUNBb0QsU0FEQSxFQUNXL29CLElBRFgsRUFDaUI7QUFDeEIsUUFBQXVRLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDbUNxSyxFQURuQyxDQUNDckssTUFERDtBQUFBLFFBQ2lCMVgsYUFEakIsR0FDbUMraEIsRUFEbkMsQ0FDUzlqQixLQURULENBQ2lCK0IsYUFEakI7QUFHTitoQixNQUFFLENBQUNpWSxjQUFILENBQWtCTyxTQUFsQixFQUE2Qm5yQixPQUE3QixDQUFxQyxVQUFBaFAsRUFBRSxFQUFJO0FBQzFDSixtQkFBYSxDQUFDSSxFQUFELENBQWIsR0FBcUJvUixJQUFJLEtBQUtrRyxNQUFNLENBQUNqVixVQUFQLENBQWtCckMsRUFBbEIsQ0FEWSxFQUUxQ3NYLE1BQU0sQ0FBQ2pWLFVBQVAsQ0FBa0JyQyxFQUFsQixJQUF3Qm9SLElBRmtCO0FBRzFDLEtBSEQsQ0FKOEIsRUFTekIrb0IsU0FUeUIsS0FVN0I3aUIsTUFBTSxDQUFDblYsU0FBUCxHQUFtQmlQLElBVlU7QUFZOUIsR0FiYTtBQWVkeW1CLFNBZmMsbUJBZU56bUIsSUFmTSxFQWVBOHBCLFlBZkEsRUFlYztBQUNyQixRQUFBdlosRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUE0bkIsS0FGQSxHQUVRNW5CLE1BQU0sQ0FBQ2pWLFVBRmY7QUFBQSxRQUdBbWYsT0FIQSxHQUdVMFosWUFBWSxJQUFJdlosRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FIbEM7QUFBQSxRQUlGdUwsR0FKRTtBQXdCTixXQWxCSXZMLE9BQU8sSUFBSUEsT0FBTyxDQUFDNVQsTUFrQnZCLEdBakJDNFQsT0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBMVMsTUFBTSxFQUFJO0FBQ3pCLFVBQU02c0IsQ0FBQyxHQUFHK1YsS0FBSyxDQUFDNWlDLE1BQU0sQ0FBQzBELEVBQVIsQ0FBZjtBQUR5QixPQUdwQm1wQixDQUFDLElBQUlBLENBQUMsQ0FBQ3RaLE9BQUYsQ0FBVXVCLElBQVYsS0FBbUIsQ0FBekIsSUFBZ0MsQ0FBQytYLENBQUQsSUFBTS9YLElBQUksS0FBSyxNQUgxQixNQUl4QjJiLEdBQUcsS0FKcUI7QUFNekIsS0FORCxDQWlCRCxHQVZXamYsTUFBTSxDQUFDQyxJQUFQLENBQVlteEIsS0FBWixFQUFtQnR4QixNQVU5QixHQVRDRSxNQUFNLENBQUNDLElBQVAsQ0FBWW14QixLQUFaLEVBQW1CbHdCLE9BQW5CLENBQTJCLFVBQUFoUCxFQUFFLEVBQUk7QUFDNUJrL0IsV0FBSyxDQUFDbC9CLEVBQUQsQ0FBTCxLQUFjb1IsSUFEYyxLQUUvQjJiLEdBQUcsS0FGNEI7QUFJaEMsS0FKRCxDQVNELEdBSENBLEdBQUcsR0FBR3pWLE1BQU0sQ0FBQ25WLFNBQVAsS0FBcUJpUCxJQUc1QixFQUFPMmIsR0FBUDtBQUNBLEdBekNhOztBQTJDZDs7Ozs7Ozs7QUFRQWdzQixXQW5EYyxxQkFtREozbkMsSUFuREksRUFtREVvUSxPQW5ERixFQW1EV3czQixPQW5EWCxFQW1EeUI7QUFBQTs7QUFDdEMsV0FEd0JBLE9BQ3hCLGdCQUR3QkEsT0FDeEIsR0FEa0MsRUFDbEMsR0FBTyxDQUFDUixLQUFLLENBQUNwbkMsSUFBRCxDQUFMLENBQ1A7QUFETyxLQUVONkMsTUFGTSxDQUVDLFVBQUFySCxDQUFDO0FBQUEsYUFBSW9zQyxPQUFPLENBQUNucEMsT0FBUixDQUFnQmpELENBQWhCLE1BQXVCLENBQUMsQ0FBNUI7QUFBQSxLQUZGLEVBR042SCxLQUhNLENBR0EsVUFBQTdILENBQUM7QUFBQSxhQUFJLENBQUMsS0FBSSxDQUFDaXJCLE9BQUwsQ0FBYWpyQixDQUFiLEVBQWdCNFUsT0FBaEIsQ0FBTDtBQUFBLEtBSEQsQ0FBUjtBQUlBLEdBeERhOztBQTBEZDs7Ozs7OztBQU9Ba2pCLFVBakVjLG9CQWlFTGozQixDQWpFSyxFQWlFRjJELElBakVFLEVBaUVJO0FBQUEsUUFDWHBSLEVBQUUsR0FBRzhNLFFBQVEsQ0FBQ1csQ0FBRCxDQUFSLEdBQWNBLENBQWQsR0FBa0JBLENBQUMsQ0FBQ3pOLEVBRGQ7QUFBQSxRQUVYaTVDLFFBQVEsR0FBRyxLQUFLM2hDLE1BQUwsQ0FBWWpWLFVBQVosQ0FBdUJyQyxFQUF2QixDQUZBO0FBSWpCLFdBQU9rTyxPQUFPLENBQUNrRCxJQUFELENBQVAsR0FDTkEsSUFBSSxDQUFDdkIsT0FBTCxDQUFhb3BDLFFBQWIsS0FBMEIsQ0FEcEIsR0FDd0JBLFFBQVEsS0FBSzduQyxJQUQ1QztBQUVBLEdBdkVhO0FBeUVkOG5DLGNBekVjLDBCQXlFQztBQUNkLFFBQU12M0IsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUNvM0IsU0FBSCxDQUFhLE1BQWIsS0FBd0JwM0IsRUFBRSxDQUFDa1csT0FBSCxDQUFXLFFBQVgsQ0FBeEIsSUFBZ0RsVyxFQUFFLENBQUNrVyxPQUFILENBQVcsU0FBWCxDQUF2RDtBQUNBLEdBN0VhOztBQStFZDs7Ozs7OztBQU9BL0YsWUF0RmMsc0JBc0ZIdFEsT0F0RkcsRUFzRk13M0IsT0F0Rk4sRUFzRmU7QUFDNUIsV0FBTyxLQUFLRCxTQUFMLENBQWUsS0FBZixFQUFzQnYzQixPQUF0QixFQUErQnczQixPQUEvQixDQUFQO0FBQ0EsR0F4RmE7QUEwRmRHLGtCQTFGYyw4QkEwRks7QUFDbEIsV0FBTyxLQUFLdGhCLE9BQUwsQ0FBYSxPQUFiLEtBQXlCLEtBQUt2Z0IsTUFBTCxDQUFZc0YsVUFBWixLQUEyQixPQUEzRDtBQUNBLEdBNUZhO0FBOEZkdTNCLFlBOUZjLHNCQThGSDFtQyxDQTlGRyxFQThGQTtBQUNiLFFBQU16TixFQUFFLEdBQUc4TSxRQUFRLENBQUNXLENBQUQsQ0FBUixHQUFjQSxDQUFkLEdBQWtCQSxDQUFDLENBQUN6TixFQUEvQjtBQUVBLFdBQU8sQ0FBQyxLQUFLc1gsTUFBTCxDQUFZalYsVUFBWixDQUF1QnJDLEVBQXZCLENBQUQsSUFDTixLQUFLMGtDLFFBQUwsQ0FBYzFrQyxFQUFkLEVBQWtCdzRDLEtBQUssQ0FBQ0ksSUFBeEIsQ0FERDtBQUVBLEdBbkdhO0FBcUdkUSxZQXJHYyxzQkFxR0gzckMsQ0FyR0csRUFxR0E7QUFDYixXQUFPLEtBQUtpM0IsUUFBTCxDQUFjajNCLENBQWQsRUFBaUIrcUMsS0FBSyxDQUFDSyxJQUF2QixDQUFQO0FBQ0EsR0F2R2E7QUF5R2RRLGNBekdjLHdCQXlHRDVyQyxDQXpHQyxFQXlHRTtBQUNmLFdBQU8sS0FBS2kzQixRQUFMLENBQWNqM0IsQ0FBZCxFQUFpQitxQyxLQUFLLENBQUNNLE1BQXZCLENBQVA7QUFDQSxHQTNHYTtBQTZHZG5GLFlBN0djLHNCQTZHSGxtQyxDQTdHRyxFQTZHQTtBQUNiLFdBQU8sS0FBS2kzQixRQUFMLENBQWNqM0IsQ0FBZCxFQUFpQitxQyxLQUFLLENBQUNDLElBQXZCLENBQVA7QUFDQSxHQS9HYTtBQWlIZGhnQixpQkFqSGMsMkJBaUhFaHJCLENBakhGLEVBaUhLO0FBQ2xCLFdBQU8sS0FBS2kzQixRQUFMLENBQWNqM0IsQ0FBZCxFQUFpQitxQyxLQUFLLENBQUNFLFNBQXZCLENBQVA7QUFDQSxHQW5IYTtBQXFIZDdiLFdBckhjLHFCQXFISnB2QixDQXJISSxFQXFIRDtBQUNaLFdBQU8sS0FBS2kzQixRQUFMLENBQWNqM0IsQ0FBZCxFQUFpQixLQUFqQixDQUFQO0FBQ0EsR0F2SGE7QUF5SGQ0bUMsY0F6SGMsd0JBeUhENW1DLENBekhDLEVBeUhFO0FBQ2YsV0FBTyxLQUFLaTNCLFFBQUwsQ0FBY2ozQixDQUFkLEVBQWlCLFFBQWpCLENBQVA7QUFDQSxHQTNIYTtBQTZIZDJtQyxlQTdIYyx5QkE2SEEzbUMsQ0E3SEEsRUE2SEc7QUFDaEIsV0FBTyxLQUFLaTNCLFFBQUwsQ0FBY2ozQixDQUFkLEVBQWlCLFNBQWpCLENBQVA7QUFDQSxHQS9IYTtBQWlJZDZyQyxXQWpJYyxxQkFpSUo3ckMsQ0FqSUksRUFpSUQ7QUFDWixXQUFPLEtBQUtpM0IsUUFBTCxDQUFjajNCLENBQWQsRUFBaUIsS0FBakIsQ0FBUDtBQUNBLEdBbklhO0FBcUlkOHJDLGFBckljLHVCQXFJRjlyQyxDQXJJRSxFQXFJQztBQUNkLFdBQU8sS0FBS2kzQixRQUFMLENBQWNqM0IsQ0FBZCxFQUFpQixPQUFqQixDQUFQO0FBQ0EsR0F2SWE7QUF5SWQrckMsYUF6SWMsdUJBeUlGL3JDLENBeklFLEVBeUlDO0FBQ2QsV0FBTyxLQUFLaTNCLFFBQUwsQ0FBY2ozQixDQUFkLEVBQWlCLE9BQWpCLENBQVA7QUFDQSxHQTNJYTtBQTZJZGtsQyxhQTdJYyx1QkE2SUZsbEMsQ0E3SUUsRUE2SUM7QUFDZCxXQUFPLEtBQUtpM0IsUUFBTCxDQUFjajNCLENBQWQsRUFBaUIsT0FBakIsQ0FBUDtBQUNBLEdBL0lhO0FBaUpkZ3NDLFdBakpjLHFCQWlKSmhzQyxDQWpKSSxFQWlKRDtBQUNaLFdBQU8sS0FBSzZyQyxTQUFMLENBQWU3ckMsQ0FBZixLQUNOLEtBQUsrckMsV0FBTCxDQUFpQi9yQyxDQUFqQixDQURNLElBRU4sS0FBSzhyQyxXQUFMLENBQWlCOXJDLENBQWpCLENBRk0sSUFHTixLQUFLa2xDLFdBQUwsQ0FBaUJsbEMsQ0FBakIsQ0FIRDtBQUlBLEdBdEphO0FBd0pkO0FBQ0Fpc0MsZUF6SmMsMkJBeUpFO0FBQ1QsUUFBQ3BpQyxNQUFELEdBQVcsSUFBWCxDQUFDQSxNQUFEO0FBQUEsUUFDQTZyQixPQURBLEdBQ1U3ckIsTUFBTSxDQUFDK0IsYUFEakI7QUFHTixXQUFPL0IsTUFBTSxDQUFDaUMsVUFBUCxLQUFzQixRQUF0QixLQUNMLENBQUM0cEIsT0FBRCxJQUFhajFCLE9BQU8sQ0FBQ2kxQixPQUFELENBQVAsSUFBb0JBLE9BQU8sQ0FBQ3YxQixNQUFSLEtBQW1CLENBRC9DLENBQVA7QUFFQSxHQS9KYTtBQWlLZCtyQyxVQWpLYyxvQkFpS0xsc0MsQ0FqS0ssRUFpS0Y7QUFDWCxXQUFPLEtBQUswbUMsVUFBTCxDQUFnQjFtQyxDQUFoQixJQUFxQixDQUFDQSxDQUFELENBQXJCLEdBQTJCLEVBQWxDO0FBQ0EsR0FuS2E7QUFxS2Rtc0MsU0FyS2MsbUJBcUtObnNDLENBcktNLEVBcUtIO0FBQ1YsV0FBTyxLQUFLZ3NDLFNBQUwsQ0FBZWhzQyxDQUFDLENBQUNxRyxJQUFqQixJQUF5QixDQUFDckcsQ0FBRCxDQUF6QixHQUErQixFQUF0QztBQUNBLEdBdkthO0FBeUtkb3NDLFNBektjLG1CQXlLTnBzQyxDQXpLTSxFQXlLSDtBQUNWLFdBQU8sS0FBS292QixTQUFMLENBQWVwdkIsQ0FBZixJQUFvQkEsQ0FBQyxDQUFDb1UsTUFBdEIsR0FBK0IsRUFBdEM7QUFDQSxHQTNLYTs7QUE2S2Q7Ozs7OztBQU1BNndCLGNBbkxjLHdCQW1MRGpsQyxDQW5MQyxFQW1MRTtBQUNmLFdBQU8sS0FBS292QixTQUFMLENBQWVwdkIsQ0FBZixLQUNOLEtBQUswbUMsVUFBTCxDQUFnQjFtQyxDQUFoQixDQURNLElBRU4sS0FBSzJtQyxhQUFMLENBQW1CM21DLENBQW5CLENBRk0sSUFHTixLQUFLNG1DLFlBQUwsQ0FBa0I1bUMsQ0FBbEIsQ0FITSxJQUlOLEtBQUtrbEMsV0FBTCxDQUFpQmxsQyxDQUFqQixDQUpNLEdBSWdCQSxDQUFDLENBQUNvVSxNQUpsQixHQUkyQixFQUpsQztBQUtBLEdBekxhO0FBMkxkaTRCLG1CQTNMYyw2QkEyTElyc0MsQ0EzTEosRUEyTE87QUFDcEIsV0FBTyxLQUFLb3ZCLFNBQUwsQ0FBZXB2QixDQUFmLEtBQXFCLEtBQUswbUMsVUFBTCxDQUFnQjFtQyxDQUFoQixDQUFyQixJQUEyQyxLQUFLNG1DLFlBQUwsQ0FBa0I1bUMsQ0FBbEIsQ0FBM0MsR0FDTkEsQ0FBQyxDQUFDb1UsTUFESSxHQUNLLEVBRFo7QUFFQSxHQTlMYTtBQWdNZDtBQUNBazRCLHFCQWpNYywrQkFpTU0zb0MsSUFqTU4sRUFpTTZCO0FBQzFDLFdBQU8sQ0FDTixPQURNLEVBRU4sY0FGTSxFQUdOLFlBSE0sRUFJTixRQUpNLEVBS04sVUFMTSxFQU1OLGlCQU5NLEVBT04sZUFQTSxFQVFOLGFBUk0sRUFTTixvQkFUTSxFQVVOLGtCQVZNLEVBV04sUUFYTSxFQVlOLGVBWk0sRUFhTixZQWJNLEVBY04sWUFkTSxFQWVOLFNBZk0sRUFnQkx2QixPQWhCSyxDQWdCR3VCLElBaEJILEtBZ0JZLENBaEJuQjtBQWlCQTtBQW5OYSxDQUFmLEU7O0FDUEE7Ozs7QUFJQTtBQUVBOzs7Ozs7Ozs7QUFRQSxTQUFTNG9DLFNBQVQsQ0FBbUJyNEIsRUFBbkIsRUFBdUJ2USxJQUF2QixFQUE0Q3RDLEtBQTVDLEVBQW1EO0FBQzVDLE1BQUN3SSxNQUFELEdBQVdxSyxFQUFYLENBQUNySyxNQUFEO0FBQUEsTUFFQWhmLEtBRkEsZUFFa0I4WSxJQUZsQjtBQUFBLE1BR0E3WSxNQUhBLGdCQUdvQjZZLElBSHBCO0FBcUJOLFNBaEJJbkUsU0FBUyxDQUFDNkIsS0FBRCxDQWdCYixLQWZLcEIsWUFBWSxDQUFDb0IsS0FBRCxDQWVqQixJQWRFbkMsT0FBTyxDQUFDbUMsS0FBSyxDQUFDeFAsQ0FBUCxDQUFQLEtBQXFCZ1ksTUFBTSxhQU5MbEcsSUFNSyxDQUFOLEdBQWdCdEMsS0FBSyxDQUFDeFAsQ0FBM0MsQ0FjRixFQWJFcU4sT0FBTyxDQUFDbUMsS0FBSyxDQUFDclAsQ0FBUCxDQUFQLEtBQXFCNlgsTUFBTSxDQUFDaGYsS0FBRCxDQUFOLEdBQWdCd1csS0FBSyxDQUFDclAsQ0FBM0MsQ0FhRixFQVpFa04sT0FBTyxDQUFDbUMsS0FBSyxDQUFDcFAsRUFBUCxDQUFQLEtBQXNCNFgsTUFBTSxDQUFDL2UsTUFBRCxDQUFOLEdBQWlCdVcsS0FBSyxDQUFDcFAsRUFBN0MsQ0FZRixLQVZFNFgsTUFBTSxDQUFDaGYsS0FBRCxDQUFOLEdBQWdCd1csS0FVbEIsRUFURXdJLE1BQU0sQ0FBQy9lLE1BQUQsQ0FBTixHQUFpQnVXLEtBU25CLEdBTkM2UyxFQUFFLENBQUNrUCxNQUFILENBQVU7QUFDVHdPLHdCQUFvQixJQURYO0FBRVRDLHFCQUFpQjtBQUZSLEdBQVYsQ0FNRCxHQUFPbDlCLFNBQVA7QUFDQTtBQUVEOzs7Ozs7Ozs7QUFPQSxTQUFTdVMsY0FBVCxDQUFtQmdOLEVBQW5CLEVBQXVCdlEsSUFBdkIsRUFBZ0Y7QUFBQSxNQUN4RWtHLE1BRHdFLEdBQzlEcUssRUFEOEQsQ0FDeEVySyxNQUR3RTtBQUcvRSxTQUFPO0FBQ05oWSxLQUFDLEVBQUVnWSxNQUFNLGFBQVdsRyxJQUFYLENBREg7QUFFTjNSLEtBQUMsRUFBRTZYLE1BQU0sYUFBV2xHLElBQVgsQ0FGSDtBQUdOMVIsTUFBRSxFQUFFNFgsTUFBTSxjQUFZbEcsSUFBWjtBQUhKLEdBQVA7QUFLQTtBQUVEOzs7Ozs7QUFJQSxJQUFNalosYUFBSSxHQUFHO0FBQ1o7Ozs7Ozs7Ozs7Ozs7QUFhQXkzQixRQUFNLEVBQUUsZ0JBQVNBLE9BQVQsRUFBd0Q7QUFDL0QsUUFBTWpPLEVBQUUsR0FBRyxLQUFLazJCLFFBQWhCO0FBRUlqdkIsYUFBUyxDQUFDaGIsTUFIaUQsS0FJOURFLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZNmhCLE9BQVosRUFBb0I1Z0IsT0FBcEIsQ0FBNEIsVUFBQTZhLE1BQU0sRUFBSTtBQUNyQ2xJLFFBQUUsQ0FBQ3hwQixJQUFILENBQVF3MEIsWUFBUixDQUFxQjlDLE1BQXJCLEVBQTZCK0YsT0FBTSxDQUFDL0YsTUFBRCxDQUFuQyxDQURxQztBQUVyQyxLQUZELENBSjhELEVBUTlEbEksRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXUzQixZQUFSLEVBUjhEO0FBVS9ELEdBeEJXOztBQTBCWjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTllLEtBQUcsRUFBRSxhQUFTQSxJQUFULEVBQXVCO0FBQzNCLFFBQU0rUSxFQUFFLEdBQUcsS0FBS2syQixRQUFoQjtBQUVBLFdBQU9sckMsT0FBTyxDQUFDaUUsSUFBRCxDQUFQLEdBQ05vcEMsU0FBUyxDQUFDcjRCLEVBQUQsRUFBSyxLQUFMLEVBQVkvUSxJQUFaLENBREgsR0FFTitELGNBQVMsQ0FBQ2dOLEVBQUQsRUFBSyxLQUFMLENBRlY7QUFHQSxHQWhEVzs7QUFrRFo7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE0QyxLQUFHLEVBQUUsYUFBU0EsSUFBVCxFQUF1QjtBQUMzQixRQUFNNUMsRUFBRSxHQUFHLEtBQUtrMkIsUUFBaEI7QUFFQSxXQUFPanZCLFNBQVMsQ0FBQ2hiLE1BQVYsR0FDTm9zQyxTQUFTLENBQUNyNEIsRUFBRCxFQUFLLEtBQUwsRUFBWTRDLElBQVosQ0FESCxHQUVONVAsY0FBUyxDQUFDZ04sRUFBRCxFQUFLLEtBQUwsQ0FGVjtBQUdBLEdBeEVXOztBQTBFWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBUyxPQUFLLEVBQUUsZUFBU0EsTUFBVCxFQUFnQjtBQUFBLFFBQ2ZqcUIsSUFEZSxHQUNQLElBRE8sQ0FDZkEsSUFEZTtBQUd0QixRQUFJeXdCLFNBQVMsQ0FBQ2hiLE1BQWQsRUFDQ1gsU0FBUyxDQUFDbVYsTUFBSyxDQUFDbUMsR0FBUCxDQUFULElBQXdCcHNCLElBQUksQ0FBQ29zQixHQUFMLENBQVNuQyxNQUFLLENBQUNtQyxHQUFmLENBRHpCLEVBRUN0WCxTQUFTLENBQUNtVixNQUFLLENBQUN4UixHQUFQLENBQVQsSUFBd0J6WSxJQUFJLENBQUN5WSxHQUFMLENBQVN3UixNQUFLLENBQUN4UixHQUFmLENBRnpCLE1BSUMsT0FBTztBQUNOMlQsU0FBRyxFQUFFcHNCLElBQUksQ0FBQ29zQixHQUFMLEVBREM7QUFFTjNULFNBQUcsRUFBRXpZLElBQUksQ0FBQ3lZLEdBQUw7QUFGQyxLQUFQO0FBTUQsV0FBT3hPLFNBQVA7QUFDQTtBQTdHVyxDQUFiO0FBZ0hlO0FBQUNqSyxNQUFJLEVBQUpBLGFBQUlBO0FBQUwsQ0FBZixFOztBQzVLQTs7OztBQUllO0FBQ2Q7Ozs7Ozs7Ozs7QUFVQThoRCxVQVhjLG9CQVdMN3BDLENBWEssRUFXTTZwQyxTQVhOLEVBV3dCO0FBQy9CLFFBQUF0NEIsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQVFOLFdBTElzUixTQUFTLENBQUNoYixNQUFWLEdBQW1CLENBS3ZCLEtBSkMwSixNQUFNLENBQUN6UCxpQkFBUCxDQUF5QnVJLENBQXpCLElBQThCNnBDLFNBSS9CLEVBSEN0NEIsRUFBRSxDQUFDa1AsTUFBSCxFQUdELEdBQU92WixNQUFNLENBQUN6UCxpQkFBUCxDQUF5QnVJLENBQXpCLENBQVA7QUFDQSxHQXJCYTs7QUF1QmQ7Ozs7Ozs7Ozs7O0FBV0FvYixZQWxDYyxzQkFrQ0hBLFdBbENHLEVBa0NtQjtBQUMxQixRQUFBN0osRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUQwQixXQUkzQnNSLFNBQVMsQ0FBQ2hiLE1BSmlCLElBUWhDMEosTUFBTSxDQUFDelAsaUJBQVAsR0FBMkIyakIsV0FSSyxFQVNoQzdKLEVBQUUsQ0FBQ2tQLE1BQUgsRUFUZ0MsRUFXekJ2WixNQUFNLENBQUN6UCxpQkFYa0IsSUFLeEJ5UCxNQUFNLENBQUN6UCxpQkFMaUI7QUFZaEM7QUE5Q2EsQ0FBZixFOztBQ0pBOzs7O0FBSUE7QUFFZTtBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaURBd3BCLE1BbERjLGdCQWtEVGppQixJQWxEUyxFQWtESDtBQUFBLFFBRU4wRSxJQUZNO0FBQUEsUUFHTnRVLE1BSE07QUFBQSxRQU1Oc1EsSUFOTTtBQUFBLFFBT05vcUMsRUFQTTtBQUFBLFFBQ0p2NEIsRUFBRSxHQUFHLEtBQUtrMkIsUUFETjtBQUFBLFFBSU5qcUMsTUFBYyxHQUFHLENBSlg7QUFBQSxRQUtOdXNDLElBQUksR0FBRyxDQUxEOztBQWFWLFNBSkkvcUMsSUFBSSxDQUFDMmpCLElBQUwsSUFBYTNqQixJQUFJLENBQUM2akIsSUFBbEIsSUFBMEI3akIsSUFBSSxDQUFDK2pCLE9BSW5DLE1BSENyZixJQUFJLEdBQUc2TixFQUFFLENBQUM4USxXQUFILENBQWVyakIsSUFBZixDQUdSLEdBQUswRSxJQUFELElBQVUyRCxZQUFZLEVBQTFCO0FBQUEsVUFJTTJpQyxXQUFxQixHQUFHLEVBSjlCO0FBQUEsVUFLTUMsWUFBWSxHQUFHMTRCLEVBQUUsQ0FBQytYLGVBQUgsRUFMckI7QUFBQSxVQU1NbFksT0FBTyxHQUFHRyxFQUFFLENBQUNnVSxvQkFBSCxDQUF3QjdoQixJQUF4QixLQU5oQjtBQVNBNk4sUUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQnhTLE9BQWhCLENBQXdCLFVBQUFtYSxDQUFDLEVBQUk7QUFHNUIsaUJBRklwYSxLQUFLLEtBRVQsRUFBU3FCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvUixPQUFPLENBQUM1VCxNQUE1QixFQUFvQ3dDLENBQUMsRUFBckMsRUFDQyxJQUFJK1ksQ0FBQyxDQUFDbnBCLEVBQUYsS0FBU3doQixPQUFPLENBQUNwUixDQUFELENBQVAsQ0FBV3BRLEVBQXhCLEVBQTRCO0FBQzNCK08sZUFBSyxLQURzQixFQUd2Qm9hLENBQUMsQ0FBQ3RILE1BQUYsQ0FBU3NILENBQUMsQ0FBQ3RILE1BQUYsQ0FBU2pVLE1BQVQsR0FBa0IsQ0FBM0IsQ0FIdUIsS0FJMUJ1c0MsSUFBSSxHQUFHaHhCLENBQUMsQ0FBQ3RILE1BQUYsQ0FBU3NILENBQUMsQ0FBQ3RILE1BQUYsQ0FBU2pVLE1BQVQsR0FBa0IsQ0FBM0IsRUFBOEJvWixLQUE5QixHQUFzQyxDQUpuQixHQU8zQnBaLE1BQU0sR0FBRzRULE9BQU8sQ0FBQ3BSLENBQUQsQ0FBUCxDQUFXeVIsTUFBWCxDQUFrQmpVLE1BUEE7O0FBUzNCLGVBQUssSUFBSTZuQixHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHN25CLE1BQXBCLEVBQTRCNm5CLEdBQUMsRUFBN0IsRUFDQ2pVLE9BQU8sQ0FBQ3BSLENBQUQsQ0FBUCxDQUFXeVIsTUFBWCxDQUFrQjRULEdBQWxCLEVBQXFCek8sS0FBckIsR0FBNkJtekIsSUFBSSxHQUFHMWtCLEdBRHJDLEVBR005VCxFQUFFLENBQUM4SixZQUFILEVBSE4sS0FJRWpLLE9BQU8sQ0FBQ3BSLENBQUQsQ0FBUCxDQUFXeVIsTUFBWCxDQUFrQjRULEdBQWxCLEVBQXFCbjJCLENBQXJCLEdBQXlCNjZDLElBQUksR0FBRzFrQixHQUpsQzs7QUFRQXRNLFdBQUMsQ0FBQ3RILE1BQUYsR0FBV3NILENBQUMsQ0FBQ3RILE1BQUYsQ0FBUy9PLE1BQVQsQ0FBZ0IwTyxPQUFPLENBQUNwUixDQUFELENBQVAsQ0FBV3lSLE1BQTNCLENBakJnQixFQWtCM0JMLE9BQU8sQ0FBQzJkLE1BQVIsQ0FBZS91QixDQUFmLEVBQWtCLENBQWxCLENBbEIyQjtBQW1CM0I7QUFDQTs7QUFHRHJCLGFBQUQsSUFBVXFyQyxXQUFXLENBQUNwbEMsSUFBWixDQUFpQm1VLENBQUMsQ0FBQ25wQixFQUFuQixDQTNCa0I7QUE0QjVCLE9BNUJELENBVEEsRUF3Q0EyaEIsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQnhTLE9BQWhCLENBQXdCLFVBQUFtYSxDQUFDLEVBQUk7QUFDNUIsYUFBSyxJQUFJL1ksRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBR2dxQyxXQUFXLENBQUN4c0MsTUFBaEMsRUFBd0N3QyxFQUFDLEVBQXpDLEVBQ0MsSUFBSStZLENBQUMsQ0FBQ25wQixFQUFGLEtBQVNvNkMsV0FBVyxDQUFDaHFDLEVBQUQsQ0FBeEIsRUFBNkI7QUFDNUIrcEMsY0FBSSxHQUFHaHhCLENBQUMsQ0FBQ3RILE1BQUYsQ0FBU3NILENBQUMsQ0FBQ3RILE1BQUYsQ0FBU2pVLE1BQVQsR0FBa0IsQ0FBM0IsRUFBOEJvWixLQUE5QixHQUFzQyxDQURqQjs7QUFHNUIsZUFBSyxJQUFJeU8sR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBRzduQixNQUFwQixFQUE0QjZuQixHQUFDLEVBQTdCLEVBQ0N0TSxDQUFDLENBQUN0SCxNQUFGLENBQVM3TSxJQUFULENBQWM7QUFDYmhWLGNBQUUsRUFBRW1wQixDQUFDLENBQUNucEIsRUFETztBQUViZ25CLGlCQUFLLEVBQUVtekIsSUFBSSxHQUFHMWtCLEdBRkQ7QUFHYm4yQixhQUFDLEVBQUVxaUIsRUFBRSxDQUFDOEosWUFBSCxLQUFvQjlKLEVBQUUsQ0FBQytWLGVBQUgsQ0FBbUJ5aUIsSUFBSSxHQUFHMWtCLEdBQTFCLENBQXBCLEdBQW1EMGtCLElBQUksR0FBRzFrQixHQUhoRDtBQUliM21CLGlCQUFLLEVBQUU7QUFKTSxXQUFkLENBREQ7QUFRQTtBQUVGLE9BZkQsQ0F4Q0EsRUEwREk2UyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCNVQsTUExRHBCLElBMkRDNFQsT0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBbWEsQ0FBQyxFQUFJO0FBR3BCLGlCQUZNbXhCLE9BQWMsR0FBRyxFQUV2QixFQUFTbHFDLENBQUMsR0FBR3VSLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQVIsQ0FBZ0IsQ0FBaEIsRUFBbUJLLE1BQW5CLENBQTBCLENBQTFCLEVBQTZCbUYsS0FBMUMsRUFBaUQ1VyxDQUFDLEdBQUcrcEMsSUFBckQsRUFBMkQvcEMsQ0FBQyxFQUE1RCxFQUNDa3FDLE9BQU8sQ0FBQ3RsQyxJQUFSLENBQWE7QUFDWmhWLFlBQUUsRUFBRW1wQixDQUFDLENBQUNucEIsRUFETTtBQUVaZ25CLGVBQUssRUFBRTVXLENBRks7QUFHWjlRLFdBQUMsRUFBRXFpQixFQUFFLENBQUM4SixZQUFILEtBQW9COUosRUFBRSxDQUFDK1YsZUFBSCxDQUFtQnRuQixDQUFuQixDQUFwQixHQUE0Q0EsQ0FIbkM7QUFJWnRCLGVBQUssRUFBRTtBQUpLLFNBQWIsQ0FERDs7QUFTQXFhLFNBQUMsQ0FBQ3RILE1BQUYsQ0FBUzdTLE9BQVQsQ0FBaUIsVUFBQXBDLENBQUMsRUFBSTtBQUNyQkEsV0FBQyxDQUFDb2EsS0FBRixJQUFXbXpCLElBRFUsRUFHaEJ4NEIsRUFBRSxDQUFDOEosWUFBSCxFQUhnQixLQUlwQjdlLENBQUMsQ0FBQ3ROLENBQUYsSUFBTzY2QyxJQUphO0FBTXJCLFNBTkQsQ0Fab0IsRUFvQnBCaHhCLENBQUMsQ0FBQ3RILE1BQUYsR0FBV3k0QixPQUFPLENBQUN4bkMsTUFBUixDQUFlcVcsQ0FBQyxDQUFDdEgsTUFBakIsQ0FwQlM7QUFxQnBCLE9BckJELENBM0RELEVBbUZBRixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLEdBQWtCRyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCMU8sTUFBaEIsQ0FBdUIwTyxPQUF2QixDQW5GbEI7QUFtRm1EO0FBRW5EO0FBQ0E7QUF0RkEsVUF1Rk0rNEIsVUFBVSxHQUFHNTRCLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQVIsQ0FBZ0IsQ0FBaEIsQ0F2Rm5CO0FBQUEsVUF3Rk1nNUIsU0FBUyxHQUFHRCxVQUFVLENBQUMxNEIsTUFBWCxDQUFrQixDQUFsQixDQXhGbEI7QUEyRkk1VSxlQUFTLENBQUNtQyxJQUFJLENBQUM4cUMsRUFBTixDQTNGYixJQTRGQ3RzQyxNQUFNLEdBQUcsQ0E1RlYsRUE2RkNzc0MsRUFBRSxHQUFHdjRCLEVBQUUsQ0FBQzhKLFlBQUgsS0FBb0J0VSxTQUFTLENBQUM5SCxJQUFWLENBQWVzUyxFQUFmLEVBQW1CdlMsSUFBSSxDQUFDOHFDLEVBQXhCLENBQXBCLEdBQWtEOXFDLElBQUksQ0FBQzhxQyxFQTdGN0QsRUErRkNLLFVBQVUsQ0FBQzE0QixNQUFYLENBQWtCN1MsT0FBbEIsQ0FBMEIsVUFBQXBDLENBQUMsRUFBSTtBQUM5QkEsU0FBQyxDQUFDdE4sQ0FBRixHQUFNNDZDLEVBQU4sSUFBWXRzQyxNQUFNLEVBRFk7QUFFOUIsT0FGRCxDQS9GRCxJQWtHV1gsU0FBUyxDQUFDbUMsSUFBSSxDQUFDeEIsTUFBTixDQWxHcEIsS0FtR0NBLE1BQU0sR0FBR3dCLElBQUksQ0FBQ3hCLE1BbkdmLEdBdUdLeXNDLFlBdkdMLEdBaUhXQSxZQUFZLEtBQUssQ0FBakIsSUFBc0IxNEIsRUFBRSxDQUFDOEosWUFBSCxFQWpIakMsS0FrSEMzYixJQUFJLEdBQUcsQ0FBQ3lxQyxVQUFVLENBQUMxNEIsTUFBWCxDQUFrQjA0QixVQUFVLENBQUMxNEIsTUFBWCxDQUFrQmpVLE1BQWxCLEdBQTJCLENBQTdDLEVBQWdEdE8sQ0FBaEQsR0FBb0RrN0MsU0FBUyxDQUFDbDdDLENBQS9ELElBQW9FLENBbEg1RSxFQW1IQ0UsTUFBTSxHQUFHLENBQUMsSUFBSXFPLElBQUosQ0FBUyxDQUFDMnNDLFNBQVMsQ0FBQ2w3QyxDQUFYLEdBQWV3USxJQUF4QixDQUFELEVBQWdDLElBQUlqQyxJQUFKLENBQVMsQ0FBQzJzQyxTQUFTLENBQUNsN0MsQ0FBWCxHQUFld1EsSUFBeEIsQ0FBaEMsQ0FuSFYsS0F5R0VBLElBekdGLEdBd0dLNlIsRUFBRSxDQUFDOEosWUFBSCxFQXhHTCxHQXlHUzh1QixVQUFVLENBQUMxNEIsTUFBWCxDQUFrQmpVLE1BQWxCLEdBQTJCLENBQTNCLEdBQ04yc0MsVUFBVSxDQUFDMTRCLE1BQVgsQ0FBa0IwNEIsVUFBVSxDQUFDMTRCLE1BQVgsQ0FBa0JqVSxNQUFsQixHQUEyQixDQUE3QyxFQUFnRHRPLENBQWhELEdBQW9EazdDLFNBQVMsQ0FBQ2w3QyxDQUR4RCxHQUVOazdDLFNBQVMsQ0FBQ2w3QyxDQUFWLEdBQWNxaUIsRUFBRSxDQUFDa2xCLFVBQUgsQ0FBY2xsQixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUF0QixFQUErQixDQUEvQixDQTNHakIsR0E2R1MsQ0E3R1QsRUFnSENoaUIsTUFBTSxHQUFHLENBQUNnN0MsU0FBUyxDQUFDbDdDLENBQVYsR0FBY3dRLElBQWYsRUFBcUIwcUMsU0FBUyxDQUFDbDdDLENBQS9CLENBaEhWLEdBc0hBRSxNQUFNLElBQUltaUIsRUFBRSxDQUFDNlAsYUFBSCxDQUFpQixJQUFqQixjQUEwQ2h5QixNQUExQyxDQXRIVixFQXlIQW1pQixFQUFFLENBQUN5ZCxhQUFILENBQWlCemQsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBekIsQ0F6SEEsRUE0SEFHLEVBQUUsQ0FBQ2tQLE1BQUgsQ0FBVTtBQUNUUSxZQUFJLEVBQUU7QUFDTHJLLGVBQUssRUFBRXd6QixTQUFTLENBQUN4ekIsS0FEWjtBQUVMcFosZ0JBQU0sRUFBRUEsTUFGSDtBQUdMOGlCLGtCQUFRLEVBQUUvakIsT0FBTyxDQUFDeUMsSUFBSSxDQUFDc2hCLFFBQU4sQ0FBUCxHQUF5QnRoQixJQUFJLENBQUNzaEIsUUFBOUIsR0FBeUMvTyxFQUFFLENBQUNySyxNQUFILENBQVV1SixtQkFIeEQ7QUFJTHlTLGNBQUksRUFBRWxrQixJQUFJLENBQUNra0IsSUFKTjtBQUtMK21CLHNCQUFZLEVBQUVBO0FBTFQsU0FERztBQVFUdmMsa0JBQVUsSUFSRDtBQVNUbk8sc0JBQWMsRUFBRTBxQixZQUFZLEdBQUcsQ0FUdEI7QUFVVEksdUJBQWUsSUFWTjtBQVdUQyx1QkFBZTtBQVhOLE9BQVYsQ0E1SEE7QUFBQTtBQXlJQTtBQXhNYSxDQUFmLEU7O0FDTkE7Ozs7QUFJQTtBQUVBOzs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVN6OUMsTUFBVCxDQUFnQjA5QyxLQUFoQixFQUEwRDtBQUNuRCxNQUFBaDVCLEVBQUUsR0FBRyxLQUFLazJCLFFBQVY7QUFBQSxNQUNDdmdDLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFEbUQsU0FJcERxakMsS0FKb0QsSUFRekRyakMsTUFBTSxDQUFDaUIsWUFBUCxHQUFzQm9pQyxLQVJtQyxFQVN6RGg1QixFQUFFLENBQUNpNUIsb0JBQUgsRUFUeUQsRUFXbER0akMsTUFBTSxDQUFDaUIsWUFYMkMsSUFLakRqQixNQUFNLENBQUNpQixZQUwwQztBQVl6RDs7QUFFRHZHLE1BQU0sQ0FBQy9VLE1BQUQsRUFBUztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBaWtCLEtBQUcsRUFBRSxhQUFTeTVCLEtBQVQsRUFBbUQ7QUFDdkQsV0FBTyxLQUFLMTlDLE1BQUwsQ0FDTixLQUFLNDZDLFFBQUwsQ0FBY3ZnQyxNQUFkLENBQXFCaUIsWUFBckIsQ0FDRXpGLE1BREYsQ0FDUzZuQyxLQUFLLElBQUksRUFEbEIsQ0FETSxDQUFQO0FBSUEsR0F6QmE7O0FBMkJkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBcjVCLFFBQU0sRUFBRSxnQkFBU3pMLE1BQVQsRUFBb0Q7QUFBRTtBQUM3RCxTQUFLZ2lDLFFBQUwsQ0FBY2dELGVBQWQsQ0FBOEJobEMsTUFBOUIsS0FEMkQ7QUFFM0Q7QUFoRGEsQ0FBVCxDO0FBbURTO0FBQUM1WSxRQUFNLEVBQU5BO0FBQUQsQ0FBZixFOztBQ3BGQTs7OztBQUlBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBYUEsU0FBU0ssTUFBVCxDQUFnQnE5QyxLQUFoQixFQUEwRDtBQUNuRCxNQUFBaDVCLEVBQUUsR0FBRyxLQUFLazJCLFFBQVY7QUFBQSxNQUNDdmdDLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFHTixNQUFJLENBQUNxakMsS0FBTCxFQUNDLE9BQU9yakMsTUFBTSxDQUFDbUIsWUFBZDtBQUdEbkIsUUFBTSxDQUFDbUIsWUFBUCxHQUFzQmtpQyxLQVJtQzs7QUFRN0JHLE1BQUksRUFBQztBQUNqQ241QixJQUFFLENBQUNpNUIsb0JBQUg7O0FBRUEsU0FBT3RqQyxNQUFNLENBQUNtQixZQUFkO0FBQ0E7O0FBRUR6RyxNQUFNLENBQUMxVSxNQUFELEVBQVM7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTRqQixLQUFHLEVBQUUsYUFBU3k1QixLQUFULEVBQW1EO0FBQ3ZELFdBQU8sS0FBS3I5QyxNQUFMLENBQ04sS0FBS3U2QyxRQUFMLENBQWN2Z0MsTUFBZCxDQUFxQm1CLFlBQXJCLENBQ0UzRixNQURGLENBQ1M2bkMsS0FBSyxJQUFJLEVBRGxCLENBRE0sQ0FBUDtBQUlBLEdBekJhOztBQTJCZDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQXI1QixRQUFNLEVBQUUsZ0JBQVN6TCxNQUFULEVBQW9EO0FBQUU7QUFDN0QsU0FBS2dpQyxRQUFMLENBQWNnRCxlQUFkLENBQThCaGxDLE1BQTlCLEtBRDJEO0FBRTNEO0FBaERhLENBQVQsQztBQW1EUztBQUFDdlksUUFBTSxFQUFOQTtBQUFELENBQWYsRTs7QUNwRkE7Ozs7QUFJQTtBQUVlO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7QUFhQXk5QyxRQWRjLGtCQWNQQSxPQWRPLEVBY3lCO0FBQ2hDLFFBQUFwNUIsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQURnQyxXQUlsQ3RLLFdBQVcsQ0FBQyt0QyxPQUFELENBSnVCLEdBSzlCempDLE1BQU0sQ0FBQzNRLFdBTHVCLElBUXRDMlEsTUFBTSxDQUFDM1EsV0FBUCxHQUFxQm8wQyxPQVJpQixFQVN0Q3A1QixFQUFFLENBQUNrUCxNQUFILEVBVHNDLEVBVy9CdlosTUFBTSxDQUFDM1EsV0FYd0I7QUFZdEM7QUExQmEsQ0FBZixFOztBQ05BOzs7O0FBSUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFjQSxTQUFTL0ssZUFBVCxDQUFpQkEsT0FBakIsRUFBaUc7QUFDMUYsTUFBQStsQixFQUFFLEdBQUcsS0FBS2syQixRQUFWO0FBQUEsTUFDQ3ZnQyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBRDBGLFNBSTNGMWIsT0FKMkYsSUFRaEcwYixNQUFNLENBQUMxYixPQUFQLEdBQWlCQSxPQVIrRSxFQVNoRytsQixFQUFFLENBQUNpNUIsb0JBQUgsRUFUZ0csRUFXekZoL0MsT0FYeUYsSUFLeEYwYixNQUFNLENBQUMxYixPQUxpRjtBQVloRzs7QUFFRG9XLE1BQU0sQ0FBQ3BXLGVBQUQsRUFBVTtBQUNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQXNsQixLQUFHLEVBQUUsYUFBU3RsQixPQUFULEVBQWtCO0FBQ2hCLFFBQUErbEIsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQURnQixXQUlqQjFiLE9BSmlCLElBUXRCMGIsTUFBTSxDQUFDMWIsT0FBUCxHQUFpQjBiLE1BQU0sQ0FBQzFiLE9BQVAsQ0FBZWtYLE1BQWYsQ0FBc0JsWCxPQUF0QixDQVJLLEVBU3RCK2xCLEVBQUUsQ0FBQ2k1QixvQkFBSCxFQVRzQixFQVdmdGpDLE1BQU0sQ0FBQzFiLE9BWFEsSUFLZDBiLE1BQU0sQ0FBQzFiLE9BTE87QUFZdEIsR0FqQ2M7O0FBbUNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBMGxCLFFBQU0sRUFBRSxnQkFBUzA1QixZQUFULEVBQXVCO0FBQ3hCLFFBQUFyNUIsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBR0E3SSxPQUhBLEdBR1V1c0MsWUFBWSxJQUFJLEVBSDFCO0FBQUEsUUFJQXRxQixRQUpBLEdBSVdsaUIsU0FBUyxDQUFDQyxPQUFELEVBQVUsVUFBVixFQUFzQjZJLE1BQU0sQ0FBQ3VKLG1CQUE3QixDQUpwQjtBQUFBLFFBS0F1Z0IsT0FMQSxHQUtVNXlCLFNBQVMsQ0FBQ0MsT0FBRCxFQUFVLFNBQVYsRUFBcUIsQ0FBQzZDLGNBQUssQ0FBQzNWLE1BQVAsQ0FBckIsQ0FMbkI7QUFBQSxRQU1GQyxPQU5FLEdBTVErbEIsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlHLE1BQVosT0FBdUJDLGNBQUssQ0FBQzFWLE9BQTdCLEVBQ1p3cUIsU0FEWSxDQUNGZ2IsT0FBTyxDQUFDcnhCLEdBQVIsQ0FBWSxVQUFBNEQsQ0FBQztBQUFBLG1CQUFRQSxDQUFSO0FBQUEsS0FBYixDQURFLENBTlI7QUFxQ04sV0E1QkEsQ0FBQytjLFFBQVEsR0FBRzkwQixPQUFPLENBQUNnb0IsVUFBUixHQUFxQjhNLFFBQXJCLENBQThCQSxRQUE5QixDQUFILEdBQTZDOTBCLE9BQXRELEVBQ0U4cUIsS0FERixDQUNRLFNBRFIsRUFDbUIsR0FEbkIsRUFFRXBGLE1BRkYsRUE0QkEsRUF4QkExbEIsT0FBTyxHQUFHMGIsTUFBTSxDQUFDMWIsT0F3QmpCLEVBdEJJa1MsTUFBTSxDQUFDQyxJQUFQLENBQVlVLE9BQVosRUFBcUJiLE1Bc0J6QixJQXJCQ2hTLE9BQU8sR0FBR0EsT0FBTyxDQUFDcVksTUFBUixDQUFlLFVBQUF0WSxNQUFNLEVBQUk7QUFDbEMsVUFBSW9ULEtBQUssS0FBVDtBQURrQyxjQUc3QnBULE1BQU0sQ0FBQ3FtQyxLQUhzQixLQU9sQ3JtQyxNQUFNLENBQUNxbUMsS0FBUCxDQUFhL3hCLEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0JqQixPQUF4QixDQUFnQyxVQUFBMkUsQ0FBQyxFQUFJO0FBQ2hDeXRCLGVBQU8sQ0FBQ3Z4QixPQUFSLENBQWdCOEQsQ0FBaEIsS0FBc0IsQ0FEVSxLQUVuQzVFLEtBQUssS0FGOEI7QUFJcEMsT0FKRCxDQVBrQyxFQWEzQixDQUFDQSxLQWIwQjtBQWNsQyxLQWRTLENBcUJYLEVBTEN1SSxNQUFNLENBQUMxYixPQUFQLEdBQWlCQSxPQUtsQixJQUhDMGIsTUFBTSxDQUFDMWIsT0FBUCxHQUFpQixFQUdsQixFQUFPQSxPQUFQO0FBQ0E7QUE3RmMsQ0FBVixDO0FBZ0dTO0FBQUNBLFNBQU8sRUFBUEEsZUFBT0E7QUFBUixDQUFmLEU7O0FDbklBOzs7O0FBSUE7QUFDQTtBQUNBO0FBR2U7QUFDZDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQXEvQyxVQWpCYyxvQkFpQkxqaEIsUUFqQkssRUFpQjBCO0FBQUEsUUFDakNyWSxFQUFFLEdBQUcsS0FBS2syQixRQUR1QjtBQUFBLFFBRWpDcUQsU0FBcUIsR0FBRyxFQUZTO0FBV3ZDLFdBUEF2NUIsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlrVixTQUFaLFFBQTBCOVUsY0FBSyxDQUFDdFYsTUFBTixHQUFlMmxCLEVBQUUsQ0FBQ21iLHVCQUFILENBQTJCOUMsUUFBM0IsQ0FBekMsR0FDRTVULFNBREYsT0FDZ0I5VSxjQUFLLENBQUN2VixLQUR0QixFQUVFa1ksTUFGRixDQUVTLFlBQVc7QUFDbEIsYUFBTzhSLGlHQUFRLENBQUMsSUFBRCxDQUFSLENBQWUyaUIsT0FBZixDQUF1QnAzQixjQUFLLENBQUM1VCxRQUE3QixDQUFQO0FBQ0EsS0FKRixFQUtFb29CLElBTEYsQ0FLTyxVQUFBclksQ0FBQztBQUFBLGFBQUl5dEMsU0FBUyxDQUFDbG1DLElBQVYsQ0FBZXZILENBQWYsQ0FBSjtBQUFBLEtBTFIsQ0FPQSxFQUFPeXRDLFNBQVA7QUFDQSxHQTdCYTs7QUErQmQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTdwQyxRQXZEYyxrQkF1RFAwa0IsR0F2RE8sRUF1RGtCc2QsT0F2RGxCLEVBdURzQzhILFVBdkR0QyxFQXVENEQ7QUFDbkUsUUFBQXg1QixFQUFFLEdBQUcsS0FBS2syQixRQUFWO0FBQUEsUUFDQ3ZnQyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBR0R1RyxVQUFNLENBQUNwUSxzQkFKNkQsSUFRekU2SixHQUFHLENBQUNHLElBQUosQ0FBU2tWLFNBQVQsT0FBdUI5VSxjQUFLLENBQUN0VixNQUE3QixFQUNFb3FCLFNBREYsT0FDZ0I5VSxjQUFLLENBQUN2VixLQUR0QixFQUVFK3BCLElBRkYsQ0FFTyxVQUFTclksQ0FBVCxFQUFZMkMsQ0FBWixFQUFlO0FBQUEsVUFDZHJVLEtBQUssR0FBR2dxQixpR0FBUSxDQUFDLElBQUQsQ0FERjtBQUFBLFVBRWQvbEIsRUFBRSxHQUFHeU4sQ0FBQyxDQUFDcUcsSUFBRixHQUFTckcsQ0FBQyxDQUFDcUcsSUFBRixDQUFPOVQsRUFBaEIsR0FBcUJ5TixDQUFDLENBQUN6TixFQUZkO0FBQUEsVUFHZHFyQyxNQUFNLEdBQUcxcEIsRUFBRSxDQUFDeTVCLFNBQUgsQ0FBYSxJQUFiLEVBQW1CM3RDLENBQW5CLEVBQXNCcVgsSUFBdEIsQ0FBMkJuRCxFQUEzQixDQUhLO0FBQUEsVUFJZDA1QixVQUFVLEdBQUcvakMsTUFBTSxDQUFDblEsc0JBQVAsSUFBaUMsQ0FBQzR1QixHQUFsQyxJQUF5Q0EsR0FBRyxDQUFDbG1CLE9BQUosQ0FBWTdQLEVBQVosS0FBbUIsQ0FKM0Q7QUFBQSxVQUtkczdDLGFBQWEsR0FBRyxDQUFDakksT0FBRCxJQUFZQSxPQUFPLENBQUN4akMsT0FBUixDQUFnQk8sQ0FBaEIsS0FBc0IsQ0FMcEM7QUFBQSxVQU1kbXJDLFVBQVUsR0FBR3gvQyxLQUFLLENBQUMyc0MsT0FBTixDQUFjcDNCLGNBQUssQ0FBQzVULFFBQXBCLENBTkM7QUFRcEI7QUFDSTNCLFdBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDN1YsSUFBcEIsS0FBNkJNLEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDclosSUFBcEIsQ0FUYixLQWFoQm9qRCxVQUFVLElBQUlDLGFBYkUsR0FjZmhrQyxNQUFNLENBQUNsUSwyQkFBUCxDQUFtQzBkLElBQW5DLENBQXdDbkQsRUFBRSxDQUFDZ0osR0FBM0MsRUFBZ0RsZCxDQUFoRCxLQUFzRCxDQUFDOHRDLFVBZHhDLElBZWxCbFEsTUFBTSxLQUFPdHZDLEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVQsUUFBcEIsS0FBUCxFQUE0QytQLENBQTVDLEVBQStDMkMsQ0FBL0MsQ0FmWSxHQWlCVG5ELFNBQVMsQ0FBQ2t1QyxVQUFELENBQVQsSUFBeUJBLFVBQXpCLElBQXVDSSxVQWpCOUIsSUFrQm5CbFEsTUFBTSxLQUFRdHZDLEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVQsUUFBcEIsS0FBUixFQUE4QytQLENBQTlDLEVBQWlEMkMsQ0FBakQsQ0FsQmE7QUFvQnBCLEtBdEJGLENBUnlFO0FBK0J6RSxHQXRGYTs7QUF3RmQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBb3JDLFVBekdjLG9CQXlHTHpsQixHQXpHSyxFQXlHb0JzZCxPQXpHcEIsRUF5R3dDO0FBQy9DLFFBQUExeEIsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNnQnFLLEVBRGhCLENBQ0NySyxNQUREO0FBQUEsUUFDU3ZHLEdBRFQsR0FDZ0I0USxFQURoQixDQUNTNVEsR0FEVDtBQUdEdUcsVUFBTSxDQUFDcFEsc0JBSnlDLElBUXJENkosR0FBRyxDQUFDRyxJQUFKLENBQVNrVixTQUFULE9BQXVCOVUsY0FBSyxDQUFDdFYsTUFBN0IsRUFDRW9xQixTQURGLE9BQ2dCOVUsY0FBSyxDQUFDdlYsS0FEdEIsRUFFRStwQixJQUZGLENBRU8sVUFBU3JZLENBQVQsRUFBWTJDLENBQVosRUFBZTtBQUFBLFVBQ2RyVSxLQUFLLEdBQUdncUIsaUdBQVEsQ0FBQyxJQUFELENBREY7QUFBQSxVQUVkL2xCLEVBQUUsR0FBR3lOLENBQUMsQ0FBQ3FHLElBQUYsR0FBU3JHLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQWhCLEdBQXFCeU4sQ0FBQyxDQUFDek4sRUFGZDtBQUFBLFVBR2RxckMsTUFBTSxHQUFHMXBCLEVBQUUsQ0FBQ3k1QixTQUFILENBQWEsSUFBYixFQUFtQjN0QyxDQUFuQixFQUFzQnFYLElBQXRCLENBQTJCbkQsRUFBM0IsQ0FISztBQUFBLFVBSWQwNUIsVUFBVSxHQUFHL2pDLE1BQU0sQ0FBQ25RLHNCQUFQLElBQWlDLENBQUM0dUIsR0FBbEMsSUFBeUNBLEdBQUcsQ0FBQ2xtQixPQUFKLENBQVk3UCxFQUFaLEtBQW1CLENBSjNEO0FBQUEsVUFLZHM3QyxhQUFhLEdBQUcsQ0FBQ2pJLE9BQUQsSUFBWUEsT0FBTyxDQUFDeGpDLE9BQVIsQ0FBZ0JPLENBQWhCLEtBQXNCLENBTHBDO0FBQUEsVUFNZG1yQyxVQUFVLEdBQUd4L0MsS0FBSyxDQUFDMnNDLE9BQU4sQ0FBY3AzQixjQUFLLENBQUM1VCxRQUFwQixDQU5DO0FBUXBCO0FBQ0kzQixXQUFLLENBQUMyc0MsT0FBTixDQUFjcDNCLGNBQUssQ0FBQzdWLElBQXBCLEtBQTZCTSxLQUFLLENBQUMyc0MsT0FBTixDQUFjcDNCLGNBQUssQ0FBQ3JaLElBQXBCLENBVGIsSUFhaEJvakQsVUFBVSxJQUFJQyxhQUFkLElBQStCaGtDLE1BQU0sQ0FBQ2xRLDJCQUFQLENBQW1DMGQsSUFBbkMsQ0FBd0NuRCxFQUFFLENBQUNnSixHQUEzQyxFQUFnRGxkLENBQWhELENBQS9CLElBQXFGOHRDLFVBYnJFLElBY25CbFEsTUFBTSxLQUFRdHZDLEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVQsUUFBcEIsS0FBUixFQUE4QytQLENBQTlDLEVBQWlEMkMsQ0FBakQsQ0FkYTtBQWdCcEIsS0FsQkYsQ0FScUQ7QUEyQnJEO0FBcElhLENBQWYsRTs7QUNUQTs7OztBQUlBO0FBRWU7QUFDZDs7Ozs7Ozs7Ozs7Ozs7QUFjQTlRLEdBZmMsYUFlWkEsRUFmWSxFQWVUO0FBQUEsUUFDRXFpQixFQUFFLEdBQUcsS0FBS2syQixRQURaO0FBQUEsUUFFRXhzQixhQUFhLEdBQUcxSixFQUFFLENBQUN5VSxTQUFILE1BQWtCelUsRUFBRSxDQUFDMEosYUFBSCxFQUZwQztBQWlCSixXQWJJbmQsT0FBTyxDQUFDNU8sRUFBRCxDQWFYLEtBWksrckIsYUFZTCxHQVhFLEtBQUtHLFVBQUwsQ0FBZ0Jsc0IsRUFBaEIsQ0FXRixJQVRFcWlCLEVBQUUsQ0FBQ3VXLGFBQUgsQ0FBaUJ2VyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUF6QixFQUFrQ2xpQixFQUFsQyxDQVNGLEVBUEVxaUIsRUFBRSxDQUFDa1AsTUFBSCxDQUFVO0FBQ1R3TywwQkFBb0IsSUFEWDtBQUVUQyx1QkFBaUI7QUFGUixLQUFWLENBT0YsSUFBT2pVLGFBQWEsR0FBRyxLQUFLRyxVQUFMLEVBQUgsR0FBdUI3SixFQUFFLENBQUM3TixJQUFILENBQVFtaUIsRUFBbkQ7QUFDQSxHQWpDYTs7QUFtQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBQSxJQXBEYyxjQW9EWEEsR0FwRFcsRUFvRFA7QUFDTixRQUFNdFUsRUFBRSxHQUFHLEtBQUtrMkIsUUFBaEI7QUFXQSxXQVRJeHBDLFFBQVEsQ0FBQzRuQixHQUFELENBU1osS0FSQ3RVLEVBQUUsQ0FBQ3dXLGNBQUgsQ0FBa0J4VyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUExQixFQUFtQ3lVLEdBQW5DLENBUUQsRUFOQ3RVLEVBQUUsQ0FBQ2tQLE1BQUgsQ0FBVTtBQUNUd08sMEJBQW9CLElBRFg7QUFFVEMsdUJBQWlCO0FBRlIsS0FBVixDQU1ELEdBQU8zZCxFQUFFLENBQUM3TixJQUFILENBQVFtaUIsRUFBZjtBQUNBO0FBakVhLENBQWYsRTs7Ozs7QUNOQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBTUEsU0FBU3dsQixXQUFULENBQXFCajhDLE1BQXJCLEVBQXVDNGlCLEtBQXZDLEVBQWlFO0FBQUEsTUFDekR4UixHQUR5RCxHQUM3Q3dSLEtBRDZDO0FBQUEsTUFDcERtQyxHQURvRCxHQUM3Q25DLEtBRDZDO0FBR2hFLFNBQU81aUIsTUFBTSxDQUFDaVYsS0FBUCxDQUFhLFVBQUM3SCxDQUFELEVBQUl3RCxDQUFKO0FBQUEsV0FDbkJBLENBQUMsS0FBSyxDQUFOLEdBQVd4RCxDQUFDLElBQUlnRSxHQUFoQixHQUF3QmhFLENBQUMsSUFBSTJYLEdBRFY7QUFBQSxHQUFiLENBQVA7QUFHQTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFBTWhGLFNBQUksR0FBRyxVQUFTOG5CLFdBQVQsRUFBaUM7QUFJekMsTUFBQXFVLFlBQVk7QUFBQSxNQUhWLzVCLEVBR1UsR0FITCxLQUFLazJCLFFBR0E7QUFBQSxNQUZUdmdDLE1BRVMsR0FGUXFLLEVBRVIsQ0FGVHJLLE1BRVM7QUFBQSxNQUZEMEssS0FFQyxHQUZRTCxFQUVSLENBRkRLLEtBRUM7QUFBQSxNQURaeGlCLE1BQ1ksR0FESDZuQyxXQUNHOztBQUVoQixNQUFJL3ZCLE1BQU0sQ0FBQ3dDLFlBQVAsSUFBdUJ0YSxNQUF2QixJQUFpQ2k4QyxXQUFXLENBQUNqOEMsTUFBRCxFQUFTbWlCLEVBQUUsQ0FBQzhsQixhQUFILEVBQVQsQ0FBaEQsRUFBOEU7QUFDN0UsUUFBTWhjLFlBQVksR0FBRzlKLEVBQUUsQ0FBQzhKLFlBQUgsRUFBckI7O0FBRUEsUUFBSUEsWUFBSixFQUFrQjtBQUNqQixVQUFNdmMsRUFBRSxHQUFHaUksU0FBUyxDQUFDMk4sSUFBVixDQUFlbkQsRUFBZixDQUFYO0FBRUFuaUIsWUFBTSxHQUFHQSxNQUFNLENBQUN1USxHQUFQLENBQVcsVUFBQXpRLENBQUM7QUFBQSxlQUFJNFAsRUFBRSxDQUFDNVAsQ0FBRCxDQUFOO0FBQUEsT0FBWixDQUhRO0FBSWpCOztBQUVELFFBQUlnWSxNQUFNLENBQUNrQyxhQUFYLEVBQTBCO0FBQ3pCLFVBQU1taUMsTUFBTSxHQUFHMzVCLEtBQUssQ0FBQ3pDLElBQU4sSUFBY3lDLEtBQUssQ0FBQzFpQixDQUFuQztBQUVBcWlCLFFBQUUsQ0FBQy9vQixLQUFILENBQVNnakQsWUFBVCxHQUF3QnZzQyxJQUF4QixDQUE2QnNTLEVBQUUsQ0FBQy9vQixLQUFILENBQVNpakQsSUFBdEMsRUFBNEMsQ0FBQ0YsTUFBTSxDQUFDbjhDLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FBUCxFQUFvQm04QyxNQUFNLENBQUNuOEMsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQUExQixDQUE1QyxDQUh5QixFQUl6Qms4QyxZQUFZLEdBQUdsOEMsTUFKVTtBQUt6QixLQUxELE1BTUN3aUIsS0FBSyxDQUFDMWlCLENBQU4sQ0FBUUUsTUFBUixDQUFlQSxNQUFmLENBTkQsRUFPQ3dpQixLQUFLLENBQUN6QyxJQUFOLEdBQWF5QyxLQUFLLENBQUMxaUIsQ0FQcEIsRUFRQ3FpQixFQUFFLENBQUN4cEIsSUFBSCxDQUFRbUgsQ0FBUixDQUFVMGlCLEtBQVYsQ0FBZ0JBLEtBQUssQ0FBQ3pDLElBQXRCLENBUkQsRUFVQ204QixZQUFZLEdBQUcxNUIsS0FBSyxDQUFDekMsSUFBTixDQUFXcVMsU0FBWCxFQVZoQjs7QUFhQWpRLE1BQUUsQ0FBQ2tQLE1BQUgsQ0FBVTtBQUNUbEIsb0JBQWMsSUFETDtBQUVUbXNCLFdBQUssRUFBRXhrQyxNQUFNLENBQUMyQyxZQUZMO0FBR1Q4aEMsbUJBQWE7QUFISixLQUFWLENBdEI2RSxFQTRCN0VwNkIsRUFBRSxDQUFDcTZCLGtCQUFILEVBNUI2RSxFQTZCN0Uvc0MsTUFBTSxDQUFDcUksTUFBTSxDQUFDNEMsV0FBUixFQUFxQnlILEVBQUUsQ0FBQ2dKLEdBQXhCLEVBQTZCK3dCLFlBQTdCLENBN0J1RTtBQThCN0UsR0E5QkQsTUErQkNBLFlBQVksR0FBRzE1QixLQUFLLENBQUN6QyxJQUFOLEdBQ2R5QyxLQUFLLENBQUN6QyxJQUFOLENBQVcvZixNQUFYLEVBRGMsR0FDUXdpQixLQUFLLENBQUMxaUIsQ0FBTixDQUFRc3lCLFNBQVIsRUFoQ3hCOztBQW1DQSxTQUFPOHBCLFlBQVA7QUFDQSxDQTFDRDs7QUE0Q0ExcEMsTUFBTSxDQUFDdU4sU0FBRCxFQUFPO0FBQ1o7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTA4QixRQUFNLEVBQUUsZ0JBQVNDLE9BQVQsRUFBa0I7QUFDbkIsUUFBQXY2QixFQUFFLEdBQUcsS0FBS2syQixRQUFWO0FBQUEsUUFDQ3ZnQyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFRjZrQyxVQUZFLEdBRWdCRCxPQUZoQjtBQUlGQSxXQUxxQixLQU14QkMsVUFBVSxHQUFHcnZDLFFBQVEsQ0FBQ292QyxPQUFELENBQVIsSUFBcUIsaUJBQWlCL3BDLElBQWpCLENBQXNCK3BDLE9BQXRCLENBQXJCLEdBQ1o7QUFBQzlxQyxVQUFJLEVBQUU4cUM7QUFBUCxLQURZLEdBQ01BLE9BUEssR0FVekI1a0MsTUFBTSxDQUFDd0MsWUFBUCxHQUFzQnFpQyxVQVZHLEVBWXBCeDZCLEVBQUUsQ0FBQ3BDLElBWmlCLEdBZWQyOEIsT0FBTyxPQWZPLElBZ0J4QnY2QixFQUFFLENBQUN5NkIsYUFBSCxJQWhCd0IsSUFheEJ6NkIsRUFBRSxDQUFDMDZCLFFBQUgsRUFid0IsRUFjeEIxNkIsRUFBRSxDQUFDeTZCLGFBQUgsRUFkd0IsR0FtQnpCejZCLEVBQUUsQ0FBQzI2QixlQUFILEVBbkJ5QjtBQW9CekIsR0F2Q1c7O0FBeUNaOzs7Ozs7Ozs7OztBQVdBLzNCLEtBQUcsRUFBRSxhQUFTQSxJQUFULEVBQStCO0FBQzdCLFFBQUE1QyxFQUFFLEdBQUcsS0FBS2syQixRQUFWO0FBQUEsUUFDQ3ZnQyxNQURELEdBQzJCcUssRUFEM0IsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNldWtCLE9BRGYsR0FDMkJsYSxFQUQzQixDQUNTdWxCLEdBRFQsQ0FDZXJMLE9BRGY7QUFPTixZQUpJdFgsSUFBRyxLQUFLLENBQVIsSUFBYUEsSUFJakIsTUFIQ2pOLE1BQU0sQ0FBQ2lELFVBQVAsR0FBb0I1RixTQUFTLENBQUMsS0FBRCxFQUFRLENBQUNrbkIsT0FBTyxDQUFDLENBQUQsQ0FBUixFQUFhdFgsSUFBYixDQUFSLENBRzlCLEdBQU9qTixNQUFNLENBQUNpRCxVQUFkO0FBQ0EsR0E3RFc7O0FBK0RaOzs7Ozs7Ozs7OztBQVdBM0osS0FBRyxFQUFFLGFBQVNBLElBQVQsRUFBK0I7QUFDN0IsUUFBQStRLEVBQUUsR0FBRyxLQUFLazJCLFFBQVY7QUFBQSxRQUNDdmdDLE1BREQsR0FDMkJxSyxFQUQzQixDQUNDckssTUFERDtBQUFBLFFBQ2V1a0IsT0FEZixHQUMyQmxhLEVBRDNCLENBQ1N1bEIsR0FEVCxDQUNlckwsT0FEZjtBQU9OLFlBSklqckIsSUFBRyxLQUFLLENBQVIsSUFBYUEsSUFJakIsTUFIQzBHLE1BQU0sQ0FBQ2dELFVBQVAsR0FBb0IzRixTQUFTLENBQUMsS0FBRCxFQUFRLENBQUNrbkIsT0FBTyxDQUFDLENBQUQsQ0FBUixFQUFhanJCLElBQWIsQ0FBUixDQUc5QixHQUFPMEcsTUFBTSxDQUFDZ0QsVUFBZDtBQUNBLEdBbkZXOztBQXFGWjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE4SCxPQUFLLEVBQUUsZUFBU0EsTUFBVCxFQUFnQjtBQUN0QixRQUFNN0MsSUFBSSxHQUFHLEtBQUtBLElBQWxCOztBQUVBLFFBQUlsUixRQUFRLENBQUMrVCxNQUFELENBQVosRUFBcUI7QUFBQSxVQUNieFIsR0FEYSxHQUNEd1IsTUFEQyxDQUNieFIsR0FEYTtBQUFBLFVBQ1IyVCxHQURRLEdBQ0RuQyxNQURDLENBQ1JtQyxHQURRO0FBR3BCdFgsZUFBUyxDQUFDMkQsR0FBRCxDQUFULElBQWtCMk8sSUFBSSxDQUFDM08sR0FBTCxDQUFTQSxHQUFULENBSEUsRUFJcEIzRCxTQUFTLENBQUNzWCxHQUFELENBQVQsSUFBa0JoRixJQUFJLENBQUNnRixHQUFMLENBQVNBLEdBQVQsQ0FKRTtBQUtwQjs7QUFFRCxXQUFPO0FBQ04zVCxTQUFHLEVBQUUyTyxJQUFJLENBQUMzTyxHQUFMLEVBREM7QUFFTjJULFNBQUcsRUFBRWhGLElBQUksQ0FBQ2dGLEdBQUw7QUFGQyxLQUFQO0FBSUE7QUFwSFcsQ0FBUCxDO0FBdUhTO0FBQ2RoRixNQUFJLEVBQUpBLFNBRGM7O0FBR2Q7Ozs7Ozs7O0FBUUFnOUIsUUFYYyxvQkFXTDtBQUNGLFFBQUE1NkIsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDs7QUFHTixRQUFJcUssRUFBRSxDQUFDSyxLQUFILENBQVN6QyxJQUFiLEVBQW1CO0FBQ2xCakksWUFBTSxDQUFDa0MsYUFBUCxHQUNDbUksRUFBRSxDQUFDL29CLEtBQUgsQ0FBU2dqRCxZQUFULEdBQXdCdnNDLElBQXhCLENBQTZCc1MsRUFBRSxDQUFDL29CLEtBQUgsQ0FBU2lqRCxJQUF0QyxFQUE0QyxJQUE1QyxDQURELEdBRUNsNkIsRUFBRSxDQUFDcEMsSUFBSCxDQUFRaTlCLG9CQUFSLENBQTZCQyxnRkFBN0IsQ0FIaUIsRUFLbEI5NkIsRUFBRSxDQUFDKzZCLFVBQUgsSUFMa0IsRUFNbEIvNkIsRUFBRSxDQUFDcEMsSUFBSCxDQUFRbzlCLFFBQVIsSUFBb0JoN0IsRUFBRSxDQUFDcEMsSUFBSCxDQUFRbzlCLFFBQVIsQ0FBaUJqMkIsS0FBakIsQ0FBdUIsU0FBdkIsRUFBa0MsTUFBbEMsQ0FORjtBQVFsQjtBQUNBLFVBQU1qc0IsVUFBVSxHQUFHa25CLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBT0csSUFBUCxDQUFZRyxNQUFaLE9BQXVCQyxjQUFLLENBQUM3VyxVQUE3QixDQUFuQjtBQUVJbWlELCtGQUFlLENBQUNuaUQsVUFBVSxDQUFDaVYsSUFBWCxFQUFELENBQWYsS0FBdUMrc0MsZ0ZBWHpCLElBWWpCOTZCLEVBQUUsQ0FBQ3BDLElBQUgsQ0FBUWxNLFNBQVIsQ0FBa0I1WSxVQUFsQixFQUE4QmdpRCxnRkFBOUIsQ0FaaUIsRUFlbEI5NkIsRUFBRSxDQUFDa1AsTUFBSCxDQUFVO0FBQ1RsQixzQkFBYyxJQURMO0FBRVQyUCx5QkFBaUIsSUFGUjtBQUdURCw0QkFBb0IsSUFIWDtBQUlUeWMsYUFBSyxFQUFFeGtDLE1BQU0sQ0FBQzJDO0FBSkwsT0FBVixDQWZrQjtBQXFCbEI7QUFDRDtBQXJDYSxDQUFmLEU7O0FDMU1BOzs7O0FBSUE7QUFDQTtBQUNBO0FBR2U7QUFDZDs7Ozs7O0FBTUFzbUIsTUFQYyxnQkFPVHJyQixLQVBTLEVBT0Y7QUFDTCxRQUFBeU0sRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUMrQnFLLEVBRC9CLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDK0I4akIsRUFEL0IsQ0FDUzlqQixLQURUO0FBQUEsUUFDc0JxVCxJQUR0QixHQUMrQnlRLEVBRC9CLENBQ2dCNVEsR0FEaEIsQ0FDc0JHLElBRHRCOztBQUdOLFFBQUksQ0FBQXlRLEVBQUUsQ0FBQ21RLFVBQUgsTUFDRnhhLE1BQU0sQ0FBQ3BRLHNCQURMLE1BQytCO0FBQ2pDLEtBQUFvUSxNQUFNLENBQUN3QyxZQUFQLElBQXdCNkgsRUFBRSxDQUFDcEMsSUFBSCxDQUFRczlCLFNBRjlCLEtBR0Z2bEMsTUFBTSxDQUFDalEsdUJBSFQsQ0FHaUM7QUFIakM7QUFBQSwrQkFRaUJ4SixLQUFLLENBQUM0QyxTQVJ2QjtBQUFBLFlBUU9xOEMsRUFSUDtBQUFBLFlBUVdDLEVBUlg7QUFBQSxZQVNPQyxFQVRQLEdBU2lCOW5DLEtBVGpCO0FBQUEsWUFTVytuQyxFQVRYLEdBU2lCL25DLEtBVGpCO0FBQUEsWUFXTWdvQyxJQVhOLEdBV2E5dkMsSUFBSSxDQUFDd0QsR0FBTCxDQUFTa3NDLEVBQVQsRUFBYUUsRUFBYixDQVhiO0FBQUEsWUFZTUcsSUFaTixHQVlhL3ZDLElBQUksQ0FBQ21YLEdBQUwsQ0FBU3U0QixFQUFULEVBQWFFLEVBQWIsQ0FaYjtBQUFBLFlBYU1JLElBYk4sR0FhYTlsQyxNQUFNLENBQUNuUSxzQkFBUCxHQUFnQ3RKLEtBQUssQ0FBQ0ssTUFBTixDQUFhQyxHQUE3QyxHQUFtRGlQLElBQUksQ0FBQ3dELEdBQUwsQ0FBU21zQyxFQUFULEVBQWFFLEVBQWIsQ0FiaEU7QUFBQSxZQWNNSSxJQWROLEdBY2EvbEMsTUFBTSxDQUFDblEsc0JBQVAsR0FBZ0N0SixLQUFLLENBQUNHLE1BQXRDLEdBQStDb1AsSUFBSSxDQUFDbVgsR0FBTCxDQUFTdzRCLEVBQVQsRUFBYUUsRUFBYixDQWQ1RDtBQWdCQS9yQyxZQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ2hYLFFBQXRCLEVBQ0VnVyxJQURGLENBQ08sR0FEUCxFQUNZNHNDLElBRFosRUFFRTVzQyxJQUZGLENBRU8sR0FGUCxFQUVZOHNDLElBRlosRUFHRTlzQyxJQUhGLENBR08sT0FIUCxFQUdnQjZzQyxJQUFJLEdBQUdELElBSHZCLEVBSUU1c0MsSUFKRixDQUlPLFFBSlAsRUFJaUIrc0MsSUFBSSxHQUFHRCxJQUp4QixDQWhCQSxFQXVCQWxzQyxJQUFJLENBQUNrVixTQUFMLE9BQW1COVUsY0FBSyxDQUFDdFYsTUFBekIsRUFDRW9xQixTQURGLE9BQ2dCOVUsY0FBSyxDQUFDdlYsS0FEdEIsRUFFRWtZLE1BRkYsQ0FFUyxVQUFBeEcsQ0FBQztBQUFBLGlCQUFJNkosTUFBTSxDQUFDbFEsMkJBQVAsQ0FBbUMwZCxJQUFuQyxDQUF3Q25ELEVBQUUsQ0FBQ2dKLEdBQTNDLEVBQWdEbGQsQ0FBaEQsQ0FBSjtBQUFBLFNBRlYsRUFHRXFZLElBSEYsQ0FHTyxVQUFTclksQ0FBVCxFQUFZMkMsQ0FBWixFQUFlO0FBQUEsY0FLaEJpN0IsTUFMZ0I7QUFBQSxjQUNkdHZDLEtBQWtCLEdBQUdncUIsaUdBQVEsQ0FBQyxJQUFELENBRGY7QUFBQSxjQUVkdzFCLFVBQVUsR0FBR3gvQyxLQUFLLENBQUMyc0MsT0FBTixDQUFjcDNCLGNBQUssQ0FBQzVULFFBQXBCLENBRkM7QUFBQSxjQUdkNC9DLFVBQVUsR0FBR3ZoRCxLQUFLLENBQUMyc0MsT0FBTixDQUFjcDNCLGNBQUssQ0FBQzNULFFBQXBCLENBSEM7QUFBQSxjQUloQjQvQyxRQUFhLEtBSkc7O0FBT3BCLGNBQUl4aEQsS0FBSyxDQUFDMnNDLE9BQU4sQ0FBY3AzQixjQUFLLENBQUNyWCxNQUFwQixDQUFKLEVBQWlDO0FBQUEsZ0JBQzFCcUYsQ0FBUyxHQUFHLENBQUN2RCxLQUFLLENBQUN1VSxJQUFOLENBQVcsSUFBWCxDQUFELEdBQW9CLENBRE47QUFBQSxnQkFFMUI3USxDQUFTLEdBQUcsQ0FBQzFELEtBQUssQ0FBQ3VVLElBQU4sQ0FBVyxJQUFYLENBQUQsR0FBb0IsQ0FGTjtBQUloQys2QixrQkFBTSxHQUFHMXBCLEVBQUUsQ0FBQzY3QixXQUpvQixFQUtoQ0QsUUFBUSxHQUFHTCxJQUFJLEdBQUc1OUMsQ0FBUCxJQUFZQSxDQUFDLEdBQUc2OUMsSUFBaEIsSUFBd0JDLElBQUksR0FBRzM5QyxDQUEvQixJQUFvQ0EsQ0FBQyxHQUFHNDlDLElBTG5CO0FBTWhDLFdBTkQsTUFNTyxJQUFJdGhELEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVksR0FBcEIsQ0FBSixFQUE4QjtBQUFBLDhCQUNOK1gsVUFBVSxDQUFDLElBQUQsQ0FESjtBQUFBLGdCQUM3Qm5SLEVBRDZCLGVBQzdCQSxDQUQ2QjtBQUFBLGdCQUMxQkcsQ0FEMEIsZUFDMUJBLENBRDBCO0FBQUEsZ0JBQ3ZCM0IsS0FEdUIsZUFDdkJBLEtBRHVCO0FBQUEsZ0JBQ2hCRSxNQURnQixlQUNoQkEsTUFEZ0I7O0FBR3BDcXRDLGtCQUFNLEdBQUcxcEIsRUFBRSxDQUFDODdCLFVBSHdCLEVBSXBDRixRQUFRLEdBQUcsRUFBRUosSUFBSSxHQUFHNzlDLEVBQVAsSUFBWUEsRUFBQyxHQUFHeEIsS0FBSixHQUFZby9DLElBQTFCLEtBQW1DLEVBQUVHLElBQUksR0FBRzU5QyxDQUFQLElBQVlBLENBQUMsR0FBR3pCLE1BQUosR0FBYW8vQyxJQUEzQixDQUpWO0FBS3BDLFdBTE0sTUFNTjtBQUNBLG1CQXBCbUIsQ0F1QnBCOzs7QUFDSUcsa0JBQVEsR0FBR0QsVUF4QkssS0F5Qm5CdmhELEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDM1QsUUFBcEIsRUFBOEIsQ0FBQzIvQyxVQUEvQixDQXpCbUIsRUEyQm5CdmhELEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVQsUUFBcEIsRUFBOEIsQ0FBQzY5QyxVQUEvQixDQTNCbUIsRUE0Qm5CbFEsTUFBTSxDQUFDaDhCLElBQVAsQ0FBWXNTLEVBQVosRUFBZ0IsQ0FBQzQ1QixVQUFqQixFQUE2QngvQyxLQUE3QixFQUFvQzBSLENBQXBDLEVBQXVDMkMsQ0FBdkMsQ0E1Qm1CO0FBOEJwQixTQWpDRixDQXZCQTtBQUFBO0FBeURBLEdBcEVhOztBQXNFZDs7Ozs7O0FBTUF1d0IsV0E1RWMscUJBNEVKenJCLEtBNUVJLEVBNEVHO0FBQ1YsUUFBQXlNLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDK0JxSyxFQUQvQixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQytCOGpCLEVBRC9CLENBQ1M5akIsS0FEVDtBQUFBLFFBQ3NCcVQsSUFEdEIsR0FDK0J5USxFQUQvQixDQUNnQjVRLEdBRGhCLENBQ3NCRyxJQUR0QjtBQUdGeVEsTUFBRSxDQUFDbVEsVUFBSCxNQUFtQixDQUFDeGEsTUFBTSxDQUFDcFEsc0JBSmYsS0FRaEJySixLQUFLLENBQUM0QyxTQUFOLEdBQWtCeVUsS0FSRixFQVVoQmhFLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDdlksS0FBdEIsRUFDRXNYLE1BREYsQ0FDUyxNQURULEVBRUVDLElBRkYsQ0FFTyxPQUZQLEVBRWdCZ0IsY0FBSyxDQUFDaFgsUUFGdEIsRUFHRW9zQixLQUhGLENBR1EsU0FIUixFQUdtQixLQUhuQixDQVZnQixFQWVoQi9FLEVBQUUsQ0FBQys3QixhQUFILElBZmdCO0FBZ0JoQixHQTVGYTs7QUE4RmQ7Ozs7O0FBS0E5YyxTQW5HYyxxQkFtR0o7QUFDSCxRQUFBamYsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN3QnFLLEVBRHhCLENBQ0NySyxNQUREO0FBQUEsUUFDZXBHLElBRGYsR0FDd0J5USxFQUR4QixDQUNTNVEsR0FEVCxDQUNlRyxJQURmO0FBR0Z5USxNQUFFLENBQUNtUSxVQUFILE1BQW1CLENBQUN4YSxNQUFNLENBQUNwUSxzQkFKdEIsS0FRVGdLLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDaFgsUUFBdEIsRUFDRXNwQixVQURGLEdBRUU4TSxRQUZGLENBRVcsR0FGWCxFQUdFaEssS0FIRixDQUdRLFNBSFIsRUFHbUIsR0FIbkIsRUFJRXBGLE1BSkYsRUFSUyxFQWNUcFEsSUFBSSxDQUFDa1YsU0FBTCxPQUFtQjlVLGNBQUssQ0FBQ3ZWLEtBQXpCLEVBQ0Uyc0MsT0FERixDQUNVcDNCLGNBQUssQ0FBQzNULFFBRGhCLEtBZFMsRUFpQlRna0IsRUFBRSxDQUFDKzdCLGFBQUgsSUFqQlM7QUFrQlQsR0FySGE7QUF1SGRBLGVBdkhjLHlCQXVIQUMsVUF2SEEsRUF1SFk7QUFDekIsU0FBS2o5QyxRQUFMLEdBQWdCaTlDLFVBRFM7QUFFekI7QUF6SGEsQ0FBZixFOzs7OztBQ1RBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFZTtBQUNkOzs7Ozs7QUFNQUMsY0FQYyx3QkFPRHh1QyxJQVBDLEVBT2U7QUFDdEIsUUFBQXVTLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQzdOLElBREQsR0FDcUI2TixFQURyQixDQUNDN04sSUFERDtBQUFBLFFBQ09qVyxLQURQLEdBQ3FCOGpCLEVBRHJCLENBQ085akIsS0FEUDtBQUFBLFFBQ2NrVCxHQURkLEdBQ3FCNFEsRUFEckIsQ0FDYzVRLEdBRGQ7QUFHTixXQUFPLFlBQVc7QUFDakIsVUFBTThzQyxVQUFVLEdBQUd6dUMsSUFBSSxDQUFDaWlCLElBQUwsQ0FBVXpqQixNQUE3QixDQURpQixDQUdqQjs7QUFDQS9QLFdBQUssQ0FBQzhDLE9BQU4sS0FKaUIsRUFPakJtVCxJQUFJLENBQUMwTixPQUFMLENBQWF4UyxPQUFiLENBQXFCLFVBQUF2QixDQUFDLEVBQUk7QUFDekJBLFNBQUMsQ0FBQ29VLE1BQUYsQ0FBU3NkLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIwZSxVQUFuQixDQUR5QjtBQUV6QixPQUZELENBUGlCLEVBWWJsOEIsRUFBRSxDQUFDbThCLFdBWlUsSUFhaEJuOEIsRUFBRSxDQUFDbThCLFdBQUgsSUFiZ0I7QUFnQmpCO0FBQ0EsVUFBTUMsUUFBUSxHQUFHLEVBQWpCO0FBRUEsT0FBQyxRQUFELEVBQVcsUUFBWCxFQUFxQixhQUFyQixFQUFvQyxhQUFwQyxFQUFtRCxNQUFuRCxFQUEyRCxLQUEzRCxFQUFrRSxNQUFsRSxFQUEwRSxNQUExRSxFQUFrRixRQUFsRixFQUNFL3VDLE9BREYsQ0FDVSxVQUFBcEMsQ0FBQyxFQUFJO0FBQUEsWUFDUDRZLElBQUksR0FBRzVZLENBQUMsQ0FBQ3FELEtBQUYsQ0FBUSxHQUFSLENBREE7QUFBQSxZQUVUUCxJQUFJLEdBQUdxQixHQUFHLENBQUN5VSxJQUFJLENBQUMsQ0FBRCxDQUFMLENBRkQ7QUFJVDlWLFlBQUksSUFBSThWLElBQUksQ0FBQzVYLE1BQUwsR0FBYyxDQUpiLEtBS1o4QixJQUFJLEdBQUdBLElBQUksQ0FBQzhWLElBQUksQ0FBQyxDQUFELENBQUwsQ0FMQyxHQVFUOVYsSUFBSSxJQUFJQSxJQUFJLENBQUNuUSxJQUFMLEVBUkMsS0FTWncrQyxRQUFRLENBQUNueEMsQ0FBRCxDQUFSLEdBQWM4QyxJQVRGO0FBV2IsT0FaRixDQW5CaUIsRUFpQ2pCaVMsRUFBRSxDQUFDcThCLGFBQUgsRUFqQ2lCLEVBa0NqQnI4QixFQUFFLENBQUNzOEIsV0FBSCxDQUFlRixRQUFmLEVBQXlCM3VDLElBQXpCLENBbENpQjtBQW1DakIsS0FuQ0Q7QUFvQ0EsR0EvQ2E7O0FBaURkOzs7Ozs7QUFNQTZ1QyxhQXZEYyx1QkF1REZGLFFBdkRFLEVBdURRM3VDLElBdkRSLEVBdURvQjtBQUMzQixRQUFBdVMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDMFAsSUFERCxHQUNrQmppQixJQURsQixDQUNDaWlCLElBREQ7QUFBQSxRQUNPN1AsT0FEUCxHQUNrQnBTLElBRGxCLENBQ09vUyxPQURQO0FBQUEsZ0JBT0Y2UCxJQVBFO0FBQUEsK0JBR0xYLFFBSEs7QUFBQSxRQUdMQSxRQUhLLCtCQUdNdGhCLElBQUksQ0FBQ3NoQixRQUhYO0FBQUEsUUFJRXd0QixTQUpGLFNBSUxsM0IsS0FKSztBQUFBLFFBS0c2MkIsVUFMSCxTQUtMandDLE1BTEs7QUFBQSxRQU1MeXNDLFlBTkssU0FNTEEsWUFOSztBQUFBLFFBU0FobkMsU0FUQSxHQVNZc08sRUFBRSxDQUFDdzhCLGdCQUFILENBQW9CMzhCLE9BQXBCLEVBQTZCNjRCLFlBQTdCLEVBQTJDNkQsU0FBM0MsRUFBc0RMLFVBQXRELENBVFo7QUFBQSxRQVVBTyxJQVZBLEdBVU96OEIsRUFBRSxDQUFDMDhCLFlBQUgsRUFWUDtBQUFBLFFBV0FDLEVBWEEsR0FXS0Msd0dBQVksR0FBR0MsSUFBZixDQUFvQkMsOEVBQXBCLEVBQ1QvdEIsUUFEUyxDQUNBQSxRQURBLENBWEw7QUFjTjB0QixRQUFJLENBQUNsOUIsR0FBTCxDQUFTcFQsTUFBTSxDQUFDQyxJQUFQLENBQVlnd0MsUUFBWixFQUFzQmh1QyxHQUF0QixDQUEwQixVQUFBbkQsQ0FBQyxFQUFJO0FBQ3ZDLFVBQUlXLENBQUMsR0FBR3d3QyxRQUFRLENBQUNueEMsQ0FBRCxDQUFoQjtBQWFBLGFBVkNXLENBVUQsR0FYSVgsQ0FBQyxLQUFLLFFBV1YsR0FWS1csQ0FBQyxDQUFDcVcsVUFBRixDQUFhMDZCLEVBQWIsRUFDRmp2QyxJQURFLENBQ0csVUFBQXNWLENBQUM7QUFBQSxlQUFJaEQsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBQVIsQ0FBVTRwQixhQUFWLENBQXdCbzFCLEVBQXhCLEVBQTRCNTVCLE1BQTVCLENBQW1DQyxDQUFuQyxDQUFKO0FBQUEsT0FESixDQVVMLEdBUlcvWCxDQUFDLEtBQUssYUFRakIsR0FQS1csQ0FBQyxDQUFDMEcsTUFBRixDQUFTME4sRUFBRSxDQUFDKzhCLFdBQVosRUFDRjk2QixVQURFLENBQ1MwNkIsRUFEVCxFQUVGaHVDLElBRkUsQ0FFRyxXQUZILEVBRWdCK0MsU0FGaEIsQ0FPTCxHQUhLOUYsQ0FBQyxDQUFDcVcsVUFBRixDQUFhMDZCLEVBQWIsRUFBaUJodUMsSUFBakIsQ0FBc0IsV0FBdEIsRUFBbUMrQyxTQUFuQyxDQUdMLEVBQU85RixDQUFQO0FBQ0EsS0FmUSxDQUFULENBZmlDLEVBZ0NqQyt3QyxFQUFFLENBQUNqdkMsSUFBSCxDQUFRK3VDLElBQVIsRUFBYyxZQUFNO0FBQ25CejhCLFFBQUUsQ0FBQ2c5QixXQUFILENBQWVaLFFBQWYsRUFBeUIzdUMsSUFBekIsQ0FEbUI7QUFFbkIsS0FGRCxDQWhDaUM7QUFtQ2pDLEdBMUZhOztBQTRGZDs7Ozs7O0FBTUF1dkMsYUFsR2MsdUJBa0dGWixRQWxHRSxFQWtHUTN1QyxJQWxHUixFQWtHb0I7QUFDM0IsUUFBQXVTLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDOEJxSyxFQUQ5QixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQzhCOGpCLEVBRDlCLENBQ1M5akIsS0FEVDtBQUFBLFFBQ3NCcXhCLEdBRHRCLEdBQzhCdk4sRUFEOUIsQ0FDZ0I1USxHQURoQixDQUNzQm1lLEdBRHRCO0FBQUEsUUFFQXhGLFNBRkEsR0FFWXBTLE1BQU0sQ0FBQ2MsWUFGbkI7QUFBQSxRQUlDaVosSUFKRCxHQUlvQmppQixJQUpwQixDQUlDaWlCLElBSkQ7QUFBQSxRQUlPdDFCLEtBSlAsR0FJb0JxVCxJQUpwQixDQUlPclQsS0FKUDtBQUFBLFFBSWM2aUQsRUFKZCxHQUlvQnh2QyxJQUpwQixDQUljd3ZDLEVBSmQ7QUFBQSxxQkFLK0I3aUQsS0FBSyxDQUFDNHJCLEdBTHJDO0FBQUEsUUFLQ2szQixFQUxELGNBS0NBLEVBTEQ7QUFBQSxRQUtLQyxFQUxMLGNBS0tBLEVBTEw7QUFBQSxRQUtTQyxRQUxULGNBS1NBLFFBTFQ7QUFBQSxRQUttQjUyQixRQUxuQixjQUttQkEsUUFMbkI7QUFBQSxpQkFTRmtKLElBVEU7QUFBQSw2QkFPTGlDLElBUEs7QUFBQSxRQU9MQSxJQVBLLDRCQU9FLFlBQU0sQ0FBRSxDQVBWO0FBQUEsUUFRR3VxQixVQVJILFVBUUxqd0MsTUFSSztBQTZCTjtBQStDQTtBQWhFSWl3QyxjQWI2QixLQWNoQyxDQUFDLFFBQUQsRUFBVyxNQUFYLEVBQW1CLE9BQW5CLEVBQTRCLFdBQTVCLEVBQXlDN3VDLE9BQXpDLENBQWlELFVBQUFwQyxDQUFDLEVBQUk7QUFDckQsVUFBTXRRLE1BQU0sR0FBRyxFQUFmOztBQUVBLFdBQUssSUFBSThULENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5dEMsVUFBcEIsRUFBZ0N6dEMsQ0FBQyxFQUFqQyxFQUNDOVQsTUFBTSxDQUFDMFksSUFBUCxPQUFnQjFELGNBQUssQ0FBQzFFLENBQUQsQ0FBckIsU0FBNEJ3RCxDQUE1QixDQUREOztBQUlBOGUsU0FBRyxDQUFDOUksU0FBSixPQUFrQjlVLGNBQUssQ0FBSTFFLENBQUosT0FBdkIsRUFBb0M7QUFBcEMsT0FDRXdaLFNBREYsQ0FDWTlwQixNQURaLEVBRUVnbEIsTUFGRixFQVBxRDtBQVVyRCxLQVZELENBZGdDLEVBMEJoQzROLEdBQUcsQ0FBQzdkLE1BQUosT0FBZUMsY0FBSyxDQUFDelUsS0FBckIsRUFDRXlrQixNQURGLEVBMUJnQyxHQStCakN4VCxNQUFNLENBQUNDLElBQVAsQ0FBWWd3QyxRQUFaLEVBQXNCL3VDLE9BQXRCLENBQThCLFVBQUFwQyxDQUFDLEVBQUk7QUFDbEMsVUFBTVcsQ0FBQyxHQUFHd3dDLFFBQVEsQ0FBQ254QyxDQUFELENBQWxCO0FBTUEsVUFKSUEsQ0FBQyxLQUFLLFFBSVYsSUFIQ1csQ0FBQyxDQUFDK0MsSUFBRixDQUFPLFdBQVAsRUFBb0IsSUFBcEIsQ0FHRCxFQUFJMUQsQ0FBQyxLQUFLLFFBQVYsRUFDQ1csQ0FBQyxDQUFDK0MsSUFBRixDQUFPelMsS0FBSyxDQUFDK0QsU0FBYixDQURELE1BRU8sSUFBSWdMLENBQUMsS0FBSyxhQUFWLEVBQ05XLENBQUMsQ0FBQytDLElBQUYsQ0FBTyxJQUFQLEVBQWFvWixTQUFTLEdBQUcsQ0FBSCxHQUFPazFCLEVBQTdCLEVBQ0V0dUMsSUFERixDQUNPLElBRFAsRUFDYW9aLFNBQVMsR0FBRzdyQixLQUFLLENBQUNDLEtBQVQsR0FBaUI4Z0QsRUFEdkMsQ0FETSxNQUdBLElBQUloeUMsQ0FBQyxLQUFLLGFBQVYsRUFDTlcsQ0FBQyxDQUFDOEQsTUFBRixDQUFTLE1BQVQsRUFBaUJmLElBQWpCLENBQXNCLElBQXRCLEVBQTRCb1osU0FBUyxHQUFHLENBQUgsR0FBT2sxQixFQUE1QyxFQUNFdHVDLElBREYsQ0FDTyxJQURQLEVBQ2FvWixTQUFTLEdBQUc3ckIsS0FBSyxDQUFDQyxLQUFULEdBQWlCOGdELEVBRHZDLENBRE0sRUFJTnJ4QyxDQUFDLENBQUM4RCxNQUFGLENBQVMsTUFBVCxFQUNFZixJQURGLENBQ08sR0FEUCxFQUNZb1osU0FBUyxHQUFHN3JCLEtBQUssQ0FBQ0MsS0FBVCxHQUFpQixDQUR0QyxFQUVFd1MsSUFGRixDQUVPLEdBRlAsRUFFWXN1QyxFQUZaLENBSk0sTUFPQSxJQUFJLG9CQUFvQnpzQyxJQUFwQixDQUF5QnZGLENBQXpCLENBQUosRUFDTlcsQ0FBQyxDQUFDK0MsSUFBRixDQUFPLEdBQVAsRUFBWXZVLEtBQUssQ0FBQ3FWLElBQU4sQ0FBV3hFLENBQVgsQ0FBWixDQURNLE1BRUEsSUFBSUEsQ0FBQyxLQUFLLE1BQVYsRUFDTlcsQ0FBQyxDQUFDK0MsSUFBRixDQUFPLEdBQVAsRUFBWXl1QyxRQUFaLEVBQ0V6dUMsSUFERixDQUNPLEdBRFAsRUFDWTZYLFFBRFosRUFFRXpCLEtBRkYsQ0FFUSxjQUZSLEVBRXdCL0UsRUFBRSxDQUFDdXdCLGNBQUgsQ0FBa0JwdEIsSUFBbEIsQ0FBdUJuRCxFQUF2QixDQUZ4QixDQURNLE1BSUEsSUFBSS9VLENBQUMsS0FBSyxRQUFWLEVBWUlBLENBQUMsS0FBSyxhQVpWLElBYU5XLENBQUMsQ0FBQzhELE1BQUYsQ0FBUyxNQUFULEVBQWlCNEMsTUFBakIsQ0FBd0IwTixFQUFFLENBQUMrOEIsV0FBM0IsRUFDRXB1QyxJQURGLENBQ08sR0FEUCxFQUNZcVIsRUFBRSxDQUFDcTlCLE9BQUgsQ0FBV2w2QixJQUFYLENBQWdCbkQsRUFBaEIsQ0FEWixFQUVFclIsSUFGRixDQUVPLE9BRlAsRUFFZ0JxUixFQUFFLENBQUNzOUIsV0FBSCxDQUFlbjZCLElBQWYsQ0FBb0JuRCxFQUFwQixDQUZoQixDQWJNLE1BQ04sSUFBSUEsRUFBRSxDQUFDKzNCLGFBQUgsRUFBSixFQUNDbnNDLENBQUMsQ0FBQytDLElBQUYsQ0FBTyxJQUFQLEVBQWF1dUMsRUFBYixFQUFpQnZ1QyxJQUFqQixDQUFzQixJQUF0QixFQUE0Qnd1QyxFQUE1QixDQURELE1BRU87QUFBQSxZQUNBSSxLQUFLLEdBQUcsVUFBQXp4QyxDQUFDO0FBQUEsaUJBQUlveEMsRUFBRSxDQUFDcHhDLENBQUQsQ0FBRixHQUFRNkosTUFBTSxDQUFDMkIsT0FBbkI7QUFBQSxTQURUO0FBQUEsWUFFQWttQyxLQUFLLEdBQUcsVUFBQTF4QyxDQUFDO0FBQUEsaUJBQUlxeEMsRUFBRSxDQUFDcnhDLENBQUQsQ0FBRixHQUFRNkosTUFBTSxDQUFDMkIsT0FBbkI7QUFBQSxTQUZUOztBQUlOMUwsU0FBQyxDQUFDK0MsSUFBRixDQUFPLEdBQVAsRUFBWTR1QyxLQUFaLEVBQ0U1dUMsSUFERixDQUNPLEdBRFAsRUFDWTZ1QyxLQURaLEVBRUU3dUMsSUFGRixDQUVPLElBRlAsRUFFYXV1QyxFQUZiLEVBRWlCO0FBRmpCLFNBR0V2dUMsSUFIRixDQUdPLElBSFAsRUFHYXd1QyxFQUhiLENBSk07QUFRTjtBQU1GLEtBMUNELENBL0JpQyxFQTJFakN4bkMsTUFBTSxDQUFDMVQsbUJBQVAsSUFBOEIrZCxFQUFFLENBQUN5OUIsZUFBSCxFQTNFRyxFQThFakM5ckIsSUFBSSxDQUFDamtCLElBQUwsQ0FBVXNTLEVBQUUsQ0FBQ2dKLEdBQWIsQ0E5RWlDLEVBZ0ZqQzlzQixLQUFLLENBQUM4QyxPQUFOLEtBaEZpQztBQWlGakMsR0FuTGE7O0FBcUxkOzs7Ozs7Ozs7QUFTQXc5QyxrQkE5TGMsNEJBOExHMzhCLE9BOUxILEVBOExZNjRCLFlBOUxaLEVBOEwwQjZELFNBOUwxQixFQThMcUNMLFVBOUxyQyxFQThMeUQ7QUFPbEUsUUFBQXdCLFVBQVU7QUFBQSxRQU5SMTlCLEVBTVEsR0FOSCxJQU1HO0FBQUEsUUFMUDdOLElBS08sR0FMYTZOLEVBS2IsQ0FMUDdOLElBS087QUFBQSxRQUxPeFUsQ0FLUCxHQUxhcWlCLEVBS2IsQ0FMREssS0FLQyxDQUxPMWlCLENBS1A7QUFBQSxRQUpSNitCLFVBSVEsR0FKS3JxQixJQUFJLENBQUMwTixPQUFMLENBQWEsQ0FBYixFQUFnQkssTUFJckI7QUFBQSxRQUZWeTlCLFNBRVUsR0FGRTM5QixFQUFFLENBQUNxVyxlQUFILENBQW1CbUcsVUFBbkIsRUFBK0IrZixTQUEvQixDQUVGO0FBQUEsUUFEVnFCLE9BQ1UsR0FEQTU5QixFQUFFLENBQUNxVyxlQUFILENBQW1CbUcsVUFBbkIsRUFBK0IrZixTQUFTLEdBQUdMLFVBQTNDLENBQ0E7QUFBQSxRQUdSanNCLFNBSFEsR0FHSXR5QixDQUFDLENBQUNFLE1BQUYsRUFISjtBQUFBLFFBSVJBLE1BSlEsR0FJQ21pQixFQUFFLENBQUM2UCxhQUFILENBQWlCaFEsT0FBakIsU0FKRDtBQU9UNjRCLGdCQWRpRSxHQTBCM0RBLFlBQVksS0FBSyxDQUFqQixJQUFzQixDQUFDaUYsU0FBUyxJQUFJQSxTQUFTLENBQUNoZ0QsQ0FBeEIsT0FBZ0NpZ0QsT0FBTyxJQUFJQSxPQUFPLENBQUNqZ0QsQ0FBbkQsQ0ExQnFDLEdBMkJyRSsvQyxVQUFVLEdBQUcvL0MsQ0FBQyxDQUFDc3lCLFNBQVMsQ0FBQyxDQUFELENBQVYsQ0FBRCxHQUFrQnR5QixDQUFDLENBQUNFLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0EzQnFDLEdBNkJyRTYvQyxVQUFVLEdBQUcxOUIsRUFBRSxDQUFDOEosWUFBSCxLQUNabnNCLENBQUMsQ0FBQ3N5QixTQUFTLENBQUMsQ0FBRCxDQUFWLENBQUQsR0FBa0J0eUIsQ0FBQyxDQUFDRSxNQUFNLENBQUMsQ0FBRCxDQUFQLENBRFAsR0FFWkYsQ0FBQyxDQUFDZ2dELFNBQVMsQ0FBQ2hnRCxDQUFYLENBQUQsR0FBaUJBLENBQUMsQ0FBQ2lnRCxPQUFPLENBQUNqZ0QsQ0FBVCxDQS9Ca0QsR0FlakU2K0IsVUFBVSxDQUFDdndCLE1BQVgsS0FBc0IsQ0FmMkMsR0FrQmhFK1QsRUFBRSxDQUFDOEosWUFBSCxFQWxCZ0UsSUFtQm5FNnpCLFNBQVMsR0FBRzM5QixFQUFFLENBQUNxVyxlQUFILENBQW1CbUcsVUFBbkIsRUFBK0IsQ0FBL0IsQ0FuQnVELEVBb0JuRW9oQixPQUFPLEdBQUc1OUIsRUFBRSxDQUFDcVcsZUFBSCxDQUFtQm1HLFVBQW5CLEVBQStCQSxVQUFVLENBQUN2d0IsTUFBWCxHQUFvQixDQUFuRCxDQXBCeUQsRUFxQm5FeXhDLFVBQVUsR0FBRy8vQyxDQUFDLENBQUNnZ0QsU0FBUyxDQUFDaGdELENBQVgsQ0FBRCxHQUFpQkEsQ0FBQyxDQUFDaWdELE9BQU8sQ0FBQ2pnRCxDQUFULENBckJvQyxJQXVCbkUrL0MsVUFBVSxHQUFHN3hDLFVBQVUsQ0FBQ2hPLE1BQUQsQ0FBVixHQUFxQixDQXZCaUMsR0FnQnBFNi9DLFVBQVUsR0FBRy8vQyxDQUFDLENBQUNzeUIsU0FBUyxDQUFDLENBQUQsQ0FBVixDQUFELEdBQWtCdHlCLENBQUMsQ0FBQ0UsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQWhCb0M7QUFrQ3RFLFFBQU1nZ0QsTUFBTSxHQUFJaHlDLFVBQVUsQ0FBQ29rQixTQUFELENBQVYsR0FBd0Jwa0IsVUFBVSxDQUFDaE8sTUFBRCxDQUFsRDtBQUVBLDBCQUFvQjYvQyxVQUFwQixrQkFBMkNHLE1BQTNDO0FBQ0E7QUFuT2EsQ0FBZixFOztBQ1RDOzs7O0FBSUQ7QUFLQTtBQUNBO0FBQ0E7QUFFZTtBQUNkOzs7OztBQUtBQyxlQU5jLDJCQU1FO0FBQ2YsUUFBTTk5QixFQUFFLEdBQUcsSUFBWDtBQUVBQSxNQUFFLENBQUM1USxHQUFILENBQU9HLElBQVAsQ0FBWUcsTUFBWixPQUF1QkMsY0FBSyxDQUFDdlksS0FBN0IsRUFDRXNYLE1BREYsQ0FDUyxHQURULEVBRUVDLElBRkYsQ0FFTyxPQUZQLEVBRWdCZ0IsY0FBSyxDQUFDN1csVUFGdEIsRUFHRWlzQixLQUhGLENBR1EsY0FIUixFQUd3QixHQUh4QixDQUhlO0FBT2YsR0FiYTs7QUFlZDs7OztBQUlBMDRCLGlCQW5CYyw2QkFtQkk7QUFJYixRQUFBTSxlQUFlO0FBQUEsUUFIYi85QixFQUdhLEdBSFIsSUFHUTtBQUFBLFFBRlpySyxNQUVZLEdBRkdxSyxFQUVILENBRlpySyxNQUVZO0FBQUEsUUFGSnZHLEdBRUksR0FGRzRRLEVBRUgsQ0FGSjVRLEdBRUk7QUFBQSxRQURiNm1CLFdBQ2EsR0FEQ2pXLEVBQUUsQ0FBQ2lXLFdBQUgsRUFDRDtBQUFBLFFBRWJ1UCxXQUZhLEdBRUM3dkIsTUFBTSxDQUFDd0MsWUFGUjtBQUFBLFFBR2JyZixVQUhhLEdBR0FrbkIsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlHLE1BQVosT0FBdUJDLGNBQUssQ0FBQzdXLFVBQTdCLEVBQ2pCaXNCLEtBRGlCLENBQ1gsUUFEVyxFQUNEeWdCLFdBQVcsSUFBSUEsV0FBVyxDQUFDLzFCLElBQVosS0FBcUIsTUFBcEMsR0FDaEJrRyxNQUFNLENBQUNjLFlBQVAsR0FBc0IsV0FBdEIsR0FBb0MsV0FEcEIsR0FFYixJQUhjLEVBSWpCc3dCLE9BSmlCLENBSVRwM0IsY0FBSyxDQUFDNVcsa0JBSkcsRUFJaUJrOUIsV0FKakIsRUFLakI4USxPQUxpQixDQUtUcDNCLGNBQUssQ0FBQzNXLGdCQUxHLEVBS2UsQ0FBQ2k5QixXQUxoQixDQUhBO0FBZ0JuQixRQUxBbjlCLFVBQVUsQ0FBQzJyQixTQUFYLE9BQXlCOVUsY0FBSyxDQUFDOVcsU0FBL0IsRUFBNEM4bUIsTUFBNUMsRUFLQSxFQUZBdlEsR0FBRyxDQUFDdlcsU0FBSixHQUFnQkMsVUFBVSxDQUFDMnJCLFNBQVgsT0FBeUI5VSxjQUFLLENBQUM5VyxTQUEvQixDQUVoQixFQUFJbzlCLFdBQUosRUFDQzhuQixlQUFlLEdBQUczdUMsR0FBRyxDQUFDdlcsU0FBSixDQUFjc1osSUFBZCxDQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FEbkIsRUFLQzRyQyxlQUFlLEdBQUcvOUIsRUFBRSxDQUFDZytCLCtCQUFILENBQW1DRCxlQUFlLENBQUNyNUIsS0FBaEIsRUFBbkMsRUFDaEJDLEtBRGdCLENBQ1ZvNUIsZUFEVSxDQUxuQixNQU9PO0FBQ047QUFDQSxVQUFNRSxlQUFlLEdBQUdqK0IsRUFBRSxDQUFDZ1kscUJBQUgsRUFBeEIsQ0FGTSxDQUlOOztBQUNBaFksUUFBRSxDQUFDaWQsa0JBQUgsQ0FBc0JnaEIsZUFBdEIsQ0FMTSxFQU1OaitCLEVBQUUsQ0FBQ3lXLFFBQUgsQ0FBWXduQixlQUFaLENBTk0sRUFPTmorQixFQUFFLENBQUNrK0IsZ0JBQUgsSUFQTSxFQVNOcGxELFVBQVUsQ0FBQzBsQyxLQUFYLENBQWlCeWYsZUFBakIsQ0FUTSxFQVdON3VDLEdBQUcsQ0FBQ3ZXLFNBQUosR0FBZ0JDLFVBQVUsQ0FBQzJyQixTQUFYLE9BQXlCOVUsY0FBSyxDQUFDOVcsU0FBL0IsQ0FYVixFQVlOa2xELGVBQWUsR0FBRzN1QyxHQUFHLENBQUN2VyxTQUFKLENBQWNzWixJQUFkLENBQW1CLFVBQUFyRyxDQUFDO0FBQUEsZUFBSUEsQ0FBSjtBQUFBLE9BQXBCLENBWlosRUFlTml5QyxlQUFlLENBQUM5NEIsSUFBaEIsR0FBdUJ0RixNQUF2QixFQWZNLEVBa0JObytCLGVBQWUsR0FBRy85QixFQUFFLENBQUNtK0IsNEJBQUgsQ0FBZ0NKLGVBQWUsQ0FBQ3I1QixLQUFoQixFQUFoQyxFQUNoQkMsS0FEZ0IsQ0FDVm81QixlQURVLENBbEJaO0FBb0JOO0FBRUQzdUMsT0FBRyxDQUFDdlcsU0FBSixHQUFnQmtsRCxlQWpEQyxFQWtEakIvOUIsRUFBRSxDQUFDbytCLGVBQUgsQ0FBbUJMLGVBQW5CLENBbERpQixFQW9EYi85QixFQUFFLENBQUM5akIsS0FBSCxDQUFTZ0MsU0FBVCxLQUF1QixPQUF2QixJQUFtQ2tSLEdBQUcsQ0FBQ21lLEdBQUosQ0FBUXVSLEVBQVIsQ0FBVyxzQkFBWCxDQUFuQyxJQUEwRTllLEVBQUUsQ0FBQ21RLFVBQUgsRUFwRDdELElBcURoQm5RLEVBQUUsQ0FBQ3ErQixvQkFBSCxDQUF3QnBvQixXQUF4QixDQXJEZ0I7QUF1RGpCLEdBMUVhO0FBNEVkb29CLHNCQTVFYyxnQ0E0RU9wb0IsV0E1RVAsRUE0RW9CO0FBeUM3QixRQUFBcW9CLE9BQU87QUFBQSxRQXhDTHQrQixFQXdDSyxHQXhDQSxJQXdDQTtBQUFBLFFBdkNKckssTUF1Q0ksR0F2Q3lCcUssRUF1Q3pCLENBdkNKckssTUF1Q0k7QUFBQSxRQXZDSXpaLEtBdUNKLEdBdkN5QjhqQixFQXVDekIsQ0F2Q0k5akIsS0F1Q0o7QUFBQSxRQXZDaUJxeEIsR0F1Q2pCLEdBdkN5QnZOLEVBdUN6QixDQXZDVzVRLEdBdUNYLENBdkNpQm1lLEdBdUNqQjtBQUFBLFFBckNMZ3hCLFlBcUNLLEdBckNVLFlBQU07QUFDMUIsVUFBTWhxQyxLQUFLLEdBQUdqRix3RkFBTyxDQUFDOEYsY0FBUixDQUF1QixDQUF2QixDQUFkO0FBRUEsYUFBT2dQLGlHQUFRLENBQUNyWixXQUFRLENBQUN5ekMsZ0JBQVQsQ0FBMEJqcUMsS0FBSyxDQUFDVixPQUFoQyxFQUF5Q1UsS0FBSyxDQUFDVCxPQUEvQyxDQUFELENBQWY7QUFDQSxLQWlDVTtBQUFBLFFBL0JMMnFDLFFBK0JLLEdBL0JNLFVBQUE1bEQsU0FBUyxFQUFJO0FBQzdCLFVBQUl3c0IsS0FBSyxHQUFHeHNCLFNBQVMsSUFBSUEsU0FBUyxDQUFDOFYsSUFBVixDQUFlLE9BQWYsQ0FBYixJQUF3QzlWLFNBQVMsQ0FBQzhWLElBQVYsQ0FBZSxPQUFmLEVBQ2xEZCxPQURrRCxDQUMxQyxJQUFJMEgsTUFBSixPQUFlNUYsY0FBSyxDQUFDOVcsU0FBckIsWUFBdUMsR0FBdkMsQ0FEMEMsRUFDRyxFQURILElBQ1MsQ0FEN0Q7QUFPQSxjQUpJd1QsS0FBSyxDQUFDZ1osS0FBRCxDQUFMLElBQWdCQSxLQUFLLEtBQUssSUFJOUIsTUFIQ0EsS0FBSyxHQUFHLENBQUMsQ0FHVixHQUFPQSxLQUFQO0FBQ0EsS0FzQlU7QUFBQSxRQXBCTHE1QixVQW9CSyxHQXBCUSxVQUFBQyxPQUFPLEVBQUk7QUFDN0IsVUFBSTFvQixXQUFKLEVBQ0NqVyxFQUFFLENBQUM0K0IsdUJBQUgsQ0FBMkJELE9BQTNCLENBREQsTUFFTztBQUFBLFlBQ0E5bEQsU0FBUyxHQUFHMGxELFlBQVksRUFEeEI7QUFBQSxZQUVBbDVCLEtBQUssR0FBR281QixRQUFRLENBQUM1bEQsU0FBRCxDQUZoQjtBQUlObW5CLFVBQUUsQ0FBQzBlLG1CQUFILENBQXVCclosS0FBdkIsQ0FKTSxFQU1OQSxLQUFLLEtBQUssQ0FBQyxDQUFYLEdBQ0NyRixFQUFFLENBQUM2K0IsWUFBSCxFQURELEdBRUM3K0IsRUFBRSxDQUFDOCtCLG1CQUFILENBQXVCSCxPQUF2QixFQUFnQzlsRCxTQUFoQyxFQUEyQ3dzQixLQUEzQyxDQVJLO0FBU047QUFDRCxLQU9VO0FBQUEsUUFITDA1QixjQUdLLEdBSFlwcEMsTUFBTSxDQUFDdlQsMkJBQVAsQ0FBbUMyOEMsY0FHL0M7QUFBQSxRQUZMQyxXQUVLLEdBRlV6ekMsU0FBUyxDQUFDd3pDLGNBQUQsQ0FBVCxJQUE2QkEsY0FBOUIsTUFFVDtBQUFBLFFBRExFLGdCQUNLLEdBRGUsQ0FBQzV5QyxLQUFLLENBQUMweUMsY0FBRCxDQUFOLElBQTBCQSxjQUEzQixJQUE4QyxJQUM1RDtBQUFBLFFBRUxHLFlBRkssR0FFVSxVQUFBN3ZDLEtBQUssRUFBSTtBQUFBLFVBQ3ZCNEUsU0FBUyxHQUFHNUUsS0FBSyxDQUFDSSxJQURLO0FBQUEsVUFFdkI4RSxLQUFLLEdBQUdsRixLQUFLLENBQUMrRixjQUFOLENBQXFCLENBQXJCLENBRmU7QUFBQSxVQUd2QitwQyxTQUFTLEdBQUc1cUMsS0FBSyxhQUFVb0IsTUFBTSxDQUFDYyxZQUFQLEdBQXNCLEdBQXRCLEdBQTRCLEdBQXRDLEVBSE07QUFNekJ4QyxlQUFTLEtBQUssWUFOVyxHQU94QitxQyxXQVB3QixHQVEzQjN2QyxLQUFLLENBQUMwdkMsY0FBTixFQVIyQixHQVNqQkUsZ0JBQWdCLEtBQUssSUFUSixLQVUzQlgsT0FBTyxHQUFHYSxTQVZpQixJQVlsQmxyQyxTQUFTLEtBQUssV0FaSSxLQWF4QitxQyxXQUFXLElBQUlWLE9BQU8sT0FBdEIsSUFDSFcsZ0JBQWdCLEtBQUssSUFBckIsSUFBNkJ4ekMsSUFBSSxDQUFDb3VCLEdBQUwsQ0FBU3lrQixPQUFPLEdBQUdhLFNBQW5CLEtBQWlDRixnQkFkbkMsTUFpQjNCWCxPQUFPLEtBakJvQixFQWtCM0JqdkMsS0FBSyxDQUFDMHZDLGNBQU4sRUFsQjJCO0FBcUI3QixLQXZCVTs7QUF5Qlg7QUFDQXh4QixPQUFHLENBQ0R1UixFQURGLENBQ0ssMENBREwsRUFDaUQsWUFBVztBQUFBLFVBQ3BEam1DLFNBQVMsR0FBRzBsRCxZQUFZLEVBRDRCO0FBQUEsVUFFcERsdkMsS0FBSyxHQUFHQyx3RkFGNEM7O0FBSTFELFVBQUksQ0FBQ3pXLFNBQVMsQ0FBQ0QsS0FBVixFQUFELElBQXNCQyxTQUFTLENBQUNrdUMsT0FBVixDQUFrQnAzQixjQUFLLENBQUM5VyxTQUF4QixDQUExQixFQUE4RDtBQUM3RDtBQUNBLFlBQUlxRCxLQUFLLENBQUM2QyxRQUFOLElBQWtCN0MsS0FBSyxDQUFDOEMsT0FBeEIsSUFBbUNnaEIsRUFBRSxDQUFDbVEsVUFBSCxFQUFuQyxJQUFzRDlnQixLQUFLLENBQUM2RixPQUFOLENBQWNqSixNQUFkLEdBQXVCLENBQWpGLEVBQ0M7QUFHRGl6QyxvQkFBWSxDQUFDN3ZDLEtBQUQsQ0FOaUQsRUFPN0RxdkMsVUFBVSxDQUFDLElBQUQsQ0FQbUQ7QUFRN0QsT0FSRCxNQVNDMStCLEVBQUUsQ0FBQzYrQixZQUFILEVBVEQsRUFVQzcrQixFQUFFLENBQUMwZSxtQkFBSCxFQVZEO0FBWUEsS0FqQkYsTUFrQkVJLEVBbEJGLENBa0JLLG9CQWxCTCxFQWtCMkIsWUFBTTtBQUMvQixVQUFNam1DLFNBQVMsR0FBRzBsRCxZQUFZLEVBQTlCO0FBRUksT0FBQzFsRCxTQUFTLENBQUNELEtBQVYsRUFBRCxJQUFzQkMsU0FBUyxDQUFDa3VDLE9BQVYsQ0FBa0JwM0IsY0FBSyxDQUFDOVcsU0FBeEIsQ0FISyxLQUkxQm1uQixFQUFFLENBQUNtUSxVQUFILE1BQW1CLENBQUNuUSxFQUFFLENBQUNvL0IsV0FBdkIsSUFBc0NsakQsS0FBSyxDQUFDK0MsV0FKbEIsS0FLN0IvQyxLQUFLLENBQUMrQyxXQUFOLEtBQXNCL0MsS0FBSyxDQUFDK0MsV0FBTixLQUF0QixDQUw2QjtBQVEvQixLQTFCRixLQW5FaUM7QUE4RmpDLEdBMUthOztBQTRLZDs7Ozs7QUFLQW0vQyxpQkFqTGMsMkJBaUxFTCxlQWpMRixFQWlMbUI7QUFNNUIsUUFBQXBnRCxDQUFDO0FBQUEsUUFDREcsQ0FEQztBQUFBLFFBRUQraUIsQ0FGQztBQUFBLFFBR0RDLENBSEM7QUFBQSxRQUxDZCxFQUtELEdBTE0sSUFLTjtBQUFBLFFBSkVySyxNQUlGLEdBSjBCcUssRUFJMUIsQ0FKRXJLLE1BSUY7QUFBQSxRQUpVMEssS0FJVixHQUowQkwsRUFJMUIsQ0FKVUssS0FJVjtBQUFBLFFBSmlCbmtCLEtBSWpCLEdBSjBCOGpCLEVBSTFCLENBSmlCOWpCLEtBSWpCO0FBQUEsUUFIQzg5QyxNQUdELEdBSFUzNUIsS0FBSyxDQUFDekMsSUFBTixJQUFjeUMsS0FBSyxDQUFDMWlCLENBRzlCO0FBQUEsUUFGQzBoRCxhQUVELEdBRmlCdEIsZUFBZSxJQUFJLzlCLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBT3ZXLFNBQVAsQ0FBaUJzWixJQUFqQixFQUVwQztBQUFBLFFBREM0VixTQUNELEdBRGFwUyxNQUFNLENBQUNjLFlBQ3BCO0FBS0wsUUFBSXVKLEVBQUUsQ0FBQ2lXLFdBQUgsRUFBSixFQUNDO0FBQ0F0NEIsS0FBQyxHQUFHLENBRkwsRUFHQ0csQ0FBQyxHQUFHLENBSEwsRUFJQytpQixDQUFDLEdBQUcza0IsS0FBSyxDQUFDQyxLQUpYLEVBS0Mya0IsQ0FBQyxHQUFHNWtCLEtBQUssQ0FBQ0csTUFMWCxNQU1PO0FBQUEsVUFDRmlqRCxLQURFLEVBRUZDLEtBRkU7QUFJTixVQUFJdi9CLEVBQUUsQ0FBQzBKLGFBQUgsRUFBSixFQUNDNDFCLEtBQUssR0FBR3QvQixFQUFFLENBQUNtdkIsaUJBQUgsRUFEVCxFQUVDb1EsS0FBSyxHQUFHLFVBQUF6ekMsQ0FBQztBQUFBLGVBQUlrdUMsTUFBTSxDQUFDbHVDLENBQUMsQ0FBQ25PLENBQUgsQ0FBTixHQUFlMmhELEtBQUssR0FBRyxDQUEzQjtBQUFBLE9BRlYsTUFHTztBQUNOLFlBQU1FLFlBQVksR0FBRyxVQUFBMXpDLENBQUMsRUFBSTtBQUN6QixjQUFNdVosS0FBSyxHQUFHdlosQ0FBQyxDQUFDdVosS0FBaEI7QUFFQSxpQkFBTztBQUNObzZCLGdCQUFJLEVBQUV6L0IsRUFBRSxDQUFDMFcsUUFBSCxDQUFZclIsS0FBWixDQURBO0FBRU5xNkIsZ0JBQUksRUFBRTEvQixFQUFFLENBQUMyVyxRQUFILENBQVl0UixLQUFaO0FBRkEsV0FBUDtBQUlBLFNBUEQ7O0FBU0FpNkIsYUFBSyxHQUFHLFVBQUF4ekMsQ0FBQyxFQUFJO0FBQ1osY0FBTW5PLENBQUMsR0FBRzZoRCxZQUFZLENBQUMxekMsQ0FBRCxDQUF0QixDQURZLENBR1o7O0FBSFksaUJBSVJuTyxDQUFDLENBQUM4aEQsSUFBRixLQUFXLElBQVgsSUFBbUI5aEQsQ0FBQyxDQUFDK2hELElBQUYsS0FBVyxJQUp0QixHQUtKMzNCLFNBQVMsR0FBRzdyQixLQUFLLENBQUNHLE1BQVQsR0FBa0JILEtBQUssQ0FBQ0MsS0FMN0IsSUFRUndCLENBQUMsQ0FBQzhoRCxJQUFGLEtBQVcsSUFSSCxLQVNYOWhELENBQUMsQ0FBQzhoRCxJQUFGLEdBQVN6RixNQUFNLENBQUNuOEMsTUFBUCxHQUFnQixDQUFoQixDQVRFLEdBWVJGLENBQUMsQ0FBQytoRCxJQUFGLEtBQVcsSUFaSCxLQWFYL2hELENBQUMsQ0FBQytoRCxJQUFGLEdBQVMxRixNQUFNLENBQUNuOEMsTUFBUCxHQUFnQixDQUFoQixDQWJFLEdBZ0JMNE4sSUFBSSxDQUFDbVgsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDbzNCLE1BQU0sQ0FBQ3I4QyxDQUFDLENBQUMraEQsSUFBSCxDQUFOLEdBQWlCMUYsTUFBTSxDQUFDcjhDLENBQUMsQ0FBQzhoRCxJQUFILENBQXhCLElBQW9DLENBQWhELENBaEJLO0FBaUJaLFNBM0JLLEVBNkJORixLQUFLLEdBQUcsVUFBQXp6QyxDQUFDLEVBQUk7QUFBQSxjQUNObk8sQ0FBQyxHQUFHNmhELFlBQVksQ0FBQzF6QyxDQUFELENBRFY7QUFBQSxjQUVONnpDLEtBQUssR0FBRzd6QyxDQUFDLENBQUNuTyxDQUZKO0FBSVo7QUFKWSxpQkFLUkEsQ0FBQyxDQUFDOGhELElBQUYsS0FBVyxJQUFYLElBQW1COWhELENBQUMsQ0FBQytoRCxJQUFGLEtBQVcsSUFMdEIsR0FNSixDQU5JLElBU1IvaEQsQ0FBQyxDQUFDOGhELElBQUYsS0FBVyxJQVRILEtBVVg5aEQsQ0FBQyxDQUFDOGhELElBQUYsR0FBU3pGLE1BQU0sQ0FBQ244QyxNQUFQLEdBQWdCLENBQWhCLENBVkUsR0FhTCxDQUFDbThDLE1BQU0sQ0FBQzJGLEtBQUQsQ0FBTixHQUFnQjNGLE1BQU0sQ0FBQ3I4QyxDQUFDLENBQUM4aEQsSUFBSCxDQUF2QixJQUFtQyxDQWI5QjtBQWNaLFNBM0NLO0FBNENOO0FBRUQ5aEQsT0FBQyxHQUFHb3FCLFNBQVMsR0FBRyxDQUFILEdBQU93M0IsS0FyRGQsRUFzRE56aEQsQ0FBQyxHQUFHaXFCLFNBQVMsR0FBR3czQixLQUFILEdBQVcsQ0F0RGxCLEVBdUROMStCLENBQUMsR0FBR2tILFNBQVMsR0FBRzdyQixLQUFLLENBQUNDLEtBQVQsR0FBaUJtakQsS0F2RHhCLEVBd0ROeCtCLENBQUMsR0FBR2lILFNBQVMsR0FBR3UzQixLQUFILEdBQVdwakQsS0FBSyxDQUFDRyxNQXhEeEI7QUF5RE47QUFFRGdqRCxpQkFBYSxDQUFDMXdDLElBQWQsQ0FBbUIsT0FBbkIsRUFBNEJxUixFQUFFLENBQUNzZ0IsVUFBSCxDQUFjbmQsSUFBZCxDQUFtQm5ELEVBQW5CLENBQTVCLEVBQ0VyUixJQURGLENBQ08sR0FEUCxFQUNZaFIsQ0FEWixFQUVFZ1IsSUFGRixDQUVPLEdBRlAsRUFFWTdRLENBRlosRUFHRTZRLElBSEYsQ0FHTyxPQUhQLEVBR2dCa1MsQ0FIaEIsRUFJRWxTLElBSkYsQ0FJTyxRQUpQLEVBSWlCbVMsQ0FKakIsQ0E1RWdDO0FBaUZoQyxHQWxRYTtBQW9RZGcrQixxQkFwUWMsK0JBb1FNSCxPQXBRTixFQW9RZTlsRCxTQXBRZixFQW9RMEJ3c0IsS0FwUTFCLEVBb1FpQztBQUN4QyxRQUFBckYsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN3QnFLLEVBRHhCLENBQ0NySyxNQUREO0FBQUEsUUFDZXBHLElBRGYsR0FDd0J5USxFQUR4QixDQUNTNVEsR0FEVCxDQUNlRyxJQURmO0FBQUEsUUFFQXF3QyxrQkFGQSxHQUVxQmpxQyxNQUFNLENBQUNwUSxzQkFGNUI7QUFBQSxRQUdBczZDLGtCQUhBLEdBR3FCbHFDLE1BQU0sQ0FBQ25RLHNCQUg1QjtBQUFBLFFBSUFzNkMsZ0JBSkEsR0FJbUJucUMsTUFBTSxDQUFDaFMsZUFKMUI7QUFBQSxRQUtBZ3lDLFlBTEEsR0FLZTMxQixFQUFFLENBQUNvVyxtQkFBSCxDQUF1Qi9RLEtBQXZCLENBTGY7QUFPRnk2QixvQkFSMEMsS0FTN0M5L0IsRUFBRSxDQUFDMDFCLFdBQUgsQ0FBZUMsWUFBZixFQUE2QmdKLE9BQTdCLENBVDZDLEVBVTdDMytCLEVBQUUsQ0FBQysvQixhQUFILENBQWlCcEssWUFBakIsQ0FWNkMsRUFZekMsQ0FBQ2lLLGtCQUFELElBQXVCQyxrQkFaa0IsS0FpQjlDdHdDLElBQUksQ0FBQ2tWLFNBQUwsT0FBbUI5VSxjQUFLLENBQUN2VixLQUF6QixTQUFrQ2lyQixLQUFsQyxFQUNFbEIsSUFERixDQUNPLFlBQVc7QUFDaEJDLHVHQUFRLENBQUMsSUFBRCxDQUFSLENBQWUyaUIsT0FBZixDQUF1QnAzQixjQUFLLENBQUM3VCxRQUE3QixLQURnQixFQUdaOGpELGtCQUhZLElBSWYvbUQsU0FBUyxDQUFDa3NCLEtBQVYsQ0FBZ0IsUUFBaEIsRUFBMEI4NkIsa0JBQWtCLEdBQUcsU0FBSCxHQUFlLElBQTNELENBSmUsRUFPWEMsZ0JBUFcsS0FRZjkvQixFQUFFLENBQUNxOEIsYUFBSCxFQVJlLEVBU2ZyOEIsRUFBRSxDQUFDNHBCLFdBQUgsRUFUZSxFQVdmLENBQUNpVyxrQkFBRCxJQUF1QjcvQixFQUFFLENBQUN5ZSxpQkFBSCxDQUFxQnBaLEtBQXJCLENBWFI7QUFhaEIsS0FkRixFQWVFL1MsTUFmRixDQWVTLFVBQVN4RyxDQUFULEVBQVk7QUFDbkIsYUFBT2tVLEVBQUUsQ0FBQ3VlLGFBQUgsQ0FBaUIsSUFBakIsRUFBdUJ6eUIsQ0FBdkIsQ0FBUDtBQUNBLEtBakJGLEVBa0JFNEIsSUFsQkYsQ0FrQk8sVUFBQTRyQyxRQUFRLEVBQUk7QUFDakIsVUFBTXh0QyxDQUFDLEdBQUd3dEMsUUFBUSxDQUFDbm5DLElBQVQsRUFBVjtBQUVJeXRDLHdCQUFrQixLQUFLQyxrQkFBa0IsSUFBSWxxQyxNQUFNLENBQUNsUSwyQkFBUCxDQUFtQzBkLElBQW5DLENBQXdDbkQsRUFBRSxDQUFDZ0osR0FBM0MsRUFBZ0RsZCxDQUFoRCxDQUEzQixDQUhMLElBSWhCalQsU0FBUyxDQUFDa3NCLEtBQVYsQ0FBZ0IsUUFBaEIsRUFBMEIsU0FBMUIsQ0FKZ0IsRUFPWis2QixnQkFQWSxLQVFoQjkvQixFQUFFLENBQUMwMUIsV0FBSCxDQUFlNXBDLENBQWYsRUFBa0I2eUMsT0FBbEIsQ0FSZ0IsRUFTaEIzK0IsRUFBRSxDQUFDKy9CLGFBQUgsQ0FBaUJqMEMsQ0FBakIsQ0FUZ0IsRUFXaEJrVSxFQUFFLENBQUNnZ0MsZUFBSCxFQVhnQixFQVloQjFHLFFBQVEsQ0FBQ24xQixJQUFULENBQWMsVUFBQXJZLENBQUM7QUFBQSxlQUFJa1UsRUFBRSxDQUFDeWUsaUJBQUgsQ0FBcUJwWixLQUFyQixFQUE0QnZaLENBQUMsQ0FBQ3pOLEVBQTlCLENBQUo7QUFBQSxPQUFmLENBWmdCO0FBY2pCLEtBaENGLENBakI4QztBQWtEOUMsR0F0VGE7QUF3VGRvZ0MsbUJBeFRjLDZCQXdUSXBaLEtBeFRKLEVBd1RXaG5CLEVBeFRYLEVBd1RleWhCLEtBeFRmLEVBd1RzQjtBQUM3QixRQUFBRSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBR05BLFVBQU0sQ0FBQzZCLDBCQUFQLElBQ0N3SSxFQUFFLENBQUNpZ0MsYUFBSCxDQUFpQjU2QixLQUFqQixFQUF3QmhuQixFQUF4QixFQUE0QnloQixLQUE1QixDQUxrQyxFQU9uQ0UsRUFBRSxDQUFDa2dDLFVBQUgsQ0FBYzc2QixLQUFkLEVBQXFCaG5CLEVBQXJCLEVBQXlCeWhCLEtBQXpCLENBUG1DO0FBUW5DLEdBaFVhO0FBa1VkOCtCLHlCQWxVYyxtQ0FrVVVELE9BbFVWLEVBa1VtQjtBQUMxQixRQUFBMytCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ2tCOGpCLEVBRGxCLENBQ1M5akIsS0FEVDtBQUFBLFFBRUF5eEIsYUFGQSxHQUVnQjNOLEVBQUUsQ0FBQzROLG1CQUFILENBQXVCNU4sRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBL0IsQ0FGaEI7O0FBSU47QUFDQSxVQUFJRyxFQUFFLENBQUNqaEIsUUFBSCxJQUFlaWhCLEVBQUUsQ0FBQ21RLFVBQUgsQ0FBY3hDLGFBQWQsQ0FBbkI7QUFBQSxVQUlNcGEsS0FBSyxHQUFHd3JCLGdHQUFPLENBQUM0ZixPQUFELENBSnJCO0FBQUEsVUFLTTNqQixPQUFPLEdBQUdoYixFQUFFLENBQUM2YSxzQkFBSCxDQUEwQmxOLGFBQTFCLEVBQXlDcGEsS0FBekMsQ0FMaEI7QUFZQSxVQUxJclgsS0FBSyxDQUFDZ0QsU0FBTixLQUFvQixDQUFDODdCLE9BQUQsSUFBWUEsT0FBTyxDQUFDMzhCLEVBQVIsS0FBZW5DLEtBQUssQ0FBQ2dELFNBQU4sQ0FBZ0JiLEVBQS9ELENBS0osS0FKQ3NYLE1BQU0sQ0FBQ3pVLFVBQVAsQ0FBa0J3TSxJQUFsQixDQUF1QnNTLEVBQUUsQ0FBQ2dKLEdBQTFCLEVBQStCOXNCLEtBQUssQ0FBQ2dELFNBQXJDLENBSUQsRUFIQ2hELEtBQUssQ0FBQ2dELFNBQU4sR0FBa0J1QixTQUduQixHQUFJLENBQUN1NkIsT0FBTCxFQUVDLFlBREFoYixFQUFFLENBQUM2K0IsWUFBSCxFQUNBO0FBZEQsVUFpQk1zQixTQUFTLEdBQ2RuZ0MsRUFBRSxDQUFDMHlCLFlBQUgsQ0FBZ0IxWCxPQUFoQixLQUE0QmhiLEVBQUUsQ0FBQ3l5QixhQUFILENBQWlCelgsT0FBakIsQ0FBNUIsSUFBeUQsQ0FBQ3JsQixNQUFNLENBQUNoUyxlQURoRCxHQUVkLENBQUNxM0IsT0FBRCxDQUZjLEdBRUZoYixFQUFFLENBQUM0VixTQUFILENBQWFqSSxhQUFiLEVBQTRCcU4sT0FBTyxDQUFDcjlCLENBQXBDLENBbkJoQjtBQUFBLFVBc0JNZzRDLFlBQVksR0FBR3dLLFNBQVMsQ0FBQy94QyxHQUFWLENBQWMsVUFBQXRDLENBQUM7QUFBQSxlQUFJa1UsRUFBRSxDQUFDbVcsT0FBSCxDQUFXcnFCLENBQVgsQ0FBSjtBQUFBLE9BQWYsQ0F0QnJCLEVBcUJBOztBQUdBa1UsUUFBRSxDQUFDMDFCLFdBQUgsQ0FBZUMsWUFBZixFQUE2QmdKLE9BQTdCLENBeEJBLEVBMkJBMytCLEVBQUUsQ0FBQ3llLGlCQUFILENBQXFCekQsT0FBTyxDQUFDM1YsS0FBN0IsRUFBb0MyVixPQUFPLENBQUMzOEIsRUFBNUMsS0EzQkEsRUE4QkEyaEIsRUFBRSxDQUFDKy9CLGFBQUgsQ0FBaUJwSyxZQUFqQixDQTlCQSxHQWlDSTMxQixFQUFFLENBQUNrYixTQUFILENBQWFGLE9BQU8sQ0FBQzM4QixFQUFyQixLQUE0QjJoQixFQUFFLENBQUNxYixJQUFILENBQVFMLE9BQVIsRUFBaUJ6bkIsS0FBakIsSUFBMEJvQyxNQUFNLENBQUM0QixpQkFqQ2pFLE1Ba0NDeUksRUFBRSxDQUFDNVEsR0FBSCxDQUFPbWUsR0FBUCxDQUFXN2QsTUFBWCxPQUFzQkMsY0FBSyxDQUFDOVcsU0FBNUIsRUFBeUNrc0IsS0FBekMsQ0FBK0MsUUFBL0MsRUFBeUQsU0FBekQsQ0FsQ0QsRUFvQ0ssQ0FBQzdvQixLQUFLLENBQUNnRCxTQXBDWixLQXFDRXlXLE1BQU0sQ0FBQzFVLFdBQVAsQ0FBbUJ5TSxJQUFuQixDQUF3QnNTLEVBQUUsQ0FBQ2dKLEdBQTNCLEVBQWdDZ1MsT0FBaEMsQ0FyQ0YsRUFzQ0U5K0IsS0FBSyxDQUFDZ0QsU0FBTixHQUFrQjg3QixPQXRDcEI7QUFBQTtBQXlDQSxHQWpYYTs7QUFtWGQ7Ozs7QUFJQTZqQixjQXZYYywwQkF1WEM7QUFDZCxRQUFNNytCLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQzVRLEdBQUgsQ0FBT21lLEdBQVAsQ0FBVzdkLE1BQVgsT0FBc0JDLGNBQUssQ0FBQzlXLFNBQTVCLEVBQXlDa3NCLEtBQXpDLENBQStDLFFBQS9DLEVBQXlELElBQXpELENBSGMsRUFJZC9FLEVBQUUsQ0FBQ3E4QixhQUFILEVBSmMsRUFLZHI4QixFQUFFLENBQUM0cEIsV0FBSCxFQUxjLEVBTWQ1cEIsRUFBRSxDQUFDKzFCLG1CQUFILElBTmMsRUFPZC8xQixFQUFFLENBQUNnZ0MsZUFBSCxFQVBjLEVBUWRoZ0MsRUFBRSxDQUFDb2dDLFlBQUgsRUFSYztBQVNkLEdBaFlhOztBQWtZZDs7Ozs7OztBQU9BakMsOEJBelljLHdDQXlZZWtDLGNBellmLEVBeVkrQjtBQUN0QyxRQUFBcmdDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ2tCOGpCLEVBRGxCLENBQ1M5akIsS0FEVDtBQUFBLFFBR0E0VCxJQUhBLEdBR091d0MsY0FBYyxDQUFDM3hDLE1BQWYsQ0FBc0IsTUFBdEIsRUFDWEMsSUFEVyxDQUNOLE9BRE0sRUFDR3FSLEVBQUUsQ0FBQ3NnQixVQUFILENBQWNuZCxJQUFkLENBQW1CbkQsRUFBbkIsQ0FESCxFQUVYK0UsS0FGVyxDQUVMLFFBRkssRUFFS3BQLE1BQU0sQ0FBQ3BRLHNCQUFQLElBQWlDb1EsTUFBTSxDQUFDblEsc0JBQXhDLEdBQWlFLFNBQWpFLEdBQTZFLElBRmxGLEVBR1hzNUIsRUFIVyxDQUdSLE9BSFEsRUFHQyxVQUFTaHpCLENBQVQsRUFBWTtBQUN4QmtVLFFBQUUsQ0FBQ3NnQyxzQkFBSCxDQUEwQm45QixJQUExQixDQUErQixJQUEvQixFQUFxQ3JYLENBQXJDLEVBQXdDa1UsRUFBeEMsQ0FEd0I7QUFFeEIsS0FMVyxFQU1YdFMsSUFOVyxDQU1Oc1MsRUFBRSxDQUFDMmUscUJBQUgsRUFOTSxDQUhQO0FBeUROLFdBOUNJemlDLEtBQUssQ0FBQ2dDLFNBQU4sS0FBb0IsT0E4Q3hCLElBN0NDNFIsSUFBSSxDQUNGZ3ZCLEVBREYsQ0FDSyxXQURMLEVBQ2tCLFVBQUFoekIsQ0FBQyxFQUFJO0FBRWpCNVAsV0FBSyxDQUFDNkMsUUFBTixJQUFrQjdDLEtBQUssQ0FBQzhDLE9BQXhCLElBQW1DZ2hCLEVBQUUsQ0FBQ21RLFVBQUgsRUFGbEIsSUFNckJ4YSxNQUFNLENBQUNoUyxlQUFQLElBQTBCcWMsRUFBRSxDQUFDa2UsVUFBSCxLQUFvQnB5QixDQUFDLENBQUN1WixLQUF0QixDQU5MO0FBT3JCLEtBUkYsRUFTRXlaLEVBVEYsQ0FTSyxXQVRMLEVBU2tCLFVBQVNoekIsQ0FBVCxFQUFZO0FBQzVCO0FBQ0EsWUFBSTVQLEtBQUssQ0FBQzZDLFFBQU4sSUFBa0I3QyxLQUFLLENBQUM4QyxPQUF4QixJQUFtQ2doQixFQUFFLENBQUNtUSxVQUFILEVBQXZDO0FBQUEsWUFJSTlLLEtBQUssR0FBR3ZaLENBQUMsQ0FBQ3VaLEtBSmQ7QUFBQSxZQUtNeHNCLFNBQVMsR0FBR21uQixFQUFFLENBQUM1USxHQUFILENBQU9tZSxHQUFQLENBQVc3ZCxNQUFYLE9BQXNCQyxjQUFLLENBQUM5VyxTQUE1QixTQUF5Q3dzQixLQUF6QyxDQUxsQjtBQU9JckYsVUFBRSxDQUFDeTNCLFVBQUgsQ0FBYzNyQyxDQUFkLEtBQ0g2SixNQUFNLENBQUNnRSxjQUFQLEtBQTBCLFlBRHZCLElBRUhvbEIsZ0dBQU8sQ0FBQyxJQUFELENBQVAsQ0FBYyxDQUFkLElBQW1CL2UsRUFBRSxDQUFDSyxLQUFILENBQVMxaUIsQ0FBVCxDQUFXcWlCLEVBQUUsQ0FBQzZWLFNBQUgsQ0FBYS9wQixDQUFDLENBQUN6TixFQUFmLEVBQW1CZ25CLEtBQW5CLENBQVgsQ0FUcEIsS0FXQ0EsS0FBSyxJQUFJLENBWFYsR0FjQUEsS0FBSyxLQUFLLENBQUMsQ0FBWCxHQUNDckYsRUFBRSxDQUFDNitCLFlBQUgsRUFERCxHQUNxQjcrQixFQUFFLENBQUM4K0IsbUJBQUgsQ0FBdUIsSUFBdkIsRUFBNkJqbUQsU0FBN0IsRUFBd0N3c0IsS0FBeEMsQ0FmckIsRUFtQksxUCxNQUFNLENBQUNoUyxlQW5CWixJQW9CQ3FjLEVBQUUsQ0FBQ2tlLFVBQUgsQ0FBYzdZLEtBQUssS0FBSyxDQUFDLENBQXpCLEVBQTRCdlosQ0FBQyxDQUFDdVosS0FBOUIsQ0FwQkQ7QUFBQTtBQXNCQSxLQWpDRixFQWtDRXlaLEVBbENGLENBa0NLLFVBbENMLEVBa0NpQixVQUFBaHpCLENBQUMsRUFBSTtBQUVoQixPQUFDNkosTUFBRCxJQUFXcUssRUFBRSxDQUFDbVEsVUFBSCxFQUZLLEtBTXBCblEsRUFBRSxDQUFDNitCLFlBQUgsRUFOb0IsRUFPcEI3K0IsRUFBRSxDQUFDa2UsVUFBSCxLQUFxQnB5QixDQUFDLENBQUN1WixLQUF2QixDQVBvQjtBQVFwQixLQTFDRixDQTZDRCxFQUFPdlYsSUFBUDtBQUNBLEdBcGNhO0FBc2Nkd3dDLHdCQXRjYyxrQ0FzY1N4MEMsQ0F0Y1QsRUFzY1lzRSxHQXRjWixFQXNjaUI7QUFDeEIsUUFBQTRQLEVBQUUsR0FBRzVQLEdBQUw7QUFBQSxRQUNDdUYsTUFERCxHQUMrQnFLLEVBRC9CLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDK0I4akIsRUFEL0IsQ0FDUzlqQixLQURUO0FBQUEsUUFDc0JxVCxJQUR0QixHQUMrQnlRLEVBRC9CLENBQ2dCNVEsR0FEaEIsQ0FDc0JHLElBRHRCO0FBR04sUUFBSXlRLEVBQUUsQ0FBQ21RLFVBQUgsTUFBbUIsQ0FBQ25RLEVBQUUsQ0FBQ28vQixXQUF2QixJQUFzQ2xqRCxLQUFLLENBQUMrQyxXQUFoRCxFQUdDLGFBRkEvQyxLQUFLLENBQUMrQyxXQUFOLEtBQXNCL0MsS0FBSyxDQUFDK0MsV0FBTixLQUF0QixDQUVBO0FBUDZCLFFBVXZCb21CLEtBVnVCLEdBVWR2WixDQVZjLENBVXZCdVosS0FWdUI7QUFZOUI5VixRQUFJLENBQUNrVixTQUFMLE9BQW1COVUsY0FBSyxDQUFDdlYsS0FBekIsU0FBa0NpckIsS0FBbEMsRUFDRWxCLElBREYsQ0FDTyxVQUFTbzhCLEVBQVQsRUFBYTtBQUFBLE9BQ2Q1cUMsTUFBTSxDQUFDblEsc0JBQVAsSUFBaUN3YSxFQUFFLENBQUN1ZSxhQUFILENBQWlCLElBQWpCLEVBQXVCZ2lCLEVBQXZCLENBRG5CLE1BRWpCdmdDLEVBQUUsQ0FBQ28vQixXQUFILENBQWUsSUFBZixFQUFxQm1CLEVBQXJCLEVBQXlCbDdCLEtBQXpCLENBRmlCLEVBR2pCMVAsTUFBTSxDQUFDM1UsWUFBUCxDQUFvQm1pQixJQUFwQixDQUF5Qm5ELEVBQUUsQ0FBQ2dKLEdBQTVCLEVBQWlDdTNCLEVBQWpDLEVBQXFDLElBQXJDLENBSGlCO0FBS2xCLEtBTkYsQ0FaOEI7QUFtQjlCLEdBemRhOztBQTJkZDs7Ozs7OztBQU9BdkMsaUNBbGVjLDJDQWtla0JxQyxjQWxlbEIsRUFrZWtDO0FBQ3pDLFFBQUFyZ0MsRUFBRSxHQUFHLElBQUw7QUFBQSxvQkFDNkJBLEVBQUUsQ0FBQzlqQixLQURoQztBQUFBLFFBQ0NDLEtBREQsYUFDQ0EsS0FERDtBQUFBLFFBQ1FFLE1BRFIsYUFDUUEsTUFEUjtBQUFBLFFBQ2dCNkIsU0FEaEIsYUFDZ0JBLFNBRGhCO0FBQUEsUUFHQTRSLElBSEEsR0FHT3V3QyxjQUFjLENBQ3pCM3hDLE1BRFcsQ0FDSixNQURJLEVBRVhDLElBRlcsQ0FFTixHQUZNLEVBRUQsQ0FGQyxFQUdYQSxJQUhXLENBR04sR0FITSxFQUdELENBSEMsRUFJWEEsSUFKVyxDQUlOLE9BSk0sRUFJR3hTLEtBSkgsRUFLWHdTLElBTFcsQ0FLTixRQUxNLEVBS0l0UyxNQUxKLEVBTVhzUyxJQU5XLENBTU4sT0FOTSxFQU1HZ0IsY0FBSyxDQUFDOVcsU0FOVCxFQU9YaW1DLEVBUFcsQ0FPUixPQVBRLEVBT0MsWUFBVztBQUN2QjllLFFBQUUsQ0FBQ3dnQyx5QkFBSCxDQUE2QnI5QixJQUE3QixDQUFrQyxJQUFsQyxFQUF3Q25ELEVBQXhDLENBRHVCO0FBRXZCLEtBVFcsRUFVWHRTLElBVlcsQ0FVTnNTLEVBQUUsQ0FBQzJlLHFCQUFILEVBVk0sQ0FIUDtBQThCTixXQWZJemdDLFNBQVMsS0FBSyxPQWVsQixJQWRDNFIsSUFBSSxDQUNGZ3ZCLEVBREYsQ0FDSyxxQkFETCxFQUM0QixZQUFXO0FBQ3JDOWUsUUFBRSxDQUFDNCtCLHVCQUFILENBQTJCLElBQTNCLENBRHFDO0FBRXJDLEtBSEYsRUFJRTlmLEVBSkYsQ0FJSyxVQUpMLEVBSWlCLFlBQU07QUFFakIsT0FBQzllLEVBQUUsQ0FBQ3JLLE1BQUosSUFBY3FLLEVBQUUsQ0FBQ21RLFVBQUgsRUFGRyxJQU1yQm5RLEVBQUUsQ0FBQzYrQixZQUFILEVBTnFCO0FBT3JCLEtBWEYsQ0FjRCxFQUFPL3VDLElBQVA7QUFDQSxHQWxnQmE7QUFvZ0JkMHdDLDJCQXBnQmMscUNBb2dCWXB3QyxHQXBnQlosRUFvZ0JpQjtBQUN4QixRQUFBNFAsRUFBRSxHQUFHNVAsR0FBTDtBQUFBLFFBQ0N1RixNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQWdZLGFBRkEsR0FFZ0IzTixFQUFFLENBQUM0TixtQkFBSCxDQUF1QjVOLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQS9CLENBRmhCOztBQUlOLFNBQUlHLEVBQUUsQ0FBQ21RLFVBQUgsQ0FBY3hDLGFBQWQsQ0FBSjtBQUFBLFVBSU1wYSxLQUFLLEdBQUd3ckIsZ0dBQU8sQ0FBQyxJQUFELENBSnJCO0FBQUEsVUFLTS9ELE9BQU8sR0FBR2hiLEVBQUUsQ0FBQzZhLHNCQUFILENBQTBCbE4sYUFBMUIsRUFBeUNwYSxLQUF6QyxDQUxoQjtBQU9JLE9BQUN5bkIsT0FQTCxLQVlJaGIsRUFBRSxDQUFDa2IsU0FBSCxDQUFhRixPQUFPLENBQUMzOEIsRUFBckIsS0FBNEIyaEIsRUFBRSxDQUFDcWIsSUFBSCxDQUFRTCxPQUFSLEVBQWlCem5CLEtBQWpCLElBQTBCb0MsTUFBTSxDQUFDNEIsaUJBWmpFLEtBYUN5SSxFQUFFLENBQUM1USxHQUFILENBQU9HLElBQVAsQ0FBWWtWLFNBQVosT0FBMEI5VSxjQUFLLENBQUN0VixNQUFoQyxHQUF5QzJsQixFQUFFLENBQUNtYix1QkFBSCxDQUEyQkgsT0FBTyxDQUFDMzhCLEVBQW5DLENBQXpDLEVBQ0VvbUIsU0FERixPQUNnQjlVLGNBQUssQ0FBQ3ZWLEtBRHRCLFNBQytCNGdDLE9BQU8sQ0FBQzNWLEtBRHZDLEVBRUVsQixJQUZGLENBRU8sWUFBVztBQUFBLFNBQ1p4TyxNQUFNLENBQUNuUSxzQkFBUCxJQUFpQ3dhLEVBQUUsQ0FBQ3VlLGFBQUgsQ0FBaUIsSUFBakIsRUFBdUJ2RCxPQUF2QixDQURyQixNQUVmaGIsRUFBRSxDQUFDby9CLFdBQUgsQ0FBZSxJQUFmLEVBQXFCcGtCLE9BQXJCLEVBQThCQSxPQUFPLENBQUMzVixLQUF0QyxDQUZlLEVBR2YxUCxNQUFNLENBQUMzVSxZQUFQLENBQW9CbWlCLElBQXBCLENBQXlCbkQsRUFBRSxDQUFDZ0osR0FBNUIsRUFBaUNnUyxPQUFqQyxFQUEwQyxJQUExQyxDQUhlO0FBS2hCLE9BUEYsQ0FiRDtBQUFBLEtBTDhCLENBZ0I5Qjs7QUFXQTtBQS9oQmEsQ0FBZixFOztBQ2JBOzs7O0FBSUE7QUFJQTtBQUtBO0FBQ0E7QUFFZTtBQUNkOzs7O0FBSUF5bEIsV0FMYyx1QkFLRjtBQUNMLFFBQUF6Z0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNtQ3FLLEVBRG5DLENBQ0NySyxNQUREO0FBQUEsUUFDUzBLLEtBRFQsR0FDbUNMLEVBRG5DLENBQ1NLLEtBRFQ7QUFBQSxRQUNzQjdRLFFBRHRCLEdBQ21Dd1EsRUFEbkMsQ0FDZ0I1USxHQURoQixDQUNzQkksUUFEdEI7QUFBQSxRQUVBdVksU0FGQSxHQUVZcFMsTUFBTSxDQUFDYyxZQUZuQjtBQUtOdUosTUFBRSxDQUFDL29CLEtBQUgsR0FBVzh3QixTQUFTLEdBQUcyNEIscUZBQVEsRUFBWCxHQUFnQkMscUZBQVEsRUFOakM7O0FBUVg7QUFSVyxRQXdCUEMsVUF4Qk87QUFBQSxRQXlCUEMsT0F6Qk87QUFBQSxRQVNMQyxZQUFZLEdBQUcsWUFBTTtBQUMxQjlnQyxRQUFFLENBQUMrZ0MsY0FBSCxFQUQwQjtBQUUxQixLQVhVO0FBQUEsUUFZTEMsWUFBWSxHQUFHLFlBQU07QUFBQSxVQUNwQi9wRCxLQUFLLEdBQUcrb0IsRUFBRSxDQUFDNVEsR0FBSCxDQUFPbWUsR0FBUCxDQUFXN2QsTUFBWCxPQUFzQkMsY0FBSyxDQUFDMVksS0FBNUIsZUFEWTtBQUFBLFVBRXBCcTRDLFNBQVMsR0FBRztBQUFDbnpDLGFBQUssRUFBRSxDQUFSO0FBQVdFLGNBQU0sRUFBRTtBQUFuQixPQUZRO0FBUzFCLGFBTElwRixLQUFLLENBQUMyRyxJQUFOLEVBS0osS0FKQzB4QyxTQUFTLENBQUNuekMsS0FBVixHQUFrQixDQUFDbEYsS0FBSyxDQUFDMFgsSUFBTixDQUFXLE9BQVgsQ0FJcEIsRUFIQzJnQyxTQUFTLENBQUNqekMsTUFBVixHQUFtQixDQUFDcEYsS0FBSyxDQUFDMFgsSUFBTixDQUFXLFFBQVgsQ0FHckIsR0FBTzJnQyxTQUFTLENBQUN2bkIsU0FBUyxHQUFHLE9BQUgsR0FBYSxRQUF2QixDQUFoQjtBQUNBLEtBdEJVOztBQXlEWDtBQTlCQS9ILE1BQUUsQ0FBQy9vQixLQUFILENBQ0U2bkMsRUFERixDQUNLLE9BREwsRUFDYyxZQUFNO0FBQ2xCOWUsUUFBRSxDQUFDOWpCLEtBQUgsQ0FBU2dDLFNBQVQsS0FBdUIsT0FBdkIsSUFBa0M4aEIsRUFBRSxDQUFDNHBCLFdBQUgsRUFEaEIsRUFFbEJrWCxZQUFZLEVBRk07QUFHbEIsS0FKRixFQUtFaGlCLEVBTEYsQ0FLSyxPQUxMLEVBS2NnaUIsWUFMZCxFQU1FaGlCLEVBTkYsQ0FNSyxLQU5MLEVBTVksWUFBTTtBQUNoQjhoQixnQkFBVSxHQUFHdmdDLEtBQUssQ0FBQzFpQixDQUFOLENBQVFzeUIsU0FBUixFQURHO0FBRWhCLEtBUkYsQ0EzQlcsRUFxQ1hqUSxFQUFFLENBQUMvb0IsS0FBSCxDQUFTZ3FELFlBQVQsR0FBd0IsWUFBVztBQUFBOztBQUNsQ0osYUFBTyxJQUFJSyxZQUFZLENBQUNMLE9BQUQsQ0FEVyxFQUVsQ0EsT0FBTyxHQUFHTSxVQUFVLENBQUMsWUFBTTtBQUMxQixZQUFNaHlDLFNBQVMsR0FBRyxLQUFJLENBQUM4cUMsWUFBTCxFQUFsQjs7QUFFQTJHLGtCQUFVLElBQUloeEMsNkZBQWdCLENBQUNULFNBQVMsQ0FBQ3BCLElBQVYsRUFBRCxDQUE5QixJQUNDLEtBQUksQ0FBQ21zQyxJQUFMLENBQVUvcUMsU0FBVixFQUFxQnl4QyxVQUFVLENBQUN4eUMsR0FBWCxDQUFlaVMsS0FBSyxDQUFDcUgsSUFBTixDQUFXd2xCLFFBQVgsRUFBZixDQUFyQixDQUp5QjtBQUsxQixPQUxtQixFQUtqQixDQUxpQixDQUZjO0FBUWxDLEtBN0NVLEVBK0NYbHRCLEVBQUUsQ0FBQy9vQixLQUFILENBQVNtcUQsTUFBVCxHQUFrQixZQUFXO0FBQzVCLFVBQU1DLE1BQU0sR0FBRyxLQUFLQSxNQUFMLElBQWY7QUFNQSxhQUpJQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUvdUMsTUFBVixDQUFpQixVQUFBckgsQ0FBQztBQUFBLGVBQUlvQixLQUFLLENBQUNwQixDQUFELENBQVQ7QUFBQSxPQUFsQixFQUFnQ2dCLE1BQWhDLEtBQTJDLENBSS9DLElBSEN1RCxRQUFRLENBQUNELElBQVQsSUFBaUJDLFFBQVEsQ0FBQ0QsSUFBVCxDQUFjRyxNQUFkLE9BQXlCQyxjQUFLLENBQUMxWSxLQUEvQixFQUF3Q3lXLElBQXhDLENBQTZDLElBQTdDLENBR2xCLEVBQU8sSUFBUDtBQUNBLEtBdkRVLEVBMERYc1MsRUFBRSxDQUFDL29CLEtBQUgsQ0FBU29wQixLQUFULEdBQWlCLFVBQVNBLEtBQVQsRUFBZ0I7QUFBQSxVQUMxQlMsQ0FBQyxHQUFHbkwsTUFBTSxDQUFDbUMsb0JBQVAsSUFBK0JrcEMsWUFBWSxFQURyQjtBQUFBLFVBRTVCSyxNQUFNLEdBQUdyaEMsRUFBRSxDQUFDc2hDLFNBQUgsRUFGbUI7QUFVaEM7QUFJQTtBQUNBO0FBWEksT0FBQ0QsTUFBRCxJQUFXaGhDLEtBQUssQ0FBQ0ksS0FKVyxHQUsvQjRnQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQUQsRUFBUyxDQUFDaGhDLEtBQUssQ0FBQ0ksS0FBTixHQUFjLENBQWQsQ0FBRCxFQUFtQkssQ0FBbkIsQ0FBVCxDQUxzQixHQU1yQnZVLE9BQU8sQ0FBQzgwQyxNQUFELENBTmMsS0FPL0JBLE1BQU0sR0FBR0EsTUFBTSxDQUFDanpDLEdBQVAsQ0FBVyxVQUFDbkQsQ0FBRCxFQUFJd0QsQ0FBSjtBQUFBLGVBQVUsQ0FBQ3hELENBQUQsRUFBSXdELENBQUMsR0FBRyxDQUFKLEdBQVFxUyxDQUFSLEdBQVlyUyxDQUFoQixDQUFWO0FBQUEsT0FBWCxDQVBzQixHQVdoQ3NaLFNBQVMsSUFBSXM1QixNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUvNkIsT0FBVixFQVhtQixFQVloQyxLQUFLKzZCLE1BQUwsQ0FBWUEsTUFBWixDQVpnQyxFQWdCaEMsS0FBS0QsTUFBTCxFQWhCZ0M7QUFpQmhDLEtBM0VVLEVBNkVYcGhDLEVBQUUsQ0FBQy9vQixLQUFILENBQVNnakQsWUFBVCxHQUF3QjtBQUFBLGFBQ3ZCO0FBQ0F6cUMsZ0JBQVEsQ0FBQ0QsSUFBVCxHQUFnQkMsUUFBUSxDQUFDRCxJQUFULENBQWNHLE1BQWQsT0FBeUJDLGNBQUssQ0FBQzFZLEtBQS9CLENBQWhCLEdBQTBEbXRCLGlHQUFRLENBQUMsRUFBRDtBQUYzQztBQUFBLEtBN0ViO0FBaUZYLEdBdEZhOztBQXdGZDs7OztBQUlBbTlCLGNBNUZjLDBCQTRGQztBQUNkLFFBQU12aEMsRUFBRSxHQUFHLElBQVg7O0FBRUEsUUFBS0EsRUFBRSxDQUFDNlcsT0FBUjtBQUFBLFVBSU9saEIsTUFKUCxHQUlrRXFLLEVBSmxFLENBSU9ySyxNQUpQO0FBQUEsVUFJdUJ2WCxJQUp2QixHQUlrRTRoQixFQUpsRSxDQUllOWpCLEtBSmYsQ0FJdUJrQyxJQUp2QjtBQUFBLG9CQUlrRTRoQixFQUpsRSxDQUk4QjVRLEdBSjlCO0FBQUEsVUFJb0NveUMsSUFKcEMsV0FJb0NBLElBSnBDO0FBQUEsVUFJMENqMEIsR0FKMUMsV0FJMENBLEdBSjFDO0FBQUEsVUFJK0MvZCxRQUovQyxXQUkrQ0EsUUFKL0M7QUFBQSxVQUl5RGhaLElBSnpELFdBSXlEQSxJQUp6RDtBQUFBLFVBS01pckQsVUFMTixHQUttQjlyQyxNQUFNLENBQUNrQyxhQUFQLEdBQXVCLFNBQXZCLEdBQW1DLFFBTHREO0FBQUEsVUFNTTZwQyxNQU5OLEdBTWtCdGpELElBQUksQ0FBQ0MsRUFOdkI7QUFBQSxVQU9NNGYsUUFQTixHQU9pQitCLEVBQUUsQ0FBQzJoQyxXQUFILENBQWVELE1BQWYsQ0FQakI7QUFTQXRqRCxVQUFJLENBQUNLLFVBQUwsR0FBa0JpakQsTUFUbEIsRUFVQTFoQyxFQUFFLENBQUM0aEMsVUFBSCxDQUFjSixJQUFkLEVBQW9CRSxNQUFwQixDQVZBLEVBV0ExaEMsRUFBRSxDQUFDeWdDLFNBQUgsRUFYQSxFQWFBanhDLFFBQVEsQ0FBQ0QsSUFBVCxHQUFnQmdlLEdBQUcsQ0FBQzdlLE1BQUosQ0FBVyxHQUFYLEVBQWdCQyxJQUFoQixDQUFxQixXQUFyQixFQUFrQ3FSLEVBQUUsQ0FBQ29JLFlBQUgsQ0FBZ0IsU0FBaEIsQ0FBbEMsQ0FiaEI7QUFBQSxVQWVPN1ksSUFmUCxHQWVlQyxRQWZmLENBZU9ELElBZlA7QUFpQkFBLFVBQUksQ0FBQ3dWLEtBQUwsQ0FBVyxZQUFYLEVBQXlCMDhCLFVBQXpCLENBakJBLEVBb0JBbHlDLElBQUksQ0FBQ2IsTUFBTCxDQUFZLEdBQVosRUFDRUMsSUFERixDQUNPLFdBRFAsRUFDb0JzUCxRQURwQixFQUVFdFAsSUFGRixDQUVPLE9BRlAsRUFFZ0JnQixjQUFLLENBQUN2WSxLQUZ0QixDQXBCQSxFQXlCQTRvQixFQUFFLENBQUNrVyxPQUFILENBQVcsS0FBWCxLQUFxQjNtQixJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ3ZZLEtBQXRCLEVBQ25Cc1gsTUFEbUIsQ0FDWixHQURZLEVBRW5CQyxJQUZtQixDQUVkLE9BRmMsRUFFTGdCLGNBQUssQ0FBQzdYLFNBRkQsQ0F6QnJCLEVBOEJBeVgsSUFBSSxDQUFDRyxNQUFMLE9BQWdCQyxjQUFLLENBQUN2WSxLQUF0QixFQUNFc1gsTUFERixDQUNTLEdBRFQsRUFFRUMsSUFGRixDQUVPLE9BRlAsRUFFZ0JnQixjQUFLLENBQUMxWCxVQUZ0QixDQTlCQSxFQW1DQXNYLElBQUksQ0FBQ2IsTUFBTCxDQUFZLEdBQVosRUFDRUMsSUFERixDQUNPLFdBRFAsRUFDb0JzUCxRQURwQixFQUVFdFAsSUFGRixDQUVPLE9BRlAsRUFFZ0JnQixjQUFLLENBQUMxWSxLQUZ0QixFQUdFeVcsSUFIRixDQUdPc1MsRUFBRSxDQUFDL29CLEtBSFYsQ0FuQ0EsRUEwQ0FULElBQUksQ0FBQ2t4QixJQUFMLEdBQVluWSxJQUFJLENBQUNiLE1BQUwsQ0FBWSxHQUFaLEVBQ1ZDLElBRFUsQ0FDTCxPQURLLEVBQ0lnQixjQUFLLENBQUNsWixLQURWLEVBRVZrWSxJQUZVLENBRUwsV0FGSyxFQUVRcVIsRUFBRSxDQUFDb0ksWUFBSCxDQUFnQixNQUFoQixDQUZSLEVBR1Z6WixJQUhVLENBR0wsV0FISyxFQUdRZ0gsTUFBTSxDQUFDYyxZQUFQLEdBQXNCLEVBQXRCLEdBQTJCclksSUFBSSxDQUFDTyxTQUh4QyxFQUlWb21CLEtBSlUsQ0FJSixZQUpJLEVBSVVwUCxNQUFNLENBQUNvQyxvQkFBUCxHQUE4QjBwQyxVQUE5QixHQUEyQyxRQUpyRCxDQTFDWjtBQUFBO0FBK0NBLEdBOUlhOztBQWdKZDs7Ozs7QUFLQUksMEJBckpjLG9DQXFKV2hpQyxPQXJKWCxFQXFKb0I7QUFDM0IsUUFBQUcsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUMyQ3FLLEVBRDNDLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDMkM4akIsRUFEM0MsQ0FDUzlqQixLQURUO0FBQUEsUUFDaUNxVCxJQURqQyxHQUMyQ3lRLEVBRDNDLENBQ2dCNVEsR0FEaEIsQ0FDc0JJLFFBRHRCLENBQ2lDRCxJQURqQztBQUFBLFFBRUF3eEIsYUFGQSxHQUVnQi9nQixFQUFFLENBQUMrZ0IsYUFBSCxDQUFpQjVkLElBQWpCLENBQXNCbkQsRUFBdEIsQ0FGaEI7QUFBQSxRQUdBK2YsU0FIQSxHQUdZL2YsRUFBRSxDQUFDK2YsU0FBSCxDQUFhNWMsSUFBYixDQUFrQm5ELEVBQWxCLENBSFo7QUFBQSxRQUlBOGdCLGNBSkEsR0FJaUI5Z0IsRUFBRSxDQUFDOGdCLGNBQUgsQ0FBa0IzZCxJQUFsQixDQUF1Qm5ELEVBQXZCLENBSmpCO0FBQUEsUUFLQTJmLFVBTEEsR0FLYTNmLEVBQUUsQ0FBQzJmLFVBQUgsQ0FBY3hjLElBQWQsQ0FBbUJuRCxFQUFuQixDQUxiO0FBQUEsUUFNQW1nQixVQU5BLEdBTWFuZ0IsRUFBRSxDQUFDbWdCLFVBQUgsQ0FBY2hkLElBQWQsQ0FBbUJuRCxFQUFuQixDQU5iOztBQVFOLFFBQUlySyxNQUFNLENBQUNrQyxhQUFYLEVBQTBCO0FBQ3pCO0FBRHlCLFVBRW5CaXFDLFNBQVMsR0FBR3Z5QyxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQzdYLFNBQXRCLEVBQ2hCMnNCLFNBRGdCLE9BQ0Y5VSxjQUFLLENBQUM5WCxRQURKLEVBRWhCc2EsSUFGZ0IsQ0FFWDBOLE9BRlcsRUFHaEJsUixJQUhnQixDQUdYLE9BSFcsRUFHRm95QixhQUhFLENBRk87QUFBQSxVQU1uQmdoQixRQUFRLEdBQUdELFNBQVMsQ0FBQ3A5QixLQUFWLEdBQ2ZoVyxNQURlLENBQ1IsR0FEUSxFQUVmcVcsS0FGZSxDQUVULFNBRlMsRUFFRSxHQUZGLEVBR2ZwVyxJQUhlLENBR1YsT0FIVSxFQUdEb3lCLGFBSEMsRUFJZnBjLEtBSmUsQ0FJVG05QixTQUpTLENBTlE7QUFhekJDLGNBQVEsQ0FBQ3J6QyxNQUFULENBQWdCLEdBQWhCLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCb3hCLFNBRGhCLENBYnlCO0FBZ0J6QjtBQWhCeUIsVUFpQm5CcmEsVUFBVSxHQUFHblcsSUFBSSxDQUFDRyxNQUFMLE9BQWdCQyxjQUFLLENBQUMxWCxVQUF0QixFQUNqQndzQixTQURpQixPQUNIOVUsY0FBSyxDQUFDM1gsU0FESCxFQUVqQm1hLElBRmlCLENBRVowTixPQUZZLEVBR2pCbFIsSUFIaUIsQ0FHWixPQUhZLEVBR0hteUIsY0FIRyxDQWpCTTtBQUFBLFVBcUJuQmtoQixTQUFTLEdBQUd0OEIsVUFBVSxDQUFDaEIsS0FBWCxHQUFtQmhXLE1BQW5CLENBQTBCLEdBQTFCLEVBQ2hCcVcsS0FEZ0IsQ0FDVixTQURVLEVBQ0MsR0FERCxFQUVoQnBXLElBRmdCLENBRVgsT0FGVyxFQUVGbXlCLGNBRkUsRUFHaEJuYyxLQUhnQixDQUdWZSxVQUhVLENBckJPO0FBMEJ6QjtBQUlBO0FBSUE7QUFQQXM4QixlQUFTLENBQUN0ekMsTUFBVixDQUFpQixHQUFqQixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQmd4QixVQURoQixDQTNCeUIsRUErQnpCM2YsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE1BQVgsS0FBc0I4ckIsU0FBUyxDQUFDdHpDLE1BQVYsQ0FBaUIsR0FBakIsRUFDcEJDLElBRG9CLENBQ2YsT0FEZSxFQUNOd3hCLFVBRE0sQ0EvQkcsRUFtQ3pCNXdCLElBQUksQ0FBQ2tWLFNBQUwsT0FBbUI5VSxjQUFLLENBQUMxWSxLQUF6QixZQUNFMFgsSUFERixDQUNPZ0gsTUFBTSxDQUFDYyxZQUFQLEdBQXNCLE9BQXRCLEdBQWdDLFFBRHZDLEVBQ2lEZCxNQUFNLENBQUNjLFlBQVAsR0FBc0J2YSxLQUFLLENBQUNFLE1BQTVCLEdBQXFDRixLQUFLLENBQUNJLE9BRDVGLENBbkN5QjtBQXFDekI7QUFDRCxHQXBNYTs7QUFzTWQ7Ozs7O0FBS0EybEQsc0JBM01jLGdDQTJNT3BSLGVBM01QLEVBMk13QjtBQUMvQixRQUFBN3dCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDT3hRLFFBRFAsR0FDb0J3USxFQURwQixDQUNDNVEsR0FERCxDQUNPSSxRQURQO0FBR05BLFlBQVEsQ0FBQ3pZLEdBQVQsR0FBZXlZLFFBQVEsQ0FBQ0QsSUFBVCxDQUFja1YsU0FBZCxPQUE0QjlVLGNBQUssQ0FBQzNZLElBQWxDLEVBQTBDeXRCLFNBQTFDLE9BQXdEOVUsY0FBSyxDQUFDNVksR0FBOUQsRUFDYm9iLElBRGEsQ0FDUjZOLEVBQUUsQ0FBQ2s0QixPQUFILENBQVcvMEIsSUFBWCxDQUFnQm5ELEVBQWhCLENBRFEsQ0FKc0IsRUFPckN4USxRQUFRLENBQUN6WSxHQUFULENBQ0VrdUIsSUFERixHQUVFaEQsVUFGRixHQUdFOE0sUUFIRixDQUdXOGhCLGVBSFgsRUFJRTlyQixLQUpGLENBSVEsU0FKUixFQUltQixHQUpuQixFQUtFcEYsTUFMRixFQVBxQyxFQWNyQ25RLFFBQVEsQ0FBQ3pZLEdBQVQsR0FBZXlZLFFBQVEsQ0FBQ3pZLEdBQVQsQ0FDYjJ0QixLQURhLEdBRWJoVyxNQUZhLENBRU4sTUFGTSxFQUdiQyxJQUhhLENBR1IsT0FIUSxFQUdDcVIsRUFBRSxDQUFDOGYsUUFBSCxDQUFZM2MsSUFBWixDQUFpQm5ELEVBQWpCLENBSEQsRUFJYitFLEtBSmEsQ0FJUCxRQUpPLEVBSUcsTUFKSCxFQUtiQSxLQUxhLENBS1AsTUFMTyxFQUtDL0UsRUFBRSxDQUFDOUMsS0FMSixFQU1ieUgsS0FOYSxDQU1QblYsUUFBUSxDQUFDelksR0FORixFQU9iZ3VCLEtBUGEsQ0FPUCxTQVBPLEVBT0kvRSxFQUFFLENBQUNraUMsY0FBSCxDQUFrQi8rQixJQUFsQixDQUF1Qm5ELEVBQXZCLENBUEosQ0Fkc0I7QUFzQnJDLEdBak9hOztBQW1PZDs7Ozs7OztBQU9BbWlDLHNCQTFPYyxnQ0EwT09DLFlBMU9QLEVBME9xQnAwQixjQTFPckIsRUEwT3FDZSxRQTFPckMsRUEwTytDO0FBQUEsUUFDckRoNEIsR0FEcUQsR0FDOUMsS0FBS3FZLEdBQUwsQ0FBU0ksUUFEcUMsQ0FDckR6WSxHQURxRDtBQUc1RCxLQUFDaTNCLGNBQWMsR0FBR2ozQixHQUFHLENBQUNrckIsVUFBSixDQUFlbFMsU0FBUyxFQUF4QixFQUE0QmdmLFFBQTVCLENBQXFDQSxRQUFyQyxDQUFILEdBQW9EaDRCLEdBQW5FLEVBQ0U0WCxJQURGLENBQ08sR0FEUCxFQUNZeXpDLFlBRFosRUFFRXI5QixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixDQUg0RDtBQU01RCxHQWhQYTs7QUFrUGQ7Ozs7O0FBS0FzOUIsdUJBdlBjLGlDQXVQUXhSLGVBdlBSLEVBdVB5QjtBQUNoQyxRQUFBN3dCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDT3hRLFFBRFAsR0FDb0J3USxFQURwQixDQUNDNVEsR0FERCxDQUNPSSxRQURQO0FBR05BLFlBQVEsQ0FBQzFWLElBQVQsR0FBZ0IwVixRQUFRLENBQUNELElBQVQsQ0FBY2tWLFNBQWQsT0FBNEI5VSxjQUFLLENBQUM1VixLQUFsQyxFQUNkMHFCLFNBRGMsT0FDQTlVLGNBQUssQ0FBQzdWLElBRE4sRUFFZHFZLElBRmMsQ0FFVDZOLEVBQUUsQ0FBQ2c0QixRQUFILENBQVk3MEIsSUFBWixDQUFpQm5ELEVBQWpCLENBRlMsQ0FKc0IsRUFRdEN4USxRQUFRLENBQUMxVixJQUFULENBQ0VtckIsSUFERixHQUVFaEQsVUFGRixHQUdFOE0sUUFIRixDQUdXOGhCLGVBSFgsRUFJRTlyQixLQUpGLENBSVEsU0FKUixFQUltQixHQUpuQixFQUtFcEYsTUFMRixFQVJzQyxFQWV0Q25RLFFBQVEsQ0FBQzFWLElBQVQsR0FBZ0IwVixRQUFRLENBQUMxVixJQUFULENBQ2Q0cUIsS0FEYyxHQUVkaFcsTUFGYyxDQUVQLE1BRk8sRUFHZEMsSUFIYyxDQUdULE9BSFMsRUFHQXFSLEVBQUUsQ0FBQzBmLFNBQUgsQ0FBYXZjLElBQWIsQ0FBa0JuRCxFQUFsQixDQUhBLEVBSWQrRSxLQUpjLENBSVIsUUFKUSxFQUlFL0UsRUFBRSxDQUFDOUMsS0FKTCxFQUtkeUgsS0FMYyxDQUtSblYsUUFBUSxDQUFDMVYsSUFMRCxFQU1kaXJCLEtBTmMsQ0FNUixTQU5RLEVBTUcvRSxFQUFFLENBQUNraUMsY0FBSCxDQUFrQi8rQixJQUFsQixDQUF1Qm5ELEVBQXZCLENBTkgsQ0Fmc0I7QUFzQnRDLEdBN1FhOztBQStRZDs7Ozs7OztBQU9Bc2lDLHVCQXRSYyxpQ0FzUlFDLGFBdFJSLEVBc1J1QnYwQixjQXRSdkIsRUFzUnVDZSxRQXRSdkMsRUFzUmlEO0FBQUEsUUFDdkRqMUIsSUFEdUQsR0FDL0MsS0FBS3NWLEdBQUwsQ0FBU0ksUUFEc0MsQ0FDdkQxVixJQUR1RDtBQUc5RCxLQUFDazBCLGNBQWMsR0FBR2wwQixJQUFJLENBQUNtb0IsVUFBTCxDQUFnQmxTLFNBQVMsRUFBekIsRUFBNkJnZixRQUE3QixDQUFzQ0EsUUFBdEMsQ0FBSCxHQUFxRGoxQixJQUFwRSxFQUNFNlUsSUFERixDQUNPLEdBRFAsRUFDWTR6QyxhQURaLEVBRUV4OUIsS0FGRixDQUVRLFNBRlIsRUFFbUIsR0FGbkIsQ0FIOEQ7QUFNOUQsR0E1UmE7O0FBOFJkOzs7OztBQUtBeTlCLHVCQW5TYyxpQ0FtU1EzUixlQW5TUixFQW1TeUI7QUFDaEMsUUFBQTd3QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ094USxRQURQLEdBQ29Cd1EsRUFEcEIsQ0FDQzVRLEdBREQsQ0FDT0ksUUFEUDtBQUdOQSxZQUFRLENBQUNsWixJQUFULEdBQWdCa1osUUFBUSxDQUFDRCxJQUFULENBQWNrVixTQUFkLE9BQTRCOVUsY0FBSyxDQUFDcFosS0FBbEMsRUFDZGt1QixTQURjLE9BQ0E5VSxjQUFLLENBQUNyWixJQUROLEVBRWQ2YixJQUZjLENBRVQ2TixFQUFFLENBQUNnNEIsUUFBSCxDQUFZNzBCLElBQVosQ0FBaUJuRCxFQUFqQixDQUZTLENBSnNCLEVBUXRDeFEsUUFBUSxDQUFDbFosSUFBVCxDQUNFMnVCLElBREYsR0FFRWhELFVBRkYsR0FHRThNLFFBSEYsQ0FHVzhoQixlQUhYLEVBSUU5ckIsS0FKRixDQUlRLFNBSlIsRUFJbUIsR0FKbkIsRUFLRXBGLE1BTEYsRUFSc0MsRUFldENuUSxRQUFRLENBQUNsWixJQUFULEdBQWdCa1osUUFBUSxDQUFDbFosSUFBVCxDQUNkb3VCLEtBRGMsR0FFZGhXLE1BRmMsQ0FFUCxNQUZPLEVBR2RDLElBSGMsQ0FHVCxPQUhTLEVBR0FxUixFQUFFLENBQUNrZ0IsU0FBSCxDQUFhL2MsSUFBYixDQUFrQm5ELEVBQWxCLENBSEEsRUFJZCtFLEtBSmMsQ0FJUixNQUpRLEVBSUEvRSxFQUFFLENBQUM5QyxLQUpILEVBS2Q2SCxLQUxjLENBS1IsU0FMUSxFQUtHLFlBQVc7QUFFNUIsYUFEQS9FLEVBQUUsQ0FBQzlqQixLQUFILENBQVNxRCxjQUFULEdBQTBCNmtCLGlHQUFRLENBQUMsSUFBRCxDQUFSLENBQWVXLEtBQWYsQ0FBcUIsU0FBckIsQ0FDMUIsRUFBTyxHQUFQO0FBQ0EsS0FSYyxFQVNkSixLQVRjLENBU1JuVixRQUFRLENBQUNsWixJQVRELEVBVWR5dUIsS0FWYyxDQVVSLFNBVlEsRUFVRyxHQVZILENBZnNCO0FBMEJ0QyxHQTdUYTs7QUE4VGQ7Ozs7Ozs7QUFPQTA5Qix1QkFyVWMsaUNBcVVRQyxhQXJVUixFQXFVdUIxMEIsY0FyVXZCLEVBcVV1Q2UsUUFyVXZDLEVBcVVpRDtBQUFBLFFBQ3ZEejRCLElBRHVELEdBQy9DLEtBQUs4WSxHQUFMLENBQVNJLFFBRHNDLENBQ3ZEbFosSUFEdUQ7QUFHOUQsS0FBQzAzQixjQUFjLEdBQUcxM0IsSUFBSSxDQUFDMnJCLFVBQUwsQ0FBZ0JsUyxTQUFTLEVBQXpCLEVBQTZCZ2YsUUFBN0IsQ0FBc0NBLFFBQXRDLENBQUgsR0FBcUR6NEIsSUFBcEUsRUFDRXFZLElBREYsQ0FDTyxHQURQLEVBQ1krekMsYUFEWixFQUVFMzlCLEtBRkYsQ0FFUSxNQUZSLEVBRWdCLEtBQUs3SCxLQUZyQixFQUdFNkgsS0FIRixDQUdRLFNBSFIsRUFHbUIsS0FBSzdvQixLQUFMLENBQVdxRCxjQUg5QixDQUg4RDtBQU85RCxHQTVVYTs7QUE4VWQ7Ozs7Ozs7QUFPQW9qRCxnQkFyVmMsMEJBcVZDQyxZQXJWRCxFQXFWZTd6QixRQXJWZixFQXFWeUIzMEIsS0FyVnpCLEVBcVZnQztBQUN2QyxRQUFBNGxCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDb0NxSyxFQURwQyxDQUNDckssTUFERDtBQUFBLFFBQzBCcEcsSUFEMUIsR0FDb0N5USxFQURwQyxDQUNTNVEsR0FEVCxDQUNlSSxRQURmLENBQzBCRCxJQUQxQjtBQUdOQSxRQUFJLENBQUN3VixLQUFMLENBQVcsWUFBWCxFQUF5QnBQLE1BQU0sQ0FBQ2tDLGFBQVAsR0FBdUIsU0FBdkIsR0FBbUMsUUFBNUQsQ0FKNkMsRUFPekNsQyxNQUFNLENBQUNrQyxhQVBrQyxLQVN4Q3ZJLHdGQUFPLElBQUlBLHdGQUFPLENBQUNHLElBQVIsS0FBaUIsTUFUWSxJQVUzQ3VRLEVBQUUsQ0FBQy9vQixLQUFILENBQVNtcUQsTUFBVCxFQVYyQyxFQWN4Q3dCLFlBZHdDLEtBZ0IzQyxDQUFDenlDLFVBQVUsQ0FBQzZQLEVBQUQsQ0FBWCxJQUFtQkEsRUFBRSxDQUFDL29CLEtBQUgsQ0FBU21xRCxNQUFULEVBaEJ3QixFQWtCM0NqMUMsTUFBTSxDQUFDQyxJQUFQLENBQVloUyxLQUFLLENBQUNxVixJQUFsQixFQUF3QnBDLE9BQXhCLENBQWdDLFVBQUFwQyxDQUFDLEVBQUk7QUFBQSxVQUM5QjRZLElBQUksR0FBR3BULFVBQVUsQ0FBQ3hGLENBQUQsQ0FEYTtBQUFBLFVBRTlCNDNDLElBQUksR0FBRzdpQyxFQUFFLGtCQUFnQjZELElBQWhCLENBQUYsQ0FBMEJ6cEIsS0FBSyxDQUFDczNDLE9BQU4sQ0FBY3ptQyxDQUFkLENBQTFCLEtBRnVCO0FBSXBDK1UsUUFBRSxZQUFVNkQsSUFBVixpQkFBRixDQUErQmtMLFFBQS9CLENBSm9DLEVBS3BDL08sRUFBRSxZQUFVNkQsSUFBVixpQkFBRixDQUErQmcvQixJQUEvQixFQUFxQzl6QixRQUFyQyxFQUErQ0EsUUFBL0MsQ0FMb0M7QUFNcEMsS0FORCxDQWxCMkM7QUEyQjdDLEdBaFhhOztBQWtYZDs7OztBQUlBZ3lCLGdCQXRYYyw0QkFzWEc7QUFDVixRQUFBL2dDLEVBQUUsR0FBRyxJQUFMO0FBQUEscUJBQzJEQSxFQUQzRCxDQUNDckssTUFERDtBQUFBLFFBQ1V1QyxnQkFEVixjQUNVQSxnQkFEVjtBQUFBLFFBQzBDaWlDLEtBRDFDLGNBQzRCN2hDLFlBRDVCO0FBQUEsUUFDa0QrSCxLQURsRCxHQUMyREwsRUFEM0QsQ0FDa0RLLEtBRGxEO0FBR05MLE1BQUUsQ0FBQ2tQLE1BQUgsQ0FBVTtBQUNUbEIsb0JBQWMsSUFETDtBQUVUbXNCLFdBQUssRUFBTEEsS0FGUztBQUdUeUksa0JBQVksSUFISDtBQUlUamxCLHVCQUFpQixJQUpSO0FBS1R5YyxtQkFBYTtBQUxKLEtBQVYsQ0FKZ0IsRUFZaEJsaUMsZ0JBQWdCLENBQUNpTCxJQUFqQixDQUFzQm5ELEVBQUUsQ0FBQ2dKLEdBQXpCLEVBQThCM0ksS0FBSyxDQUFDMWlCLENBQU4sQ0FBUXN5QixTQUFSLEVBQTlCLENBWmdCO0FBYWhCLEdBbllhOztBQXFZZDs7Ozs7O0FBTUEybUIsa0JBM1ljLDRCQTJZRzVvQixjQTNZSCxFQTJZbUJtQixXQTNZbkIsRUEyWWdDO0FBR3pDLFFBQUEyekIsUUFBUTtBQUFBLFFBRk45aUMsRUFFTSxHQUZELElBRUM7QUFBQSxRQURMelEsSUFDSyxHQURHeVEsRUFBRSxDQUFDNVEsR0FBSCxDQUFPSSxRQUNWLENBRExELElBQ0s7QUFFUjRmLGVBQVcsSUFBSUEsV0FBVyxDQUFDRixRQUxjLEdBTTVDNnpCLFFBQVEsR0FBRzN6QixXQUFXLENBQUNGLFFBTnFCLElBUTVDNnpCLFFBQVEsR0FBR3Z6QyxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ2xaLEtBQXRCLENBUmlDLEVBVXhDdTNCLGNBVndDLEtBVzNDODBCLFFBQVEsR0FBR0EsUUFBUSxDQUFDN2dDLFVBQVQsRUFYZ0MsSUFlN0MxUyxJQUFJLENBQUNaLElBQUwsQ0FBVSxXQUFWLEVBQXVCcVIsRUFBRSxDQUFDb0ksWUFBSCxDQUFnQixTQUFoQixDQUF2QixDQWY2QyxFQWdCN0MwNkIsUUFBUSxDQUFDbjBDLElBQVQsQ0FBYyxXQUFkLEVBQTJCcVIsRUFBRSxDQUFDb0ksWUFBSCxDQUFnQixNQUFoQixDQUEzQixDQWhCNkM7QUFpQjdDLEdBNVphOztBQThaZDs7Ozs7QUFLQWs1QixXQW5hYyx1QkFtYUY7QUFDTCxRQUFBdGhDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1MwSyxLQURULEdBQ2tCTCxFQURsQixDQUNTSyxLQURUO0FBQUEsUUFFRmdoQyxNQUZFLEdBRU8xckMsTUFBTSxDQUFDck8sYUFGZDtBQUlOLFFBQUkrNUMsTUFBSixFQUNDLElBQUluMkMsVUFBVSxDQUFDbTJDLE1BQUQsQ0FBZCxFQUNDQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ2wrQixJQUFQLENBQVluRCxFQUFFLENBQUNnSixHQUFmLEVBQW9CaEosRUFBRSxDQUFDa2xCLFVBQUgsQ0FBY2xsQixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUF0QixDQUFwQixFQUFvRFEsS0FBSyxDQUFDcUgsSUFBMUQsQ0FEVixNQUVPLElBQUkxSCxFQUFFLENBQUM4SixZQUFILE1BQXFCdTNCLE1BQU0sQ0FBQ3Z1QyxLQUFQLENBQWF6RyxLQUFiLENBQXpCLEVBQThDO0FBQ3BELFVBQU1rQixFQUFFLEdBQUdpSSxTQUFTLENBQUMyTixJQUFWLENBQWVuRCxFQUFmLENBQVg7QUFFQXFoQyxZQUFNLEdBQUdBLE1BQU0sQ0FBQ2p6QyxHQUFQLENBQVcsVUFBQW5ELENBQUM7QUFBQSxlQUFJb1YsS0FBSyxDQUFDcUgsSUFBTixDQUFXbmEsRUFBRSxDQUFDdEMsQ0FBRCxDQUFiLENBQUo7QUFBQSxPQUFaLENBSDJDO0FBSXBEO0FBR0YsV0FBT28yQyxNQUFQO0FBQ0E7QUFuYmEsQ0FBZixFOztBQ2hCQTs7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVlO0FBQ2Q7Ozs7QUFJQTNHLFVBTGMsc0JBS0g7QUFDVixRQUFNMTZCLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQ0ssS0FBSCxDQUFTekMsSUFBVCxHQUFnQixJQUhOLEVBS1ZvQyxFQUFFLENBQUMraUMsWUFBSCxFQUxVLEVBTVYvaUMsRUFBRSxDQUFDZ2pDLGlCQUFILEVBTlU7QUFPVixHQVphOztBQWNkOzs7OztBQUtBdkksZUFuQmMseUJBbUJBdDNCLElBbkJBLEVBbUJhO0FBQWJBLFFBQWEsZ0JBQWJBLElBQWE7QUFDcEIsUUFBQW5ELEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDd0JxSyxFQUR4QixDQUNDckssTUFERDtBQUFBLFFBQ2VwRyxJQURmLEdBQ3dCeVEsRUFEeEIsQ0FDUzVRLEdBRFQsQ0FDZUcsSUFEZjtBQUFBLFFBRUFpMkIsV0FGQSxHQUVjN3ZCLE1BQU0sQ0FBQ3dDLFlBRnJCO0FBSU42SCxNQUFFLENBQUN5OUIsZUFBSCxFQUwwQjtBQU8xQixRQUFNM2tELFVBQVUsR0FBR3lXLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDN1csVUFBdEIsQ0FBbkI7QUFFSTBzQyxlQUFXLElBQUlyaUIsSUFUTyxHQVd6QixDQUFDeE4sTUFBTSxDQUFDa0MsYUFBUixJQUNDbUksRUFBRSxDQUFDaWpDLG1CQUFILENBQXVCbnFELFVBQXZCLEVBQW1DMHNDLFdBQVcsQ0FBQy8xQixJQUEvQyxDQVp3QixHQWFmMFQsSUFBSSxPQWJXLEtBY3pCbkQsRUFBRSxDQUFDZ0osR0FBSCxDQUFPNHhCLE1BQVAsRUFkeUIsRUFnQnpCOWhELFVBQVUsQ0FDUmdtQyxFQURGLENBQ0ssT0FETCxFQUNjLElBRGQsRUFFRUEsRUFGRixDQUVLLE9BRkwsRUFFYyxJQUZkLENBaEJ5QjtBQW9CMUIsR0F2Q2E7O0FBeUNkOzs7O0FBSUFpa0IsY0E3Q2MsMEJBNkNDO0FBQ1IsUUFBQS9pQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3VCcUssRUFEdkIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTNHZCLEdBRFQsR0FDdUJ2bEIsRUFEdkIsQ0FDU3VsQixHQURUO0FBQUEsUUFDY2xsQixLQURkLEdBQ3VCTCxFQUR2QixDQUNjSyxLQURkO0FBQUEsUUFHQXpDLElBSEEsR0FHT3NsQyxnRkFBTSxHQUFHbjBCLFFBQVQsQ0FBa0IsQ0FBbEIsRUFDWCtQLEVBRFcsQ0FDUixPQURRLEVBQ0M5ZSxFQUFFLENBQUNtakMsV0FBSCxDQUFlaGdDLElBQWYsQ0FBb0JuRCxFQUFwQixDQURELEVBRVg4ZSxFQUZXLENBRVIsTUFGUSxFQUVBOWUsRUFBRSxDQUFDb2pDLE1BQUgsQ0FBVWpnQyxJQUFWLENBQWVuRCxFQUFmLENBRkEsRUFHWDhlLEVBSFcsQ0FHUixLQUhRLEVBR0Q5ZSxFQUFFLENBQUNxakMsU0FBSCxDQUFhbGdDLElBQWIsQ0FBa0JuRCxFQUFsQixDQUhDLENBSFA7QUFRTjtBQUNBO0FBT0E7O0FBVUE7Ozs7O0FBS0E7QUFyQkFwQyxRQUFJLENBQUMwbEMsY0FBTCxHQUFzQixZQUFNO0FBQzNCLFVBQU1qQyxNQUFNLEdBQUcxckMsTUFBTSxDQUFDeUMsV0FBUCxJQUFzQixDQUFDLENBQUQsRUFBSSxFQUFKLENBQXJDO0FBRUEsYUFBTyxDQUFDaXBDLE1BQU0sQ0FBQyxDQUFELENBQVAsRUFBWTUxQyxJQUFJLENBQUNtWCxHQUFMLENBQVM1QyxFQUFFLENBQUMrWCxlQUFILEtBQXVCc3BCLE1BQU0sQ0FBQyxDQUFELENBQXRDLEVBQTJDQSxNQUFNLENBQUMsQ0FBRCxDQUFqRCxDQUFaLENBQVA7QUFDQSxLQWZhLEVBa0JkempDLElBQUksQ0FBQzZuQixpQkFBTCxHQUF5QixZQUFXO0FBQUEsVUFDN0JuSixLQUFLLEdBQUd6d0IsVUFBVSxDQUFDbVUsRUFBRSxDQUFDSyxLQUFILENBQVMxaUIsQ0FBVCxDQUFXc3lCLFNBQVgsRUFBRCxDQUFWLEdBQXFDcGtCLFVBQVUsQ0FBQ21VLEVBQUUsQ0FBQzhsQixhQUFILEVBQUQsQ0FEMUI7QUFBQSxVQUU3QnViLE1BQU0sR0FBRyxLQUFLaUMsY0FBTCxFQUZvQjtBQU1uQyxhQUZBLEtBQUs1aUMsV0FBTCxDQUFpQixDQUFDMmdDLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWS9rQixLQUFiLEVBQW9CK2tCLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWS9rQixLQUFoQyxDQUFqQixDQUVBLEVBQU8sSUFBUDtBQUNBLEtBekJhLEVBaUNkMWUsSUFBSSxDQUFDaTlCLG9CQUFMLEdBQTRCLFVBQUFucEMsU0FBUyxFQUFJO0FBRXhDNnpCLFNBQUcsQ0FBQ3lVLE1BQUosSUFBY3pVLEdBQUcsQ0FBQ3lVLE1BQUosQ0FBV3Y1QixLQUFYLENBQWlCSixLQUFLLENBQUMxaUIsQ0FBTixDQUFROGlCLEtBQVIsRUFBakIsQ0FGMEI7QUFJeEM7QUFKd0MsVUFLbENpQixRQUFRLEdBQUdoUSxTQUFTLENBQ3pCaUUsTUFBTSxDQUFDYyxZQUFQLEdBQXNCLFVBQXRCLEdBQW1DLFVBRFYsQ0FBVCxDQUVmOHVCLEdBQUcsQ0FBQ3lVLE1BQUosSUFBYzM1QixLQUFLLENBQUMxaUIsQ0FGTCxDQUx1QjtBQUFBLFVBU2xDRSxNQUFNLEdBQUdtaUIsRUFBRSxDQUFDNGxCLFdBQUgsQ0FBZWxrQixRQUFRLENBQUM3akIsTUFBVCxFQUFmLENBVHlCO0FBQUEsVUFVbEMwbEQsT0FBTyxHQUFHNXRDLE1BQU0sQ0FBQzJDLFlBVmlCO0FBWXhDb0osY0FBUSxDQUFDN2pCLE1BQVQsQ0FBZ0JBLE1BQWhCLEVBQXdCMG5DLEdBQUcsQ0FBQ3JMLE9BQTVCLENBWndDLEVBY3hDN1osS0FBSyxDQUFDekMsSUFBTixHQUFhb0MsRUFBRSxDQUFDNnNCLGtCQUFILENBQXNCbnJCLFFBQXRCLENBZDJCLEVBZXhDMUIsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBQVIsQ0FBVTBpQixLQUFWLENBQWdCQSxLQUFLLENBQUN6QyxJQUF0QixDQWZ3QyxFQWlCcEMybEMsT0FqQm9DLEtBbUJ2QyxDQUFDaGUsR0FBRyxDQUFDeVUsTUFBTCxLQUFnQnpVLEdBQUcsQ0FBQ3lVLE1BQUosR0FBYTM1QixLQUFLLENBQUMxaUIsQ0FBTixDQUFRZ2tCLElBQVIsRUFBN0IsQ0FuQnVDLEVBb0J2Q3RCLEtBQUssQ0FBQzFpQixDQUFOLENBQVFFLE1BQVIsQ0FBZUEsTUFBZixDQXBCdUM7QUFzQnhDLEtBdkRhLEVBeURkbWlCLEVBQUUsQ0FBQ3BDLElBQUgsR0FBVUEsSUF6REk7QUEwRGQsR0F2R2E7O0FBeUdkOzs7O0FBSUF1bEMsYUE3R2MseUJBNkdBO0FBQUEsUUFDUG5qQyxFQUFFLEdBQUcsSUFERTtBQUFBLFFBRVAzUSxLQUFLLEdBQUdDLHdGQUFPLENBQUNrMEMsV0FGVDtBQUlSbjBDLFNBSlEsS0FRYjJRLEVBQUUsQ0FBQ3BDLElBQUgsQ0FBUTZsQyxVQUFSLEdBQXFCcDBDLEtBUlIsRUFTYi9CLE1BQU0sQ0FBQzBTLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVTZDLGdCQUFYLEVBQTZCd0gsRUFBRSxDQUFDZ0osR0FBaEMsRUFBcUMzWixLQUFyQyxDQVRPO0FBVWIsR0F2SGE7O0FBeUhkOzs7O0FBSUErekMsUUE3SGMsb0JBNkhMO0FBQ0YsUUFBQXBqQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3VCcUssRUFEdkIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTMEssS0FEVCxHQUN1QkwsRUFEdkIsQ0FDU0ssS0FEVDtBQUFBLFFBQ2dCa2xCLEdBRGhCLEdBQ3VCdmxCLEVBRHZCLENBQ2dCdWxCLEdBRGhCO0FBQUEsUUFFQWwyQixLQUZBLEdBRVFDLHdGQUZSO0FBQUEsUUFHQ2swQyxXQUhELEdBR2dCbjBDLEtBSGhCLENBR0NtMEMsV0FIRDs7QUFLTixRQUNFN3RDLE1BQU0sQ0FBQ3dDLFlBQVIsSUFDQzlJLEtBQUssQ0FBQ20wQyxXQURQLElBRUF4akMsRUFBRSxDQUFDNE4sbUJBQUgsQ0FBdUI1TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUEvQixFQUF3QzVULE1BQXhDLEtBQW1ELENBRm5ELEtBR0VvVSxLQUFLLENBQUN6QyxJQUFQLE1BQWU0bEMsV0FBVyxDQUFDL3pDLElBQVosQ0FBaUJ2QixPQUFqQixDQUF5QixPQUF6QixJQUFvQyxDQUFDLENBQXBELEtBQXlEczFDLFdBQVcsQ0FBQ3R1QyxPQUFaLENBQW9CakosTUFBcEIsS0FBK0IsQ0FIekYsQ0FERDtBQVNNLFVBQUF5M0MsV0FBVyxHQUFHRixXQUFXLENBQUMvekMsSUFBWixLQUFxQixXQUFuQztBQUFBLFVBQ0FrMEMsU0FEQSxHQUNZSCxXQUFXLENBQUNJLFVBQVosR0FBeUIsQ0FEckM7QUFBQSxVQUVDbHlDLFNBRkQsR0FFY3JDLEtBRmQsQ0FFQ3FDLFNBRkQ7QUFJRixPQUFDZ3lDLFdBQUQsSUFBZ0JDLFNBQWhCLElBQTZCdGpDLEtBQUssQ0FBQzFpQixDQUFOLENBQVFFLE1BQVIsR0FBaUJpVixLQUFqQixDQUF1QixVQUFDN0gsQ0FBRCxFQUFJd0QsQ0FBSjtBQUFBLGVBQVV4RCxDQUFDLEtBQUtzNkIsR0FBRyxDQUFDckwsT0FBSixDQUFZenJCLENBQVosQ0FBaEI7QUFBQSxPQUF2QixDQWJqQyxJQWNDNFIsS0FBSyxDQUFDMWlCLENBQU4sQ0FBUUUsTUFBUixDQUFlMG5DLEdBQUcsQ0FBQ3JMLE9BQW5CLENBZEQsRUFpQkFsYSxFQUFFLENBQUNwQyxJQUFILENBQVFpOUIsb0JBQVIsQ0FBNkJucEMsU0FBN0IsQ0FqQkEsRUFtQklzTyxFQUFFLENBQUMwSixhQUFILE1BQXNCckosS0FBSyxDQUFDMWlCLENBQU4sQ0FBUXN5QixTQUFSLEdBQW9CLENBQXBCLE1BQTJCc1YsR0FBRyxDQUFDckwsT0FBSixDQUFZLENBQVosQ0FuQnJELElBb0JDN1osS0FBSyxDQUFDMWlCLENBQU4sQ0FBUUUsTUFBUixDQUFlLENBQUMwbkMsR0FBRyxDQUFDckwsT0FBSixDQUFZLENBQVosSUFBaUIsS0FBbEIsRUFBeUI3WixLQUFLLENBQUMxaUIsQ0FBTixDQUFRc3lCLFNBQVIsR0FBb0IsQ0FBcEIsQ0FBekIsQ0FBZixDQXBCRCxFQXVCQWpRLEVBQUUsQ0FBQ2tQLE1BQUgsQ0FBVTtBQUNUbEIsc0JBQWMsSUFETDtBQUVUbXNCLGFBQUssRUFBRXhrQyxNQUFNLENBQUMyQyxZQUZMO0FBR1RzcUMsb0JBQVksSUFISDtBQUlUaUIscUJBQWEsSUFKSjtBQUtUekoscUJBQWE7QUFMSixPQUFWLENBdkJBLEVBK0JBcDZCLEVBQUUsQ0FBQzlqQixLQUFILENBQVMrQyxXQUFULEdBQXVCeWtELFdBL0J2QixFQWdDQXAyQyxNQUFNLENBQUNxSSxNQUFNLENBQUM0QyxXQUFSLEVBQXFCeUgsRUFBRSxDQUFDZ0osR0FBeEIsRUFBNkIzSSxLQUFLLENBQUN6QyxJQUFOLENBQVcvZixNQUFYLEVBQTdCLENBaENOO0FBQUE7QUFpQ0EsR0FwS2E7O0FBc0tkOzs7O0FBSUF3bEQsV0ExS2MsdUJBMEtGO0FBQ0wsUUFBQXJqQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2tCcUssRUFEbEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTMEssS0FEVCxHQUNrQkwsRUFEbEIsQ0FDU0ssS0FEVDtBQUFBLFFBRURvakMsVUFGQyxHQUVhempDLEVBQUUsQ0FBQ3BDLElBRmhCLENBRUQ2bEMsVUFGQztBQUFBLFFBR0ZwMEMsS0FIRSxHQUdNQyx3RkFBTyxJQUFJQSx3RkFBTyxDQUFDazBDLFdBSHpCO0FBS0RDLGNBQVUsSUFBSUEsVUFBVSxDQUFDaDBDLElBQVgsQ0FBZ0J2QixPQUFoQixDQUF3QixPQUF4QixJQUFtQyxDQUFDLENBTjVDLEtBT1Z1MUMsVUFBVSxHQUFHQSxVQUFVLENBQUNydUMsY0FBWCxDQUEwQixDQUExQixDQVBILEVBUVYvRixLQUFLLEdBQUdBLEtBQUssQ0FBQytGLGNBQU4sQ0FBcUIsQ0FBckIsQ0FSRTtBQVdYO0FBQ0ksS0FBQ3F1QyxVQUFELElBQ0ZwMEMsS0FBSyxJQUFJbzBDLFVBQVUsQ0FBQzV2QyxPQUFYLEtBQXVCeEUsS0FBSyxDQUFDd0UsT0FBdEMsSUFBaUQ0dkMsVUFBVSxDQUFDM3ZDLE9BQVgsS0FBdUJ6RSxLQUFLLENBQUN5RSxPQWJyRSxLQWtCWGtNLEVBQUUsQ0FBQ3k5QixlQUFILEVBbEJXLEVBbUJYejlCLEVBQUUsQ0FBQys2QixVQUFILEVBbkJXLEVBcUJYenRDLE1BQU0sQ0FBQ3FJLE1BQU0sQ0FBQzhDLGNBQVIsRUFBd0J1SCxFQUFFLENBQUNnSixHQUEzQixFQUFnQzNJLEtBQUssQ0FBQ0EsS0FBSyxDQUFDekMsSUFBTixHQUFhLE1BQWIsR0FBc0IsTUFBdkIsQ0FBTCxDQUFvQy9mLE1BQXBDLEVBQWhDLENBckJLO0FBc0JYLEdBaE1hOztBQWtNZDs7Ozs7QUFLQWlvQyxlQXZNYywyQkF1TUU7QUFDVCxRQUFBOWxCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDZ0JxSyxFQURoQixDQUNDckssTUFERDtBQUFBLFFBQ1M0dkIsR0FEVCxHQUNnQnZsQixFQURoQixDQUNTdWxCLEdBRFQ7QUFBQSx1QkFFV0EsR0FBRyxDQUFDckwsT0FGZjtBQUFBLFFBRURqckIsR0FGQztBQUFBLFFBRUkyVCxHQUZKO0FBWU4sV0FSSXRYLFNBQVMsQ0FBQ3FLLE1BQU0sQ0FBQ2dELFVBQVIsQ0FRYixLQVBDMUosR0FBRyxHQUFHK0QsU0FBUyxDQUFDLEtBQUQsRUFBUSxDQUFDL0QsR0FBRCxFQUFNMEcsTUFBTSxDQUFDZ0QsVUFBYixDQUFSLENBT2hCLEdBSklyTixTQUFTLENBQUNxSyxNQUFNLENBQUNpRCxVQUFSLENBSWIsS0FIQ2dLLEdBQUcsR0FBRzVQLFNBQVMsQ0FBQyxLQUFELEVBQVEsQ0FBQzRQLEdBQUQsRUFBTWpOLE1BQU0sQ0FBQ2lELFVBQWIsQ0FBUixDQUdoQixHQUFPLENBQUMzSixHQUFELEVBQU0yVCxHQUFOLENBQVA7QUFDQSxHQXJOYTs7QUF1TmQ7Ozs7O0FBS0FtNEIsWUE1TmMsc0JBNE5IaG1DLEtBNU5HLEVBNE5JO0FBQ1gsUUFBQWlMLEVBQUUsR0FBRyxJQUFMO0FBQUEsb0JBQ2dCQSxFQUFFLENBQUNLLEtBRG5CO0FBQUEsUUFDRHFILElBREMsYUFDREEsSUFEQztBQUFBLFFBQ0svcEIsQ0FETCxhQUNLQSxDQURMO0FBQUEsUUFDUWlnQixJQURSLGFBQ1FBLElBRFI7O0FBR04sUUFBSUEsSUFBSixFQUFVO0FBQUEsVUFDSGlvQixVQUFVLEdBQUdqb0IsSUFBSSxDQUFDL2YsTUFBTCxFQURWO0FBQUEsVUFFSHE4QixPQUFPLEdBQUd4UyxJQUFJLENBQUM3cEIsTUFBTCxFQUZQO0FBQUEsVUFHSGltRCxLQUFLLEdBQUcsSUFITDtBQUFBLFVBS0hDLFlBQVksR0FBRyxDQUFDbGUsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQjNMLE9BQU8sQ0FBQyxDQUFELENBQXhCLElBQWdDMkwsVUFBVSxDQUFDLENBQUQsQ0FBVixHQUFnQmllLEtBQWpCLElBQTJCNXBCLE9BQU8sQ0FBQyxDQUFELENBQWxFLE1BQ25CQSxPQUFPLENBQUMsQ0FBRCxDQUFQLElBQWMyTCxVQUFVLENBQUMsQ0FBRCxDQUF4QixJQUErQjNMLE9BQU8sQ0FBQyxDQUFELENBQVAsSUFBZTJMLFVBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0JpZSxLQUQzQyxDQUxaO0FBQUEsT0FTTC91QyxLQUFLLElBQUlndkMsWUFUSixNQVVSL2pDLEVBQUUsQ0FBQ3hwQixJQUFILENBQVFtSCxDQUFSLENBQVUwaUIsS0FBVixDQUFnQnFILElBQWhCLENBVlEsRUFXUi9wQixDQUFDLENBQUNFLE1BQUYsQ0FBUzZwQixJQUFJLENBQUN1SSxTQUFMLEVBQVQsQ0FYUSxFQVlSclMsSUFBSSxHQUFHLElBWkM7QUFjVDtBQUNELEdBL09hOztBQWlQZDs7OztBQUlBcWxDLHFCQXJQYywrQkFxUE1ucUQsVUFyUE4sRUFxUGtCMlcsSUFyUGxCLEVBcVB3QjtBQUFBLFFBQy9CdVEsRUFBRSxHQUFHLElBRDBCO0FBQUEsUUFFL0Jna0MsU0FBUyxHQUFHdjBDLElBQUksS0FBSyxNQUFULEdBQWtCdVEsRUFBRSxDQUFDaWtDLGFBQXJCLEdBQXFDamtDLEVBQUUsQ0FBQ3BDLElBRnJCO0FBSXJDOWtCLGNBQVUsQ0FDUjRVLElBREYsQ0FDT3MyQyxTQURQLEVBRUVsbEIsRUFGRixDQUVLLGVBRkwsRUFFc0IsSUFGdEIsQ0FKcUM7QUFPckMsR0E1UGE7O0FBOFBkOzs7O0FBSUFra0IsbUJBbFFjLCtCQWtRTTtBQU1mLFFBQUFubkQsUUFBUTtBQUFBLFFBTE5ta0IsRUFLTSxHQUxELElBS0M7QUFBQSxRQUpMckssTUFJSyxHQUpZcUssRUFJWixDQUpMckssTUFJSztBQUFBLFFBSkd6WixLQUlILEdBSlk4akIsRUFJWixDQUpHOWpCLEtBSUg7QUFBQSxRQUhONnJCLFNBR00sR0FITXBTLE1BQU0sQ0FBQ2MsWUFHYjtBQUFBLFFBRlJ0RCxLQUVRLEdBRkEsQ0FFQTtBQUFBLFFBRFJDLEdBQ1EsR0FERixDQUNFO0FBQUEsUUFFTjh3QyxJQUZNLEdBRUM7QUFDWjF0RCxVQUFJLEVBQUV1eEIsU0FBUyxHQUFHLEdBQUgsR0FBUyxHQURaO0FBRVpwWixVQUFJLEVBQUVvWixTQUFTLEdBQUcsUUFBSCxHQUFjLE9BRmpCO0FBR1oxQyxXQUFLLEVBQUUwQyxTQUFTLEdBQUcsQ0FBSCxHQUFPO0FBSFgsS0FGRDtBQVFaL0gsTUFBRSxDQUFDaWtDLGFBQUgsR0FBbUJwbEIsZ0ZBQU0sR0FDdkJzbEIsYUFEaUIsQ0FDSCxDQURHLEVBRWpCcmxCLEVBRmlCLENBRWQsT0FGYyxFQUVMLFlBQVc7QUFXdkI7QUFWQTllLFFBQUUsQ0FBQys3QixhQUFILElBRHVCLEVBR2xCbGdELFFBSGtCLEtBSXRCQSxRQUFRLEdBQUdta0IsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVliLE1BQVosQ0FBbUIsTUFBbkIsRUFDVEMsSUFEUyxDQUNKLFdBREksRUFDU3pTLEtBQUssQ0FBQ2tDLElBQU4sQ0FBV00sSUFEcEIsRUFFVGlRLElBRlMsQ0FFSixPQUZJLEVBRUtnQixjQUFLLENBQUMvVCxTQUZYLEVBR1QrUyxJQUhTLENBR0osT0FISSxFQUdLb1osU0FBUyxHQUFHN3JCLEtBQUssQ0FBQ0MsS0FBVCxHQUFpQixDQUgvQixFQUlUd1MsSUFKUyxDQUlKLFFBSkksRUFJTW9aLFNBQVMsR0FBRyxDQUFILEdBQU83ckIsS0FBSyxDQUFDRyxNQUo1QixDQUpXLEdBWXZCOFcsS0FBSyxHQUFHNHJCLGdHQUFPLENBQUMsSUFBRCxDQUFQLENBQWNtbEIsSUFBSSxDQUFDNytCLEtBQW5CLENBWmUsRUFhdkJqUyxHQUFHLEdBQUdELEtBYmlCLEVBZXZCdFgsUUFBUSxDQUNOOFMsSUFERixDQUNPdTFDLElBQUksQ0FBQzF0RCxJQURaLEVBQ2tCMmMsS0FEbEIsRUFFRXhFLElBRkYsQ0FFT3UxQyxJQUFJLENBQUN2MUMsSUFGWixFQUVrQixDQUZsQixDQWZ1QixFQW1CdkJxUixFQUFFLENBQUNtakMsV0FBSCxFQW5CdUI7QUFvQnZCLEtBdEJpQixFQXVCakJya0IsRUF2QmlCLENBdUJkLE1BdkJjLEVBdUJOLFlBQVc7QUFDdEI7QUFDQTFyQixTQUFHLEdBQUcyckIsZ0dBQU8sQ0FBQyxJQUFELENBQVAsQ0FBY21sQixJQUFJLENBQUM3K0IsS0FBbkIsQ0FGZ0IsRUFJdEJ4cEIsUUFBUSxDQUNOOFMsSUFERixDQUNPdTFDLElBQUksQ0FBQzF0RCxJQURaLEVBQ2tCaVYsSUFBSSxDQUFDd0QsR0FBTCxDQUFTa0UsS0FBVCxFQUFnQkMsR0FBaEIsQ0FEbEIsRUFFRXpFLElBRkYsQ0FFT3UxQyxJQUFJLENBQUN2MUMsSUFGWixFQUVrQmxELElBQUksQ0FBQ291QixHQUFMLENBQVN6bUIsR0FBRyxHQUFHRCxLQUFmLENBRmxCLENBSnNCO0FBT3RCLEtBOUJpQixFQStCakIyckIsRUEvQmlCLENBK0JkLEtBL0JjLEVBK0JQLFlBQVk7QUFBQTtBQUFBLFVBQ2hCemUsS0FBSyxHQUFHTCxFQUFFLENBQUNLLEtBQUgsQ0FBU3pDLElBQVQsSUFBaUJvQyxFQUFFLENBQUNLLEtBQUgsQ0FBUzFpQixDQURsQjs7QUFrQnRCLFVBZkFxaUIsRUFBRSxDQUFDKzdCLGFBQUgsSUFlQSxFQWJBbGdELFFBQVEsQ0FDTjhTLElBREYsQ0FDT3UxQyxJQUFJLENBQUMxdEQsSUFEWixFQUNrQixDQURsQixFQUVFbVksSUFGRixDQUVPdTFDLElBQUksQ0FBQ3YxQyxJQUZaLEVBRWtCLENBRmxCLENBYUEsRUFUSXdFLEtBQUssR0FBR0MsR0FTWixZQVJnQixDQUFDQSxHQUFELEVBQU1ELEtBQU4sQ0FRaEIsRUFSRUEsS0FRRixZQVJTQyxHQVFULG1CQUxJRCxLQUFLLEdBQUcsQ0FLWixLQUpDQyxHQUFHLElBQUkzSCxJQUFJLENBQUNvdUIsR0FBTCxDQUFTMW1CLEtBQVQsQ0FJUixFQUhDQSxLQUFLLEdBQUcsQ0FHVCxHQUFJQSxLQUFLLEtBQUtDLEdBQWQsRUFDQzRNLEVBQUUsQ0FBQ2dKLEdBQUgsQ0FBT3BMLElBQVAsQ0FBWSxDQUFDekssS0FBRCxFQUFRQyxHQUFSLEVBQWFoRixHQUFiLENBQWlCLFVBQUFuRCxDQUFDO0FBQUEsZUFBSW9WLEtBQUssQ0FBQ3NsQixNQUFOLENBQWExNkIsQ0FBYixDQUFKO0FBQUEsT0FBbEIsQ0FBWixDQURELEVBRUMrVSxFQUFFLENBQUNxakMsU0FBSCxFQUZELE1BSUMsSUFBSXJqQyxFQUFFLENBQUNpVyxXQUFILEVBQUosRUFDQ2pXLEVBQUUsQ0FBQ3dnQyx5QkFBSCxDQUE2QnI5QixJQUE3QixDQUFrQyxJQUFsQyxFQUF3Q25ELEVBQXhDLENBREQsTUFFTztBQUNBLFlBQUEzUSxPQUFLLEdBQUdDLHdGQUFPLENBQUNrMEMsV0FBUixJQUF1QmwwQyx3RkFBL0I7QUFBQSxvQkFDUyxhQUFhRCxPQUFiLEdBQXFCLENBQUNBLE9BQUssQ0FBQ3dFLE9BQVAsRUFBZ0J4RSxPQUFLLENBQUN5RSxPQUF0QixDQUFyQixHQUFzRCxDQUFDekUsT0FBSyxDQUFDMVIsQ0FBUCxFQUFVMFIsT0FBSyxDQUFDdlIsQ0FBaEIsQ0FEL0Q7QUFBQSxZQUNDSCxDQUREO0FBQUEsWUFDSUcsQ0FESjtBQUFBLFlBRUFuRCxNQUZBLEdBRVNvUSxXQUFRLENBQUN5ekMsZ0JBQVQsQ0FBMEI3Z0QsQ0FBMUIsRUFBNkJHLENBQTdCLENBRlQ7O0FBSU5raUIsVUFBRSxDQUFDc2dDLHNCQUFILENBQTBCbjlCLElBQTFCLENBQStCeG9CLE1BQS9CLEVBQXVDeXBCLGlHQUFRLENBQUN6cEIsTUFBRCxDQUFSLENBQWlCNmpDLEtBQWpCLEVBQXZDLEVBQWlFeGUsRUFBakUsQ0FMTTtBQU1OO0FBRUYsS0EvRGlCLENBZEE7QUE4RW5CLEdBaFZhO0FBa1ZkcTZCLG9CQWxWYyxnQ0FrVk87QUFDZCxRQUFBcjZCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFBQSxRQUVBeXVDLFdBRkEsR0FFY3p1QyxNQUFNLENBQUMrQyxnQkFGckI7QUFJRjByQyxlQUFXLElBQUl6dUMsTUFBTSxDQUFDd0MsWUFBUCxDQUFvQjFJLElBQXBCLEtBQTZCLE1BTDVCLEtBTWR1USxFQUFFLENBQUNwQyxJQUFILENBQVFvOUIsUUFOTSxHQWlCbEJoN0IsRUFBRSxDQUFDcEMsSUFBSCxDQUFRbzlCLFFBQVIsQ0FBaUJqMkIsS0FBakIsQ0FBdUIsU0FBdkIsRUFBa0MsSUFBbEMsQ0FqQmtCLEdBT2xCL0UsRUFBRSxDQUFDcEMsSUFBSCxDQUFRbzlCLFFBQVIsR0FBbUJoN0IsRUFBRSxDQUFDNVEsR0FBSCxDQUFPaFksS0FBUCxDQUFhc1gsTUFBYixDQUFvQixLQUFwQixFQUNqQnE0QixPQURpQixDQUNUcDNCLGNBQUssQ0FBQ3pZLE1BREcsTUFFakJ3WCxNQUZpQixDQUVWLE1BRlUsRUFHakJvd0IsRUFIaUIsQ0FHZCxPQUhjLEVBR0wsWUFBVztBQUN2QjV6QixnQkFBVSxDQUFDazVDLFdBQVcsQ0FBQ0MsT0FBYixDQUFWLElBQW1DRCxXQUFXLENBQUNDLE9BQVosQ0FBb0JsaEMsSUFBcEIsQ0FBeUJuRCxFQUFFLENBQUNnSixHQUE1QixFQUFpQyxJQUFqQyxDQURaLEVBRXZCaEosRUFBRSxDQUFDZ0osR0FBSCxDQUFPNHhCLE1BQVAsRUFGdUI7QUFHdkIsS0FOaUIsRUFPakI3VCxPQVBpQixDQU9UcDNCLGNBQUssQ0FBQ3hZLGVBUEcsTUFRakJ5RCxJQVJpQixDQVFad3BELFdBQVcsQ0FBQ3hwRCxJQUFaLElBQW9CLFlBUlIsQ0FQRDtBQW9CcEI7QUF0V2EsQ0FBZixFOztBQ2ZBOzs7O0FBSWU7QUFDZDs7Ozs7O0FBTUE4dkIsY0FQYyx3QkFPRGpjLENBUEMsRUFPRTtBQUFBLFFBQ1dvYixVQURYLEdBQ3lCLEtBQUtsVSxNQUQ5QixDQUNSelAsaUJBRFE7QUFHZixXQUFPdUksQ0FBQyxHQUFHb2IsVUFBVSxDQUFDNWQsTUFBZixHQUF3QjRkLFVBQVUsQ0FBQ3BiLENBQUQsQ0FBbEMsR0FBd0NBLENBQS9DO0FBQ0E7QUFYYSxDQUFmLEU7O0FDSkE7Ozs7QUFJQTtBQUVlO0FBQ2Q2MUMsVUFEYyxzQkFDSDtBQUNKLFFBQUF0a0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDNWhCLElBREQsR0FDUzRoQixFQUFFLENBQUM5akIsS0FEWixDQUNDa0MsSUFERDtBQUdOO0FBTUE7QUFMQUEsUUFBSSxDQUFDQyxFQUFMLEdBQWEyaEIsRUFBRSxDQUFDOWpCLEtBQUgsQ0FBU2lDLFVBQXRCLFVBTFUsRUFNVkMsSUFBSSxDQUFDRSxPQUFMLEdBQWtCRixJQUFJLENBQUNDLEVBQXZCLFdBTlUsRUFPVkQsSUFBSSxDQUFDRyxPQUFMLEdBQWtCSCxJQUFJLENBQUNDLEVBQXZCLFdBUFUsRUFRVkQsSUFBSSxDQUFDSSxNQUFMLEdBQWlCSixJQUFJLENBQUNDLEVBQXRCLFVBUlUsRUFXVkQsSUFBSSxDQUFDTSxJQUFMLEdBQVlzaEIsRUFBRSxDQUFDMmhDLFdBQUgsQ0FBZXZqRCxJQUFJLENBQUNDLEVBQXBCLENBWEYsRUFZVkQsSUFBSSxDQUFDTyxTQUFMLEdBQWlCcWhCLEVBQUUsQ0FBQzJoQyxXQUFILENBQWV2akQsSUFBSSxDQUFDRSxPQUFwQixDQVpQLEVBYVZGLElBQUksQ0FBQ1EsU0FBTCxHQUFpQm9oQixFQUFFLENBQUMyaEMsV0FBSCxDQUFldmpELElBQUksQ0FBQ0csT0FBcEIsQ0FiUCxFQWNWSCxJQUFJLENBQUNTLFFBQUwsR0FBZ0JtaEIsRUFBRSxDQUFDMmhDLFdBQUgsQ0FBZXZqRCxJQUFJLENBQUNJLE1BQXBCLENBZE47QUFlVixHQWhCYTtBQWtCZG1qRCxhQWxCYyx1QkFrQkZ0akQsRUFsQkUsRUFrQkU7QUFDVCxRQUFBMmhCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFHTixRQUFLLENBQUNBLE1BQU0sQ0FBQ3NJLFFBQVIsSUFBb0IsU0FBU3pOLElBQVQsQ0FBY25TLEVBQWQsQ0FBckIsSUFDRixDQUFDc1gsTUFBTSxDQUFDN1AsZUFBUixJQUEyQixlQUFlMEssSUFBZixDQUFvQm5TLEVBQXBCLENBRHpCLElBRUYsQ0FBQ3NYLE1BQU0sQ0FBQ2xPLGVBQVIsSUFBMkIsZUFBZStJLElBQWYsQ0FBb0JuUyxFQUFwQixDQUY3QixFQUdDLE9BQU8sSUFBUDtBQUdELFFBQU1rbUQsS0FBSyxLQUFHNzVDLEdBQU0sQ0FBQ3dMLFNBQVYsSUFDVnhMLEdBQU0sQ0FBQ3dMLFNBQVAsQ0FBaUJzdUMsVUFBakIsQ0FDRXJyQixXQURGLEdBQ2dCanJCLE9BRGhCLENBQ3dCLFNBRHhCLEtBQ3NDLENBRnZDO0FBSUEscUJBQWVxMkMsS0FBSyxHQUFHLEVBQUgsR0FBUXg1QyxXQUFRLENBQUMwNUMsR0FBVCxDQUFhbjJDLEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBNUIsVUFBMkRqUSxFQUEzRDtBQUNBLEdBakNhO0FBbUNkdWpELFlBbkNjLHNCQW1DSHZULE1BbkNHLEVBbUNLaHdDLEVBbkNMLEVBbUNTO0FBQ3RCLFdBQU9nd0MsTUFBTSxDQUFDMy9CLE1BQVAsQ0FBYyxVQUFkLEVBQ0xDLElBREssQ0FDQSxJQURBLEVBQ010USxFQUROLEVBRUxxUSxNQUZLLENBRUUsTUFGRixDQUFQO0FBR0EsR0F2Q2E7QUF5Q2RnMkMsY0F6Q2Msd0JBeUNENThCLGFBekNDLEVBeUNjO0FBQ3JCLFFBQUN2ckIsTUFBRCxHQUFXLEtBQUtMLEtBQWhCLENBQUNLLE1BQUQ7QUFBQSxRQUVBRyxJQUZBLEdBRU8rTyxJQUFJLENBQUNtWCxHQUFMLENBQVMsRUFBVCxFQUFhcm1CLE1BQU0sQ0FBQ0csSUFBcEIsQ0FGUCxDQURxQixDQUUzQjs7QUFHQSxXQUFPb3JCLGFBQWEsR0FBRyxFQUFFLElBQUlwckIsSUFBTixDQUFILEdBQWlCLEVBQUVBLElBQUksR0FBRyxDQUFULENBQXJDO0FBQ0EsR0EvQ2E7QUFpRGRpb0QsY0FqRGMsd0JBaURENzhCLGFBakRDLEVBaURjO0FBQUEsUUFDcEJ2ckIsTUFEb0IsR0FDVixLQUFLTCxLQURLLENBQ3BCSyxNQURvQjtBQUczQixXQUFPdXJCLGFBQWEsR0FBRyxDQUFDLEVBQUosR0FBUyxDQUFDdnJCLE1BQU0sQ0FBQ0MsR0FBckM7QUFDQSxHQXJEYTtBQXVEZCt5QyxlQXZEYywyQkF1REU7QUFDZixRQUFNdnZCLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDMGtDLFlBQUgsQ0FBZ0IsQ0FBQzFrQyxFQUFFLENBQUNySyxNQUFILENBQVVjLFlBQTNCLENBQVA7QUFDQSxHQTNEYTtBQTZEZCs0QixlQTdEYywyQkE2REU7QUFDZixRQUFNeHZCLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDMmtDLFlBQUgsQ0FBZ0IsQ0FBQzNrQyxFQUFFLENBQUNySyxNQUFILENBQVVjLFlBQTNCLENBQVA7QUFDQSxHQWpFYTtBQW1FZGs1QixlQW5FYywyQkFtRUU7QUFDZixRQUFNM3ZCLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDckssTUFBSCxDQUFVM04sWUFBVixHQUNOLENBQUMsQ0FESyxHQUNEZ1ksRUFBRSxDQUFDMGtDLFlBQUgsQ0FBZ0Ixa0MsRUFBRSxDQUFDckssTUFBSCxDQUFVYyxZQUExQixDQUROO0FBRUEsR0F4RWE7QUEwRWRtNUIsZUExRWMsMkJBMEVFO0FBQ2YsUUFBTTV2QixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQzJrQyxZQUFILENBQWdCM2tDLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWMsWUFBMUIsQ0FBUDtBQUNBLEdBOUVhO0FBZ0ZkbXVDLGtCQWhGYyw0QkFnRkc5OEIsYUFoRkgsRUFnRmtCO0FBQ3pCLFFBQUE5SCxFQUFFLEdBQUcsSUFBTDtBQUFBLG9CQUNrQkEsRUFBRSxDQUFDOWpCLEtBRHJCO0FBQUEsUUFDQ0ssTUFERCxhQUNDQSxNQUREO0FBQUEsUUFDU0osS0FEVCxhQUNTQSxLQURUO0FBQUEsUUFFQU8sSUFGQSxHQUVPK08sSUFBSSxDQUFDbVgsR0FBTCxDQUFTLEVBQVQsRUFBYXJtQixNQUFNLENBQUNHLElBQXBCLENBRlA7QUFBQSxRQUdBQyxLQUhBLEdBR1E4TyxJQUFJLENBQUNtWCxHQUFMLENBQVMsRUFBVCxFQUFhcm1CLE1BQU0sQ0FBQ0ksS0FBcEIsQ0FIUjtBQUtOO0FBQ0EsV0FBT21yQixhQUFhLEdBQ25CM3JCLEtBQUssR0FBRyxDQUFSLEdBQVlPLElBQVosR0FBbUJDLEtBREEsR0FDUUosTUFBTSxDQUFDRyxJQUFQLEdBQWMsRUFEMUM7QUFFQSxHQXpGYTtBQTJGZG1vRCxtQkEzRmMsNkJBMkZJLzhCLGFBM0ZKLEVBMkZtQjtBQUFBLHNCQUNQLEtBQUs1ckIsS0FERTtBQUFBLFFBQ3pCSyxNQUR5QixlQUN6QkEsTUFEeUI7QUFBQSxRQUNqQkYsTUFEaUIsZUFDakJBLE1BRGlCLEVBR2hDOztBQUNBLFdBQU8sQ0FBQ3lyQixhQUFhLEdBQUd2ckIsTUFBTSxDQUFDRSxNQUFWLEdBQW9CRixNQUFNLENBQUNDLEdBQVAsR0FBYUgsTUFBL0MsSUFBMEQsRUFBakU7QUFDQSxHQWhHYTtBQWtHZG96QyxtQkFsR2MsK0JBa0dNO0FBQ25CLFFBQU16dkIsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUM0a0MsZ0JBQUgsQ0FBb0IsQ0FBQzVrQyxFQUFFLENBQUNySyxNQUFILENBQVVjLFlBQS9CLENBQVA7QUFDQSxHQXRHYTtBQXdHZGk1QixvQkF4R2MsZ0NBd0dPO0FBQ3BCLFFBQU0xdkIsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUM2a0MsaUJBQUgsQ0FBcUIsQ0FBQzdrQyxFQUFFLENBQUNySyxNQUFILENBQVVjLFlBQWhDLENBQVA7QUFDQSxHQTVHYTtBQThHZG81QixtQkE5R2MsK0JBOEdNO0FBQ25CLFFBQU03dkIsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUM0a0MsZ0JBQUgsQ0FBb0I1a0MsRUFBRSxDQUFDckssTUFBSCxDQUFVYyxZQUE5QixLQUErQ3VKLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVTNOLFlBQVYsR0FBeUIsRUFBekIsR0FBOEIsQ0FBN0UsQ0FBUDtBQUNBLEdBbEhhO0FBb0hkOG5DLG9CQXBIYyxnQ0FvSE87QUFDcEIsUUFBTTl2QixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQzZrQyxpQkFBSCxDQUFxQjdrQyxFQUFFLENBQUNySyxNQUFILENBQVVjLFlBQS9CLENBQVA7QUFDQTtBQXhIYSxDQUFmLEU7O0FDTkE7Ozs7QUFJQTtBQUlBO0NBR0E7O0lBQ01xdUMsaUJBQWlCLEdBQUcsVUFBQWg1QyxDQUFDO0FBQUEsU0FBSWQsT0FBTyxDQUFDYyxDQUFDLENBQUNxZixRQUFILENBQVAsSUFBdUIsS0FBM0I7QUFBQSxDO0lBQ3JCNDVCLGFBQWEsR0FBRyxVQUFBajVDLENBQUM7QUFBQSxTQUFLQSxDQUFDLENBQUNxZixRQUFGLEtBQWUsT0FBZixHQUF5QixDQUF6QixHQUE4QnJmLENBQUMsQ0FBQ3FmLFFBQUYsS0FBZSxRQUFmLEdBQTBCLENBQTFCLEdBQThCLENBQUMsQ0FBbEU7QUFBQSxDOztBQUV2QixTQUFTNjVCLFlBQVQsQ0FBc0J2N0IsR0FBdEIsRUFBMkJ0dEIsS0FBM0IsRUFBa0NFLE1BQWxDLEVBQTBDO0FBQ3pDLFNBQU8sVUFBQXlQLENBQUMsRUFBSTtBQUNYLFFBQUluTyxDQUFDLEdBQUc4ckIsR0FBRyxHQUFHLENBQUgsR0FBT3R0QixLQUFsQjtBQVFBLFdBTkkyUCxDQUFDLENBQUNxZixRQUFGLEtBQWUsT0FNbkIsR0FMQ3h0QixDQUFDLEdBQUc4ckIsR0FBRyxHQUFHLENBQUNwdEIsTUFBSixHQUFhLENBS3JCLEdBSld5UCxDQUFDLENBQUNxZixRQUFGLEtBQWUsUUFJMUIsS0FIQ3h0QixDQUFDLEdBQUcsQ0FBQzhyQixHQUFHLEdBQUcsQ0FBQ3B0QixNQUFKLEdBQWFGLEtBQWpCLElBQTBCLENBRy9CLEdBQU93QixDQUFQO0FBQ0EsR0FWRDtBQVdBOztBQUVELFNBQVNzbkQsV0FBVCxDQUFxQmp4QyxFQUFyQixFQUF5QnZFLElBQXpCLEVBQStCO0FBQzFCQSxNQUFJLEtBQUssTUFEaUIsSUFFN0J1RSxFQUFFLENBQUNtUSxJQUFILENBQVEsWUFBVztBQUNsQixRQUFNbkIsQ0FBQyxHQUFHb0IsaUdBQVEsQ0FBQyxJQUFELENBQWxCO0FBRUEsS0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFDRS9XLE9BREYsQ0FDVSxVQUFBcEMsQ0FBQztBQUFBLGFBQUkrWCxDQUFDLENBQUNyVSxJQUFGLENBQU8xRCxDQUFQLEVBQVVRLElBQUksQ0FBQ0MsSUFBTCxDQUFVLENBQUNzWCxDQUFDLENBQUNyVSxJQUFGLENBQU8xRCxDQUFQLENBQVgsQ0FBVixDQUFKO0FBQUEsS0FEWCxDQUhrQjtBQUtsQixHQUxELENBRjZCO0FBUzlCOztBQUVjO0FBQ2RpNkMsVUFEYyxzQkFDSDtBQUNWLFFBQU1sbEMsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDbWxDLGFBQUgsRUFIVSxFQUlWbmxDLEVBQUUsQ0FBQ29sQyxhQUFILEVBSlU7QUFLVixHQU5hO0FBUWRELGVBUmMsMkJBUUU7QUFDVCxRQUFBbmxDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0RxSyxFQURsRCxDQUNDckssTUFERDtBQUFBLFFBQ2lCdlgsSUFEakIsR0FDa0Q0aEIsRUFEbEQsQ0FDUzlqQixLQURULENBQ2lCa0MsSUFEakI7QUFBQSxrQkFDa0Q0aEIsRUFEbEQsQ0FDd0I1USxHQUR4QjtBQUFBLFFBQzhCaFcsU0FEOUIsV0FDOEJBLFNBRDlCO0FBQUEsUUFDeUNtVyxJQUR6QyxXQUN5Q0EsSUFEekM7QUFEUyxLQUlYb0csTUFBTSxDQUFDaUIsWUFBUCxDQUFvQjNLLE1BQXBCLElBQThCMEosTUFBTSxDQUFDbUIsWUFBUCxDQUFvQjdLLE1BSnZDLE1BS2Q3UyxTQUFTLENBQUNtVyxJQUFWLEdBQWlCQSxJQUFJLENBQUN1VixNQUFMLENBQVksR0FBWixRQUFxQm5WLGNBQUssQ0FBQ3ZZLEtBQTNCLElBQW1DdWUsTUFBTSxDQUFDeUIsZ0JBQVAsR0FBMEIsTUFBMUIsR0FBbUMsRUFBdEUsR0FDZnpJLElBRGUsQ0FDVixXQURVLEVBQ0d2USxJQUFJLENBQUNTLFFBRFIsRUFFZjhQLElBRmUsQ0FFVixPQUZVLEVBRUVnQixjQUFLLENBQUN4VyxJQUZSLFNBRWdCd1csY0FBSyxDQUFDdlcsU0FGdEIsQ0FMSCxFQVNkQSxTQUFTLENBQUNtVyxJQUFWLENBQWViLE1BQWYsQ0FBc0IsR0FBdEIsRUFBMkJDLElBQTNCLENBQWdDLE9BQWhDLEVBQXlDZ0IsY0FBSyxDQUFDdFUsVUFBL0MsQ0FUYyxFQVVkakMsU0FBUyxDQUFDbVcsSUFBVixDQUFlYixNQUFmLENBQXNCLEdBQXRCLEVBQTJCQyxJQUEzQixDQUFnQyxPQUFoQyxFQUF5Q2dCLGNBQUssQ0FBQ2pVLFVBQS9DLENBVmMsRUFZZHRDLFNBQVMsQ0FBQ3VFLENBQVYsR0FBYzQxQyxvR0FBVyxDQUFDLEVBQUQsQ0FaWDtBQWNmLEdBdEJhO0FBd0JkNEksYUF4QmMsdUJBd0JGa0osYUF4QkUsRUF3QmE7QUFDcEIsUUFBQXJsQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQzRDcUssRUFENUMsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTMEssS0FEVCxHQUM0Q0wsRUFENUMsQ0FDU0ssS0FEVDtBQUFBLFFBQ2dCbmtCLEtBRGhCLEdBQzRDOGpCLEVBRDVDLENBQ2dCOWpCLEtBRGhCO0FBQUEsbUJBQzRDOGpCLEVBRDVDLENBQ3VCNVEsR0FEdkI7QUFBQSxRQUM2QkcsSUFEN0IsWUFDNkJBLElBRDdCO0FBQUEsUUFDbUNwVyxJQURuQyxZQUNtQ0EsSUFEbkM7QUFBQSxRQUVBNHVCLFNBRkEsR0FFWXBTLE1BQU0sQ0FBQ2MsWUFGbkI7QUFBQSxRQUdBNnVDLFNBSEEsR0FHWXRsQyxFQUFFLENBQUN1bEMsZ0JBQUgsQ0FBb0I1dkMsTUFBTSxDQUFDZ0IsV0FBM0IsRUFBd0MwSixLQUFLLENBQUMxaUIsQ0FBOUMsQ0FIWjtBQUFBLFFBSUFvakIsVUFKQSxHQUlhZixFQUFFLENBQUMwSixhQUFILEtBQXFCMUosRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBQVIsQ0FBVW9qQixVQUFWLEVBQXJCLEdBQThDLENBSjNEO0FBQUEsUUFLQWlGLEdBTEEsR0FLTSxVQUFBbGEsQ0FBQztBQUFBLGFBQUksQ0FBQyxDQUFDdVUsS0FBSyxDQUFDekMsSUFBTixJQUFjeUMsS0FBSyxDQUFDMWlCLENBQXJCLEVBQXdCbU8sQ0FBeEIsSUFBNkJpVixVQUE5QixLQUE2Q2dILFNBQVMsR0FBRyxDQUFDLENBQUosR0FBUSxDQUE5RCxDQUFKO0FBQUEsS0FMUDs7QUFPTjdyQixTQUFLLENBQUMrRCxTQUFOLEdBQWtCOG5CLFNBQVMsR0FBRztBQUM3QixZQUFNLENBRHVCO0FBRTdCLFlBQU03ckIsS0FBSyxDQUFDQyxLQUZpQjtBQUc3QixZQUFNNnBCLEdBSHVCO0FBSTdCLFlBQU1BO0FBSnVCLEtBQUgsR0FLdkI7QUFDSCxZQUFNQSxHQURIO0FBRUgsWUFBTUEsR0FGSDtBQUdILFlBQU0sQ0FISDtBQUlILFlBQU05cEIsS0FBSyxDQUFDRztBQUpULEtBYnNCLEVBb0IxQmxELElBQUksQ0FBQ3dFLENBQUwsR0FBUzRSLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDclUsTUFBdEIsRUFDUG1wQixTQURPLE9BQ085VSxjQUFLLENBQUN6VSxLQURiLEVBRVBpWCxJQUZPLENBRUZtekMsU0FGRSxDQXBCaUIsRUF3QjFCbnNELElBQUksQ0FBQ3dFLENBQUwsQ0FBT3NuQixJQUFQLEdBQWN0RixNQUFkLEVBeEIwQixFQTBCMUJ4bUIsSUFBSSxDQUFDd0UsQ0FBTCxHQUFTeEUsSUFBSSxDQUFDd0UsQ0FBTCxDQUFPK21CLEtBQVAsR0FDUGhXLE1BRE8sQ0FDQSxNQURBLEVBRVBDLElBRk8sQ0FFRixPQUZFLEVBRU9nQixjQUFLLENBQUN6VSxLQUZiLEVBR1B5cEIsS0FITyxDQUdEeHJCLElBQUksQ0FBQ3dFLENBSEosQ0ExQmlCLEVBK0JyQjBuRCxhQS9CcUIsSUFnQ3pCbHNELElBQUksQ0FBQ3dFLENBQUwsQ0FBT3dtQixJQUFQLENBQVksWUFBVztBQUN0QixVQUFNaHJCLElBQUksR0FBR2lyQixpR0FBUSxDQUFDLElBQUQsQ0FBckI7QUFFQWpZLFlBQU0sQ0FBQ0MsSUFBUCxDQUFZbFEsS0FBSyxDQUFDK0QsU0FBbEIsRUFBNkJvTixPQUE3QixDQUFxQyxVQUFBaFAsRUFBRSxFQUFJO0FBQzFDbEYsWUFBSSxDQUFDd1YsSUFBTCxDQUFVdFEsRUFBVixFQUFjbkMsS0FBSyxDQUFDK0QsU0FBTixDQUFnQjVCLEVBQWhCLENBQWQsRUFDRTBtQixLQURGLENBQ1EsU0FEUixFQUNtQjtBQUFBLGlCQUNqQjVyQixJQUFJLENBQUN3VixJQUFMLENBQVVvWixTQUFTLEdBQUcsSUFBSCxHQUFVLElBQTdCLE9BQXdDQSxTQUFTLEdBQUc3ckIsS0FBSyxDQUFDRyxNQUFULEdBQWtCLENBQW5FLElBQ0MsR0FERCxHQUNPLEdBRlU7QUFBQSxTQURuQixDQUQwQztBQU0xQyxPQU5ELENBSHNCO0FBVXRCLEtBVkQsQ0FoQ3lCO0FBNEMxQixHQXBFYTtBQXNFZG1wRCxhQXRFYyx5QkFzRUE7QUFDUCxRQUFBeGxDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDcUNxSyxFQURyQyxDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ3FDOGpCLEVBRHJDLENBQ1M5akIsS0FEVDtBQUFBLG1CQUNxQzhqQixFQURyQyxDQUNnQjVRLEdBRGhCO0FBQUEsUUFDc0JqVyxJQUR0QixZQUNzQkEsSUFEdEI7QUFBQSxRQUM0Qm9XLElBRDVCLFlBQzRCQSxJQUQ1QjtBQUFBLFFBRUF3WSxTQUZBLEdBRVlwUyxNQUFNLENBQUNjLFlBRm5CO0FBQUEsUUFHQWd2QyxVQUhBLEdBR2F6bEMsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXNILENBQVIsQ0FBVTZrQixVQUFWLE1BQTBCM0MsRUFBRSxDQUFDSyxLQUFILENBQVN2aUIsQ0FBVCxDQUFXc2pCLEtBQVgsQ0FBaUJ6TCxNQUFNLENBQUNvQixZQUF4QixDQUh2QztBQUFBLFFBSUFpUCxHQUpBLEdBSU0sVUFBQWxhLENBQUM7QUFBQSxhQUFJTCxJQUFJLENBQUNDLElBQUwsQ0FBVXNVLEVBQUUsQ0FBQ0ssS0FBSCxDQUFTdmlCLENBQVQsQ0FBV2dPLENBQVgsQ0FBVixDQUFKO0FBQUEsS0FKUDs7QUFNTjNTLFFBQUksQ0FBQzJFLENBQUwsR0FBU3lSLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDaFUsTUFBdEIsRUFDUDhvQixTQURPLE9BQ085VSxjQUFLLENBQUNwVSxLQURiLEVBRVA0VyxJQUZPLENBRUZzekMsVUFGRSxDQVBJLEVBV2J0c0QsSUFBSSxDQUFDMkUsQ0FBTCxDQUFPbW5CLElBQVAsR0FBY3RGLE1BQWQsRUFYYSxFQWFieG1CLElBQUksQ0FBQzJFLENBQUwsR0FBUzNFLElBQUksQ0FBQzJFLENBQUwsQ0FDUDRtQixLQURPLEdBRVBoVyxNQUZPLENBRUEsTUFGQSxFQUdQQyxJQUhPLENBR0YsT0FIRSxFQUdPZ0IsY0FBSyxDQUFDcFUsS0FIYixFQUlQb3BCLEtBSk8sQ0FJRHhyQixJQUFJLENBQUMyRSxDQUpKLENBYkksRUFtQmIzRSxJQUFJLENBQUMyRSxDQUFMLENBQU82USxJQUFQLENBQVksSUFBWixFQUFrQm9aLFNBQVMsR0FBRy9CLEdBQUgsR0FBUyxDQUFwQyxFQUNFclgsSUFERixDQUNPLElBRFAsRUFDYW9aLFNBQVMsR0FBRy9CLEdBQUgsR0FBUzlwQixLQUFLLENBQUNDLEtBRHJDLEVBRUV3UyxJQUZGLENBRU8sSUFGUCxFQUVhb1osU0FBUyxHQUFHLENBQUgsR0FBTy9CLEdBRjdCLEVBR0VyWCxJQUhGLENBR08sSUFIUCxFQUdhb1osU0FBUyxHQUFHN3JCLEtBQUssQ0FBQ0csTUFBVCxHQUFrQjJwQixHQUh4QyxDQW5CYSxFQXdCYmkvQixXQUFXLENBQUM5ckQsSUFBSSxDQUFDMkUsQ0FBTixFQUFTLE1BQVQsQ0F4QkU7QUF5QmIsR0EvRmE7QUFpR2Q0bkQsWUFqR2Msc0JBaUdIMzJCLFFBakdHLEVBaUdPO0FBQ2QsUUFBQS9PLEVBQUUsR0FBRyxJQUFMO0FBQUEsbUJBQzJCQSxFQUQzQixDQUNDNVEsR0FERDtBQUFBLFFBQ09qVyxJQURQLFlBQ09BLElBRFA7QUFBQSxRQUNhQyxTQURiLFlBQ2FBLFNBRGI7QUFLTjtBQUZDQSxhQUFTLENBQUNtVyxJQUFYLElBQW1CeVEsRUFBRSxDQUFDbWxDLGFBQUgsRUFKQyxFQU9wQmhzRCxJQUFJLENBQUNvVyxJQUFMLENBQVV3VixLQUFWLENBQWdCLFlBQWhCLEVBQThCL0UsRUFBRSxDQUFDbVEsVUFBSCxLQUFrQixRQUFsQixHQUE2QixTQUEzRCxDQVBvQixFQVNwQm5RLEVBQUUsQ0FBQ3E4QixhQUFILEVBVG9CLEVBVXBCcjhCLEVBQUUsQ0FBQzJsQyxnQkFBSCxDQUFvQjUyQixRQUFwQixDQVZvQixFQVdwQi9PLEVBQUUsQ0FBQzRsQyxnQkFBSCxDQUFvQjcyQixRQUFwQixDQVhvQjtBQVlwQixHQTdHYTs7QUErR2Q7Ozs7O0FBS0E0MkIsa0JBcEhjLDRCQW9IRzUyQixRQXBISCxFQW9IYTtBQUNwQixRQUFBL08sRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNtQ3FLLEVBRG5DLENBQ0NySyxNQUREO0FBQUEsbUJBQ21DcUssRUFEbkMsQ0FDUzVRLEdBRFQ7QUFBQSxRQUNlaFcsU0FEZixZQUNlQSxTQURmO0FBQUEsUUFDMEJtVyxJQUQxQixZQUMwQkEsSUFEMUI7QUFBQSxRQUVBd1ksU0FGQSxHQUVZcFMsTUFBTSxDQUFDYyxZQUZuQjtBQUlOZCxVQUFNLENBQUNlLFdBQVAsSUFBc0JzSixFQUFFLENBQUNtOEIsV0FBSCxFQUxJO0FBTzFCLFFBQUkwSixNQUFNLEdBQUd0MkMsSUFBSSxDQUFDRyxNQUFMLE9BQWdCQyxjQUFLLENBQUN0VSxVQUF0QixFQUNYb3BCLFNBRFcsT0FDRzlVLGNBQUssQ0FBQ3ZVLFNBRFQsRUFFWCtXLElBRlcsQ0FFTndELE1BQU0sQ0FBQ2lCLFlBRkQsQ0FBYixDQVAwQixDQVcxQjs7QUFDQWl2QyxVQUFNLENBQUM1Z0MsSUFBUCxHQUFjaEQsVUFBZCxHQUNFOE0sUUFERixDQUNXQSxRQURYLEVBRUVoSyxLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFcEYsTUFIRixFQVowQjtBQWlCMUI7QUFDQSxRQUFNdmtCLFNBQVMsR0FBR3lxRCxNQUFNLENBQUNuaEMsS0FBUCxHQUFlaFcsTUFBZixDQUFzQixHQUF0QixDQUFsQjtBQUVBdFQsYUFBUyxDQUFDc1QsTUFBVixDQUFpQixNQUFqQixFQUNFcVcsS0FERixDQUNRLFNBRFIsRUFDbUIsR0FEbkIsQ0FwQjBCLEVBdUIxQjNwQixTQUFTLENBQUNzVCxNQUFWLENBQWlCLE1BQWpCLEVBQ0VDLElBREYsQ0FDTyxXQURQLEVBQ29Cb1osU0FBUyxHQUFHLEVBQUgsR0FBUSxhQURyQyxFQUVFcFosSUFGRixDQUVPLElBRlAsRUFFYSxDQUFDLENBRmQsRUFHRW9XLEtBSEYsQ0FHUSxTQUhSLEVBR21CLEdBSG5CLENBdkIwQixFQTRCMUI4Z0MsTUFBTSxHQUFHenFELFNBQVMsQ0FBQ3VwQixLQUFWLENBQWdCa2hDLE1BQWhCLENBNUJpQixFQThCMUJBLE1BQU0sQ0FDSmwzQyxJQURGLENBQ08sT0FEUCxFQUNnQixVQUFBN0MsQ0FBQztBQUFBLGFBQUksQ0FBRzZELGNBQUssQ0FBQ3ZVLFNBQVQsVUFBc0IwUSxDQUFDLENBQUN1MEIsS0FBRixJQUFXLEVBQWpDLEdBQXNDZ0MsSUFBdEMsRUFBSjtBQUFBLEtBRGpCLEVBRUUzeUIsTUFGRixDQUVTLE1BRlQsRUFHRWYsSUFIRixDQUdPLGFBSFAsRUFHc0JtMkMsaUJBSHRCLEVBSUVuMkMsSUFKRixDQUlPLElBSlAsRUFJYW8yQyxhQUpiLEVBS0U5aUMsVUFMRixHQU1FOE0sUUFORixDQU1XQSxRQU5YLEVBT0VuMEIsSUFQRixDQU9PLFVBQUFrUixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDbFIsSUFBTjtBQUFBLEtBUFIsRUFRRXFuQixVQVJGLEdBU0U4QyxLQVRGLENBU1EsU0FUUixFQVNtQixHQVRuQixDQTlCMEIsRUF5QzFCM3JCLFNBQVMsQ0FBQ3VFLENBQVYsR0FBY2tvRCxNQXpDWTtBQTBDMUIsR0E5SmE7O0FBZ0tkOzs7OztBQUtBRCxrQkFyS2MsNEJBcUtHNzJCLFFBcktILEVBcUthO0FBQ3BCLFFBQUEvTyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3dDcUssRUFEeEMsQ0FDQ3JLLE1BREQ7QUFBQSxvQkFDd0NxSyxFQUR4QyxDQUNTOWpCLEtBRFQ7QUFBQSxRQUNpQkMsS0FEakIsYUFDaUJBLEtBRGpCO0FBQUEsUUFDd0JFLE1BRHhCLGFBQ3dCQSxNQUR4QjtBQUFBLFFBQ2lDK1MsR0FEakMsR0FDd0M0USxFQUR4QyxDQUNpQzVRLEdBRGpDO0FBQUEsUUFFQTJZLFNBRkEsR0FFWXBTLE1BQU0sQ0FBQ2MsWUFGbkI7QUFJTmQsVUFBTSxDQUFDa0IsV0FBUCxJQUFzQm1KLEVBQUUsQ0FBQ3dsQyxXQUFILEVBTEk7QUFPMUIsUUFBSTlwRCxVQUFVLEdBQUcwVCxHQUFHLENBQUNHLElBQUosQ0FBU0csTUFBVCxPQUFvQkMsY0FBSyxDQUFDalUsVUFBMUIsRUFDZitvQixTQURlLE9BQ0Q5VSxjQUFLLENBQUNsVSxTQURMLEVBRWYwVyxJQUZlLENBRVZ3RCxNQUFNLENBQUNtQixZQUZHLENBQWpCLENBUDBCLENBVzFCOztBQUNBcGIsY0FBVSxDQUFDdXBCLElBQVgsR0FDRWhELFVBREYsR0FFRThNLFFBRkYsQ0FFV0EsUUFGWCxFQUdFaEssS0FIRixDQUdRLFNBSFIsRUFHbUIsR0FIbkIsRUFJRXBGLE1BSkYsRUFaMEI7QUFrQjFCO0FBQ0EsUUFBTWxrQixTQUFTLEdBQUdDLFVBQVUsQ0FBQ2dwQixLQUFYLEdBQW1CaFcsTUFBbkIsQ0FBMEIsR0FBMUIsQ0FBbEI7QUFFQWpULGFBQVMsQ0FBQ2lULE1BQVYsQ0FBaUIsTUFBakIsRUFDRXFXLEtBREYsQ0FDUSxTQURSLEVBQ21CLEdBRG5CLENBckIwQixFQXdCMUJ0cEIsU0FBUyxDQUFDaVQsTUFBVixDQUFpQixNQUFqQixFQUNFQyxJQURGLENBQ08sV0FEUCxFQUNvQm9aLFNBQVMsR0FBRyxhQUFILEdBQW1CLEVBRGhELEVBRUVoRCxLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixDQXhCMEIsRUE0QjFCcnBCLFVBQVUsR0FBR0QsU0FBUyxDQUFDa3BCLEtBQVYsQ0FBZ0JqcEIsVUFBaEIsQ0E1QmE7QUE4QjFCO0FBQ0EsUUFBTW9xRCxFQUFFLEdBQUc5bEMsRUFBRSxDQUFDOGxDLEVBQUgsQ0FBTTNpQyxJQUFOLENBQVduRCxFQUFYLENBQVg7QUFFQXRrQixjQUFVLENBQ1JpVCxJQURGLENBQ08sT0FEUCxFQUNnQixVQUFBN0MsQ0FBQztBQUFBLGFBQUksQ0FBRzZELGNBQUssQ0FBQ2xVLFNBQVQsVUFBc0JxUSxDQUFDLENBQUN1MEIsS0FBRixJQUFXLEVBQWpDLEdBQXNDZ0MsSUFBdEMsRUFBSjtBQUFBLEtBRGpCLEVBRUUzeUIsTUFGRixDQUVTLE1BRlQsRUFHRXVTLFVBSEYsR0FJRThNLFFBSkYsQ0FJV0EsUUFKWCxFQUtFcGdCLElBTEYsQ0FLTyxJQUxQLEVBS2FvWixTQUFTLEdBQUcrOUIsRUFBSCxHQUFRLENBTDlCLEVBTUVuM0MsSUFORixDQU1PLElBTlAsRUFNYW9aLFNBQVMsR0FBRys5QixFQUFILEdBQVEzcEQsS0FOOUIsRUFPRXdTLElBUEYsQ0FPTyxJQVBQLEVBT2FvWixTQUFTLEdBQUcsQ0FBSCxHQUFPKzlCLEVBUDdCLEVBUUVuM0MsSUFSRixDQVFPLElBUlAsRUFRYW9aLFNBQVMsR0FBRzFyQixNQUFILEdBQVl5cEQsRUFSbEMsRUFTRTdqQyxVQVRGLEdBVUU4QyxLQVZGLENBVVEsU0FWUixFQVVtQixHQVZuQixDQWpDMEIsRUE2QzFCcnBCLFVBQVUsQ0FBQ2dVLE1BQVgsQ0FBa0IsTUFBbEIsRUFDRWYsSUFERixDQUNPLGFBRFAsRUFDc0JtMkMsaUJBRHRCLEVBRUVuMkMsSUFGRixDQUVPLElBRlAsRUFFYW8yQyxhQUZiLEVBR0U5aUMsVUFIRixHQUlFOE0sUUFKRixDQUlXQSxRQUpYLEVBS0VwZ0IsSUFMRixDQUtPLElBTFAsRUFLYSxDQUFDLENBTGQsRUFNRUEsSUFORixDQU1PLEdBTlAsRUFNWXEyQyxZQUFZLENBQUNqOUIsU0FBRCxFQUFZNXJCLEtBQVosRUFBbUJFLE1BQW5CLENBTnhCLEVBT0VzUyxJQVBGLENBT08sR0FQUCxFQU9ZbTNDLEVBUFosRUFRRWxyRCxJQVJGLENBUU8sVUFBQWtSLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNsUixJQUFOO0FBQUEsS0FSUixFQVNFcW5CLFVBVEYsR0FVRThDLEtBVkYsQ0FVUSxTQVZSLEVBVW1CLEdBVm5CLENBN0MwQixFQXlEMUIzVixHQUFHLENBQUNoVyxTQUFKLENBQWMwRSxDQUFkLEdBQWtCcEMsVUF6RFE7QUEwRDFCLEdBL05hO0FBaU9kcXFELFlBak9jLHNCQWlPSC8zQixjQWpPRyxFQWlPYTtBQUNwQixRQUFBaE8sRUFBRSxHQUFHLElBQUw7QUFBQSxRQUVrQitILFNBRmxCLEdBS0YvSCxFQUxFLENBRUxySyxNQUZLLENBRUljLFlBRko7QUFBQSxxQkFLRnVKLEVBTEUsQ0FHTDlqQixLQUhLO0FBQUEsUUFHR0MsS0FISCxjQUdHQSxLQUhIO0FBQUEsUUFHVUUsTUFIVixjQUdVQSxNQUhWO0FBQUEsUUFJQ2pELFNBSkQsR0FLRjRtQixFQUxFLENBSUw1USxHQUpLLENBSUNoVyxTQUpEO0FBQUEsUUFNQTZqRCxFQU5BLEdBTUtqOUIsRUFBRSxDQUFDaTlCLEVBQUgsQ0FBTTk1QixJQUFOLENBQVduRCxFQUFYLENBTkw7QUFBQSxRQVFGam1CLEtBUkUsR0FRTVgsU0FBUyxDQUFDdUUsQ0FBVixDQUFZK1IsTUFBWixDQUFtQixNQUFuQixDQVJOO0FBQUEsUUFTRjdVLEtBVEUsR0FTTXpCLFNBQVMsQ0FBQ3VFLENBQVYsQ0FBWStSLE1BQVosQ0FBbUIsTUFBbkIsQ0FUTjtBQXNCTixXQVhBM1YsS0FBSyxHQUFHLENBQUNpMEIsY0FBYyxHQUFHajBCLEtBQUssQ0FBQ2tvQixVQUFOLEVBQUgsR0FBd0Jsb0IsS0FBdkMsRUFDTjRVLElBRE0sQ0FDRCxJQURDLEVBQ0tvWixTQUFTLEdBQUcsQ0FBSCxHQUFPazFCLEVBRHJCLEVBRU50dUMsSUFGTSxDQUVELElBRkMsRUFFS29aLFNBQVMsR0FBRzVyQixLQUFILEdBQVc4Z0QsRUFGekIsRUFHTnR1QyxJQUhNLENBR0QsSUFIQyxFQUdLb1osU0FBUyxHQUFHazFCLEVBQUgsR0FBUSxDQUh0QixFQUlOdHVDLElBSk0sQ0FJRCxJQUpDLEVBSUtvWixTQUFTLEdBQUdrMUIsRUFBSCxHQUFRNWdELE1BSnRCLENBV1IsRUFMQXhCLEtBQUssR0FBRyxDQUFDbXpCLGNBQWMsR0FBR256QixLQUFLLENBQUNvbkIsVUFBTixFQUFILEdBQXdCcG5CLEtBQXZDLEVBQ044VCxJQURNLENBQ0QsR0FEQyxFQUNJcTJDLFlBQVksQ0FBQyxDQUFDajlCLFNBQUYsRUFBYTVyQixLQUFiLEVBQW9CRSxNQUFwQixDQURoQixFQUVOc1MsSUFGTSxDQUVELEdBRkMsRUFFSXN1QyxFQUZKLEVBR05yaUQsSUFITSxDQUdELFVBQUFrUixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDbFIsSUFBTjtBQUFBLEtBSEEsQ0FLUixFQUFPLENBQ04sQ0FBQ296QixjQUFjLEdBQUdqMEIsS0FBSyxDQUFDa29CLFVBQU4sRUFBSCxHQUF3QmxvQixLQUF2QyxFQUE4Q2dyQixLQUE5QyxDQUFvRCxTQUFwRCxFQUErRCxHQUEvRCxDQURNLEVBRU4sQ0FBQ2lKLGNBQWMsR0FBR256QixLQUFLLENBQUNvbkIsVUFBTixFQUFILEdBQXdCcG5CLEtBQXZDLEVBQThDa3FCLEtBQTlDLENBQW9ELFNBQXBELEVBQStELEdBQS9ELENBRk0sQ0FBUDtBQUlBLEdBNVBhO0FBOFBkcWdDLGVBOVBjLDJCQThQRTtBQUNULFFBQUFwbEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUMrQnFLLEVBRC9CLENBQ0NySyxNQUREO0FBQUEsUUFDaUJ2WCxJQURqQixHQUMrQjRoQixFQUQvQixDQUNTOWpCLEtBRFQsQ0FDaUJrQyxJQURqQjtBQUFBLFFBQ3dCZ1IsR0FEeEIsR0FDK0I0USxFQUQvQixDQUN3QjVRLEdBRHhCO0FBQUEsUUFFQTQyQyxPQUZBLEdBRVVyd0MsTUFBTSxDQUFDd0IsVUFGakI7QUFBQSxRQUdBbVMsU0FIQSxTQUdnQjNaLGNBQUssQ0FBQ3EyQyxPQUFPLElBQUk1MkMsR0FBRyxDQUFDalcsSUFBSixDQUFTb1csSUFBcEIsR0FBMkIsV0FBM0IsR0FBeUMsT0FBMUMsQ0FIckIsSUFHMEV5MkMsT0FBTyxHQUFHLE1BQUgsR0FBWSxFQUg3RjtBQUFBLFFBS0E3c0QsSUFMQSxHQUtPaVcsR0FBRyxDQUFDalcsSUFBSixDQUFTb1csSUFBVCxHQUFnQkgsR0FBRyxDQUFDRyxJQUFKLENBQVN1VixNQUFULENBQWdCLEdBQWhCLEVBQXFCd0UsU0FBckIsRUFDM0IzYSxJQUQyQixDQUN0QixXQURzQixFQUNUdlEsSUFBSSxDQUFDUyxRQURJLEVBRTNCOFAsSUFGMkIsQ0FFdEIsT0FGc0IsRUFFYmdCLGNBQUssQ0FBQ3hXLElBRk8sQ0FMdkI7QUFTTndjLFVBQU0sQ0FBQ2UsV0FBUCxJQUNDdmQsSUFBSSxDQUFDdVYsTUFBTCxDQUFZLEdBQVosRUFBaUJDLElBQWpCLENBQXNCLE9BQXRCLEVBQStCZ0IsY0FBSyxDQUFDclUsTUFBckMsQ0FYYyxFQWFmcWEsTUFBTSxDQUFDa0IsV0FBUCxJQUNDMWQsSUFBSSxDQUFDdVYsTUFBTCxDQUFZLEdBQVosRUFBaUJDLElBQWpCLENBQXNCLE9BQXRCLEVBQStCZ0IsY0FBSyxDQUFDaFUsTUFBckMsQ0FkYyxFQWdCWGdhLE1BQU0sQ0FBQ3NCLGVBaEJJLEtBaUJkOWQsSUFBSSxDQUFDdVYsTUFBTCxDQUFZLEdBQVosRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JnQixjQUFLLENBQUN4VSxVQUR0QixFQUVFdVQsTUFGRixDQUVTLE1BRlQsRUFHRUMsSUFIRixDQUdPLE9BSFAsRUFHZ0JnQixjQUFLLENBQUN4VSxVQUh0QixDQWpCYyxFQXVCVndhLE1BQU0sQ0FBQ3VCLFlBQVAsSUFBdUIsQ0FBQ3ZCLE1BQU0sQ0FBQ2hTLGVBdkJyQixJQXdCYnhLLElBQUksQ0FBQ3VWLE1BQUwsQ0FBWSxHQUFaLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCZ0IsY0FBSyxDQUFDblUsVUFEdEIsRUFFRWtULE1BRkYsQ0FFUyxNQUZULEVBR0VDLElBSEYsQ0FHTyxPQUhQLEVBR2dCZ0IsY0FBSyxDQUFDblUsVUFIdEIsQ0F4QmE7QUE4QmYsR0E1UmE7O0FBOFJkOzs7OztBQUtBdWtELGVBblNjLHlCQW1TQXBLLFlBblNBLEVBbVNjO0FBQ3JCLFFBQUEzMUIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNtQ3FLLEVBRG5DLENBQ0NySyxNQUREO0FBQUEscUJBQ21DcUssRUFEbkMsQ0FDUzlqQixLQURUO0FBQUEsUUFDaUJDLEtBRGpCLGNBQ2lCQSxLQURqQjtBQUFBLFFBQ3dCRSxNQUR4QixjQUN3QkEsTUFEeEI7QUFBQSxRQUVBMHJCLFNBRkEsR0FFWXBTLE1BQU0sQ0FBQ2MsWUFGbkI7QUFBQSxRQUdBNCtCLFVBSEEsR0FHYU0sWUFBWSxDQUFDcmpDLE1BQWIsQ0FBb0IsVUFBQXhHLENBQUM7QUFBQSxhQUFJQSxDQUFDLElBQUlkLE9BQU8sQ0FBQ2dWLEVBQUUsQ0FBQzRXLFlBQUgsQ0FBZ0I5cUIsQ0FBaEIsQ0FBRCxDQUFoQjtBQUFBLEtBQXJCLENBSGI7O0FBS047QUFDQSxVQUFJLENBQUM2SixNQUFNLENBQUNsUyxZQUFSLElBQXdCNHhDLFVBQVUsQ0FBQ3BwQyxNQUFYLEtBQXNCLENBQTlDLElBQW1EK1QsRUFBRSxDQUFDa1csT0FBSCxDQUFXLFFBQVgsQ0FBbkQsSUFBMkVsVyxFQUFFLENBQUNtUSxVQUFILEVBQS9FO0FBQUEsVUFJTTgxQixPQUFPLEdBQUdqbUMsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlrVixTQUFaLFdBQThCOVUsY0FBSyxDQUFDeFUsVUFBcEMsZUFBd0R3VSxjQUFLLENBQUNuVSxVQUE5RCxDQUpoQjtBQUFBLFVBS00wcUQsTUFBTSxHQUFHdndDLE1BQU0sQ0FBQ3FCLGVBQVAsSUFBMEIsQ0FBQ3JCLE1BQU0sQ0FBQ2hTLGVBTGpEO0FBQUEsVUFNTXdpRCxFQUFFLEdBQUdubUMsRUFBRSxDQUFDbW1DLEVBQUgsQ0FBTWhqQyxJQUFOLENBQVduRCxFQUFYLENBTlg7QUFRQWltQyxhQUFPLENBQ0xsaEMsS0FERixDQUNRLFlBRFIsRUFDc0IsU0FEdEIsRUFFRTVTLElBRkYsQ0FFT2tqQyxVQUFVLENBQUNsa0MsTUFBWCxDQUFrQmtrQyxVQUFsQixDQUZQLEVBR0VseEIsSUFIRixDQUdPLFVBQVNyWSxDQUFULEVBQVk7QUFBQSxZQU1iczZDLEVBTmE7QUFBQSxZQUNYcHlDLEVBQUUsR0FBR29RLGlHQUFRLENBQUMsSUFBRCxDQURGO0FBQUEsWUFFWDRCLEdBQUcsR0FBRztBQUNYcm9CLFdBQUMsRUFBRXdvRCxFQUFFLENBQUNyNkMsQ0FBRCxDQURNO0FBRVhoTyxXQUFDLEVBQUVraUIsRUFBRSxDQUFDbXRCLFNBQUgsQ0FBYXJoQyxDQUFDLENBQUN6TixFQUFmLEVBQW1CeU4sQ0FBQyxDQUFDcUIsS0FBckI7QUFGUSxTQUZLO0FBUWpCLFlBQUk2RyxFQUFFLENBQUMreUIsT0FBSCxDQUFXcDNCLGNBQUssQ0FBQ3hVLFVBQWpCLENBQUosRUFFQ2lyRCxFQUFFLEdBQUdyK0IsU0FBUyxHQUNiLENBQ0MsSUFERCxFQUNPO0FBQ04vQixXQUFHLENBQUNyb0IsQ0FGTCxFQUVRO0FBQ1B1b0QsY0FBTSxHQUFHbGdDLEdBQUcsQ0FBQ2xvQixDQUFQLEdBQVczQixLQUhsQixFQUd5QjtBQUN4QjZwQixXQUFHLENBQUNyb0IsQ0FKTCxDQUlPO0FBSlAsU0FEYSxHQU1ULENBQ0hxb0IsR0FBRyxDQUFDcm9CLENBREQsRUFFSHVvRCxNQUFNLEdBQUdsZ0MsR0FBRyxDQUFDbG9CLENBQVAsR0FBVyxJQUZkLEVBR0hrb0IsR0FBRyxDQUFDcm9CLENBSEQsRUFJSHRCLE1BSkcsQ0FSTixNQWNPO0FBQ04sY0FBTWdxRCxJQUFJLEdBQUdybUMsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUTZ6QixLQUFSLENBQWN2ZSxDQUFDLENBQUN6TixFQUFoQixNQUF3QixJQUFyQztBQUVBK25ELFlBQUUsR0FBR3IrQixTQUFTLEdBQ2IsQ0FDQy9CLEdBQUcsQ0FBQ2xvQixDQURMLEVBQ1E7QUFDUG9vRCxnQkFBTSxJQUFJLENBQUNHLElBQVgsR0FBa0JyZ0MsR0FBRyxDQUFDcm9CLENBQXRCLEdBQTBCLElBRjNCLEVBRWlDO0FBQ2hDcW9CLGFBQUcsQ0FBQ2xvQixDQUhMLEVBR1E7QUFDUG9vRCxnQkFBTSxJQUFJRyxJQUFWLEdBQWlCcmdDLEdBQUcsQ0FBQ3JvQixDQUFyQixHQUF5QnRCLE1BSjFCLENBSWlDO0FBSmpDLFdBRGEsR0FNVCxDQUNINnBELE1BQU0sSUFBSUcsSUFBVixHQUFpQnJnQyxHQUFHLENBQUNyb0IsQ0FBckIsR0FBeUIsSUFEdEIsRUFFSHFvQixHQUFHLENBQUNsb0IsQ0FGRCxFQUdIb29ELE1BQU0sSUFBSSxDQUFDRyxJQUFYLEdBQWtCcmdDLEdBQUcsQ0FBQ3JvQixDQUF0QixHQUEwQnhCLEtBSHZCLEVBSUg2cEIsR0FBRyxDQUFDbG9CLENBSkQsQ0FUQztBQWVOO0FBRUQsU0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFDRXVQLE9BREYsQ0FDVSxVQUFDcEMsQ0FBRCxFQUFJd0QsQ0FBSjtBQUFBLGlCQUFVdUYsRUFBRSxDQUFDckYsSUFBSCxDQUFRMUQsQ0FBUixFQUFXbTdDLEVBQUUsQ0FBQzMzQyxDQUFELENBQWIsQ0FBVjtBQUFBLFNBRFYsQ0F2Q2lCO0FBeUNqQixPQTVDRixDQVJBLEVBc0RBdzJDLFdBQVcsQ0FBQ2dCLE9BQUQsRUFBVSxNQUFWLENBdERYO0FBQUE7QUF1REEsR0FqV2E7QUFtV2Q1SixlQW5XYywyQkFtV0U7QUFDZixTQUFLanRDLEdBQUwsQ0FBU0csSUFBVCxDQUFja1YsU0FBZCxXQUFnQzlVLGNBQUssQ0FBQ3hVLFVBQXRDLGVBQTBEd1UsY0FBSyxDQUFDblUsVUFBaEUsRUFDRXVwQixLQURGLENBQ1EsWUFEUixFQUNzQixRQUR0QixDQURlO0FBR2YsR0F0V2E7QUF3V2R1aEMsaUJBeFdjLDZCQXdXSTtBQUNYLFFBQUF0bUMsRUFBRSxHQUFHLElBQUw7QUFBQSxxQkFDa0JBLEVBQUUsQ0FBQzlqQixLQURyQjtBQUFBLFFBQ0NDLEtBREQsY0FDQ0EsS0FERDtBQUFBLFFBQ1FFLE1BRFIsY0FDUUEsTUFEUjtBQUFBLFFBRUEwckIsU0FGQSxHQUVZL0gsRUFBRSxDQUFDckssTUFBSCxDQUFVYyxZQUZ0QjtBQUlOdUosTUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlHLE1BQVosV0FBMkJDLGNBQUssQ0FBQ3hVLFVBQWpDLEVBQ0V3VCxJQURGLENBQ08sSUFEUCxFQUNhb1osU0FBUyxHQUFHLENBQUgsR0FBTyxDQUFDLEVBRDlCLEVBRUVwWixJQUZGLENBRU8sSUFGUCxFQUVhb1osU0FBUyxHQUFHNXJCLEtBQUgsR0FBVyxDQUFDLEVBRmxDLEVBR0V3UyxJQUhGLENBR08sSUFIUCxFQUdhb1osU0FBUyxHQUFHLENBQUMsRUFBSixHQUFTLENBSC9CLEVBSUVwWixJQUpGLENBSU8sSUFKUCxFQUlhb1osU0FBUyxHQUFHLENBQUMsRUFBSixHQUFTMXJCLE1BSi9CLENBTGlCO0FBVWpCLEdBbFhhO0FBb1hka3BELGtCQXBYYyw0QkFvWEc5MUMsSUFwWEgsRUFvWFM0USxLQXBYVCxFQW9YZ0I7QUFBQSxRQUN2QkwsRUFBRSxHQUFHLElBRGtCO0FBQUEsUUFFdkJ1bUMsT0FBTyxHQUFHdm1DLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBT0csSUFBUCxDQUFZRyxNQUFaLE9BQXVCQyxjQUFLLENBQUNsWixLQUE3QixFQUNkZ3VCLFNBRGMsQ0FDSixPQURJLEVBRWQ3bUIsSUFGYyxFQUZhO0FBQUEsUUFLekI0b0QsUUFBZ0IsR0FBRyxFQUxNOztBQU83QixRQUFJLzJDLElBQUksS0FBSyxNQUFiLEVBQXFCO0FBQUEsVUFDZHlxQixPQUFPLEdBQUdsYSxFQUFFLENBQUNrbEIsVUFBSCxFQURJO0FBQUEsVUFFZHVoQixTQUFTLEdBQUd2c0IsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXd3NCLFdBQVgsRUFGRTtBQUFBLFVBR2RDLFFBQVEsR0FBR3pzQixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVd3c0IsV0FBWCxFQUhHOztBQUtwQixXQUFLLElBQUlqNEMsQ0FBQyxHQUFHZzRDLFNBQWIsRUFBd0JoNEMsQ0FBQyxJQUFJazRDLFFBQTdCLEVBQXVDbDRDLENBQUMsRUFBeEMsRUFDQyszQyxRQUFRLENBQUNuekMsSUFBVCxDQUFjLElBQUluSCxJQUFKLENBQVl1QyxDQUFaLHFCQUFkLENBREQ7QUFHQSxLQVJELE1BU0MrM0MsUUFBUSxHQUFHbm1DLEtBQUssQ0FBQ2UsS0FBTixDQUFZLEVBQVosQ0FUWixFQVdLb2xDLFFBQVEsQ0FBQ3Y2QyxNQUFULEdBQWtCczZDLE9BWHZCLEtBWUVDLFFBQVEsR0FBR0EsUUFBUSxDQUFDbDBDLE1BQVQsQ0FBZ0IsVUFBQXhHLENBQUM7QUFBQSxhQUFJLENBQU9BLENBQVAsT0FBVW9DLE9BQVYsQ0FBa0IsR0FBbEIsSUFBeUIsQ0FBN0I7QUFBQSxLQUFqQixDQVpiOztBQWdCQSxXQUFPczRDLFFBQVA7QUFDQSxHQTVZYTtBQThZZEksdUJBOVljLGlDQThZUTF5QyxNQTlZUixFQThZZ0I7QUFDN0IsV0FBT0EsTUFBTSxHQUFHLFVBQUFwYSxJQUFJLEVBQUk7QUFDdkIsVUFBSXNULEtBQUssS0FBVDtBQVFBLGFBTkEsQ0FBQ2IsT0FBTyxDQUFDMkgsTUFBRCxDQUFQLEdBQWtCQSxNQUFNLENBQUMvQyxNQUFQLEVBQWxCLEdBQW9DLENBQUMrQyxNQUFELENBQXJDLEVBQStDN0csT0FBL0MsQ0FBdUQsVUFBQXNuQyxLQUFLLEVBQUk7QUFBQSxTQUN6RCxXQUFXQSxLQUFYLElBQW9CNzZDLElBQUksQ0FBQ3FULEtBQUwsS0FBZXduQyxLQUFLLENBQUN4bkMsS0FBMUMsSUFBcUQsV0FBV3duQyxLQUFYLElBQW9CNzZDLElBQUksQ0FBQ3VtQyxLQUFMLEtBQWVzVSxLQUFLLENBQUN0VSxLQURwQyxNQUU5RGp6QixLQUFLLEtBRnlEO0FBSS9ELE9BSkQsQ0FNQSxFQUFPQSxLQUFQO0FBQ0EsS0FWWSxHQVVUO0FBQUE7QUFBQSxLQVZKO0FBV0EsR0ExWmE7QUE0WmQ4ckMsaUJBNVpjLDJCQTRaRWhsQyxNQTVaRixFQTRaVXk5QixJQTVaVixFQTRaZ0I7QUFDdkIsUUFBQTN4QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQWt4QyxRQUZBLEdBRVc3bUMsRUFBRSxDQUFDNG1DLHFCQUFILENBQXlCMXlDLE1BQXpCLENBRlg7QUFBQSxRQUlBeXJCLFVBSkEsR0FJYWdTLElBQUksR0FBR2hpQyxjQUFLLENBQUN0VSxVQUFULEdBQXNCc1UsY0FBSyxDQUFDalUsVUFKN0M7QUFBQSxRQUtBZ2tDLFNBTEEsR0FLWWlTLElBQUksR0FBR2hpQyxjQUFLLENBQUN2VSxTQUFULEdBQXFCdVUsY0FBSyxDQUFDbFUsU0FMM0M7QUFPTnVrQixNQUFFLENBQUM1USxHQUFILENBQU9HLElBQVAsQ0FBWUcsTUFBWixPQUF1Qml3QixVQUF2QixFQUNFbGIsU0FERixPQUNnQmliLFNBRGhCLEVBRUVwdEIsTUFGRixDQUVTdTBDLFFBRlQsRUFHRTVrQyxVQUhGLEdBSUU4TSxRQUpGLENBSVdwWixNQUFNLENBQUN1SixtQkFKbEIsRUFLRTZGLEtBTEYsQ0FLUSxTQUxSLEVBS21CLEdBTG5CLEVBTUVwRixNQU5GLEVBUjZCO0FBZ0I3QixRQUFNdm1CLFNBQVMsY0FBV3U0QyxJQUFJLEdBQUcsR0FBSCxHQUFTLEdBQXhCLFlBQWY7QUFFQWg4QixVQUFNLENBQUN2YyxTQUFELENBQU4sR0FBb0J1YyxNQUFNLENBQUN2YyxTQUFELENBQU4sQ0FBa0JrWixNQUFsQixDQWRMLGdCQUFBeFksSUFBSTtBQUFBLGFBQUksQ0FBQytzRCxRQUFRLENBQUMvc0QsSUFBRCxDQUFiO0FBQUEsS0FjQyxDQWxCUztBQW1CN0I7QUEvYWEsQ0FBZixFOztBQ3hDQTs7OztDQUlpRDs7QUFDakQ7QUFDQTtBQUVlO0FBQ2RndEQsWUFEYyx3QkFDRDtBQUNOLFFBQUE5bUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDNVEsR0FERCxHQUNRNFEsRUFEUixDQUNDNVEsR0FERDtBQUdOQSxPQUFHLENBQUNwVixNQUFKLENBQVd1VixJQUFYLEdBQWtCSCxHQUFHLENBQUNHLElBQUosQ0FBU2IsTUFBVCxDQUFnQixHQUFoQixFQUNoQkMsSUFEZ0IsQ0FDWCxXQURXLEVBQ0VxUixFQUFFLENBQUM5akIsS0FBSCxDQUFTa0MsSUFBVCxDQUFjTSxJQURoQixFQUVoQmlRLElBRmdCLENBRVgsT0FGVyxFQUVGZ0IsY0FBSyxDQUFDMVYsT0FGSixDQUpOO0FBT1osR0FSYTtBQVVkOHNELGNBVmMsd0JBVURoNEIsUUFWQyxFQVVTO0FBQ2hCLFFBQUEvTyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBSU5BLE9BQUcsQ0FBQ3BWLE1BQUosQ0FBV3VWLElBQVgsQ0FBZ0J3VixLQUFoQixDQUFzQixZQUF0QixFQUFvQy9FLEVBQUUsQ0FBQ21RLFVBQUgsS0FBa0IsUUFBbEIsR0FBNkIsU0FBakUsQ0FMc0I7QUFPdEI7QUFDQSxRQUFJNjJCLElBQUksR0FBRzUzQyxHQUFHLENBQUNHLElBQUosQ0FBU0csTUFBVCxPQUFvQkMsY0FBSyxDQUFDMVYsT0FBMUIsRUFDVHdxQixTQURTLE9BQ0s5VSxjQUFLLENBQUMzVixNQURYLEVBRVRtWSxJQUZTLENBRUp3RCxNQUFNLENBQUMxYixPQUZILENBQVg7QUFJQStzRCxRQUFJLENBQUMvaEMsSUFBTCxHQUNFaEQsVUFERixHQUVFOE0sUUFGRixDQUVXQSxRQUZYLEVBR0VoSyxLQUhGLENBR1EsU0FIUixFQUdtQixHQUhuQixFQUlFcEYsTUFKRixFQVpzQixFQWtCdEJxbkMsSUFBSSxHQUFHQSxJQUFJLENBQUN0aUMsS0FBTCxHQUNMaFcsTUFESyxDQUNFLEdBREYsRUFFTGlXLEtBRkssQ0FFQ3FpQyxJQUZELEVBR0xyNEMsSUFISyxDQUdBLE9BSEEsRUFHU3FSLEVBQUUsQ0FBQ29nQixXQUFILENBQWVqZCxJQUFmLENBQW9CbkQsRUFBcEIsQ0FIVCxDQWxCZSxFQXVCdEJnbkMsSUFBSSxDQUNGdDRDLE1BREYsQ0FDUyxNQURULEVBRUVxVyxLQUZGLENBRVEsY0FGUixFQUV3QixHQUZ4QixDQXZCc0IsRUEyQnRCM1YsR0FBRyxDQUFDcFYsTUFBSixDQUFXZ3RELElBQVgsR0FBa0JBLElBM0JJO0FBNEJ0QixHQXRDYTtBQXdDZEMsY0F4Q2Msd0JBd0NEajVCLGNBeENDLEVBd0NlO0FBQUEsUUFDdEJoTyxFQUFFLEdBQUcsSUFEaUI7QUFBQSxRQUV4Qi9sQixPQUFPLEdBQUcrbEIsRUFBRSxDQUFDNVEsR0FBSCxDQUFPcFYsTUFBUCxDQUFjZ3RELElBQWQsQ0FBbUJ0M0MsTUFBbkIsQ0FBMEIsTUFBMUIsQ0FGYztBQVU1QixXQU5BelYsT0FBTyxHQUFHLENBQUMrekIsY0FBYyxHQUFHL3pCLE9BQU8sQ0FBQ2dvQixVQUFSLEVBQUgsR0FBMEJob0IsT0FBekMsRUFDUjBVLElBRFEsQ0FDSCxHQURHLEVBQ0VxUixFQUFFLENBQUNxOUIsT0FBSCxDQUFXbDZCLElBQVgsQ0FBZ0JuRCxFQUFoQixDQURGLEVBRVJyUixJQUZRLENBRUgsR0FGRyxFQUVFcVIsRUFBRSxDQUFDa25DLE9BQUgsQ0FBVy9qQyxJQUFYLENBQWdCbkQsRUFBaEIsQ0FGRixFQUdSclIsSUFIUSxDQUdILE9BSEcsRUFHTXFSLEVBQUUsQ0FBQ3M5QixXQUFILENBQWVuNkIsSUFBZixDQUFvQm5ELEVBQXBCLENBSE4sRUFJUnJSLElBSlEsQ0FJSCxRQUpHLEVBSU9xUixFQUFFLENBQUNtbkMsWUFBSCxDQUFnQmhrQyxJQUFoQixDQUFxQm5ELEVBQXJCLENBSlAsQ0FNVixFQUFPLENBQ04sQ0FBQ2dPLGNBQWMsR0FBRy96QixPQUFPLENBQUNnb0IsVUFBUixFQUFILEdBQTBCaG9CLE9BQXpDLEVBQ0U4cUIsS0FERixDQUNRLGNBRFIsRUFDd0IsVUFBQWpaLENBQUM7QUFBQSxhQUFLZCxPQUFPLENBQUNjLENBQUMsQ0FBQ3dqQixPQUFILENBQVAsR0FBcUJ4akIsQ0FBQyxDQUFDd2pCLE9BQXZCLEdBQWlDLEtBQXRDO0FBQUEsS0FEekIsRUFFRXdQLEVBRkYsQ0FFSyxLQUZMLEVBRVksWUFBVztBQUVyQjFhLHVHQUFRLENBQUMsS0FBSytkLFVBQU4sQ0FBUixDQUNFMWQsU0FERixDQUNZLGVBRFosRUFFRTlFLE1BRkYsRUFGcUI7QUFLckIsS0FQRixDQURNLENBQVA7QUFVQSxHQTVEYTtBQThEZHluQyxhQTlEYyx1QkE4REYzM0MsSUE5REUsRUE4REkzRCxDQTlESixFQThETztBQU1oQixRQUFBdTdDLFNBQVM7QUFBQSxRQUxQcm5DLEVBS08sR0FMRixJQUtFO0FBQUEsUUFKTnJLLE1BSU0sR0FKV3FLLEVBSVgsQ0FKTnJLLE1BSU07QUFBQSxRQUpFMEssS0FJRixHQUpXTCxFQUlYLENBSkVLLEtBSUY7QUFBQSxRQUhQMEgsU0FHTyxHQUhLcFMsTUFBTSxDQUFDYyxZQUdaO0FBQUEsUUFGUGdULEdBRU8sR0FGRGhhLElBQUksS0FBSyxHQUVSO0FBQUEsUUFEVDFDLEdBQ1MsR0FESCxPQUNHO0FBQUEsUUFDVGlaLEdBRFMsR0FDSCxDQURHO0FBaUJiLFdBZElsYSxDQUFDLENBQUN0VixJQUFGLEtBQVcsR0FBWCxJQUFrQnNWLENBQUMsQ0FBQ3RWLElBQUYsS0FBVyxJQWNqQyxJQWJLLENBQUNpekIsR0FhTixLQVpFMWMsR0FBRyxHQUFHLEtBWVIsR0FUSyxDQUFDMGMsR0FBRyxHQUFHMUIsU0FBSCxHQUFlLENBQUNBLFNBQXBCLEtBQWtDaGIsR0FBRyxJQUFJakIsQ0FTOUMsS0FSRXU3QyxTQUFTLEdBQUdobkMsS0FBSyxDQUFDdlUsQ0FBQyxDQUFDdFYsSUFBSCxDQVFuQixFQVBFd3ZCLEdBQUcsR0FBR3FoQyxTQUFTLENBQUN2N0MsQ0FBQyxDQUFDaUIsR0FBRCxDQUFGLENBT2pCLEtBTFcsQ0FBQzBjLEdBQUcsR0FBRyxDQUFDMUIsU0FBSixHQUFnQkEsU0FBcEIsS0FBa0NoYixHQUFHLElBQUlqQixDQUtwRCxLQUpDdTdDLFNBQVMsR0FBR2huQyxLQUFLLENBQUN6QyxJQUFOLElBQWN5QyxLQUFLLENBQUMxaUIsQ0FJakMsRUFIQ3FvQixHQUFHLEdBQUdxaEMsU0FBUyxDQUFDcm5DLEVBQUUsQ0FBQzhKLFlBQUgsS0FBb0J0VSxTQUFTLENBQUM5SCxJQUFWLENBQWVzUyxFQUFmLEVBQW1CbFUsQ0FBQyxDQUFDaUIsR0FBRCxDQUFwQixDQUFwQixHQUFpRGpCLENBQUMsQ0FBQ2lCLEdBQUQsQ0FBbkQsQ0FHaEIsR0FBT2laLEdBQVA7QUFDQSxHQXRGYTtBQXdGZHEzQixTQXhGYyxtQkF3Rk52eEMsQ0F4Rk0sRUF3Rkg7QUFDVixXQUFPLEtBQUtzN0MsV0FBTCxDQUFpQixHQUFqQixFQUFzQnQ3QyxDQUF0QixDQUFQO0FBQ0EsR0ExRmE7QUE0RmRvN0MsU0E1RmMsbUJBNEZOcDdDLENBNUZNLEVBNEZIO0FBQ1YsV0FBTyxLQUFLczdDLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0J0N0MsQ0FBdEIsQ0FBUDtBQUNBLEdBOUZhO0FBZ0dkdzdDLGVBaEdjLHlCQWdHQTczQyxJQWhHQSxFQWdHTTNELENBaEdOLEVBZ0dTO0FBTWxCLFFBQUF1N0MsU0FBUztBQUFBLFFBTFBybkMsRUFLTyxHQUxGLElBS0U7QUFBQSxRQUpOckssTUFJTSxHQUprQnFLLEVBSWxCLENBSk5ySyxNQUlNO0FBQUEsUUFKRTBLLEtBSUYsR0FKa0JMLEVBSWxCLENBSkVLLEtBSUY7QUFBQSxRQUpTbmtCLEtBSVQsR0FKa0I4akIsRUFJbEIsQ0FKUzlqQixLQUlUO0FBQUEsUUFIUDZyQixTQUdPLEdBSEtwUyxNQUFNLENBQUNjLFlBR1o7QUFBQSxRQUZQOHdDLE9BRU8sR0FGRzkzQyxJQUFJLEtBQUssT0FFWjtBQUFBLFFBRFAwRCxLQUNPLEdBREM2TSxFQUFFLENBQUN1bkMsT0FBTyxHQUFHLFNBQUgsR0FBZSxTQUF2QixDQUFGLENBQW9DejdDLENBQXBDLENBQ0Q7QUFBQSxRQUNUaUIsR0FEUyxHQUNILEtBREc7QUFBQSxRQUVUcUcsR0FGUyxHQUVIbFgsS0FBSyxDQUFDdVQsSUFBRCxDQUZGO0FBa0JiLFdBZEkzRCxDQUFDLENBQUN0VixJQUFGLEtBQVcsR0FBWCxJQUFrQnNWLENBQUMsQ0FBQ3RWLElBQUYsS0FBVyxJQWNqQyxJQWJLLENBQUMrd0QsT0FhTixLQVpFeDZDLEdBQUcsR0FBRyxPQVlSLEdBVEssQ0FBQ3c2QyxPQUFPLEdBQUd4L0IsU0FBSCxHQUFlLENBQUNBLFNBQXhCLEtBQXNDaGIsR0FBRyxJQUFJakIsQ0FTbEQsS0FSRXU3QyxTQUFTLEdBQUdobkMsS0FBSyxDQUFDdlUsQ0FBQyxDQUFDdFYsSUFBSCxDQVFuQixFQVBFNGMsR0FBRyxHQUFHaTBDLFNBQVMsQ0FBQ3Y3QyxDQUFDLENBQUNpQixHQUFELENBQUYsQ0FPakIsS0FMVyxDQUFDdzZDLE9BQU8sR0FBRyxDQUFDeC9CLFNBQUosR0FBZ0JBLFNBQXhCLEtBQXNDaGIsR0FBRyxJQUFJakIsQ0FLeEQsS0FKQ3U3QyxTQUFTLEdBQUdobkMsS0FBSyxDQUFDekMsSUFBTixJQUFjeUMsS0FBSyxDQUFDMWlCLENBSWpDLEVBSEN5VixHQUFHLEdBQUdpMEMsU0FBUyxDQUFDcm5DLEVBQUUsQ0FBQzhKLFlBQUgsS0FBb0J0VSxTQUFTLENBQUM5SCxJQUFWLENBQWVzUyxFQUFmLEVBQW1CbFUsQ0FBQyxDQUFDaUIsR0FBRCxDQUFwQixDQUFwQixHQUFpRGpCLENBQUMsQ0FBQ2lCLEdBQUQsQ0FBbkQsQ0FHaEIsR0FBT3FHLEdBQUcsR0FBR0QsS0FBTixHQUFjLENBQWQsR0FBa0JDLEdBQUcsR0FBR0QsS0FBL0I7QUFDQSxHQXpIYTtBQTJIZG1xQyxhQTNIYyx1QkEySEZ4eEMsQ0EzSEUsRUEySEM7QUFDZCxXQUFPLEtBQUt3N0MsYUFBTCxDQUFtQixPQUFuQixFQUE0Qng3QyxDQUE1QixDQUFQO0FBQ0EsR0E3SGE7QUErSGRxN0MsY0EvSGMsd0JBK0hEcjdDLENBL0hDLEVBK0hFO0FBQ2YsV0FBTyxLQUFLdzdDLGFBQUwsQ0FBbUIsUUFBbkIsRUFBNkJ4N0MsQ0FBN0IsQ0FBUDtBQUNBLEdBaklhO0FBbUlkaXhDLGFBbkljLHVCQW1JRmp4QyxDQW5JRSxFQW1JQztBQUNkLFdBQU8sQ0FBQ0EsQ0FBQyxDQUFDdFYsSUFBSCxJQUFXc1YsQ0FBQyxDQUFDdFYsSUFBRixLQUFXLEdBQTdCO0FBQ0E7QUFySWEsQ0FBZixFOzs7OztBQ1JBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFZTtBQUNkOzs7Ozs7O0FBT0FneEQsYUFSYyx1QkFRRjdzRCxNQVJFLEVBUU1tUixDQVJOLEVBUVMyQyxDQVJULEVBUVk7QUFDbkIsUUFBQXVSLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDd0JxSyxFQUR4QixDQUNDckssTUFERDtBQUFBLFFBQ2VwRyxJQURmLEdBQ3dCeVEsRUFEeEIsQ0FDUzVRLEdBRFQsQ0FDZUcsSUFEZjtBQUFBLFFBRUF3WSxTQUZBLEdBRVlwUyxNQUFNLENBQUNjLFlBRm5CO0FBQUEsUUFHQXltQyxFQUhBLEdBR0ssQ0FBQ24xQixTQUFTLEdBQUcvSCxFQUFFLENBQUN3YixPQUFOLEdBQWdCeGIsRUFBRSxDQUFDeW5DLE9BQTdCLEVBQXNDdGtDLElBQXRDLENBQTJDbkQsRUFBM0MsQ0FITDtBQUFBLFFBSUFtOUIsRUFKQSxHQUlLLENBQUNwMUIsU0FBUyxHQUFHL0gsRUFBRSxDQUFDeW5DLE9BQU4sR0FBZ0J6bkMsRUFBRSxDQUFDd2IsT0FBN0IsRUFBc0NyWSxJQUF0QyxDQUEyQ25ELEVBQTNDLENBSkw7QUFBQSxRQUtBcUcsQ0FMQSxHQUtJckcsRUFBRSxDQUFDMG5DLFlBQUgsQ0FBZ0J2a0MsSUFBaEIsQ0FBcUJuRCxFQUFyQixDQUxKO0FBU047QUFGQTFTLFVBQU0sQ0FBQ3FJLE1BQU0sQ0FBQy9QLGVBQVIsRUFBeUJvYSxFQUFFLENBQUNnSixHQUE1QixFQUFpQ2xkLENBQWpDLEVBQW9DblIsTUFBTSxDQUFDb1QsSUFBUCxFQUFwQyxDQVJtQixFQVd6QndCLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDeFYsZUFBdEIsR0FBd0M2bEIsRUFBRSxDQUFDbWIsdUJBQUgsQ0FBMkJydkIsQ0FBQyxDQUFDek4sRUFBN0IsQ0FBeEMsRUFDRW9tQixTQURGLE9BQ2dCOVUsY0FBSyxDQUFDelYsY0FEdEIsU0FDd0N1VSxDQUR4QyxFQUVFMEQsSUFGRixDQUVPLENBQUNyRyxDQUFELENBRlAsRUFHRTRZLEtBSEYsR0FJRWhXLE1BSkYsQ0FJUyxRQUpULEVBS0VDLElBTEYsQ0FLTyxPQUxQLEVBS2dCO0FBQUEsYUFBTXFSLEVBQUUsQ0FBQ21mLGFBQUgsQ0FBaUJ4dkIsY0FBSyxDQUFDelYsY0FBdkIsRUFBdUN1VSxDQUF2QyxDQUFOO0FBQUEsS0FMaEIsRUFNRUUsSUFORixDQU1PLElBTlAsRUFNYXV1QyxFQU5iLEVBT0V2dUMsSUFQRixDQU9PLElBUFAsRUFPYXd1QyxFQVBiLEVBUUV4dUMsSUFSRixDQVFPLFFBUlAsRUFRaUJxUixFQUFFLENBQUM5QyxLQVJwQixFQVNFdk8sSUFURixDQVNPLEdBVFAsRUFTWSxVQUFBNHhDLEVBQUU7QUFBQSxhQUFJdmdDLEVBQUUsQ0FBQzBuQyxZQUFILENBQWdCbkgsRUFBaEIsSUFBc0IsR0FBMUI7QUFBQSxLQVRkLEVBVUV0K0IsVUFWRixHQVdFOE0sUUFYRixDQVdXLEdBWFgsRUFZRXBnQixJQVpGLENBWU8sR0FaUCxFQVlZMFgsQ0FaWixDQVh5QjtBQXdCekIsR0FoQ2E7O0FBa0NkOzs7Ozs7O0FBT0FzaEMsZUF6Q2MseUJBeUNBaHRELE1BekNBLEVBeUNRbVIsQ0F6Q1IsRUF5Q1cyQyxDQXpDWCxFQXlDYztBQUNyQixRQUFBdVIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNnQnFLLEVBRGhCLENBQ0NySyxNQUREO0FBQUEsUUFDU3ZHLEdBRFQsR0FDZ0I0USxFQURoQixDQUNTNVEsR0FEVDtBQUtOO0FBRkE5QixVQUFNLENBQUNxSSxNQUFNLENBQUM5UCxpQkFBUixFQUEyQm1hLEVBQUUsQ0FBQ2dKLEdBQTlCLEVBQW1DbGQsQ0FBbkMsRUFBc0NuUixNQUFNLENBQUNvVCxJQUFQLEVBQXRDLENBSnFCLEVBTzNCcUIsR0FBRyxDQUFDRyxJQUFKLENBQVNHLE1BQVQsT0FBb0JDLGNBQUssQ0FBQ3hWLGVBQTFCLEdBQTRDNmxCLEVBQUUsQ0FBQ21iLHVCQUFILENBQTJCcnZCLENBQUMsQ0FBQ3pOLEVBQTdCLENBQTVDLEVBQ0VvbUIsU0FERixPQUNnQjlVLGNBQUssQ0FBQ3pWLGNBRHRCLFNBQ3dDdVUsQ0FEeEMsRUFFRXdULFVBRkYsR0FHRThNLFFBSEYsQ0FHVyxHQUhYLEVBSUVwZ0IsSUFKRixDQUlPLEdBSlAsRUFJWSxDQUpaLEVBS0VnUixNQUxGLEVBUDJCO0FBYTNCLEdBdERhOztBQXdEZDs7Ozs7Ozs7QUFRQWs4QixhQWhFYyx1QkFnRUZ2QyxRQWhFRSxFQWdFUTMrQyxNQWhFUixFQWdFZ0JtUixDQWhFaEIsRUFnRW1CMkMsQ0FoRW5CLEVBZ0VzQjtBQUNuQyxRQUFNbTVDLE1BQU0sSUFBTXRPLFFBQVEsR0FBRyxFQUFILEdBQVEsSUFBdEIsaUJBQVo7QUFFQSxTQUFLc08sTUFBTCxFQUFhanRELE1BQWIsRUFBcUJtUixDQUFyQixFQUF3QjJDLENBQXhCLENBSG1DO0FBSW5DLEdBcEVhOztBQXNFZDs7Ozs7O0FBTUFvNUMsWUE1RWMsc0JBNEVIbHRELE1BNUVHLEVBNEVLbVIsQ0E1RUwsRUE0RVE7QUFDZixRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdOckksVUFBTSxDQUFDcUksTUFBTSxDQUFDL1AsZUFBUixFQUF5Qm9hLEVBQUUsQ0FBQ2dKLEdBQTVCLEVBQWlDbGQsQ0FBakMsRUFBb0NuUixNQUFNLENBQUNvVCxJQUFQLEVBQXBDLENBSmUsRUFNakI0SCxNQUFNLENBQUN6VCxvQkFOVSxJQU9wQnZILE1BQU0sQ0FBQ3NuQixVQUFQLEdBQW9COE0sUUFBcEIsQ0FBNkIsR0FBN0IsRUFDRWhLLEtBREYsQ0FDUSxNQURSLEVBQ2dCO0FBQUEsYUFBTStpQyxrRkFBSyxDQUFDOW5DLEVBQUUsQ0FBQzlDLEtBQUgsQ0FBU3BSLENBQVQsQ0FBRCxDQUFMLENBQW1CaThDLFFBQW5CLENBQTRCLEdBQTVCLENBQU47QUFBQSxLQURoQixDQVBvQjtBQVVyQixHQXRGYTs7QUF3RmQ7Ozs7OztBQU1BQyxjQTlGYyx3QkE4RkRydEQsTUE5RkMsRUE4Rk9tUixDQTlGUCxFQThGVTtBQUNqQixRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdOckksVUFBTSxDQUFDcUksTUFBTSxDQUFDOVAsaUJBQVIsRUFBMkJtYSxFQUFFLENBQUNnSixHQUE5QixFQUFtQ2xkLENBQW5DLEVBQXNDblIsTUFBTSxDQUFDb1QsSUFBUCxFQUF0QyxDQUppQixFQU1uQjRILE1BQU0sQ0FBQ3pULG9CQU5ZLElBT3RCdkgsTUFBTSxDQUFDc25CLFVBQVAsR0FBb0I4TSxRQUFwQixDQUE2QixHQUE3QixFQUNFaEssS0FERixDQUNRLE1BRFIsRUFDZ0I7QUFBQSxhQUFNL0UsRUFBRSxDQUFDOUMsS0FBSCxDQUFTcFIsQ0FBVCxDQUFOO0FBQUEsS0FEaEIsQ0FQc0I7QUFVdkIsR0F4R2E7O0FBMEdkOzs7Ozs7OztBQVFBZ3dDLFlBbEhjLHNCQWtISHhDLFFBbEhHLEVBa0hPMytDLE1BbEhQLEVBa0hlbVIsQ0FsSGYsRUFrSGtCMkMsQ0FsSGxCLEVBa0hxQjtBQUNsQyxVQUNJNnFDLFFBQVEsR0FBRyxFQUFILEdBQVEsSUFEcEIsa0JBRUUzK0MsTUFGRixFQUVVbVIsQ0FGVixFQUVhMkMsQ0FGYixDQURrQztBQUlsQyxHQXRIYTs7QUF3SGQ7Ozs7Ozs7QUFPQWdyQyxXQS9IYyxxQkErSEp3TyxJQS9ISSxFQStIRW44QyxDQS9IRixFQStISztBQUNsQixRQUFNa1UsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPaW9DLElBQUksQ0FBQy9iLFFBQUwsS0FBa0IsTUFBbEIsR0FDTmxzQixFQUFFLENBQUM4N0IsVUFERyxHQUVMOTdCLEVBQUUsQ0FBQ3kzQixVQUFILENBQWMzckMsQ0FBZCxJQUNDLFlBQU0sQ0FBRSxDQURULEdBQ1k7QUFDWGtVLE1BQUUsQ0FBQzY3QixXQUpOO0FBTUEsR0F4SWE7O0FBMElkOzs7Ozs7O0FBT0F1RCxhQWpKYyx1QkFpSkY2SSxJQWpKRSxFQWlKSW44QyxDQWpKSixFQWlKTzJDLENBakpQLEVBaUpVO0FBTW5CLFFBQUF5NUMsWUFBWTtBQUFBLFFBTFZsb0MsRUFLVSxHQUxMLElBS0s7QUFBQSxRQUpUckssTUFJUyxHQUpjcUssRUFJZCxDQUpUckssTUFJUztBQUFBLFFBSktwRyxJQUlMLEdBSmN5USxFQUlkLENBSkQ1USxHQUlDLENBSktHLElBSUw7QUFBQSxRQUhWblYsS0FHVSxHQUhGZ3FCLGlHQUFRLENBQUM2akMsSUFBRCxDQUdOO0FBQUEsUUFGVnJPLFVBRVUsR0FGR3gvQyxLQUFLLENBQUMyc0MsT0FBTixDQUFjcDNCLGNBQUssQ0FBQzVULFFBQXBCLENBRUg7QUFBQSxRQURWMnRDLE1BQ1UsR0FERDFwQixFQUFFLENBQUN5NUIsU0FBSCxDQUFhd08sSUFBYixFQUFtQm44QyxDQUFuQixFQUFzQnFYLElBQXRCLENBQTJCbkQsRUFBM0IsQ0FDQzs7QUFFaEIsUUFBSXJLLE1BQU0sQ0FBQ3BRLHNCQUFQLElBQWlDb1EsTUFBTSxDQUFDbFEsMkJBQVAsQ0FBbUMwZCxJQUFuQyxDQUF3Q25ELEVBQUUsQ0FBQ2dKLEdBQTNDLEVBQWdEbGQsQ0FBaEQsQ0FBckMsRUFBeUY7QUFDeEYsVUFBSSxDQUFDNkosTUFBTSxDQUFDalEsdUJBQVosRUFBcUM7QUFDcEMsWUFBSXc1QixRQUFRLFNBQU92dkIsY0FBSyxDQUFDdFYsTUFBekI7QUFFSXNiLGNBQU0sQ0FBQ25RLHNCQUh5QixLQUluQzA1QixRQUFRLElBQUlsZixFQUFFLENBQUNtYix1QkFBSCxDQUEyQnJ2QixDQUFDLENBQUN6TixFQUE3QixDQUp1QixHQU9wQ2tSLElBQUksQ0FBQ2tWLFNBQUwsQ0FBZXlhLFFBQWYsRUFDRXphLFNBREYsT0FDZ0I5VSxjQUFLLENBQUN2VixLQUR0QixFQUVFK3BCLElBRkYsQ0FFTyxVQUFTclksQ0FBVCxFQUFZMkMsQ0FBWixFQUFlO0FBQ3BCLGNBQU1yVSxLQUFLLEdBQUdncUIsaUdBQVEsQ0FBQyxJQUFELENBQXRCO0FBRUlocUIsZUFBSyxDQUFDMnNDLE9BQU4sQ0FBY3AzQixjQUFLLENBQUM1VCxRQUFwQixDQUhnQixLQUluQm1zRCxZQUFZLEdBQUc5dEQsS0FKSSxFQUtuQnN2QyxNQUFNLEtBQVF0dkMsS0FBSyxDQUFDMnNDLE9BQU4sQ0FBY3AzQixjQUFLLENBQUM1VCxRQUFwQixLQUFSLEVBQThDK1AsQ0FBOUMsRUFBaUQyQyxDQUFqRCxDQUxhO0FBT3BCLFNBVEYsQ0FQb0M7QUFpQnBDOztBQUVJeTVDLGtCQUFELElBQWlCQSxZQUFZLENBQUNuNkMsSUFBYixPQUF3QjNULEtBQUssQ0FBQzJULElBQU4sRUFwQjJDLEtBcUJ2RjNULEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVQsUUFBcEIsRUFBOEIsQ0FBQzY5QyxVQUEvQixDQXJCdUYsRUFzQnZGbFEsTUFBTSxDQUFDLENBQUNrUSxVQUFGLEVBQWN4L0MsS0FBZCxFQUFxQjBSLENBQXJCLEVBQXdCMkMsQ0FBeEIsQ0F0QmlGO0FBd0J4RjtBQUNEO0FBbExhLENBQWYsRTs7QUNUQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVlO0FBQ2QwNUMsU0FEYyxxQkFDSjtBQUNULFFBQU1ub0MsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlHLE1BQVosT0FBdUJDLGNBQUssQ0FBQ3ZZLEtBQTdCLEVBQXNDc1gsTUFBdEMsQ0FBNkMsR0FBN0MsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JnQixjQUFLLENBQUM3WCxTQUR0QixDQUhTO0FBS1QsR0FOYTtBQVFkc3dELHFCQVJjLCtCQVFNdm9DLE9BUk4sRUFRZTtBQUN0QixRQUFBRyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBQUEsUUFFQTJ4QixhQUZBLEdBRWdCL2dCLEVBQUUsQ0FBQytnQixhQUFILENBQWlCNWQsSUFBakIsQ0FBc0JuRCxFQUF0QixDQUZoQjtBQUFBLFFBR0ErZixTQUhBLEdBR1kvZixFQUFFLENBQUMrZixTQUFILENBQWE1YyxJQUFiLENBQWtCbkQsRUFBbEIsQ0FIWjtBQUFBLFFBSUEwZ0IsVUFKQSxHQUlhMWdCLEVBQUUsQ0FBQzBnQixVQUFILENBQWN2ZCxJQUFkLENBQW1CbkQsRUFBbkIsQ0FKYjtBQU1ENVEsT0FBRyxDQUFDclksR0FQbUIsSUFRM0JpcEIsRUFBRSxDQUFDbW9DLE9BQUgsRUFSMkI7QUFBQSxRQVd0QkUsYUFBYSxHQUFHcm9DLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBT0csSUFBUCxDQUFZRyxNQUFaLE9BQXVCQyxjQUFLLENBQUM3WCxTQUE3QixFQUNwQjJzQixTQURvQixPQUNOOVUsY0FBSyxDQUFDOVgsUUFEQSxFQUVwQnNhLElBRm9CLENBRWYwTixPQUZlLEVBR3BCbFIsSUFIb0IsQ0FHZixPQUhlLEVBR04sVUFBQTdDLENBQUM7QUFBQSxhQUFJaTFCLGFBQWEsQ0FBQ2oxQixDQUFELENBQWIsR0FBbUI0MEIsVUFBVSxDQUFDNTBCLENBQUQsQ0FBakM7QUFBQSxLQUhLLENBWE07QUFBQSxRQWdCdEJ3OEMsWUFBWSxHQUFHRCxhQUFhLENBQUMzakMsS0FBZCxHQUFzQmhXLE1BQXRCLENBQTZCLEdBQTdCLEVBQ25CQyxJQURtQixDQUNkLE9BRGMsRUFDTG95QixhQURLLEVBRW5CaGMsS0FGbUIsQ0FFYixTQUZhLEVBRUYsR0FGRSxFQUduQkEsS0FIbUIsQ0FHYixnQkFIYSxFQUdLLE1BSEwsQ0FoQk87QUFxQjVCO0FBQ0F1akMsZ0JBQVksQ0FBQzU1QyxNQUFiLENBQW9CLEdBQXBCLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCb3hCLFNBRGhCLEVBRUVoYixLQUZGLENBRVEsUUFGUixFQUVrQixVQUFBalosQ0FBQztBQUFBLGFBQUs2SixNQUFNLENBQUNsUSwyQkFBUCxDQUFtQzBkLElBQW5DLENBQXdDbkQsRUFBRSxDQUFDZ0osR0FBM0MsRUFBZ0RsZCxDQUFoRCxJQUFxRCxTQUFyRCxHQUFpRSxJQUF0RTtBQUFBLEtBRm5CLENBdEI0QjtBQXlCNUIsR0FqQ2E7QUFtQ2R5OEMsV0FuQ2MscUJBbUNKMVgsZUFuQ0ksRUFtQ2E7QUFDcEIsUUFBQTd3QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0M1USxHQURELEdBQ1E0USxFQURSLENBQ0M1USxHQUREO0FBQUEsUUFFQThvQyxPQUZBLEdBRVVsNEIsRUFBRSxDQUFDazRCLE9BQUgsQ0FBVy8wQixJQUFYLENBQWdCbkQsRUFBaEIsQ0FGVjtBQUFBLFFBR0E4ZixRQUhBLEdBR1c5ZixFQUFFLENBQUM4ZixRQUFILENBQVkzYyxJQUFaLENBQWlCbkQsRUFBakIsQ0FIWDtBQUFBLFFBSUFraUMsY0FKQSxHQUlpQmxpQyxFQUFFLENBQUNraUMsY0FBSCxDQUFrQi8rQixJQUFsQixDQUF1Qm5ELEVBQXZCLENBSmpCO0FBTU41USxPQUFHLENBQUNyWSxHQUFKLEdBQVVxWSxHQUFHLENBQUNHLElBQUosQ0FBU2tWLFNBQVQsT0FBdUI5VSxjQUFLLENBQUMzWSxJQUE3QixFQUFxQ3l0QixTQUFyQyxPQUFtRDlVLGNBQUssQ0FBQzVZLEdBQXpELEVBQ1JvYixJQURRLENBQ0grbEMsT0FERyxDQVBnQixFQVUxQjlvQyxHQUFHLENBQUNyWSxHQUFKLENBQVFrdUIsSUFBUixHQUFlaEQsVUFBZixHQUNFOE0sUUFERixDQUNXOGhCLGVBRFgsRUFFRTlyQixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFcEYsTUFIRixFQVYwQixFQWUxQnZRLEdBQUcsQ0FBQ3JZLEdBQUosR0FBVXFZLEdBQUcsQ0FBQ3JZLEdBQUosQ0FBUTJ0QixLQUFSLEdBQWdCaFcsTUFBaEIsQ0FBdUIsTUFBdkIsRUFDUkMsSUFEUSxDQUNILE9BREcsRUFDTW14QixRQUROLEVBRVIvYSxLQUZRLENBRUYsTUFGRSxFQUVNL0UsRUFBRSxDQUFDOUMsS0FGVCxFQUdSeUgsS0FIUSxDQUdGdlYsR0FBRyxDQUFDclksR0FIRixFQUlSZ3VCLEtBSlEsQ0FJRixTQUpFLEVBSVNtOUIsY0FKVCxDQWZnQjtBQW9CMUIsR0F2RGE7QUF5RGRzRyxXQXpEYyxxQkF5REpDLE9BekRJLEVBeURLejZCLGNBekRMLEVBeURxQjtBQUFBLFFBQzNCajNCLEdBRDJCLEdBQ3BCLEtBQUtxWSxHQURlLENBQzNCclksR0FEMkI7QUFHbEMsV0FBTyxDQUNOLENBQUNpM0IsY0FBYyxHQUFHajNCLEdBQUcsQ0FBQ2tyQixVQUFKLENBQWVsUyxTQUFTLEVBQXhCLENBQUgsR0FBaUNoWixHQUFoRCxFQUNFNFgsSUFERixDQUNPLEdBRFAsRUFDWTg1QyxPQURaLEVBRUUxakMsS0FGRixDQUVRLE1BRlIsRUFFZ0IsS0FBSzdILEtBRnJCLEVBR0U2SCxLQUhGLENBR1EsU0FIUixFQUdtQixHQUhuQixDQURNLENBQVA7QUFNQSxHQWxFYTtBQW9FZDJqQyxTQXBFYyxtQkFvRU5seUQsSUFwRU0sRUFvRUFteUQsYUFwRUEsRUFvRWU7QUFPeEIsUUFBQUMsTUFBTTtBQUFBLFFBTko1b0MsRUFNSSxHQU5DLElBTUQ7QUFBQSxRQUxIckssTUFLRyxHQUxjcUssRUFLZCxDQUxIckssTUFLRztBQUFBLFFBTEswSyxLQUtMLEdBTGNMLEVBS2QsQ0FMS0ssS0FLTDtBQUFBLFFBSkoya0IsWUFJSSxHQUpXaGxCLEVBQUUsQ0FBQytYLGVBQUgsRUFJWDtBQUFBLFFBSEp2QyxTQUdJLEdBSFE3ZixNQUFNLENBQUMzUSxXQUFQLENBQW1CaUgsTUFHM0I7QUFBQSxRQUZKa2IsWUFFSSxHQUZXLENBQUM5RyxLQUFLLENBQUN6QyxJQUFOLElBQWNvQyxFQUFmLEtBQXNCLENBQUNBLEVBQUUsQ0FBQzBKLGFBQUgsRUFBdkIsR0FDcEIxSixFQUFFLENBQUNtbUMsRUFBSCxDQUFNOWxDLEtBQUssQ0FBQ3FILElBQU4sQ0FBVzdwQixNQUFYLEdBQW9CLENBQXBCLENBQU4sSUFBZ0NtbkMsWUFEWixHQUMyQnh1QyxJQUFJLENBQUMyd0IsWUFBTCxDQUFrQjZkLFlBQWxCLENBQ3RDO0FBQUEsUUFFSjZqQixRQUZJLEdBRU8sVUFBQ3hxRCxFQUFELEVBQWlCO0FBQUEsVUFDM0JsQyxLQUFLLEdBQUdrQyxFQUFFLEdBQUdzWCxNQUFNLENBQUN5RCxTQUFQLENBQWlCL2EsRUFBakIsQ0FBSCxHQUEwQnNYLE1BQU0sQ0FBQ3lELFNBRGhCO0FBQUEsVUFFM0JrakIsS0FBSyxHQUFHaitCLEVBQUUsR0FBR2xDLEtBQUssQ0FBQ21nQyxLQUFULEdBQWlCM21CLE1BQU0sQ0FBQzBELGVBRlA7QUFBQSxVQUczQnVKLEdBQUcsR0FBR3ZrQixFQUFFLEdBQUdsQyxLQUFLLENBQUN5bUIsR0FBVCxHQUFlak4sTUFBTSxDQUFDMkQsYUFISDtBQUFBLFVBSTNCdUgsQ0FBQyxHQUFHelYsUUFBUSxDQUFDalAsS0FBRCxDQUFSLEdBQ1RBLEtBRFMsR0FDRHdzRCxhQUFhLEdBQUl4aEMsWUFBWSxHQUFHbVYsS0FBaEIsR0FBeUJxc0IsYUFBNUIsR0FBNEMsQ0FMakM7QUFPakMsYUFBTy9sQyxHQUFHLElBQUkvQixDQUFDLEdBQUcrQixHQUFYLEdBQWlCQSxHQUFqQixHQUF1Qi9CLENBQTlCO0FBQ0EsS0FWUzs7QUF5QlYsV0FiQStuQyxNQUFNLEdBQUdDLFFBQVEsRUFhakIsRUFYSSxDQUFDcnpCLFNBQUQsSUFBY3pwQixZQUFZLENBQUM0SixNQUFNLENBQUN5RCxTQUFSLENBVzlCLEtBVkN3dkMsTUFBTSxHQUFHO0FBQUN6c0QsV0FBSyxFQUFFeXNELE1BQVI7QUFBZ0I5d0IsV0FBSyxFQUFFO0FBQXZCLEtBVVYsRUFSQzlYLEVBQUUsQ0FBQzROLG1CQUFILENBQXVCNU4sRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBL0IsRUFBd0N4UyxPQUF4QyxDQUFnRCxVQUFBcEMsQ0FBQyxFQUFJO0FBQ2hEMEssWUFBTSxDQUFDeUQsU0FBUCxDQUFpQm5PLENBQUMsQ0FBQzVNLEVBQW5CLENBRGdELEtBRW5EdXFELE1BQU0sQ0FBQzM5QyxDQUFDLENBQUM1TSxFQUFILENBQU4sR0FBZXdxRCxRQUFRLENBQUM1OUMsQ0FBQyxDQUFDNU0sRUFBSCxDQUY0QixFQUduRHVxRCxNQUFNLENBQUM5d0IsS0FBUCxDQUFhemtCLElBQWIsQ0FBa0J1MUMsTUFBTSxDQUFDMzlDLENBQUMsQ0FBQzVNLEVBQUgsQ0FBTixJQUFnQnVxRCxNQUFNLENBQUN6c0QsS0FBekMsQ0FIbUQ7QUFLcEQsS0FMRCxDQVFELEdBQU95c0QsTUFBUDtBQUNBLEdBckdhO0FBdUdkRSxTQXZHYyxtQkF1R05yNkMsQ0F2R00sRUF1R0hwUSxFQXZHRyxFQXVHQztBQUNSLFFBQUEyaEIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDelEsSUFERCxHQUNTeVEsRUFBRSxDQUFDNVEsR0FEWixDQUNDRyxJQUREO0FBQUEsUUFFQXc1QyxNQUZBLEdBRVUvOUMsT0FBTyxDQUFDeUQsQ0FBRCxDQUFQLFNBQWlCQSxDQUFqQixLQUZWO0FBSU4sV0FBTyxDQUFDcFEsRUFBRSxHQUFHa1IsSUFBSSxDQUNma1YsU0FEVyxPQUNHOVUsY0FBSyxDQUFDM1ksSUFEVCxHQUNnQmdwQixFQUFFLENBQUNtYix1QkFBSCxDQUEyQjk4QixFQUEzQixDQURoQixDQUFILEdBQ3VEa1IsSUFEMUQsRUFFTGtWLFNBRkssT0FFUzlVLGNBQUssQ0FBQzVZLEdBRmYsR0FFcUJneUQsTUFGckIsQ0FBUDtBQUdBLEdBL0dhO0FBaUhkN0ksWUFqSGMsc0JBaUhIenhDLENBakhHLEVBaUhBcFEsRUFqSEEsRUFpSEl5aEIsS0FqSEosRUFpSFc7QUFDeEIsUUFBTUUsRUFBRSxHQUFHLElBQVg7QUFFQUYsU0FBSyxJQUFJRSxFQUFFLENBQUNvZ0MsWUFBSCxFQUhlLEVBSXhCcGdDLEVBQUUsQ0FBQzhvQyxPQUFILENBQVdyNkMsQ0FBWCxFQUFjcFEsRUFBZCxFQUFrQjBvQyxPQUFsQixDQUEwQnAzQixjQUFLLENBQUM3VCxRQUFoQyxLQUp3QjtBQUt4QixHQXRIYTtBQXdIZHNrRCxjQXhIYyx3QkF3SEQzeEMsQ0F4SEMsRUF3SEU7QUFDZixTQUFLcTZDLE9BQUwsQ0FBYXI2QyxDQUFiLEVBQWdCczRCLE9BQWhCLENBQXdCcDNCLGNBQUssQ0FBQzdULFFBQTlCLEtBRGU7QUFFZixHQTFIYTtBQTRIZGt0RCxpQkE1SGMsMkJBNEhFQyxVQTVIRixFQTRIY0MsS0E1SGQsRUE0SHFCO0FBQzVCLFFBQUFscEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUF3ekMsU0FGQSxHQUVZbnBDLEVBQUUsQ0FBQ29wQyxvQkFBSCxDQUF3QkgsVUFBeEIsRUFBb0NDLEtBQXBDLENBRlo7QUFBQSxRQUdBbmhDLFNBSEEsR0FHWXBTLE1BQU0sQ0FBQ2MsWUFIbkI7QUFBQSxRQUlBK2UsU0FKQSxHQUlZN2YsTUFBTSxDQUFDM1EsV0FBUCxDQUFtQmlILE1BSi9CO0FBQUEsUUFLQW85QyxTQUxBLEdBS1kxekMsTUFBTSxDQUFDc0QsVUFMbkI7QUFBQSxRQU1BcXdDLGNBTkEsR0FNaUIzekMsTUFBTSxDQUFDdUQsZ0JBTnhCO0FBQUEsUUFTQXF3QyxTQVRBLEdBU1luK0MsUUFBUSxDQUFDaStDLFNBQUQsQ0FBUixJQUF1QkEsU0FBUyxHQUFHLENBQW5DLEdBQ2pCO0FBQUEsYUFBTUEsU0FBTjtBQUFBLEtBRGlCLEdBRWhCaitDLFFBQVEsQ0FBQ2srQyxjQUFELENBQVIsR0FBMkIsVUFBQXpvQyxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxHQUFHeW9DLGNBQVI7QUFBQSxLQUE1QixHQUFxRCxJQVhqRDtBQWNOLFdBQU8sVUFBQ3g5QyxDQUFELEVBQUkyQyxDQUFKLEVBQVU7QUFDaEI7QUFEZ0IsVUFFVm1qQyxNQUFNLEdBQUd1WCxTQUFTLENBQUNyOUMsQ0FBRCxFQUFJMkMsQ0FBSixDQUZSO0FBQUEsVUFLVis2QyxNQUFNLEdBQUcsQ0FBQ3poQyxTQUxBO0FBQUEsVUFNVjBoQyxNQUFNLEdBQUcsQ0FBQyxDQUFDRCxNQU5EO0FBQUEsVUFRVkUsVUFBVSxHQUFHNTlDLENBQUMsQ0FBQ3FCLEtBQUYsR0FBVSxDQVJiO0FBQUEsVUFTVnc4QyxVQUFVLEdBQUcsQ0FBQyxFQUFELEVBQUssRUFBTCxDQVRIO0FBQUEsVUFVWi9wRCxNQUFNLEdBQUcsQ0FWRyxFQUloQjs7QUFRQSxVQUFJMnBELFNBQVMsSUFBSSxDQUFDL3pCLFNBQWxCLEVBQTZCO0FBQUEsWUFDdEJuUSxLQUFLLEdBQUcwQyxTQUFTLEdBQUcwaEMsTUFBSCxHQUFZRCxNQURQO0FBQUEsWUFFdEJJLElBQUksR0FBR2hZLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVXZzQixLQUFWLElBQW1CdXNCLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVXZzQixLQUFWLENBRko7QUFJNUJ6bEIsY0FBTSxHQUFHMnBELFNBQVMsQ0FBQ0ssSUFBRCxDQUpVO0FBTTVCLFlBQU16ekQsR0FBRyxTQUFPeUosTUFBUCxTQUFpQkEsTUFBakIsVUFBMkI4cEQsVUFBVSxvQkFBckMsT0FBVDtBQUVBQyxrQkFBVSxDQUFDLENBQUMsQ0FBQzVoQyxTQUFILENBQVYsUUFBNkI1eEIsR0FBN0IsR0FBbUN5SixNQUFuQyxTQUE2Q0EsTUFSakIsRUFTNUIrcEQsVUFBVSxDQUFDLENBQUM1aEMsU0FBRixDQUFWLFFBQTRCNXhCLEdBQTVCLEdBQWtDLENBQUMsQ0FBQ3lKLE1BQUYsRUFBVUEsTUFBVixFQUFrQm1vQixTQUFTLEdBQUcsTUFBSCxHQUFZLFNBQXZDLEdBVE4sRUFXNUIyaEMsVUFBVSxJQUFJQyxVQUFVLENBQUNyakMsT0FBWCxFQVhjO0FBWTVCLE9BeEJlLENBMEJoQjtBQUNBOzs7QUFDQSxVQUFNNW5CLElBQUksR0FBR3FwQixTQUFTLFVBQ2pCNnBCLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTRYLE1BQVYsSUFBb0I1cEQsTUFESCxVQUNhK3BELFVBQVUsQ0FBQyxDQUFELENBRHZCLFVBQzhCL1gsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVNlgsTUFBVixJQUFvQjdwRCxNQURsRCxVQUM0RCtwRCxVQUFVLENBQUMsQ0FBRCxDQUR0RSxTQUM2RS9YLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTRYLE1BQVYsQ0FEN0UsVUFFakI1WCxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVU2WCxNQUFWLEtBQXFCQyxVQUFVLEdBQUcsQ0FBQzlwRCxNQUFKLEdBQWFBLE1BQTVDLENBRmlCLFVBRXNDK3BELFVBQVUsQ0FBQyxDQUFELENBRmhELFVBRXVEL1gsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVNFgsTUFBVixJQUFvQjVwRCxNQUYzRSxVQUVxRitwRCxVQUFVLENBQUMsQ0FBRCxDQUYvRixTQUVzRy9YLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTZYLE1BQVYsQ0FGNUg7QUFJQSxtQkFBVzdYLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTRYLE1BQVYsQ0FBWCxTQUFnQzVYLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTZYLE1BQVYsQ0FBaEMsR0FBb0QvcUQsSUFBcEQ7QUFDQSxLQWpDRDtBQWtDQSxHQTdLYTtBQStLZDBxRCxzQkEvS2MsZ0NBK0tPSCxVQS9LUCxFQStLbUJDLEtBL0tuQixFQStLMEI7QUFDakMsUUFBQWxwQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQW5mLElBRkEsR0FFTzB5RCxLQUFLLEdBQUdscEMsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUWt4QixJQUFYLEdBQWtCMUgsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUW1ILENBRnRDO0FBQUEsUUFHQWdyRCxhQUhBLEdBR2dCM29DLEVBQUUsQ0FBQzZwQyxhQUFILENBQWlCWixVQUFqQixJQUErQixDQUgvQztBQUFBLFFBSUFXLElBSkEsR0FJTzVwQyxFQUFFLENBQUMwb0MsT0FBSCxDQUFXbHlELElBQVgsRUFBaUJteUQsYUFBakIsQ0FKUDtBQUFBLFFBS0FtQixJQUxBLEdBS085cEMsRUFBRSxDQUFDK3BDLFNBQUgsQ0FBYUgsSUFBYixFQUFtQlgsVUFBbkIsRUFBK0IsQ0FBQyxDQUFDQyxLQUFqQyxDQUxQO0FBQUEsUUFNQWMsSUFOQSxHQU1PaHFDLEVBQUUsQ0FBQ2lxQyxTQUFILENBQWEsQ0FBQyxDQUFDZixLQUFmLENBTlA7QUFBQSxRQU9BZ0IsU0FQQSxHQU9ZbHFDLEVBQUUsQ0FBQ21xQyxjQUFILENBQWtCbnFDLEVBQUUsQ0FBQ2tiLFNBQXJCLEVBQWdDK3RCLFVBQWhDLEVBQTRDLENBQUMsQ0FBQ0MsS0FBOUMsQ0FQWjtBQUFBLFFBUUFrQixNQVJBLEdBUVNsQixLQUFLLEdBQUdscEMsRUFBRSxDQUFDb3RCLFlBQU4sR0FBcUJwdEIsRUFBRSxDQUFDbXRCLFNBUnRDO0FBVU4sV0FBTyxVQUFDcmhDLENBQUQsRUFBSTJDLENBQUosRUFBVTtBQUFBLFVBQ1Y0N0MsRUFBRSxHQUFHRCxNQUFNLENBQUMxOEMsSUFBUCxDQUFZc1MsRUFBWixFQUFnQmxVLENBQUMsQ0FBQ3pOLEVBQWxCLEVBQXNCLENBQXRCLENBREs7QUFBQSxVQUVWdXVDLE1BQU0sR0FBR3NkLFNBQVMsQ0FBQ3ArQyxDQUFELEVBQUkyQyxDQUFKLENBQVQsSUFBbUI0N0MsRUFGbEI7QUFBQSxVQUdWbHVELEtBQUssR0FBR2lQLFFBQVEsQ0FBQ3crQyxJQUFELENBQVIsR0FBaUJBLElBQWpCLEdBQXdCQSxJQUFJLENBQUM5OUMsQ0FBQyxDQUFDek4sRUFBSCxDQUFKLElBQWN1ckQsSUFBSSxDQUFDenRELEtBSHpDO0FBQUEsVUFJVm11RCxJQUFJLEdBQUdSLElBQUksQ0FBQ2grQyxDQUFELENBSkQ7QUFBQSxVQUtaeStDLElBQUksR0FBR1AsSUFBSSxDQUFDbCtDLENBQUQsQ0FMQztBQWdCaEI7QUFDQSxhQVRJNkosTUFBTSxDQUFDYyxZQUFQLEtBQ0YzSyxDQUFDLENBQUNxQixLQUFGLEdBQVUsQ0FBVixJQUFlbzlDLElBQUksR0FBR0YsRUFBdkIsSUFBK0J2K0MsQ0FBQyxDQUFDcUIsS0FBRixHQUFVLENBQVYsSUFBZWs5QyxFQUFFLEdBQUdFLElBRGhELENBU0osS0FOQ0EsSUFBSSxHQUFHRixFQU1SLEdBSEFFLElBQUksSUFBS0YsRUFBRSxHQUFHemQsTUFHZCxFQUFPLENBQ04sQ0FBQzBkLElBQUQsRUFBTzFkLE1BQVAsQ0FETSxFQUVOLENBQUMwZCxJQUFELEVBQU9DLElBQVAsQ0FGTSxFQUdOLENBQUNELElBQUksR0FBR251RCxLQUFSLEVBQWVvdUQsSUFBZixDQUhNLEVBSU4sQ0FBQ0QsSUFBSSxHQUFHbnVELEtBQVIsRUFBZXl3QyxNQUFmLENBSk0sQ0FBUDtBQU1BLEtBdkJEO0FBd0JBLEdBbE5hO0FBb05keFIsYUFwTmMsdUJBb05GNnNCLElBcE5FLEVBb05JO0FBQ1gsUUFBQTEwQyxLQUFLLEdBQUd3ckIsZ0dBQU8sQ0FBQ2twQixJQUFELENBQWY7QUFBQSxRQUNBakIsSUFEQSxHQUNPcDRDLGNBQWMsQ0FBQ3E1QyxJQUFELENBRHJCO0FBQUEsZ0JBRWVqQixJQUZmO0FBQUEsUUFFQ3dELElBRkQ7QUFBQSxRQUVPQyxJQUZQO0FBQUEsUUFHQTlzRCxDQUhBLEdBR0k4TixJQUFJLENBQUN3RCxHQUFMLENBQVN1N0MsSUFBSSxDQUFDN3NELENBQWQsRUFBaUI4c0QsSUFBSSxDQUFDOXNELENBQXRCLENBSEo7QUFBQSxRQUlBRyxDQUpBLEdBSUkyTixJQUFJLENBQUN3RCxHQUFMLENBQVN1N0MsSUFBSSxDQUFDMXNELENBQWQsRUFBaUIyc0QsSUFBSSxDQUFDM3NELENBQXRCLENBSko7QUFBQSxRQUtBOHVDLE1BTEEsR0FLUyxLQUFLajNCLE1BQUwsQ0FBWXdELGVBTHJCO0FBQUEsd0JBTWtCOHVDLElBQUksQ0FBQ3A1QyxPQUFMLEVBTmxCO0FBQUEsUUFNQzFTLEtBTkQsaUJBTUNBLEtBTkQ7QUFBQSxRQU1RRSxNQU5SLGlCQU1RQSxNQU5SOztBQVlOLFdBTFdzQixDQUFDLEdBQUdpdkMsTUFLUixHQUFLcjVCLEtBQUssQ0FBQyxDQUFELENBQVYsSUFDTkEsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUxVNVYsQ0FBQyxHQUFHeEIsS0FBSixHQUFZeXdDLE1BSWhCLElBRkk5dUMsQ0FBQyxHQUFHOHVDLE1BSWQsR0FBS3I1QixLQUFLLENBQUMsQ0FBRCxDQUZKLElBR05BLEtBQUssQ0FBQyxDQUFELENBQUwsR0FOVXpWLENBQUMsR0FBR3pCLE1BQUosR0FBYXV3QyxNQUd4QjtBQUlBO0FBck9hLENBQWYsRTs7QUNSQTs7OztBQUlBO0FBRWU7QUFDZDs7OztBQUlBOGQsWUFMYyx3QkFLRDtBQUNOLFFBQUExcUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdGcUssTUFBRSxDQUFDa1csT0FBSCxDQUFXLFFBQVgsQ0FKUSxLQUtYdmdCLE1BQU0sQ0FBQzBCLFVBQVAsS0FMVyxFQU1YMUIsTUFBTSxDQUFDaUMsVUFBUCxHQUFvQixRQU5ULEVBT1hqQyxNQUFNLENBQUM0QixpQkFBUCxHQUEyQixFQVBoQjtBQVNaLEdBZGE7O0FBZ0JkOzs7Ozs7QUFNQW96QyxlQXRCYywyQkFzQkU7QUFDVCxRQUFBM3FDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3hwQixJQURELEdBQ1N3cEIsRUFBRSxDQUFDNVEsR0FEWixDQUNDNVksSUFERDtBQUFBLFFBRUE0Z0MsUUFGQSxHQUVXLGFBRlg7QUFBQSxRQUdGd3pCLFVBSEUsR0FHVzVxQyxFQUFFLENBQUNQLEtBQUgsQ0FBU0csR0FBVCxDQUFhd1gsUUFBYixDQUhYO0FBY04sV0FUS3d6QixVQVNMLElBUkM1cUMsRUFBRSxDQUFDUCxLQUFILENBQVNGLEdBQVQsQ0FBYTZYLFFBQWIsRUFBdUJ3ekIsVUFBVSxHQUFHNTNDLFNBQVMsQ0FBQyxLQUFELEVBQVEsQ0FDcER4YyxJQUFJLENBQUNtSCxDQUFMLENBQU8rUixNQUFQLENBQWMsTUFBZCxFQUFzQjNCLElBQXRCLEdBQ0VxWixjQURGLEVBRG9ELEVBR3BENXdCLElBQUksQ0FBQ3NILENBQUwsQ0FBTzRSLE1BQVAsQ0FBYyxNQUFkLEVBQXNCM0IsSUFBdEIsR0FDRXFaLGNBREYsRUFIb0QsQ0FBUixDQUE3QyxDQVFELEVBQU93akMsVUFBUDtBQUNBLEdBdENhOztBQXdDZDs7Ozs7O0FBTUFDLFlBOUNjLHNCQThDSC8rQyxDQTlDRyxFQThDQTtBQUFBLFFBQ1BrVSxFQUFFLEdBQUcsSUFERTtBQUFBLFFBRVQ4cUMsSUFBSSxHQUFHOXFDLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVTZELFdBRlI7QUFJVHRPLGNBQVUsQ0FBQzQvQyxJQUFELENBSkQsR0FLWkEsSUFBSSxHQUFHQSxJQUFJLENBQUMzbkMsSUFBTCxDQUFVbkQsRUFBRSxDQUFDZ0osR0FBYixFQUFrQmxkLENBQWxCLENBTEssR0FNRixDQUFDVixRQUFRLENBQUMwL0MsSUFBRCxDQU5QLEtBT1pBLElBQUksR0FBSTlxQyxFQUFFLENBQUMycUMsYUFBSCxNQUFzQjNxQyxFQUFFLENBQUMrWCxlQUFILEtBQXVCLENBQTdDLENBQUQsR0FBb0QsRUFQL0M7QUFBQSxRQVVQblYsR0FBRyxHQUFHNVAsU0FBUyxDQUFDLEtBQUQsRUFBUWdOLEVBQUUsQ0FBQ21YLGFBQUgsR0FBbUJ2VSxHQUFuQixDQUF1QnhVLEdBQXZCLENBQTJCLFVBQUF0QyxDQUFDO0FBQUEsYUFDeERrVSxFQUFFLENBQUNnWCxhQUFILENBQWlCbHJCLENBQWpCLElBQ0NrVSxFQUFFLENBQUNpWCxjQUFILENBQWtCbnJCLENBQUMsQ0FBQ3FCLEtBQXBCLEVBQTJCLEdBQTNCLENBREQsR0FFRVQsUUFBUSxDQUFDWixDQUFDLENBQUNxQixLQUFILENBQVIsR0FBb0JyQixDQUFDLENBQUNxQixLQUFGLENBQVE0OUMsR0FBNUIsR0FBa0NqL0MsQ0FBQyxDQUFDcUIsS0FIa0I7QUFBQSxLQUE1QixDQUFSLENBVlI7QUFBQSxRQWdCUDY5QyxPQUFPLEdBQUdGLElBQUksR0FBR0EsSUFBUCxHQUFjci9DLElBQUksQ0FBQzBQLEVBaEJ0QjtBQUFBLFFBaUJQN2tCLElBQUksR0FBRyxDQUFDMHBCLEVBQUUsQ0FBQ2dYLGFBQUgsQ0FBaUJsckIsQ0FBakIsSUFBc0JrVSxFQUFFLENBQUNpWCxjQUFILENBQWtCbnJCLENBQUMsQ0FBQ3FCLEtBQXBCLEVBQTJCLEdBQTNCLENBQXRCLEdBQXdEckIsQ0FBQyxDQUFDcUIsS0FBM0QsS0FBcUU2OUMsT0FBTyxHQUFHcG9DLEdBQS9FLENBakJBO0FBbUJiLFdBQU9uWCxJQUFJLENBQUNnd0IsSUFBTCxDQUFVbmxDLElBQUksR0FBR21WLElBQUksQ0FBQzBQLEVBQXRCLENBQVA7QUFDQSxHQWxFYTs7QUFvRWQ7Ozs7Ozs7QUFPQThiLGdCQTNFYywwQkEyRUNuckIsQ0EzRUQsRUEyRUkyRCxJQTNFSixFQTJFVTtBQUN2QixXQUFPL0MsUUFBUSxDQUFDWixDQUFELENBQVIsR0FBY0EsQ0FBQyxDQUFDMkQsSUFBRCxDQUFmLEdBQXdCM0QsQ0FBQyxDQUFDMkQsSUFBSSxLQUFLLEdBQVQsR0FBZSxDQUFmLEdBQW1CLENBQXBCLENBQWhDO0FBQ0EsR0E3RWE7O0FBK0VkOzs7Ozs7QUFNQXVuQixlQXJGYyx5QkFxRkFsckIsQ0FyRkEsRUFxRkc7QUFDaEIsUUFBTWtVLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDMHlCLFlBQUgsQ0FBZ0I1bUMsQ0FBaEIsTUFDTFksUUFBUSxDQUFDWixDQUFDLENBQUNxQixLQUFILENBQVIsS0FBc0IsT0FBT3JCLENBQUMsQ0FBQ3FCLEtBQVQsSUFBa0IsT0FBT3JCLENBQUMsQ0FBQ3FCLEtBQWpELENBQUQsSUFDQ1osT0FBTyxDQUFDVCxDQUFDLENBQUNxQixLQUFILENBQVAsSUFBb0JyQixDQUFDLENBQUNxQixLQUFGLENBQVFsQixNQUFSLEtBQW1CLENBRmxDLENBQVA7QUFJQTtBQTVGYSxDQUFmLEU7Ozs7O0FDTkE7Ozs7QUFJQTtBQUlBO0FBSUE7QUFDQTtBQUVlO0FBQ2RnL0MsVUFEYyxzQkFDSDtBQUNWLFFBQU1qckMsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlHLE1BQVosT0FBdUJDLGNBQUssQ0FBQ3ZZLEtBQTdCLEVBQXNDc1gsTUFBdEMsQ0FBNkMsR0FBN0MsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JnQixjQUFLLENBQUMxWCxVQUR0QixDQUhVO0FBS1YsR0FOYTtBQVFkaXpELHNCQVJjLGdDQVFPcnJDLE9BUlAsRUFRZ0I7QUFDdkIsUUFBQUcsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDNVEsR0FERCxHQUNRNFEsRUFEUixDQUNDNVEsR0FERDtBQUFBLFFBRUEweEIsY0FGQSxHQUVpQjlnQixFQUFFLENBQUM4Z0IsY0FBSCxDQUFrQjNkLElBQWxCLENBQXVCbkQsRUFBdkIsQ0FGakI7QUFBQSxRQUdBMmYsVUFIQSxHQUdhM2YsRUFBRSxDQUFDMmYsVUFBSCxDQUFjeGMsSUFBZCxDQUFtQm5ELEVBQW5CLENBSGI7QUFBQSxRQUlBMGdCLFVBSkEsR0FJYTFnQixFQUFFLENBQUMwZ0IsVUFBSCxDQUFjdmQsSUFBZCxDQUFtQm5ELEVBQW5CLENBSmI7QUFNRDVRLE9BQUcsQ0FBQ3RWLElBUG9CLElBUTVCa21CLEVBQUUsQ0FBQ2lyQyxRQUFILEVBUjRCO0FBQUEsUUFXdkJFLGNBQWMsR0FBRy83QyxHQUFHLENBQUNHLElBQUosQ0FBU0csTUFBVCxPQUFvQkMsY0FBSyxDQUFDMVgsVUFBMUIsRUFDckJ3c0IsU0FEcUIsT0FDUDlVLGNBQUssQ0FBQzNYLFNBREMsRUFFckJtYSxJQUZxQixDQUVoQjBOLE9BRmdCLEVBR3JCbFIsSUFIcUIsQ0FHaEIsT0FIZ0IsRUFHUCxVQUFBN0MsQ0FBQztBQUFBLGFBQUlnMUIsY0FBYyxDQUFDaDFCLENBQUQsQ0FBZCxHQUFvQjQwQixVQUFVLENBQUM1MEIsQ0FBRCxDQUFsQztBQUFBLEtBSE0sQ0FYTTtBQUFBLFFBZ0J2QnMvQyxhQUFhLEdBQUdELGNBQWMsQ0FBQ3ptQyxLQUFmLEdBQXVCaFcsTUFBdkIsQ0FBOEIsR0FBOUIsRUFDcEJDLElBRG9CLENBQ2YsT0FEZSxFQUNObXlCLGNBRE0sRUFFcEIvYixLQUZvQixDQUVkLFNBRmMsRUFFSCxHQUZHLEVBR3BCQSxLQUhvQixDQUdkLGdCQUhjLEVBR0ksTUFISixDQWhCTztBQXFCN0I7QUFDQXFtQyxpQkFBYSxDQUFDMThDLE1BQWQsQ0FBcUIsR0FBckIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JneEIsVUFEaEIsQ0F0QjZCLEVBMEJ6QjNmLEVBQUUsQ0FBQ28zQixTQUFILENBQWEsTUFBYixDQTFCeUIsSUEyQjVCZ1UsYUFBYSxDQUFDMThDLE1BQWQsQ0FBcUIsR0FBckIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JxUixFQUFFLENBQUNtZ0IsVUFBSCxDQUFjaGQsSUFBZCxDQUFtQm5ELEVBQW5CLENBRGhCLENBM0I0QjtBQWlDN0IsR0F6Q2E7QUEyQ2RxckMsWUEzQ2Msc0JBMkNIeGEsZUEzQ0csRUEyQ2M7QUFDckIsUUFBQTd3QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ1VzckMsZ0JBRFYsR0FDb0N0ckMsRUFEcEMsQ0FDQ3BLLE1BREQsQ0FDVTAxQyxnQkFEVjtBQUFBLFFBQzZCbDhDLEdBRDdCLEdBQ29DNFEsRUFEcEMsQ0FDNkI1USxHQUQ3QjtBQUdOQSxPQUFHLENBQUN0VixJQUFKLEdBQVdzVixHQUFHLENBQUNHLElBQUosQ0FDVGtWLFNBRFMsT0FDSzlVLGNBQUssQ0FBQzVWLEtBRFgsRUFFVDBxQixTQUZTLE9BRUs5VSxjQUFLLENBQUM3VixJQUZYLEVBR1RxWSxJQUhTLENBR0o2TixFQUFFLENBQUNnNEIsUUFBSCxDQUFZNzBCLElBQVosQ0FBaUJuRCxFQUFqQixDQUhJLENBSmdCLEVBUzNCNVEsR0FBRyxDQUFDdFYsSUFBSixDQUFTbXJCLElBQVQsR0FBZ0JoRCxVQUFoQixHQUNFOE0sUUFERixDQUNXOGhCLGVBRFgsRUFFRTlyQixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFcEYsTUFIRixFQVQyQixFQWMzQnZRLEdBQUcsQ0FBQ3RWLElBQUosR0FBV3NWLEdBQUcsQ0FBQ3RWLElBQUosQ0FBUzRxQixLQUFULEdBQ1RoVyxNQURTLENBQ0YsTUFERSxFQUVUQyxJQUZTLENBRUosT0FGSSxFQUVLLFVBQUE3QyxDQUFDO0FBQUEsYUFBT2tVLEVBQUUsQ0FBQzBmLFNBQUgsQ0FBYXZjLElBQWIsQ0FBa0JuRCxFQUFsQixFQUFzQmxVLENBQXRCLENBQVAsVUFBbUN3L0MsZ0JBQWdCLENBQUN4L0MsQ0FBRCxDQUFoQixJQUF1QixFQUExRDtBQUFBLEtBRk4sRUFHVGlaLEtBSFMsQ0FHSCxRQUhHLEVBR08vRSxFQUFFLENBQUM5QyxLQUhWLEVBSVR5SCxLQUpTLENBSUh2VixHQUFHLENBQUN0VixJQUpELEVBS1RpckIsS0FMUyxDQUtILFNBTEcsRUFLUS9FLEVBQUUsQ0FBQ2tpQyxjQUFILENBQWtCLytCLElBQWxCLENBQXVCbkQsRUFBdkIsQ0FMUixFQU1UK0UsS0FOUyxDQU1ILGlCQU5HLEVBTWdCLFVBQUFqWixDQUFDO0FBQUEsYUFBS2tVLEVBQUUsQ0FBQ3kzQixVQUFILENBQWMzckMsQ0FBZCxJQUFtQixZQUFuQixHQUFrQyxFQUF2QztBQUFBLEtBTmpCLEVBT1Q2QyxJQVBTLENBT0osV0FQSSxFQU9TLElBUFQsQ0FkZ0I7QUFzQjNCLEdBakVhO0FBbUVkNDhDLFlBbkVjLHNCQW1FSEMsUUFuRUcsRUFtRU94OUIsY0FuRVAsRUFtRXVCO0FBQUEsUUFDN0JsMEIsSUFENkIsR0FDckIsS0FBS3NWLEdBRGdCLENBQzdCdFYsSUFENkI7QUFHcEMsV0FBTyxDQUNOLENBQUNrMEIsY0FBYyxHQUFHbDBCLElBQUksQ0FBQ21vQixVQUFMLENBQWdCbFMsU0FBUyxFQUF6QixDQUFILEdBQWtDalcsSUFBakQsRUFDRTZVLElBREYsQ0FDTyxHQURQLEVBQ1k2OEMsUUFEWixFQUVFem1DLEtBRkYsQ0FFUSxRQUZSLEVBRWtCLEtBQUs3SCxLQUZ2QixFQUdFNkgsS0FIRixDQUdRLFNBSFIsRUFHbUIsR0FIbkIsQ0FETSxDQUFQO0FBTUEsR0E1RWE7O0FBOEVkOzs7Ozs7QUFNQTBtQyxVQXBGYyxvQkFvRkwzL0MsQ0FwRkssRUFvRkY7QUFBQSxRQUNMa1UsRUFBRSxHQUFHLElBREE7QUFBQSxRQUVMMHJDLGlCQUFpQixHQUFHMXJDLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWMsWUFBVixJQUEwQnVKLEVBQUUsQ0FBQ3kzQixVQUFILENBQWMzckMsQ0FBZCxDQUZ6QztBQUlYO0FBQ0E7QUFDQSxXQUFPNC9DLGlCQUFpQixHQUFHLFVBQUEvTSxPQUFPLEVBQUk7QUFDckMsVUFBTXpXLElBQUksR0FBR2xvQixFQUFFLENBQUMyckMsY0FBSCxDQUFrQjcvQyxDQUFsQixFQUFxQjZ5QyxPQUFyQixDQUFiLENBRHFDLENBR3JDOztBQW9CQSxhQW5CQXpXLElBQUksQ0FBQzBqQixRQUFMLEdBQWdCMWpCLElBQUksQ0FBQ3ZxQixLQW1CckIsRUFoQkF1cUIsSUFBSSxDQUFDMmpCLFlBQUwsR0FBb0IsVUFBU2x1RCxDQUFULEVBQVlHLENBQVosRUFBZTtBQUNsQyxhQUFLZ3VELE1BQUwsS0FBZ0IsQ0FBaEIsS0FBc0IsS0FBS0EsTUFBTCxHQUFjLENBQXBDLENBRGtDO0FBR2xDLFlBQU0xckQsRUFBRSxHQUFHLEtBQUsyckQsRUFBTCxJQUFXLElBQUksS0FBS0MsRUFBcEIsSUFBMEJsdUQsQ0FBQyxHQUFHLEtBQUtrdUQsRUFBOUM7QUFFQSxhQUFLQyxRQUFMLENBQWNDLE1BQWQsQ0FBcUIsS0FBS0MsRUFBMUIsRUFBOEIvckQsRUFBOUIsQ0FMa0MsRUFNbEMsS0FBSzZyRCxRQUFMLENBQWNDLE1BQWQsQ0FBcUJ2dUQsQ0FBckIsRUFBd0J5QyxFQUF4QixDQU5rQyxFQVFsQyxLQUFLK3JELEVBQUwsR0FBVXh1RCxDQVJ3QixFQVNsQyxLQUFLb3VELEVBQUwsR0FBVWp1RCxDQVR3QjtBQVVsQyxPQU1ELEVBSkFvcUMsSUFBSSxDQUFDdnFCLEtBQUwsR0FBYSxVQUFTaGdCLENBQVQsRUFBWUcsQ0FBWixFQUFlO0FBQzNCLGFBQUtndUQsTUFBTCxLQUFnQixDQUFoQixHQUFvQixLQUFLRixRQUFMLENBQWNqdUQsQ0FBZCxFQUFpQkcsQ0FBakIsQ0FBcEIsR0FBMEMsS0FBSyt0RCxZQUFMLENBQWtCbHVELENBQWxCLEVBQXFCRyxDQUFyQixDQURmO0FBRTNCLE9BRUQsRUFBT29xQyxJQUFQO0FBQ0EsS0F4QnVCLEdBd0JwQmxvQixFQUFFLENBQUMyckMsY0FBSCxDQUFrQjcvQyxDQUFsQixDQXhCSjtBQXlCQSxHQW5IYTtBQXFIZHNnRCxrQkFySGMsNEJBcUhHQyxXQXJISCxFQXFIZ0JuRCxLQXJIaEIsRUFxSHVCO0FBQzlCLFFBQUFscEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNrQnFLLEVBRGxCLENBQ0NySyxNQUREO0FBQUEsUUFDUzBLLEtBRFQsR0FDa0JMLEVBRGxCLENBQ1NLLEtBRFQ7QUFBQSxRQUVBaXNDLGVBRkEsR0FFa0IzMkMsTUFBTSxDQUFDK0QsZ0JBRnpCO0FBQUEsUUFHQXFPLFNBSEEsR0FHWXBTLE1BQU0sQ0FBQ2MsWUFIbkI7QUFBQSxRQUtBMHlDLFNBTEEsR0FLWW5wQyxFQUFFLENBQUN1c0MscUJBQUgsQ0FBeUJGLFdBQXpCLEVBQXNDbkQsS0FBdEMsQ0FMWjtBQUFBLFFBTUFzRCxZQU5BLEdBTWV0RCxLQUFLLEdBQUdscEMsRUFBRSxDQUFDb3RCLFlBQU4sR0FBcUJwdEIsRUFBRSxDQUFDbXRCLFNBTjVDO0FBQUEsUUFRQXNmLE1BUkEsR0FRUyxVQUFBM2dELENBQUM7QUFBQSxhQUFJLENBQUNvOUMsS0FBSyxHQUFHbHBDLEVBQUUsQ0FBQzBzQyxLQUFOLEdBQWMxc0MsRUFBRSxDQUFDbW1DLEVBQXZCLEVBQTJCejRDLElBQTNCLENBQWdDc1MsRUFBaEMsRUFBb0NsVSxDQUFwQyxDQUFKO0FBQUEsS0FSVjtBQUFBLFFBU0E2Z0QsTUFUQSxHQVNTLFVBQUM3Z0QsQ0FBRCxFQUFJMkMsQ0FBSjtBQUFBLGFBQ2R1UixFQUFFLENBQUN3VixTQUFILENBQWExcEIsQ0FBQyxDQUFDek4sRUFBZixJQUNDOHFELFNBQVMsQ0FBQ3I5QyxDQUFELEVBQUkyQyxDQUFKLENBQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FERCxHQUVDKzlDLFlBQVksQ0FBQzkrQyxJQUFiLENBQWtCc1MsRUFBbEIsRUFBc0JsVSxDQUFDLENBQUN6TixFQUF4QixFQUE0QjJoQixFQUFFLENBQUM0VyxZQUFILENBQWdCOXFCLENBQWhCLENBQTVCLENBSGE7QUFBQSxLQVRUO0FBQUEsUUFlRmhTLElBZkUsR0FlSzh5RCxtRkFBTSxFQWZYOztBQWlCTjl5RCxRQUFJLEdBQUdpdUIsU0FBUyxHQUNmanVCLElBQUksQ0FBQzZELENBQUwsQ0FBT2d2RCxNQUFQLEVBQWU3dUQsQ0FBZixDQUFpQjJ1RCxNQUFqQixDQURlLEdBQ1kzeUQsSUFBSSxDQUFDNkQsQ0FBTCxDQUFPOHVELE1BQVAsRUFBZTN1RCxDQUFmLENBQWlCNnVELE1BQWpCLENBbkJRLEVBcUIvQkwsZUFyQitCLEtBc0JuQ3h5RCxJQUFJLEdBQUdBLElBQUksQ0FBQyt5RCxPQUFMLENBQWEsVUFBQS9nRCxDQUFDO0FBQUEsYUFBSWtVLEVBQUUsQ0FBQzRXLFlBQUgsQ0FBZ0I5cUIsQ0FBaEIsTUFBdUIsSUFBM0I7QUFBQSxLQUFkLENBdEI0QjtBQXlCcEMsUUFBTW5PLENBQUMsR0FBR3VyRCxLQUFLLEdBQUc3b0MsS0FBSyxDQUFDcUgsSUFBVCxHQUFnQnJILEtBQUssQ0FBQzFpQixDQUFyQztBQUVBLFdBQU8sVUFBQW1PLENBQUMsRUFBSTtBQUFBLFVBS1BwTixJQUxPO0FBQUEsVUFDTFosQ0FBQyxHQUFHMHVELFlBQVksQ0FBQzkrQyxJQUFiLENBQWtCc1MsRUFBbEIsRUFBc0JsVSxDQUFDLENBQUN6TixFQUF4QixDQURDO0FBQUEsVUFFUDZoQixNQUFNLEdBQUdvc0MsZUFBZSxHQUFHdHNDLEVBQUUsQ0FBQ2dhLGdCQUFILENBQW9CbHVCLENBQUMsQ0FBQ29VLE1BQXRCLENBQUgsR0FBbUNwVSxDQUFDLENBQUNvVSxNQUZ0RDtBQUFBLFVBR1A0c0MsRUFBRSxHQUFHLENBSEU7QUFBQSxVQUlQekMsRUFBRSxHQUFHLENBSkU7O0FBT1gsVUFBSXJxQyxFQUFFLENBQUN3eUIsVUFBSCxDQUFjMW1DLENBQWQsQ0FBSixFQUFzQjtBQUNyQixZQUFNN1IsT0FBTyxHQUFHMGIsTUFBTSxDQUFDdFEsWUFBUCxDQUFvQnlHLENBQUMsQ0FBQ3pOLEVBQXRCLENBQWhCO0FBRUlwRSxlQUhpQixHQUlwQnlFLElBQUksR0FBR3NoQixFQUFFLENBQUMrc0MsZUFBSCxDQUFtQjdzQyxNQUFuQixFQUEyQnZpQixDQUEzQixFQUE4QkcsQ0FBOUIsRUFBaUM3RCxPQUFqQyxDQUphLElBTWhCK2xCLEVBQUUsQ0FBQ3kzQixVQUFILENBQWMzckMsQ0FBZCxDQU5nQixLQU9uQm9VLE1BQU0sR0FBR0YsRUFBRSxDQUFDMmIsbUJBQUgsQ0FBdUJ6YixNQUF2QixDQVBVLEdBVXBCeGhCLElBQUksR0FBRzVFLElBQUksQ0FBQ2t6RCxLQUFMLENBQVdodEMsRUFBRSxDQUFDeXJDLFFBQUgsQ0FBWTMvQyxDQUFaLENBQVgsRUFBMkJvVSxNQUEzQixDQVZhO0FBYXJCLE9BYkQsTUFjS0EsTUFBTSxDQUFDLENBQUQsQ0FkWCxLQWVFNHNDLEVBQUUsR0FBR252RCxDQUFDLENBQUN1aUIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVdmlCLENBQVgsQ0FmUixFQWdCRTBzRCxFQUFFLEdBQUd2c0QsQ0FBQyxDQUFDb2lCLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVS9TLEtBQVgsQ0FoQlIsR0FtQkN6TyxJQUFJLEdBQUdxcEIsU0FBUyxVQUFRc2lDLEVBQVIsU0FBY3lDLEVBQWQsVUFBMEJBLEVBQTFCLFNBQWdDekMsRUFuQmpEOztBQXNCQSxhQUFPM3JELElBQUksSUFBSSxPQUFmO0FBQ0EsS0E5QkQ7QUErQkEsR0EvS2E7QUFpTGQ2dEQsdUJBakxjLGlDQWlMUUYsV0FqTFIsRUFpTHFCWSxVQWpMckIsRUFpTGlDO0FBQUU7QUFDMUMsUUFBQWp0QyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQXV6QyxLQUZBLEdBRVEsQ0FBQyxDQUFDK0QsVUFGVjtBQUFBLFFBR0F0dkQsQ0FIQSxHQUdJcWlCLEVBQUUsQ0FBQytwQyxTQUFILENBQWEsQ0FBYixFQUFnQnNDLFdBQWhCLEVBQTZCbkQsS0FBN0IsQ0FISjtBQUFBLFFBSUFwckQsQ0FKQSxHQUlJa2lCLEVBQUUsQ0FBQ2lxQyxTQUFILENBQWFmLEtBQWIsQ0FKSjtBQUFBLFFBS0FnRSxVQUxBLEdBS2FsdEMsRUFBRSxDQUFDbXFDLGNBQUgsQ0FBa0JucUMsRUFBRSxDQUFDd3lCLFVBQXJCLEVBQWlDNlosV0FBakMsRUFBOENuRCxLQUE5QyxDQUxiO0FBQUEsUUFNQWtCLE1BTkEsR0FNU2xCLEtBQUssR0FBR2xwQyxFQUFFLENBQUNvdEIsWUFBTixHQUFxQnB0QixFQUFFLENBQUNtdEIsU0FOdEM7QUFRTixXQUFPLFVBQUNyaEMsQ0FBRCxFQUFJMkMsQ0FBSixFQUFVO0FBQUEsVUFDVjQ3QyxFQUFFLEdBQUdELE1BQU0sQ0FBQzE4QyxJQUFQLENBQVlzUyxFQUFaLEVBQWdCbFUsQ0FBQyxDQUFDek4sRUFBbEIsRUFBc0IsQ0FBdEIsQ0FESztBQUFBLFVBRVZ1dUMsTUFBTSxHQUFHc2dCLFVBQVUsQ0FBQ3BoRCxDQUFELEVBQUkyQyxDQUFKLENBQVYsSUFBb0I0N0MsRUFGbkI7QUFBQSxVQUdWQyxJQUFJLEdBQUczc0QsQ0FBQyxDQUFDbU8sQ0FBRCxDQUhFO0FBQUEsVUFJWnkrQyxJQUFJLEdBQUd6c0QsQ0FBQyxDQUFDZ08sQ0FBRCxDQUpJO0FBT1o2SixZQUFNLENBQUNjLFlBQVAsS0FDRjNLLENBQUMsQ0FBQ3FCLEtBQUYsR0FBVSxDQUFWLElBQWVvOUMsSUFBSSxHQUFHRixFQUF2QixJQUErQnYrQyxDQUFDLENBQUNxQixLQUFGLEdBQVUsQ0FBVixJQUFlazlDLEVBQUUsR0FBR0UsSUFEaEQsQ0FQWSxLQVVmQSxJQUFJLEdBQUdGLEVBVlE7QUFhaEI7QUFDQSxVQUFNMXNDLEtBQUssR0FBRyxDQUFDMnNDLElBQUQsRUFBT0MsSUFBSSxJQUFJRixFQUFFLEdBQUd6ZCxNQUFULENBQVgsQ0FBZDtBQUVBLGFBQU8sQ0FDTmp2QixLQURNLEVBRU5BLEtBRk0sRUFFQztBQUNQQSxXQUhNLEVBSU5BLEtBSk0sQ0FBUDtBQU1BLEtBdEJEO0FBdUJBLEdBak5hO0FBbU5kb3ZDLGlCQW5OYywyQkFtTkVqaEQsQ0FuTkYsRUFtTktuTyxDQW5OTCxFQW1OUUcsQ0FuTlIsRUFtTldxdkQsUUFuTlgsRUFtTnFCO0FBUzlCLFFBQUFDLEVBQUU7QUFBQSxRQUNGQyxFQURFO0FBQUEsUUFFRmwvQyxJQUZFO0FBQUEsUUFHRm0vQyxNQUhFO0FBQUEsUUFSQXR0QyxFQVFBLEdBUkssSUFRTDtBQUFBLFFBUENySyxNQU9ELEdBUFdxSyxFQU9YLENBUENySyxNQU9EO0FBQUEsUUFOQW9TLFNBTUEsR0FOWXBTLE1BQU0sQ0FBQ2MsWUFNbkI7QUFBQSxRQUxBcVQsWUFLQSxHQUxlOUosRUFBRSxDQUFDOEosWUFBSCxFQUtmO0FBQUEsUUFKQXVpQixPQUlBLEdBSlVyc0IsRUFBRSxDQUFDMEosYUFBSCxLQUFxQixFQUFyQixHQUEyQixDQUlyQztBQUFBLFFBSEF6dkIsT0FHQSxHQUhpQixFQUdqQjtBQUFBLFFBRkFzekQsU0FFQSxHQUZZLEtBRVo7QUFBQSxRQU1BQyxlQU5BLEdBTWtCLFVBQUNDLE9BQUQsRUFBVUMsYUFBVixFQUE0QjtBQUNuRCxXQUFLLElBQVdDLEdBQVgsRUFBSWwvQyxDQUFDLEdBQUcsQ0FBYixFQUFzQmsvQyxHQUFHLEdBQUdELGFBQWEsQ0FBQ2ovQyxDQUFELENBQXpDLEVBQStDQSxDQUFDLEVBQWhELEVBQ0MsSUFBSWsvQyxHQUFHLENBQUN4NkMsS0FBSixHQUFZczZDLE9BQVosSUFBdUJBLE9BQU8sSUFBSUUsR0FBRyxDQUFDdjZDLEdBQTFDLEVBQ0MsT0FBT3U2QyxHQUFHLENBQUM1b0MsS0FBWDs7QUFJRjtBQUNBLEtBZEs7O0FBZ0JOO0FBQ0EsUUFBSXpaLFNBQVMsQ0FBQzZoRCxRQUFELENBQWIsRUFBeUI7QUFDeEIsVUFBTVMsUUFBUSxHQUFHLFVBQUMzaUQsQ0FBRCxFQUFnQlYsR0FBaEI7QUFBQSxlQUNoQmMsV0FBVyxDQUFDSixDQUFELENBQVgsR0FBaUJWLEdBQWpCLEdBQXdCdWYsWUFBWSxHQUFHdFUsU0FBUyxDQUFDOUgsSUFBVixDQUFlc1MsRUFBZixFQUFtQi9VLENBQW5CLENBQUgsR0FBMkJBLENBRC9DO0FBQUEsT0FBakI7O0FBSUEsV0FBSyxJQUFXMGlELEdBQVgsRUFBSWwvQyxDQUFDLEdBQUcsQ0FBYixFQUFzQmsvQyxHQUFHLEdBQUdSLFFBQVEsQ0FBQzErQyxDQUFELENBQXBDLEVBQTBDQSxDQUFDLEVBQTNDLEVBQStDO0FBQUEsWUFDeEMwRSxLQUFLLEdBQUd5NkMsUUFBUSxDQUFDRCxHQUFHLENBQUN4NkMsS0FBTCxFQUFZckgsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFLbk8sQ0FBakIsQ0FEd0I7QUFBQSxZQUV4Q3lWLEdBQUcsR0FBR3c2QyxRQUFRLENBQUNELEdBQUcsQ0FBQ3Y2QyxHQUFMLEVBQVV0SCxDQUFDLENBQUNBLENBQUMsQ0FBQ0csTUFBRixHQUFXLENBQVosQ0FBRCxDQUFnQnRPLENBQTFCLENBRjBCO0FBQUEsWUFHeENvbkIsS0FBSyxHQUFHNG9DLEdBQUcsQ0FBQzVvQyxLQUFKLElBQWE7QUFBQ3dvQyxtQkFBUyxFQUFUQTtBQUFELFNBSG1CO0FBSzlDdHpELGVBQU8sQ0FBQ3dVLENBQUQsQ0FBUCxHQUFhO0FBQUMwRSxlQUFLLEVBQUxBLEtBQUQ7QUFBUUMsYUFBRyxFQUFIQSxHQUFSO0FBQWEyUixlQUFLLEVBQUxBO0FBQWIsU0FMaUM7QUFNOUM7QUFDRCxLQXRDaUMsQ0F3Q2xDOzs7QUF4Q2tDLFFBeUM1QjBuQyxNQUFNLEdBQUcxa0MsU0FBUyxHQUFHLFVBQUE4bEMsRUFBRTtBQUFBLGFBQUkvdkQsQ0FBQyxDQUFDK3ZELEVBQUUsQ0FBQzFnRCxLQUFKLENBQUw7QUFBQSxLQUFMLEdBQXVCLFVBQUEwZ0QsRUFBRTtBQUFBLGFBQUlsd0QsQ0FBQyxDQUFDa3dELEVBQUUsQ0FBQ2x3RCxDQUFKLENBQUw7QUFBQSxLQXpDZjtBQUFBLFFBMEM1Qmd2RCxNQUFNLEdBQUc1a0MsU0FBUyxHQUFHLFVBQUE4bEMsRUFBRTtBQUFBLGFBQUlsd0QsQ0FBQyxDQUFDa3dELEVBQUUsQ0FBQ2x3RCxDQUFKLENBQUw7QUFBQSxLQUFMLEdBQW1CLFVBQUFrd0QsRUFBRTtBQUFBLGFBQUkvdkQsQ0FBQyxDQUFDK3ZELEVBQUUsQ0FBQzFnRCxLQUFKLENBQUw7QUFBQSxLQTFDWDtBQUFBLFFBNkM1QjJnRCxTQUFTLEdBQUcsVUFBQWxjLE1BQU07QUFBQSxtQkFBUUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FBUixTQUF3QkEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FBeEIsU0FBd0NBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLENBQXhDLFNBQXdEQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUF4RDtBQUFBLEtBN0NVO0FBQUEsUUErQzVCbWMsV0FBVyxHQUFHamtDLFlBQVksR0FBRyxVQUFDa2tDLEVBQUQsRUFBS0MsRUFBTCxFQUFTcjZCLENBQVQsRUFBWXM2QixjQUFaLEVBQStCO0FBQUEsVUFDM0RwQixFQUFFLEdBQUdrQixFQUFFLENBQUNyd0QsQ0FBSCxDQUFLMG5DLE9BQUwsRUFEc0Q7QUFBQSxVQUUzRDhvQixLQUFLLEdBQUdGLEVBQUUsQ0FBQ3R3RCxDQUFILEdBQU9xd0QsRUFBRSxDQUFDcndELENBRnlDO0FBQUEsVUFHM0R5d0QsR0FBRyxHQUFHLElBQUlsaUQsSUFBSixDQUFTNGdELEVBQUUsR0FBR3FCLEtBQUssR0FBR3Y2QixDQUF0QixDQUhxRDtBQUFBLFVBSTNEeTZCLEdBQUcsR0FBRyxJQUFJbmlELElBQUosQ0FBUzRnRCxFQUFFLEdBQUdxQixLQUFLLElBQUl2NkIsQ0FBQyxHQUFHczZCLGNBQVIsQ0FBbkIsQ0FKcUQ7QUFBQSxVQU0zRHRjLE1BQU0sR0FBRzdwQixTQUFTLEdBQ3ZCLENBQUMsQ0FBQ2pxQixDQUFDLENBQUN1dkQsRUFBRSxDQUFDejVCLENBQUQsQ0FBSCxDQUFGLEVBQVdqMkIsQ0FBQyxDQUFDeXdELEdBQUQsQ0FBWixDQUFELEVBQXFCLENBQUN0d0QsQ0FBQyxDQUFDdXZELEVBQUUsQ0FBQ3o1QixDQUFDLEdBQUd6bEIsSUFBTCxDQUFILENBQUYsRUFBa0J4USxDQUFDLENBQUMwd0QsR0FBRCxDQUFuQixDQUFyQixDQUR1QixHQUV2QixDQUFDLENBQUMxd0QsQ0FBQyxDQUFDeXdELEdBQUQsQ0FBRixFQUFTdHdELENBQUMsQ0FBQ3V2RCxFQUFFLENBQUN6NUIsQ0FBRCxDQUFILENBQVYsQ0FBRCxFQUFxQixDQUFDajJCLENBQUMsQ0FBQzB3RCxHQUFELENBQUYsRUFBU3Z3RCxDQUFDLENBQUN1dkQsRUFBRSxDQUFDejVCLENBQUMsR0FBR3psQixJQUFMLENBQUgsQ0FBVixDQUFyQixDQVJnRTtBQVVqRSxhQUFPMi9DLFNBQVMsQ0FBQ2xjLE1BQUQsQ0FBaEI7QUFDQSxLQVgrQixHQVc1QixVQUFDb2MsRUFBRCxFQUFLQyxFQUFMLEVBQVNyNkIsQ0FBVCxFQUFZMDZCLFNBQVosRUFBMEI7QUFDN0IsVUFBTTFjLE1BQU0sR0FBRzdwQixTQUFTLEdBQ3ZCLENBQUMsQ0FBQ2pxQixDQUFDLENBQUN1dkQsRUFBRSxDQUFDejVCLENBQUQsQ0FBSCxLQUFGLEVBQWlCajJCLENBQUMsQ0FBQ3l2RCxFQUFFLENBQUN4NUIsQ0FBRCxDQUFILENBQWxCLENBQUQsRUFBNkIsQ0FBQzkxQixDQUFDLENBQUN1dkQsRUFBRSxDQUFDejVCLENBQUMsR0FBRzA2QixTQUFMLENBQUgsS0FBRixFQUE2QjN3RCxDQUFDLENBQUN5dkQsRUFBRSxDQUFDeDVCLENBQUMsR0FBRzA2QixTQUFMLENBQUgsQ0FBOUIsQ0FBN0IsQ0FEdUIsR0FFdkIsQ0FBQyxDQUFDM3dELENBQUMsQ0FBQ3l2RCxFQUFFLENBQUN4NUIsQ0FBRCxDQUFILEtBQUYsRUFBaUI5MUIsQ0FBQyxDQUFDdXZELEVBQUUsQ0FBQ3o1QixDQUFELENBQUgsQ0FBbEIsQ0FBRCxFQUE2QixDQUFDajJCLENBQUMsQ0FBQ3l2RCxFQUFFLENBQUN4NUIsQ0FBQyxHQUFHMDZCLFNBQUwsQ0FBSCxLQUFGLEVBQTZCeHdELENBQUMsQ0FBQ3V2RCxFQUFFLENBQUN6NUIsQ0FBQyxHQUFHMDZCLFNBQUwsQ0FBSCxDQUE5QixDQUE3QixDQUZEO0FBSUEsYUFBT1IsU0FBUyxDQUFDbGMsTUFBRCxDQUFoQjtBQUNBLEtBaEVpQztBQUFBLFFBbUU5Qmx6QyxJQUFJLEdBQUcsRUFuRXVCOztBQXFFbEMsU0FBSyxJQUFXeVQsSUFBWCxFQUFJMUQsRUFBQyxHQUFHLENBQWIsRUFBdUIwRCxJQUFJLEdBQUdyRyxDQUFDLENBQUMyQyxFQUFELENBQS9CLEVBQXFDQSxFQUFDLEVBQXRDLEVBQTBDO0FBQUEsVUFDbkM4L0MsUUFBUSxHQUFHemlELENBQUMsQ0FBQzJDLEVBQUMsR0FBRyxDQUFMLENBRHVCO0FBQUEsVUFFbkMrL0MsV0FBVyxHQUFHRCxRQUFRLElBQUl2akQsT0FBTyxDQUFDdWpELFFBQVEsQ0FBQ3BoRCxLQUFWLENBRkU7QUFBQSxVQUdyQzRYLEtBQUssR0FBR3lvQyxlQUFlLENBQUNyN0MsSUFBSSxDQUFDeFUsQ0FBTixFQUFTMUQsT0FBVCxDQUhjO0FBS3pDO0FBQ0EsVUFBSytRLE9BQU8sQ0FBQ21ILElBQUksQ0FBQ2hGLEtBQU4sQ0FBWixFQUlBO0FBQ0EsWUFBSTlCLFdBQVcsQ0FBQ3BSLE9BQUQsQ0FBWCxJQUF3QixDQUFDOHFCLEtBQXpCLElBQWtDLENBQUN5cEMsV0FBdkMsRUFDQzl2RCxJQUFJLFVBQU8rUCxFQUFDLElBQUkrL0MsV0FBTCxHQUFtQixHQUFuQixHQUF5QixHQUFoQyxJQUFzQy9CLE1BQU0sQ0FBQ3Q2QyxJQUFELENBQTVDLFNBQXNEdzZDLE1BQU0sQ0FBQ3g2QyxJQUFELENBRGpFLE1BRU8sSUFBSXE4QyxXQUFKLEVBQWlCO0FBQ3ZCLGNBQUk7QUFDSHpwQyxpQkFBSyxHQUFHQSxLQUFLLENBQUN3b0MsU0FBTixDQUFnQmovQyxLQUFoQixDQUFzQixHQUF0QixDQURMO0FBRUgsV0FGRCxDQUVFLE9BQU84QyxDQUFQLEVBQVU7QUFDWDJULGlCQUFLLEdBQUd3b0MsU0FBUyxDQUFDai9DLEtBQVYsQ0FBZ0IsR0FBaEIsQ0FERztBQUVYLFdBTHNCLENBT3ZCOzs7QUFDQTgrQyxZQUFFLEdBQUdwdEMsRUFBRSxDQUFDd3NCLFFBQUgsQ0FBWStoQixRQUFRLENBQUM1d0QsQ0FBVCxHQUFhMHVDLE9BQXpCLEVBQWtDbDZCLElBQUksQ0FBQ3hVLENBQUwsR0FBUzB1QyxPQUEzQyxFQUFvRHZpQixZQUFwRCxDQVJrQixFQVN2QnVqQyxFQUFFLEdBQUdydEMsRUFBRSxDQUFDd3NCLFFBQUgsQ0FBWStoQixRQUFRLENBQUNwaEQsS0FBckIsRUFBNEJnRixJQUFJLENBQUNoRixLQUFqQyxDQVRrQjtBQUFBLGNBV2pCcVksRUFBRSxHQUFHN25CLENBQUMsQ0FBQ3dVLElBQUksQ0FBQ3hVLENBQU4sQ0FBRCxHQUFZQSxDQUFDLENBQUM0d0QsUUFBUSxDQUFDNXdELENBQVYsQ0FYRDtBQUFBLGNBWWpCcVEsRUFBRSxHQUFHbFEsQ0FBQyxDQUFDcVUsSUFBSSxDQUFDaEYsS0FBTixDQUFELEdBQWdCclAsQ0FBQyxDQUFDeXdELFFBQVEsQ0FBQ3BoRCxLQUFWLENBWkw7QUFBQSxjQWFqQnNoRCxFQUFFLEdBQUdoakQsSUFBSSxDQUFDZ3dCLElBQUwsQ0FBVWh3QixJQUFJLENBQUNpd0IsR0FBTCxDQUFTbFcsRUFBVCxFQUFhLENBQWIsSUFBa0IvWixJQUFJLENBQUNpd0IsR0FBTCxDQUFTMXRCLEVBQVQsRUFBYSxDQUFiLENBQTVCLENBYlk7QUFldkJHLGNBQUksR0FBRzRXLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVzBwQyxFQWZLLEVBZ0J2Qm5CLE1BQU0sR0FBR24vQyxJQUFJLEdBQUc0VyxLQUFLLENBQUMsQ0FBRCxDQWhCRTs7QUFrQnZCLGVBQUssSUFBSStPLEVBQUMsR0FBRzNsQixJQUFiLEVBQW1CMmxCLEVBQUMsSUFBSSxDQUF4QixFQUEyQkEsRUFBQyxJQUFJdzVCLE1BQWhDLEVBQ0M1dUQsSUFBSSxJQUFJcXZELFdBQVcsQ0FBQ1EsUUFBRCxFQUFXcDhDLElBQVgsRUFBaUIyaEIsRUFBakIsRUFBb0IzbEIsSUFBcEIsQ0FEcEIsRUFJSzJsQixFQUFDLEdBQUd3NUIsTUFBSixJQUFjLENBSm5CLEtBS0U1dUQsSUFBSSxJQUFJcXZELFdBQVcsQ0FBQ1EsUUFBRCxFQUFXcDhDLElBQVgsRUFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FMckI7QUFRQTtBQUNEOztBQUVELFdBQU96VCxJQUFQO0FBQ0EsR0FuVWE7QUFxVWRnd0Qsb0JBclVjLGdDQXFVTztBQUNkLFFBQUExdUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUM2Q3FLLEVBRDdDLENBQ0NySyxNQUREO0FBQUEsUUFDaUJ4WCxVQURqQixHQUM2QzZoQixFQUQ3QyxDQUNTOWpCLEtBRFQsQ0FDaUJpQyxVQURqQjtBQUFBLFFBQ29DcWpELElBRHBDLEdBQzZDeGhDLEVBRDdDLENBQzhCNVEsR0FEOUIsQ0FDb0NveUMsSUFEcEM7QUFHTnhoQyxNQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCeFMsT0FBaEIsQ0FBd0IsVUFBQXZCLENBQUMsRUFBSTtBQUM1QixVQUFNek4sRUFBRSxHQUFNRixVQUFOLHFCQUFnQzZoQixFQUFFLENBQUNtYix1QkFBSCxDQUEyQnJ2QixDQUFDLENBQUN6TixFQUE3QixDQUF4Qzs7QUFFQSxVQUFJMmhCLEVBQUUsQ0FBQ2d5QixVQUFILENBQWNsbUMsQ0FBZCxLQUFvQjAxQyxJQUFJLENBQUM5eEMsTUFBTCxPQUFnQnJSLEVBQWhCLEVBQXNCekYsS0FBdEIsRUFBeEIsRUFBdUQ7QUFDaEQsWUFBQXNrQixLQUFLLEdBQUc4QyxFQUFFLENBQUM5QyxLQUFILENBQVNwUixDQUFULENBQVI7QUFBQSxvQ0FLRjZKLE1BQU0sQ0FBQ29ELG1CQUxMO0FBQUEsMkRBRUxwYixDQUZLO0FBQUEsWUFFTEEsQ0FGSyx1Q0FFRCxDQUFDLENBQUQsRUFBSSxDQUFKLENBRkM7QUFBQSwyREFHTEcsQ0FISztBQUFBLFlBR0xBLENBSEssdUNBR0QsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUhDO0FBQUEsMkRBSUw2d0QsS0FKSztBQUFBLFlBSUxBLEtBSkssdUNBSUcsQ0FBQyxDQUFDLENBQUQsRUFBSXp4QyxLQUFKLEVBQVcsQ0FBWCxDQUFELEVBQWdCLENBQUMsQ0FBRCxFQUFJQSxLQUFKLEVBQVcsQ0FBWCxDQUFoQixDQUpIO0FBQUEsWUFPQTB4QyxjQVBBLEdBT2lCcE4sSUFBSSxDQUFDOXlDLE1BQUwsQ0FBWSxnQkFBWixFQUNyQkMsSUFEcUIsQ0FDaEIsSUFEZ0IsT0FDUHRRLEVBRE8sRUFFckJzUSxJQUZxQixDQUVoQixJQUZnQixFQUVWaFIsQ0FBQyxDQUFDLENBQUQsQ0FGUyxFQUdyQmdSLElBSHFCLENBR2hCLElBSGdCLEVBR1ZoUixDQUFDLENBQUMsQ0FBRCxDQUhTLEVBSXJCZ1IsSUFKcUIsQ0FJaEIsSUFKZ0IsRUFJVjdRLENBQUMsQ0FBQyxDQUFELENBSlMsRUFLckI2USxJQUxxQixDQUtoQixJQUxnQixFQUtWN1EsQ0FBQyxDQUFDLENBQUQsQ0FMUyxDQVBqQjtBQWNONndELGFBQUssQ0FBQ3RoRCxPQUFOLENBQWMsVUFBQXBDLENBQUMsRUFBSTtBQUNsQixjQUFNNGpELFNBQVMsR0FBRzNqRCxVQUFVLENBQUNELENBQUMsQ0FBQyxDQUFELENBQUYsQ0FBVixHQUFtQkEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFLa1ksSUFBTCxDQUFVbkQsRUFBRSxDQUFDZ0osR0FBYixFQUFrQmxkLENBQUMsQ0FBQ3pOLEVBQXBCLENBQW5CLEdBQTZDNE0sQ0FBQyxDQUFDLENBQUQsQ0FBaEU7QUFFQTJqRCx3QkFBYyxDQUFDbGdELE1BQWYsQ0FBc0IsTUFBdEIsRUFDRUMsSUFERixDQUNPLFFBRFAsRUFDaUIxRCxDQUFDLENBQUMsQ0FBRCxDQURsQixFQUVFMEQsSUFGRixDQUVPLFlBRlAsRUFFcUJrZ0QsU0FBUyxJQUFJM3hDLEtBRmxDLEVBR0V2TyxJQUhGLENBR08sY0FIUCxFQUd1QjFELENBQUMsQ0FBQyxDQUFELENBSHhCLENBSGtCO0FBT2xCLFNBUEQsQ0Fmc0Q7QUF1QnREO0FBQ0QsS0EzQkQsQ0FKb0I7QUFnQ3BCLEdBcldhO0FBdVdkNmpELGlCQXZXYywyQkF1V0VoakQsQ0F2V0YsRUF1V0s7QUFDbEIsUUFBTWtVLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDckssTUFBSCxDQUFVb0QsbUJBQVYsYUFDRWlILEVBQUUsQ0FBQzlqQixLQUFILENBQVNpQyxVQURYLHFCQUNxQzZoQixFQUFFLENBQUNtYix1QkFBSCxDQUEyQnJ2QixDQUFDLENBQUN6TixFQUE3QixDQURyQyxTQUVOMmhCLEVBQUUsQ0FBQzlDLEtBQUgsQ0FBU3BSLENBQVQsQ0FGRDtBQUdBLEdBN1dhO0FBK1dkaWpELFlBL1djLHNCQStXSGxlLGVBL1dHLEVBK1djO0FBQ3JCLFFBQUE3d0IsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN1QnFLLEVBRHZCLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDdUI4akIsRUFEdkIsQ0FDUzlqQixLQURUO0FBQUEsUUFDZ0JrVCxHQURoQixHQUN1QjRRLEVBRHZCLENBQ2dCNVEsR0FEaEI7QUFHTnVHLFVBQU0sQ0FBQ29ELG1CQUFQLElBQThCaUgsRUFBRSxDQUFDMHVDLGtCQUFILEVBSkgsRUFNM0J0L0MsR0FBRyxDQUFDOVksSUFBSixHQUFXOFksR0FBRyxDQUFDRyxJQUFKLENBQVNrVixTQUFULE9BQXVCOVUsY0FBSyxDQUFDcFosS0FBN0IsRUFDVGt1QixTQURTLE9BQ0s5VSxjQUFLLENBQUNyWixJQURYLEVBRVQ2YixJQUZTLENBRUo2TixFQUFFLENBQUNnNEIsUUFBSCxDQUFZNzBCLElBQVosQ0FBaUJuRCxFQUFqQixDQUZJLENBTmdCLEVBVTNCNVEsR0FBRyxDQUFDOVksSUFBSixDQUFTMnVCLElBQVQsR0FBZ0JoRCxVQUFoQixHQUNFOE0sUUFERixDQUNXOGhCLGVBRFgsRUFFRTlyQixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFcEYsTUFIRixFQVYyQixFQWUzQnZRLEdBQUcsQ0FBQzlZLElBQUosR0FBVzhZLEdBQUcsQ0FBQzlZLElBQUosQ0FBU291QixLQUFULEdBQWlCaFcsTUFBakIsQ0FBd0IsTUFBeEIsRUFDVEMsSUFEUyxDQUNKLE9BREksRUFDS3FSLEVBQUUsQ0FBQ2tnQixTQUFILENBQWEvYyxJQUFiLENBQWtCbkQsRUFBbEIsQ0FETCxFQUVUK0UsS0FGUyxDQUVILE1BRkcsRUFFSy9FLEVBQUUsQ0FBQzh1QyxlQUFILENBQW1CM3JDLElBQW5CLENBQXdCbkQsRUFBeEIsQ0FGTCxFQUdUK0UsS0FIUyxDQUdILFNBSEcsRUFHUSxZQUFXO0FBRTVCLGFBREE3b0IsS0FBSyxDQUFDcUQsY0FBTixHQUF1QjZrQixpR0FBUSxDQUFDLElBQUQsQ0FBUixDQUFlVyxLQUFmLENBQXFCLFNBQXJCLENBQ3ZCLEVBQU8sR0FBUDtBQUNBLEtBTlMsRUFPVEosS0FQUyxDQU9IdlYsR0FBRyxDQUFDOVksSUFQRCxDQWZnQixFQXdCM0I4WSxHQUFHLENBQUM5WSxJQUFKLENBQ0V5dUIsS0FERixDQUNRLFNBRFIsRUFDbUI3b0IsS0FBSyxDQUFDcUQsY0FEekIsQ0F4QjJCO0FBMEIzQixHQXpZYTtBQTJZZHl2RCxZQTNZYyxzQkEyWUhDLFFBM1lHLEVBMllPamhDLGNBM1lQLEVBMll1QjtBQUM5QixRQUFBaE8sRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDemdCLGNBREQsR0FDbUJ5Z0IsRUFBRSxDQUFDOWpCLEtBRHRCLENBQ0NxRCxjQUREO0FBR04sV0FBTyxDQUNOLENBQUN5dUIsY0FBYyxHQUFHaE8sRUFBRSxDQUFDNVEsR0FBSCxDQUFPOVksSUFBUCxDQUFZMnJCLFVBQVosQ0FBdUJsUyxTQUFTLEVBQWhDLENBQUgsR0FBeUNpUSxFQUFFLENBQUM1USxHQUFILENBQU85WSxJQUEvRCxFQUNFcVksSUFERixDQUNPLEdBRFAsRUFDWXNnRCxRQURaLEVBRUVscUMsS0FGRixDQUVRLE1BRlIsRUFFZ0IvRSxFQUFFLENBQUM4dUMsZUFBSCxDQUFtQjNyQyxJQUFuQixDQUF3Qm5ELEVBQXhCLENBRmhCLEVBR0UrRSxLQUhGLENBR1EsU0FIUixFQUdtQixVQUFBalosQ0FBQztBQUFBLGNBQVdrVSxFQUFFLENBQUM4VyxlQUFILENBQW1CaHJCLENBQW5CLElBQXdCdk0sY0FBYyxHQUFHLElBQXpDLEdBQWdEQSxjQUEzRDtBQUFBLEtBSHBCLENBRE0sQ0FBUDtBQU1BLEdBclphOztBQXVaZDs7Ozs7OztBQU9BMnZELGtCQTlaYyw0QkE4WkdDLFdBOVpILEVBOFpnQmpHLEtBOVpoQixFQThadUI7QUFDOUIsUUFBQWxwQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQTIyQyxlQUZBLEdBRWtCMzJDLE1BQU0sQ0FBQytELGdCQUZ6QjtBQUFBLFFBR0FxTyxTQUhBLEdBR1lwUyxNQUFNLENBQUNjLFlBSG5CO0FBQUEsUUFLQTB5QyxTQUxBLEdBS1lucEMsRUFBRSxDQUFDb3ZDLHFCQUFILENBQXlCRCxXQUF6QixFQUFzQ2pHLEtBQXRDLENBTFo7QUFBQSxRQU1Bc0QsWUFOQSxHQU1ldEQsS0FBSyxHQUFHbHBDLEVBQUUsQ0FBQ290QixZQUFOLEdBQXFCcHRCLEVBQUUsQ0FBQ210QixTQU41QztBQUFBLFFBUUFzZixNQVJBLEdBUVMsVUFBQTNnRCxDQUFDO0FBQUEsYUFBSSxDQUFDbzlDLEtBQUssR0FBR2xwQyxFQUFFLENBQUMwc0MsS0FBTixHQUFjMXNDLEVBQUUsQ0FBQ21tQyxFQUF2QixFQUEyQno0QyxJQUEzQixDQUFnQ3NTLEVBQWhDLEVBQW9DbFUsQ0FBcEMsQ0FBSjtBQUFBLEtBUlY7QUFBQSxRQVNBdWpELE1BVEEsR0FTUyxVQUFDdmpELENBQUQsRUFBSTJDLENBQUo7QUFBQSxhQUFXdVIsRUFBRSxDQUFDd1YsU0FBSCxDQUFhMXBCLENBQUMsQ0FBQ3pOLEVBQWYsSUFDekI4cUQsU0FBUyxDQUFDcjlDLENBQUQsRUFBSTJDLENBQUosQ0FBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUR5QixHQUV6Qis5QyxZQUFZLENBQUM5K0MsSUFBYixDQUFrQnNTLEVBQWxCLEVBQXNCbFUsQ0FBQyxDQUFDek4sRUFBeEIsRUFDQzJoQixFQUFFLENBQUM4VyxlQUFILENBQW1CaHJCLENBQW5CLElBQ0NrVSxFQUFFLENBQUMrVyxnQkFBSCxDQUFvQmpyQixDQUFwQixFQUF1QixNQUF2QixDQURELEdBQ2tDLENBRm5DLENBRmM7QUFBQSxLQVRUO0FBQUEsUUFlQXdqRCxNQWZBLEdBZVMsVUFBQ3hqRCxDQUFELEVBQUkyQyxDQUFKO0FBQUEsYUFBV3VSLEVBQUUsQ0FBQ3dWLFNBQUgsQ0FBYTFwQixDQUFDLENBQUN6TixFQUFmLElBQ3pCOHFELFNBQVMsQ0FBQ3I5QyxDQUFELEVBQUkyQyxDQUFKLENBQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FEeUIsR0FFekIrOUMsWUFBWSxDQUFDOStDLElBQWIsQ0FBa0JzUyxFQUFsQixFQUFzQmxVLENBQUMsQ0FBQ3pOLEVBQXhCLEVBQ0MyaEIsRUFBRSxDQUFDOFcsZUFBSCxDQUFtQmhyQixDQUFuQixJQUNDa1UsRUFBRSxDQUFDK1csZ0JBQUgsQ0FBb0JqckIsQ0FBcEIsRUFBdUIsS0FBdkIsQ0FERCxHQUNpQ0EsQ0FBQyxDQUFDcUIsS0FGcEMsQ0FGYztBQUFBLEtBZlQ7O0FBc0JOLFdBQU8sVUFBQXJCLENBQUMsRUFBSTtBQUFBLFVBSVBwTixJQUpPO0FBQUEsVUFDUHdoQixNQUFNLEdBQUdvc0MsZUFBZSxHQUFHdHNDLEVBQUUsQ0FBQ2dhLGdCQUFILENBQW9CbHVCLENBQUMsQ0FBQ29VLE1BQXRCLENBQUgsR0FBbUNwVSxDQUFDLENBQUNvVSxNQUR0RDtBQUFBLFVBRVA0c0MsRUFBRSxHQUFHLENBRkU7QUFBQSxVQUdQekMsRUFBRSxHQUFHLENBSEU7O0FBTVgsVUFBSXJxQyxFQUFFLENBQUNneUIsVUFBSCxDQUFjbG1DLENBQWQsQ0FBSixFQUFzQjtBQUNyQixZQUFJeFYsSUFBSSxHQUFHaTVELG1GQUFNLEVBQWpCO0FBRUFqNUQsWUFBSSxHQUFHeXhCLFNBQVMsR0FDZnp4QixJQUFJLENBQUN3SCxDQUFMLENBQU8ydUQsTUFBUCxFQUNFSyxFQURGLENBQ0t1QyxNQURMLEVBRUVudkQsRUFGRixDQUVLb3ZELE1BRkwsQ0FEZSxHQUlmaDVELElBQUksQ0FBQ3FILENBQUwsQ0FBTzh1RCxNQUFQLEVBQ0M7QUFERCxTQUVFcEMsRUFGRixDQUVLMTBDLE1BQU0sQ0FBQ21ELFVBQVAsR0FBb0IsQ0FBcEIsR0FBd0J1MkMsTUFGN0IsRUFHRWp2RCxFQUhGLENBR0trdkQsTUFITCxDQVBvQixFQVloQmhELGVBWmdCLEtBYXBCaDJELElBQUksR0FBR0EsSUFBSSxDQUFDdTJELE9BQUwsQ0FBYSxVQUFBL2dELENBQUM7QUFBQSxpQkFBSWtVLEVBQUUsQ0FBQzRXLFlBQUgsQ0FBZ0I5cUIsQ0FBaEIsTUFBdUIsSUFBM0I7QUFBQSxTQUFkLENBYmEsR0FnQmpCa1UsRUFBRSxDQUFDeTNCLFVBQUgsQ0FBYzNyQyxDQUFkLENBaEJpQixLQWlCcEJvVSxNQUFNLEdBQUdGLEVBQUUsQ0FBQzJiLG1CQUFILENBQXVCemIsTUFBdkIsQ0FqQlcsR0FvQnJCeGhCLElBQUksR0FBR3BJLElBQUksQ0FBQzAyRCxLQUFMLENBQVdodEMsRUFBRSxDQUFDeXJDLFFBQUgsQ0FBWTMvQyxDQUFaLENBQVgsRUFBMkJvVSxNQUEzQixDQXBCYztBQXFCckIsT0FyQkQsTUFzQktBLE1BQU0sQ0FBQyxDQUFELENBdEJYLEtBdUJFNHNDLEVBQUUsR0FBRzlzQyxFQUFFLENBQUNLLEtBQUgsQ0FBUzFpQixDQUFULENBQVd1aUIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVdmlCLENBQXJCLENBdkJQLEVBd0JFMHNELEVBQUUsR0FBR3JxQyxFQUFFLENBQUNtdEIsU0FBSCxDQUFhcmhDLENBQUMsQ0FBQ3pOLEVBQWYsRUFBbUI2aEIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVL1MsS0FBN0IsQ0F4QlAsR0EyQkN6TyxJQUFJLEdBQUdxcEIsU0FBUyxVQUFRc2lDLEVBQVIsU0FBY3lDLEVBQWQsVUFBMEJBLEVBQTFCLFNBQWdDekMsRUEzQmpEOztBQThCQSxhQUFPM3JELElBQUksSUFBSSxPQUFmO0FBQ0EsS0FyQ0Q7QUFzQ0EsR0EzZGE7QUE2ZGQwd0QsdUJBN2RjLGlDQTZkUUQsV0E3ZFIsRUE2ZHFCakcsS0E3ZHJCLEVBNmQ0QjtBQUN6QztBQUNNLFFBQUFscEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUFoWSxDQUZBLEdBRUlxaUIsRUFBRSxDQUFDK3BDLFNBQUgsQ0FBYSxDQUFiLEVBQWdCb0YsV0FBaEIsRUFBNkIsQ0FBQyxDQUFDakcsS0FBL0IsQ0FGSjtBQUFBLFFBR0FwckQsQ0FIQSxHQUdJa2lCLEVBQUUsQ0FBQ2lxQyxTQUFILENBQWEsQ0FBQyxDQUFDZixLQUFmLENBSEo7QUFBQSxRQUlBc0csVUFKQSxHQUlheHZDLEVBQUUsQ0FBQ21xQyxjQUFILENBQWtCbnFDLEVBQUUsQ0FBQ2d5QixVQUFyQixFQUFpQ21kLFdBQWpDLEVBQThDLENBQUMsQ0FBQ2pHLEtBQWhELENBSmI7QUFBQSxRQUtBa0IsTUFMQSxHQUtTbEIsS0FBSyxHQUFHbHBDLEVBQUUsQ0FBQ290QixZQUFOLEdBQXFCcHRCLEVBQUUsQ0FBQ210QixTQUx0QztBQU9OLFdBQU8sVUFBU3JoQyxDQUFULEVBQVkyQyxDQUFaLEVBQWU7QUFBQSxVQUNmNDdDLEVBQUUsR0FBR0QsTUFBTSxDQUFDMThDLElBQVAsQ0FBWXNTLEVBQVosRUFBZ0JsVSxDQUFDLENBQUN6TixFQUFsQixFQUFzQixDQUF0QixDQURVO0FBQUEsVUFFZnV1QyxNQUFNLEdBQUc0aUIsVUFBVSxDQUFDMWpELENBQUQsRUFBSTJDLENBQUosQ0FBVixJQUFvQjQ3QyxFQUZkO0FBQUEsVUFHZkMsSUFBSSxHQUFHM3NELENBQUMsQ0FBQ21PLENBQUQsQ0FITztBQUFBLFVBSWpCeStDLElBQUksR0FBR3pzRCxDQUFDLENBQUNnTyxDQUFELENBSlM7QUFhckI7QUFDQSxhQVBJNkosTUFBTSxDQUFDYyxZQUFQLEtBQ0YzSyxDQUFDLENBQUNxQixLQUFGLEdBQVUsQ0FBVixJQUFlbzlDLElBQUksR0FBR0YsRUFBdkIsSUFBK0J2K0MsQ0FBQyxDQUFDcUIsS0FBRixHQUFVLENBQVYsSUFBZWs5QyxFQUFFLEdBQUdFLElBRGhELENBT0osS0FKQ0EsSUFBSSxHQUFHRixFQUlSLEdBQU8sQ0FDTixDQUFDQyxJQUFELEVBQU8xZCxNQUFQLENBRE0sRUFFTixDQUFDMGQsSUFBRCxFQUFPQyxJQUFJLElBQUlGLEVBQUUsR0FBR3pkLE1BQVQsQ0FBWCxDQUZNLEVBR04sQ0FBQzBkLElBQUQsRUFBT0MsSUFBSSxJQUFJRixFQUFFLEdBQUd6ZCxNQUFULENBQVgsQ0FITSxFQUd3QjtBQUM5QixPQUFDMGQsSUFBRCxFQUFPMWQsTUFBUCxDQUpNLENBSVM7QUFKVCxPQUFQO0FBTUEsS0FwQkQ7QUFxQkEsR0EzZmE7QUE2ZmQ2aUIsY0E3ZmMsd0JBNmZEeEgsSUE3ZkMsRUE2ZktucUQsQ0E3ZkwsRUE2ZlE7QUFDckIsV0FBTzJOLElBQUksQ0FBQ291QixHQUFMLENBQVMvN0IsQ0FBQyxHQUFHaWhDLGdHQUFPLENBQUNrcEIsSUFBRCxDQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEVBQXhDO0FBQ0EsR0EvZmE7QUFpZ0JkeUgseUJBamdCYyxtQ0FpZ0JVNWpELENBamdCVixFQWlnQmE7QUFDMUIsUUFBTTZqRCxTQUFTLEdBQUcsS0FBS2g2QyxNQUFMLENBQVltRSxVQUE5QjtBQUVBLFdBQU82MUMsU0FBUyxPQUFULElBQ0xwakQsT0FBTyxDQUFDb2pELFNBQUQsQ0FBUCxJQUFzQkEsU0FBUyxDQUFDemhELE9BQVYsQ0FBa0JwQyxDQUFDLENBQUN6TixFQUFwQixNQUE0QixDQUFDLENBRHJEO0FBRUE7QUF0Z0JhLENBQWYsRTs7QUNmQTs7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBRWU7QUFDZDJ0QyxtQkFEYyw2QkFDSXY4QixJQURKLEVBQ1U7QUFDdkIsV0FBTywrQ0FBK0NlLElBQS9DLENBQW9EZixJQUFJLElBQUksS0FBS2tHLE1BQUwsQ0FBWWlDLFVBQXhFLENBQVA7QUFDQSxHQUhhO0FBS2RnNEMsMEJBTGMsb0NBS1duZ0QsSUFMWCxFQUtpQjtBQUM5QixRQUFNb2dELFNBQVMsR0FBR3BnRCxJQUFJLElBQUksS0FBS2tHLE1BQUwsQ0FBWWlDLFVBQXRDO0FBRUEsV0FBTzdMLFlBQVksQ0FBQzhqRCxTQUFELENBQVosSUFDTjNrRCxVQUFVLENBQUMya0QsU0FBUyxDQUFDOXNDLE1BQVgsQ0FESixJQUMwQjdYLFVBQVUsQ0FBQzJrRCxTQUFTLENBQUN6TyxNQUFYLENBRDNDO0FBRUEsR0FWYTtBQVlkME8seUJBWmMsbUNBWVVoa0QsQ0FaVixFQVlhO0FBQUEsUUFDbkI3TixhQURtQixHQUNGLEtBQUsvQixLQURILENBQ25CK0IsYUFEbUI7QUFHMUIsV0FBTyxLQUFLMjRCLFlBQUwsQ0FBa0I5cUIsQ0FBbEIsTUFBeUIsSUFBekIsSUFDTjdOLGFBQWEsQ0FBQzZOLENBQUMsQ0FBQ3pOLEVBQUgsQ0FEUCxHQUNnQixLQUFLMHhELGdCQUFMLENBQXNCamtELENBQXRCLENBRGhCLEdBQzJDLEdBRGxEO0FBRUEsR0FqQmE7QUFtQmRpa0Qsa0JBbkJjLDRCQW1CR2prRCxDQW5CSCxFQW1CTTtBQUNuQixRQUFNd2pCLE9BQU8sR0FBRyxLQUFLM1osTUFBTCxDQUFZMEIsVUFBWixHQUF5QixHQUF6QixHQUErQixHQUEvQztBQUVBLFdBQU9yTSxPQUFPLENBQUMsS0FBSzRyQixZQUFMLENBQWtCOXFCLENBQWxCLENBQUQsQ0FBUCxHQUNMLEtBQUs0bUMsWUFBTCxDQUFrQjVtQyxDQUFsQixLQUF3QixLQUFLMm1DLGFBQUwsQ0FBbUIzbUMsQ0FBbkIsQ0FBeEIsR0FDQSxLQURBLEdBQ1F3akIsT0FGSCxHQUVjLEdBRnJCO0FBR0EsR0F6QmE7QUEyQmQwZ0MsWUEzQmMsd0JBMkJEO0FBQ04sUUFBQWh3QyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3dCcUssRUFEeEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNlcEcsSUFEZixHQUN3QnlRLEVBRHhCLENBQ1M1USxHQURULENBQ2VHLElBRGY7QUFHTnlRLE1BQUUsQ0FBQ3JDLEtBQUgsR0FBV3FDLEVBQUUsQ0FBQ2l3QyxhQUFILEVBSkMsRUFNUnQ2QyxNQUFNLENBQUMwQixVQU5DLElBT1g5SCxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ3ZZLEtBQXRCLEVBQ0VzWCxNQURGLENBQ1MsR0FEVCxFQUVFQyxJQUZGLENBRU8sT0FGUCxFQUVnQmdCLGNBQUssQ0FBQzVYLFlBRnRCLENBUFc7QUFXWixHQXRDYTtBQXdDZG00RCx1QkF4Q2MsaUNBd0NRMW9DLENBeENSLEVBd0NXO0FBQ2xCLFFBQUF4SCxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3NCcUssRUFEdEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTeEQsSUFEVCxHQUNzQjZOLEVBRHRCLENBQ1M3TixJQURUO0FBQUEsUUFDZS9DLEdBRGYsR0FDc0I0USxFQUR0QixDQUNlNVEsR0FEZjtBQUFBLFFBRUF5USxPQUZBLEdBRVUySCxDQUFDLElBQUlyVixJQUFJLENBQUMwTixPQUZwQjtBQUFBLFFBR0FnZ0IsWUFIQSxHQUdlN2YsRUFBRSxDQUFDNmYsWUFBSCxDQUFnQjFjLElBQWhCLENBQXFCbkQsRUFBckIsQ0FIZjtBQUtGLEtBQUM1USxHQUFHLENBQUM5VyxNQUFMLElBQWVxZCxNQUFNLENBQUMwQixVQU5GLElBT3ZCMkksRUFBRSxDQUFDZ3dDLFVBQUgsRUFQdUI7QUFBQSxRQVVsQkcsVUFBVSxHQUFHL2dELEdBQUcsQ0FBQ0csSUFBSixDQUFTRyxNQUFULE9BQW9CQyxjQUFLLENBQUM1WCxZQUExQixFQUNqQmd0QixLQURpQixDQUNYLGdCQURXLEVBQ08sTUFEUCxFQUVqQk4sU0FGaUIsT0FFSDlVLGNBQUssQ0FBQ3BYLE9BRkgsRUFHakI0WixJQUhpQixDQUdaME4sT0FIWSxFQUlqQmxSLElBSmlCLENBSVosT0FKWSxFQUlIa3hCLFlBSkcsQ0FWSztBQUFBLFFBZ0JsQnV3QixlQUFlLEdBQUdELFVBQVUsQ0FBQ3pyQyxLQUFYLEVBaEJBO0FBa0J4QjtBQVFBO0FBUEEvTyxVQUFNLENBQUNwUSxzQkFBUCxJQUFpQzZxRCxlQUFlLENBQUMxaEQsTUFBaEIsQ0FBdUIsR0FBdkIsRUFDL0JDLElBRCtCLENBQzFCLE9BRDBCLEVBQ2pCLFVBQUE3QyxDQUFDO0FBQUEsYUFBSWtVLEVBQUUsQ0FBQ21mLGFBQUgsQ0FBaUJ4dkIsY0FBSyxDQUFDeFYsZUFBdkIsRUFBd0MyUixDQUFDLENBQUN6TixFQUExQyxDQUFKO0FBQUEsS0FEZ0IsQ0FuQlQsRUFzQnhCK3hELGVBQWUsQ0FBQzFoRCxNQUFoQixDQUF1QixHQUF2QixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQmt4QixZQURoQixFQUVFOWEsS0FGRixDQUVRLFFBRlIsRUFFa0IsVUFBQWpaLENBQUM7QUFBQSxhQUFLNkosTUFBTSxDQUFDbFEsMkJBQVAsQ0FBbUMwZCxJQUFuQyxDQUF3Q25ELEVBQUUsQ0FBQ2dKLEdBQTNDLEVBQWdEbGQsQ0FBaEQsSUFBcUQsU0FBckQsR0FBaUUsSUFBdEU7QUFBQSxLQUZuQixDQXRCd0IsRUEyQnhCK1QsT0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBbWEsQ0FBQyxFQUFJO0FBQ3BCcFksU0FBRyxDQUFDRyxJQUFKLENBQVNrVixTQUFULE9BQXVCOVUsY0FBSyxDQUFDeFYsZUFBN0IsR0FBK0M2bEIsRUFBRSxDQUFDbWIsdUJBQUgsQ0FBMkIzVCxDQUFDLENBQUNucEIsRUFBN0IsQ0FBL0MsRUFDRW9tQixTQURGLE1BQ2U5VSxjQUFLLENBQUN6VixjQURyQixFQUVFaXFCLElBRkYsQ0FFTyxVQUFBclksQ0FBQyxFQUFJO0FBQ1ZBLFNBQUMsQ0FBQ3FCLEtBQUYsR0FBVXFhLENBQUMsQ0FBQ3RILE1BQUYsQ0FBU3BVLENBQUMsQ0FBQ3VaLEtBQVgsRUFBa0JsWSxLQURsQjtBQUVWLE9BSkYsQ0FEb0I7QUFNcEIsS0FORCxDQTNCd0I7QUFrQ3hCLEdBMUVhO0FBNEVka2pELGNBNUVjLDBCQTRFQztBQUNSLFFBQUFyd0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNnQnFLLEVBRGhCLENBQ0NySyxNQUREO0FBQUEsUUFDU3ZHLEdBRFQsR0FDZ0I0USxFQURoQixDQUNTNVEsR0FEVDs7QUFHTixRQUFLdUcsTUFBTSxDQUFDMEIsVUFBWjtBQUlBLFVBQU05ZSxPQUFPLEdBQUc2VyxHQUFHLENBQUNHLElBQUosQ0FBU2tWLFNBQVQsT0FBdUI5VSxjQUFLLENBQUNwWCxPQUE3QixFQUF3Q2tzQixTQUF4QyxPQUFzRDlVLGNBQUssQ0FBQ3JYLE1BQTVELEVBQ2Q2WixJQURjLENBQ1QsVUFBQXJHLENBQUM7QUFBQSxlQUFJLENBQUNrVSxFQUFFLENBQUNrYixTQUFILENBQWFwdkIsQ0FBYixDQUFELEtBQ1YsQ0FBQ2tVLEVBQUUsQ0FBQ3d5QixVQUFILENBQWMxbUMsQ0FBZCxDQUFELElBQXFCa1UsRUFBRSxDQUFDMHZDLHVCQUFILENBQTJCNWpELENBQTNCLENBRFgsS0FFTmtVLEVBQUUsQ0FBQyt3QixZQUFILENBQWdCamxDLENBQWhCLENBRkU7QUFBQSxPQURRLENBQWhCO0FBTUF2VCxhQUFPLENBQUMwc0IsSUFBUixHQUFldEYsTUFBZixFQVZBO0FBWUEsVUFBTXBTLEVBQUUsR0FBR3lTLEVBQUUsQ0FBQ3JDLEtBQUgsQ0FBUyxRQUFULEVBQW1CLElBQW5CLEVBQXlCcUMsRUFBRSxDQUFDb3NCLE1BQUgsQ0FBVWpwQixJQUFWLENBQWVuRCxFQUFmLENBQXpCLEVBQTZDQSxFQUFFLENBQUM5QyxLQUFoRCxDQUFYO0FBRUE5TixTQUFHLENBQUM5VyxNQUFKLEdBQWFDLE9BQU8sQ0FBQ21zQixLQUFSLEdBQ1hoVyxNQURXLENBQ0puQixFQURJLEVBRVhvWCxLQUZXLENBRUxwc0IsT0FGSyxFQUdYd3NCLEtBSFcsQ0FHTCxRQUhLLEVBR0svRSxFQUFFLENBQUM5QyxLQUhSLEVBSVg2SCxLQUpXLENBSUwsU0FKSyxFQUlNL0UsRUFBRSxDQUFDOHZDLHVCQUFILENBQTJCM3NDLElBQTNCLENBQWdDbkQsRUFBaEMsQ0FKTixDQWRiO0FBQUE7QUFtQkEsR0FuR2E7QUFxR2Rzd0MsY0FyR2Msd0JBcUdEcFQsRUFyR0MsRUFxR0dDLEVBckdILEVBcUdPbnZCLGNBckdQLEVBcUd1QjBCLElBckd2QixFQXFHNkI7QUFDcEMsUUFBQTFQLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDUzdnQixRQURULEdBQzJDNmdCLEVBRDNDLENBQ0M5akIsS0FERCxDQUNTaUQsUUFEVDtBQUFBLGtCQUMyQzZnQixFQUQzQyxDQUNvQjVRLEdBRHBCO0FBQUEsUUFDMEI5VyxNQUQxQixXQUMwQkEsTUFEMUI7QUFBQSxRQUNrQ2lYLElBRGxDLFdBQ2tDQSxJQURsQztBQUFBLFFBRUFwVixlQUZBLEdBRWtCb1YsSUFBSSxDQUFDa1YsU0FBTCxPQUFtQjlVLGNBQUssQ0FBQ3pWLGNBQXpCLENBRmxCO0FBSU4sUUFBSSxDQUFDOGxCLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVTBCLFVBQWYsRUFDQyxPQUFPLEVBQVA7QUFOeUMsUUFTcEM5SixFQUFFLEdBQUd5UyxFQUFFLENBQUNyQyxLQUFILENBQVMsUUFBVCxFQUFtQnFDLEVBQW5CLEVBQXVCazlCLEVBQXZCLEVBQTJCQyxFQUEzQixFQUErQm45QixFQUFFLENBQUM5QyxLQUFsQyxFQUF5QzhRLGNBQXpDLEVBQXlEMEIsSUFBekQsRUFBK0R2MUIsZUFBL0QsQ0FUK0I7QUFBQSxRQVVwQ28yRCxPQUFPLEdBQUd2d0MsRUFBRSxDQUFDKzNCLGFBQUgsS0FBcUIsR0FBckIsR0FBMkIsRUFWRDtBQUFBLFFBWXBDdndCLENBQUMsR0FBR3pYLFNBQVMsRUFadUI7QUFBQSxRQWFwQ3lnRCxjQUFjLEdBQUd4d0MsRUFBRSxDQUFDK3ZDLGdCQUFILENBQW9CNXNDLElBQXBCLENBQXlCbkQsRUFBekIsQ0FibUI7QUFBQSxRQWVwQ3l3QyxXQUFXLEdBQUcsRUFmc0I7QUEwQjFDLFdBVEFuNEQsTUFBTSxDQUFDNnJCLElBQVAsQ0FBWSxVQUFTclksQ0FBVCxFQUFZO0FBQ3ZCLFVBQUk4OEMsTUFBTSxHQUFHcjdDLEVBQUUsQ0FBQzRWLElBQUgsQ0FBUSxJQUFSLEVBQWNyWCxDQUFkLENBQWI7QUFFQTg4QyxZQUFNLEdBQUcsQ0FBRTU2QixjQUFjLElBQUksQ0FBQzd1QixRQUFwQixHQUFnQ3lwRCxNQUFNLENBQUMzbUMsVUFBUCxDQUFrQnVGLENBQWxCLENBQWhDLEdBQXVEb2hDLE1BQXhELEVBQ1A3akMsS0FETyxDQUNELFNBREMsRUFDVXlyQyxjQURWLENBSGMsRUFNdkJDLFdBQVcsQ0FBQ3A5QyxJQUFaLENBQWlCdTFDLE1BQWpCLENBTnVCO0FBT3ZCLEtBUEQsQ0FTQSxFQUFPLENBQ042SCxXQURNLEVBRU50MkQsZUFBZSxDQUNid1UsSUFERixDQUNVNGhELE9BRFYsUUFDc0JyVCxFQUR0QixFQUVFdnVDLElBRkYsQ0FFVTRoRCxPQUZWLFFBRXNCcFQsRUFGdEIsQ0FGTSxDQUFQO0FBTUEsR0FySWE7QUF1SWRzSyxTQXZJYyxtQkF1SU4zN0MsQ0F2SU0sRUF1SUg7QUFDSixRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxvQkFDWUEsRUFBRSxDQUFDSyxLQURmO0FBQUEsUUFDQzFpQixDQURELGFBQ0NBLENBREQ7QUFBQSxRQUNJaWdCLElBREosYUFDSUEsSUFESjtBQUFBLFFBRUEzUSxRQUZBLEdBRVdqQyxPQUFPLENBQUNjLENBQUMsQ0FBQ25PLENBQUgsQ0FGbEI7QUFJTixXQUFPcWlCLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXdDLFlBQVYsSUFBMEJ5RixJQUExQixHQUNMM1EsUUFBUSxHQUFHMlEsSUFBSSxDQUFDOVIsQ0FBQyxDQUFDbk8sQ0FBSCxDQUFQLEdBQWUsSUFEbEIsR0FFTHNQLFFBQVEsR0FBR3RQLENBQUMsQ0FBQ21PLENBQUMsQ0FBQ25PLENBQUgsQ0FBSixHQUFZLElBRnRCO0FBR0EsR0EvSWE7QUFpSmQreUQsZUFqSmMsMkJBaUpFO0FBQUEsUUFDVDF3QyxFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRtcEMsU0FBUyxHQUFHbnBDLEVBQUUsQ0FBQ3VzQyxxQkFBSCxDQUF5QnZzQyxFQUFFLENBQUMyd0MsZUFBSCxDQUFtQjN3QyxFQUFFLENBQUN3eUIsVUFBdEIsQ0FBekIsS0FGSDs7QUFJZnh5QixNQUFFLENBQUN3YixPQUFILEdBQWEsVUFBQzF2QixDQUFELEVBQUkyQyxDQUFKLEVBQVU7QUFDdEIsVUFBTXBRLEVBQUUsR0FBR3lOLENBQUMsQ0FBQ3pOLEVBQWI7QUFFQSxhQUFPMmhCLEVBQUUsQ0FBQ3dWLFNBQUgsQ0FBYW4zQixFQUFiLElBQ044cUQsU0FBUyxDQUFDcjlDLENBQUQsRUFBSTJDLENBQUosQ0FBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQURNLEdBRU51UixFQUFFLENBQUNtdEIsU0FBSCxDQUFhOXVDLEVBQWIsRUFBaUIyaEIsRUFBRSxDQUFDNFcsWUFBSCxDQUFnQjlxQixDQUFoQixDQUFqQixDQUZEO0FBR0EsS0FWYztBQVdmLEdBNUphO0FBOEpkOGtELFlBOUpjLHNCQThKSG5pRCxDQTlKRyxFQThKQXBRLEVBOUpBLEVBOEpJO0FBQUEsUUFDWDJoQixFQUFFLEdBQUcsSUFETTtBQUFBLFFBRVgrb0MsTUFBTSxHQUFJLzlDLE9BQU8sQ0FBQ3lELENBQUQsQ0FBUCxTQUFpQkEsQ0FBakIsS0FGQztBQUlqQixXQUFPLENBQUNwUSxFQUFFLEdBQUcyaEIsRUFBRSxDQUFDNVEsR0FBSCxDQUFPRyxJQUFQLENBQVlrVixTQUFaLE9BQTBCOVUsY0FBSyxDQUFDcFgsT0FBaEMsR0FBMEN5bkIsRUFBRSxDQUFDbWIsdUJBQUgsQ0FBMkI5OEIsRUFBM0IsQ0FBMUMsQ0FBSCxHQUFpRjJoQixFQUFFLENBQUM1USxHQUFILENBQU9HLElBQTNGLEVBQ0xrVixTQURLLE9BQ1M5VSxjQUFLLENBQUNyWCxNQURmLEdBQ3dCeXdELE1BRHhCLENBQVA7QUFFQSxHQXBLYTtBQXNLZDlJLGVBdEtjLHlCQXNLQXh4QyxDQXRLQSxFQXNLR3BRLEVBdEtILEVBc0tPeWhCLEtBdEtQLEVBc0tjO0FBQUEsUUFDckJFLEVBQUUsR0FBRyxJQURnQjtBQUFBLFFBRXJCcUcsQ0FBQyxHQUFHckcsRUFBRSxDQUFDNndDLGNBQUgsQ0FBa0IxdEMsSUFBbEIsQ0FBdUJuRCxFQUF2QixDQUZpQjtBQUkzQkYsU0FBSyxJQUFJRSxFQUFFLENBQUNnZ0MsZUFBSCxFQUprQjtBQUFBLFFBTXJCem5ELE9BQU8sR0FBR3luQixFQUFFLENBQUM0d0MsVUFBSCxDQUFjbmlELENBQWQsRUFBaUJwUSxFQUFqQixFQUFxQjBvQyxPQUFyQixDQUE2QnAzQixjQUFLLENBQUM3VCxRQUFuQyxLQU5XO0FBQUEsUUFPckJ1a0IsS0FBSyxHQUFHZ0csQ0FBQyxDQUFDOXRCLE9BQUQsQ0FBRCxHQUFheW5CLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVTJCLE9BUFY7QUFBQSxRQVFyQmdsQixLQUFLLEdBQUcsSUFBSWpjLEtBUlM7QUFVdkJMLE1BQUUsQ0FBQyszQixhQUFILEVBVnVCLEdBVzFCeC9DLE9BQU8sQ0FBQ29XLElBQVIsQ0FBYSxHQUFiLEVBQWtCMFgsQ0FBbEIsQ0FYMEIsR0FjMUI5dEIsT0FBTyxDQUFDNHJCLElBQVIsQ0FBYSxZQUFXO0FBQ3ZCLFVBQU14RyxLQUFLLEdBQUd5RyxpR0FBUSxDQUFDLElBQUQsQ0FBdEI7QUFFQSxVQUFJLEtBQUtrcUIsT0FBTCxLQUFpQixRQUFyQixFQUNDM3dCLEtBQUssQ0FBQ2hQLElBQU4sQ0FBVyxHQUFYLEVBQWdCMFgsQ0FBaEIsQ0FERCxNQUVPO0FBQUEsNEJBQ2tCLEtBQUt4WCxPQUFMLEVBRGxCO0FBQUEsWUFDQzFTLEtBREQsaUJBQ0NBLEtBREQ7QUFBQSxZQUNRRSxNQURSLGlCQUNRQSxNQURSO0FBQUEsWUFFQXNCLENBRkEsR0FFSTIrQixLQUFLLElBQUksQ0FBQzNlLEtBQUssQ0FBQ2hQLElBQU4sQ0FBVyxHQUFYLENBQUQsR0FBbUJ4UyxLQUFLLEdBQUcsQ0FBL0IsQ0FGVDtBQUFBLFlBR0EyQixDQUhBLEdBR0l3K0IsS0FBSyxJQUFJLENBQUMzZSxLQUFLLENBQUNoUCxJQUFOLENBQVcsR0FBWCxDQUFELEdBQW1CdFMsTUFBTSxHQUFHLENBQWhDLENBSFQ7O0FBS05zaEIsYUFBSyxDQUFDaFAsSUFBTixDQUFXLFdBQVgsaUJBQXFDaFIsQ0FBckMsU0FBMENHLENBQTFDLGdCQUFzRHVpQixLQUF0RCxPQUxNO0FBTU47QUFDRCxLQVpELENBZDBCO0FBNEIzQixHQWxNYTtBQW9NZDIvQixpQkFwTWMsMkJBb01FdnhDLENBcE1GLEVBb01LO0FBQUEsUUFDWnVSLEVBQUUsR0FBRyxJQURPO0FBQUEsUUFFWnFHLENBQUMsR0FBR3JHLEVBQUUsQ0FBQ29zQixNQUFILENBQVVqcEIsSUFBVixDQUFlbkQsRUFBZixDQUZRO0FBQUEsUUFJWnpuQixPQUFPLEdBQUd5bkIsRUFBRSxDQUFDNHdDLFVBQUgsQ0FBY25pRCxDQUFkLEVBQ2Q2RCxNQURjLENBQ1AsWUFBVztBQUNsQixhQUFPOFIsaUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZTJpQixPQUFmLENBQXVCcDNCLGNBQUssQ0FBQzdULFFBQTdCLENBQVA7QUFDQSxLQUhjLEVBSWRpckMsT0FKYyxDQUlOcDNCLGNBQUssQ0FBQzdULFFBSkEsS0FKRTtBQVVsQnZELFdBQU8sQ0FBQ29XLElBQVIsQ0FBYSxHQUFiLEVBQWtCMFgsQ0FBbEIsQ0FWa0IsRUFZakJyRyxFQUFFLENBQUMrM0IsYUFBSCxFQUFELElBQ0N4L0MsT0FBTyxDQUFDb1csSUFBUixDQUFhLFdBQWIsYUFBbUMwWCxDQUFDLENBQUM5dEIsT0FBRCxDQUFELEdBQWF5bkIsRUFBRSxDQUFDckssTUFBSCxDQUFVMkIsT0FBMUQsT0FiaUI7QUFjbEIsR0FsTmE7QUFvTmQ4MEIsUUFwTmMsWUFvTlB0Z0MsQ0FwTk8sRUFvTko7QUFDSCxRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUF5MkIsTUFGQSxHQUVTejJCLE1BQU0sQ0FBQzJCLE9BRmhCO0FBQUEsUUFHRitPLENBSEUsR0FHRStsQixNQUhGO0FBYU4sV0FSSXBzQixFQUFFLENBQUN5M0IsVUFBSCxDQUFjM3JDLENBQWQsQ0FRSixHQVBDdWEsQ0FBQyxHQUFHLENBT0wsR0FOV3JHLEVBQUUsQ0FBQzB5QixZQUFILENBQWdCNW1DLENBQWhCLENBTVgsR0FMQ3VhLENBQUMsR0FBR3JHLEVBQUUsQ0FBQzZxQyxVQUFILENBQWMvK0MsQ0FBZCxDQUtMLEdBSldaLFVBQVUsQ0FBQ2toQyxNQUFELENBSXJCLEtBSEMvbEIsQ0FBQyxHQUFHK2xCLE1BQU0sQ0FBQ2pwQixJQUFQLENBQVluRCxFQUFFLENBQUNnSixHQUFmLEVBQW9CbGQsQ0FBcEIsQ0FHTCxHQUFPdWEsQ0FBUDtBQUNBLEdBbk9hO0FBcU9kd3FDLGdCQXJPYywwQkFxT0Mva0QsQ0FyT0QsRUFxT0k7QUFDWCxRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUEwSyxLQUZBLEdBRVFMLEVBQUUsQ0FBQzB5QixZQUFILENBQWdCNW1DLENBQWhCLElBQXFCLElBQXJCLEdBQTRCLElBRnBDO0FBSU4sV0FBTzZKLE1BQU0sQ0FBQzZCLDBCQUFQLEdBQ0w3QixNQUFNLENBQUM4QixvQkFBUCxJQUErQnVJLEVBQUUsQ0FBQ29zQixNQUFILENBQVV0Z0MsQ0FBVixJQUFldVUsS0FEekMsR0FDa0RMLEVBQUUsQ0FBQ29zQixNQUFILENBQVV0Z0MsQ0FBVixDQUR6RDtBQUVBLEdBNU9hO0FBOE9kNDdDLGNBOU9jLHdCQThPRDU3QyxDQTlPQyxFQThPRTtBQUFBLFFBQ1RrVSxFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVQ4d0MsT0FBTyxHQUFHOXdDLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWdDLGNBRlg7QUFJZixXQUFPek0sVUFBVSxDQUFDNGxELE9BQUQsQ0FBVixHQUNOQSxPQUFPLENBQUNobEQsQ0FBRCxDQURELEdBQ1FnbEQsT0FBTyxJQUFJOXdDLEVBQUUsQ0FBQ29zQixNQUFILENBQVV0Z0MsQ0FBVixJQUFlLENBRHpDO0FBRUEsR0FwUGE7QUFzUGRpbEQsZ0JBdFBjLDBCQXNQQ2hqRCxJQXRQRCxFQXNQT3NZLENBdFBQLEVBc1BVO0FBQUEsUUFDakI5UyxLQUFLLEdBQUd3ckIsZ0dBQU8sQ0FBQ2h4QixJQUFELENBREU7QUFBQSxRQUVqQnNqQyxPQUFPLEdBQUdqdEIsaUdBQVEsQ0FBQ3JXLElBQUQsQ0FGRDtBQUFBLFFBR2pCZ1csTUFBTSxHQUFHLEtBQUtnMEIsYUFBTCxLQUF1QixHQUF2QixHQUE2QixFQUhyQjtBQUFBLFFBS25CbUYsRUFBRSxHQUFHLENBQUM3TCxPQUFPLENBQUMxaUMsSUFBUixDQUFnQm9WLE1BQWhCLE9BTGE7QUFBQSxRQU1uQm81QixFQUFFLEdBQUcsQ0FBQzlMLE9BQU8sQ0FBQzFpQyxJQUFSLENBQWdCb1YsTUFBaEIsT0FOYTs7QUFRdkI7QUFDQSxRQUFJLEVBQUVtNUIsRUFBRSxJQUFJQyxFQUFSLEtBQWVwdkMsSUFBSSxDQUFDbkIsUUFBTCxLQUFrQixDQUFyQyxFQUF3QztBQUFBLDZCQUN4QmlELGVBQWUsQ0FBQzlCLElBQUQsQ0FEUztBQUFBLFVBQ2hDcFEsQ0FEZ0Msb0JBQ2hDQSxDQURnQztBQUFBLFVBQzdCRyxDQUQ2QixvQkFDN0JBLENBRDZCOztBQUd2Q28vQyxRQUFFLEdBQUd2L0MsQ0FIa0MsRUFJdkN3L0MsRUFBRSxHQUFHci9DLENBSmtDO0FBS3ZDOztBQUVELFdBQU8yTixJQUFJLENBQUNnd0IsSUFBTCxDQUNOaHdCLElBQUksQ0FBQ2l3QixHQUFMLENBQVN3aEIsRUFBRSxHQUFHM3BDLEtBQUssQ0FBQyxDQUFELENBQW5CLEVBQXdCLENBQXhCLElBQTZCOUgsSUFBSSxDQUFDaXdCLEdBQUwsQ0FBU3loQixFQUFFLEdBQUc1cEMsS0FBSyxDQUFDLENBQUQsQ0FBbkIsRUFBd0IsQ0FBeEIsQ0FEdkIsS0FFRjhTLENBQUMsSUFBSSxLQUFLMVEsTUFBTCxDQUFZNEIsaUJBRmYsQ0FBUDtBQUdBLEdBelFhO0FBMlFkeTVDLHFCQTNRYywrQkEyUU1yekMsS0EzUU4sRUEyUWF0ZixFQTNRYixFQTJRaUI7QUFBQSxRQUN4QjJoQixFQUFFLEdBQUcsSUFEbUI7QUFBQSxRQUV4Qml4QyxRQUFRLEdBQUcsVUFBQ0MsSUFBRCxFQUFPdjJELE1BQVAsRUFBa0I7QUFHbEMsZUFBZ0JrcEIsSUFBaEIsRUFGTXN0QyxPQUFPLEdBQUdELElBQUksQ0FBQ0UsVUFFckIsRUFBUzNpRCxDQUFDLEdBQUcsQ0FBYixFQUF1Qm9WLElBQUksR0FBR3N0QyxPQUFPLENBQUMxaUQsQ0FBRCxDQUFyQyxFQUEyQ0EsQ0FBQyxFQUE1QyxFQUNDb1YsSUFBSSxHQUFHQSxJQUFJLENBQUNBLElBRGIsRUFFQ2xwQixNQUFNLENBQUMwMkQsWUFBUCxDQUFvQnh0QyxJQUFwQixFQUEwQnF0QyxJQUFJLENBQUNJLFlBQUwsQ0FBa0J6dEMsSUFBbEIsQ0FBMUIsQ0FGRDtBQUlBLEtBVDZCO0FBQUEsUUFXeEIvWSxHQUFHLEdBQUcsSUFBSXltRCxTQUFKLEdBQWdCQyxlQUFoQixDQUFnQzd6QyxLQUFoQyxFQUF1QyxlQUF2QyxDQVhrQjtBQUFBLFFBWXhCNVAsSUFBSSxHQUFHakQsR0FBRyxDQUFDMm1ELGVBWmE7QUFBQSxRQWF4QkMsS0FBSyxHQUFHM21ELFdBQVEsQ0FBQytnQyxlQUFULENBQXlCQyw2RkFBWSxDQUFDeGUsR0FBdEMsRUFBMkN4ZixJQUFJLENBQUNtK0IsUUFBTCxDQUFjL1MsV0FBZCxFQUEzQyxDQWJnQjs7QUFxQjlCLFFBTkF1NEIsS0FBSyxDQUFDcnpELEVBQU4sR0FBV0EsRUFNWCxFQUxBcXpELEtBQUssQ0FBQzNzQyxLQUFOLENBQVk0c0MsSUFBWixHQUFtQixTQUtuQixFQUpBRCxLQUFLLENBQUMzc0MsS0FBTixDQUFZNnNDLE1BQVosR0FBcUIsU0FJckIsRUFGQVgsUUFBUSxDQUFDbGpELElBQUQsRUFBTzJqRCxLQUFQLENBRVIsRUFBSTNqRCxJQUFJLENBQUN3NUIsVUFBTCxJQUFtQng1QixJQUFJLENBQUN3NUIsVUFBTCxDQUFnQnQ3QixNQUF2QyxFQUErQztBQUM5QyxVQUFNb2lDLE1BQU0sR0FBR2pxQixpR0FBUSxDQUFDc3RDLEtBQUQsQ0FBdkI7QUFFSSxxQkFBZUEsS0FIMkIsR0FJN0NyakIsTUFBTSxDQUFDNy9CLElBQVAsQ0FBWVQsSUFBSSxDQUFDOGpELFNBQWpCLENBSjZDLEdBTTdDaGhELE9BQU8sQ0FBQzlDLElBQUksQ0FBQ3c1QixVQUFOLENBQVAsQ0FBeUJsNkIsT0FBekIsQ0FBaUMsVUFBQXBDLENBQUMsRUFBSTtBQUNyQ2dtRCxnQkFBUSxDQUFDaG1ELENBQUQsRUFBSW9qQyxNQUFNLENBQUMzL0IsTUFBUCxDQUFjekQsQ0FBQyxDQUFDcWpDLE9BQWhCLEVBQXlCdmdDLElBQXpCLEVBQUosQ0FENkI7QUFFckMsT0FGRCxDQU42QztBQVU5Qzs7QUFFRGlTLE1BQUUsQ0FBQzVRLEdBQUgsQ0FBT295QyxJQUFQLENBQVl6ekMsSUFBWixHQUFtQmcwQixXQUFuQixDQUErQjJ2QixLQUEvQixDQWpDOEI7QUFrQzlCLEdBN1NhO0FBK1NkSSxlQS9TYyx5QkErU0F6ekQsRUEvU0EsRUErU0k7QUFDakIsV0FBTyxLQUFLK1EsR0FBTCxDQUFTb3lDLElBQVQsQ0FBYzl4QyxNQUFkLE9BQXlCclIsRUFBekIsQ0FBUDtBQUNBLEdBalRhO0FBbVRkNi9DLGtCQW5UYyw0QkFtVEdweUMsQ0FuVEgsRUFtVE07QUFDYixRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDMW5CLE1BREQsR0FDVzBuQixFQUFFLENBQUM1USxHQURkLENBQ0M5VyxNQUREO0FBQUEsUUFFRnk1RCxVQUZFO0FBVU4sWUFOSXJsRCxRQUFRLENBQUNaLENBQUQsQ0FBUixJQUFleFQsTUFNbkIsTUFMQ3k1RCxVQUFVLEdBQUdqbUQsQ0FBQyxPQUFELEdBQ1p4VCxNQUFNLENBQUNxVyxJQUFQLENBQVksT0FBWixFQUFxQnFSLEVBQUUsQ0FBQzRmLFdBQUgsQ0FBZXpjLElBQWYsQ0FBb0JuRCxFQUFwQixDQUFyQixDQURZLEdBRVpBLEVBQUUsQ0FBQzRmLFdBQUgsQ0FBZTl6QixDQUFmLENBR0YsR0FBT2ltRCxVQUFQO0FBQ0EsR0EvVGE7QUFpVWQ5QixlQWpVYywyQkFpVUU7QUFDVCxRQUFBandDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDZ0NxSyxFQURoQyxDQUNDckssTUFERDtBQUFBLFFBQ2lCeFgsVUFEakIsR0FDZ0M2aEIsRUFEaEMsQ0FDUzlqQixLQURULENBQ2lCaUMsVUFEakI7QUFBQSxRQUVBaTJCLEdBRkEsR0FFZ0IsRUFGaEI7QUFBQSxRQUdBb04sT0FIQSxHQUdVbDFCLFFBQVEsQ0FBQ3FKLE1BQU0sQ0FBQytCLGFBQVIsQ0FBUixHQUFpQy9CLE1BQU0sQ0FBQytCLGFBQXhDLEdBQXdELENBQUMvQixNQUFNLENBQUNpQyxVQUFSLENBSGxFO0FBS04sV0FBTyxVQUFTZ3dDLE1BQVQsRUFBaUJqSixPQUFqQixFQUFtQztBQUFBLHdDQUFObHhDLElBQU0sa0VBQU5BLElBQU07O0FBQ3pDLGFBQU8sVUFBUzNCLENBQVQsRUFBWTtBQUFBLFlBQ1p6TixFQUFVLEdBQUd5TixDQUFDLENBQUN6TixFQUFGLElBQVN5TixDQUFDLENBQUNxRyxJQUFGLElBQVVyRyxDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUExQixJQUFpQ3lOLENBRGxDO0FBQUEsWUFFWnVsQyxPQUFPLEdBQUdqdEIsaUdBQVEsQ0FBQyxJQUFELENBRk47QUFJbEJnUSxXQUFHLENBQUNsbUIsT0FBSixDQUFZN1AsRUFBWixJQUFrQixDQUFsQixJQUF1QisxQixHQUFHLENBQUMvZ0IsSUFBSixDQUFTaFYsRUFBVCxDQUpMO0FBTWxCLFlBQUlzZixLQUFLLEdBQUc2akIsT0FBTyxDQUFDcE4sR0FBRyxDQUFDbG1CLE9BQUosQ0FBWTdQLEVBQVosSUFBa0JtakMsT0FBTyxDQUFDdjFCLE1BQTNCLENBQW5CO0FBRUEsWUFBSStULEVBQUUsQ0FBQ2dzQixpQkFBSCxDQUFxQnJ1QixLQUFyQixDQUFKLEVBQ0NBLEtBQUssR0FBR3FDLEVBQUUsQ0FBQ3JDLEtBQUQsQ0FEWCxNQUVPLElBQUksQ0FBQ3FDLEVBQUUsQ0FBQzR2Qyx3QkFBSCxDQUE0Qmp5QyxLQUE1QixDQUFMLEVBQXlDO0FBQUEsY0FDekNxMEMsT0FBTyxHQUFNN3pELFVBQU4sZUFBMEJFLEVBRFE7QUFBQSxjQUV6Q3l6RCxhQUFhLEdBQUc5eEMsRUFBRSxDQUFDOHhDLGFBQUgsQ0FBaUJFLE9BQWpCLENBRnlCO0FBUS9DLGNBSklGLGFBQWEsQ0FBQ2wwRCxJQUFkLEtBQXVCLENBSTNCLElBSENvaUIsRUFBRSxDQUFDZ3hDLG1CQUFILENBQXVCcnpDLEtBQXZCLEVBQThCcTBDLE9BQTlCLENBR0QsRUFBSXBLLE1BQU0sS0FBSyxRQUFmLEVBQ0MsT0FBTzVuQyxFQUFFLENBQUNpeUMsTUFBSCxDQUFVbHZDLE1BQVYsQ0FBaUJJLElBQWpCLENBQXNCdzdCLE9BQXRCLGlCQUErQnROLE9BQS9CLEVBQXdDMmdCLE9BQXhDLFNBQW9EdmtELElBQXBELEVBQVA7QUFDTSxjQUFJbTZDLE1BQU0sS0FBSyxRQUFmLEVBQ04sT0FBTzVuQyxFQUFFLENBQUNpeUMsTUFBSCxDQUFVN1EsTUFBVixDQUFpQmorQixJQUFqQixDQUFzQnc3QixPQUF0QixpQkFBK0J0TixPQUEvQixTQUEyQzVqQyxJQUEzQyxFQUFQO0FBRUQ7QUFFRCxlQUFPa1EsS0FBSyxDQUFDaXFDLE1BQUQsQ0FBTCxDQUFjemtDLElBQWQsQ0FBbUJ3N0IsT0FBbkIsaUJBQTRCdE4sT0FBNUIsU0FBd0M1akMsSUFBeEMsRUFBUDtBQUNBLE9BMUJEO0FBMkJBLEtBNUJEO0FBNkJBLEdBcFdhO0FBc1dkeWtELG1CQXRXYywrQkFzV007QUFDbkIsV0FBT25pRCxTQUFTLEVBQWhCO0FBQ0EsR0F4V2E7QUEwV2RraUQsUUFBTSxFQUFFO0FBQ1BsdkMsVUFETyxrQkFDQXN1QixPQURBLEVBQ1NoekMsRUFEVCxFQUNhOHpELE1BRGIsRUFDcUJDLFdBRHJCLEVBQ2tDO0FBQ3hDLGFBQU8vZ0IsT0FBTyxDQUFDM2lDLE1BQVIsQ0FBZSxLQUFmLEVBQ0xDLElBREssQ0FDQSxZQURBLFFBQ2tCdFEsRUFEbEIsRUFFTHNRLElBRkssQ0FFQSxPQUZBLEVBRVMsS0FBS3V2QyxnQkFBTCxDQUFzQi82QixJQUF0QixDQUEyQixJQUEzQixDQUZULEVBR0w0QixLQUhLLENBR0MsTUFIRCxFQUdTcXRDLFdBSFQsRUFJTHJrRCxJQUpLLEVBQVA7QUFLQSxLQVBNO0FBU1BxekMsVUFUTyxrQkFTQS9QLE9BVEEsRUFTU2doQixNQVRULEVBU2lCQyxNQVRqQixFQVN5QkYsV0FUekIsRUFVTnBrQyxjQVZNLEVBVVUwQixJQVZWLEVBVWdCdjFCLGVBVmhCLEVBVWlDO0FBQ2pDLFVBQUE2bEIsRUFBRSxHQUFHLElBQUw7QUFBQSxrQ0FDa0JxeEIsT0FBTyxDQUFDdGpDLElBQVIsR0FBZWMsT0FBZixFQURsQjtBQUFBLFVBQ0MxUyxLQURELHlCQUNDQSxLQUREO0FBQUEsVUFDUUUsTUFEUix5QkFDUUEsTUFEUjtBQUFBLFVBR0FrMkQsT0FIQSxHQUdVLFVBQUF6bUQsQ0FBQztBQUFBLGVBQUl1bUQsTUFBTSxDQUFDdm1ELENBQUQsQ0FBTixHQUFZM1AsS0FBSyxHQUFHLENBQXhCO0FBQUEsT0FIWDtBQUFBLFVBS0ZzMEQsV0FMRSxHQUtZcGYsT0FMWjs7QUFPTixVQUFJcmpCLGNBQUosRUFBb0I7QUFDbkIsWUFBTXdrQyxjQUFjLEdBQUd4eUMsRUFBRSxDQUFDa3lDLGlCQUFILEVBQXZCO0FBRUF4aUMsWUFBSSxJQUFJK2dDLFdBQVcsQ0FBQzloRCxJQUFaLENBQWlCLEdBQWpCLEVBQXNCNGpELE9BQXRCLENBSFcsRUFLbkI5QixXQUFXLEdBQUdBLFdBQVcsQ0FBQ3h1QyxVQUFaLENBQXVCdXdDLGNBQXZCLENBTEssRUFNbkJyNEQsZUFBZSxDQUFDOG5CLFVBQWhCLENBQTJCakMsRUFBRSxDQUFDa3lDLGlCQUFILEVBQTNCLENBTm1CO0FBT25COztBQUVELGFBQU96QixXQUFXLENBQ2hCOWhELElBREssQ0FDQSxHQURBLEVBQ0s0akQsT0FETCxFQUVMNWpELElBRkssQ0FFQSxHQUZBLEVBWlMsaUJBQUE3QyxDQUFDO0FBQUEsZUFBSXdtRCxNQUFNLENBQUN4bUQsQ0FBRCxDQUFOLEdBQVl6UCxNQUFNLEdBQUcsQ0FBekI7QUFBQSxPQVlWLEVBR0wwb0IsS0FISyxDQUdDLE1BSEQsRUFHU3F0QyxXQUhULENBQVA7QUFJQTtBQS9CTSxHQTFXTTtBQTRZZDtBQUNBOTVELFFBQU0sRUFBRTtBQUNQeXFCLFVBRE8sa0JBQ0FzdUIsT0FEQSxFQUNTOGdCLE1BRFQsRUFDaUJDLFdBRGpCLEVBQzhCO0FBQ3BDLGFBQU8vZ0IsT0FBTyxDQUFDM2lDLE1BQVIsQ0FBZSxRQUFmLEVBQ0xDLElBREssQ0FDQSxPQURBLEVBQ1MsS0FBS3V2QyxnQkFBTCxDQUFzQi82QixJQUF0QixDQUEyQixJQUEzQixDQURULEVBRUx4VSxJQUZLLENBRUEsR0FGQSxFQUVLd2pELE1BRkwsRUFHTHB0QyxLQUhLLENBR0MsTUFIRCxFQUdTcXRDLFdBSFQsRUFJTHJrRCxJQUpLLEVBQVA7QUFLQSxLQVBNO0FBU1BxekMsVUFUTyxrQkFTQS9QLE9BVEEsRUFTU2doQixNQVRULEVBU2lCQyxNQVRqQixFQVN5QkYsV0FUekIsRUFVTnBrQyxjQVZNLEVBVVUwQixJQVZWLEVBVWdCdjFCLGVBVmhCLEVBVWlDO0FBQUEsVUFDakM2bEIsRUFBRSxHQUFHLElBRDRCO0FBQUEsVUFFbkN5d0MsV0FBVyxHQUFHcGYsT0FGcUI7O0FBU3ZDLFVBSklyeEIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLFFBQVgsQ0FJSixJQUhDdTZCLFdBQVcsQ0FBQzloRCxJQUFaLENBQWlCLEdBQWpCLEVBQXNCcVIsRUFBRSxDQUFDb3NCLE1BQUgsQ0FBVWpwQixJQUFWLENBQWVuRCxFQUFmLENBQXRCLENBR0QsRUFBSWdPLGNBQUosRUFBb0I7QUFDbkIsWUFBTXdrQyxjQUFjLEdBQUd4eUMsRUFBRSxDQUFDa3lDLGlCQUFILEVBQXZCO0FBRUF4aUMsWUFBSSxJQUFJK2dDLFdBQVcsQ0FBQzloRCxJQUFaLENBQWlCLElBQWpCLEVBQXVCMGpELE1BQXZCLENBSFcsRUFLZjVCLFdBQVcsQ0FBQzloRCxJQUFaLENBQWlCLElBQWpCLENBTGUsS0FNbEI4aEQsV0FBVyxHQUFHQSxXQUFXLENBQUN4dUMsVUFBWixDQUF1QnV3QyxjQUF2QixDQU5JLEdBU25CcjRELGVBQWUsQ0FBQzhuQixVQUFoQixDQUEyQmpDLEVBQUUsQ0FBQ2t5QyxpQkFBSCxFQUEzQixDQVRtQjtBQVVuQjs7QUFFRCxhQUFPekIsV0FBVyxDQUNoQjloRCxJQURLLENBQ0EsSUFEQSxFQUNNMGpELE1BRE4sRUFFTDFqRCxJQUZLLENBRUEsSUFGQSxFQUVNMmpELE1BRk4sRUFHTHZ0QyxLQUhLLENBR0MsTUFIRCxFQUdTcXRDLFdBSFQsQ0FBUDtBQUlBO0FBbkNNLEdBN1lNO0FBbWJkO0FBQ0FLLFdBQVMsRUFBRTtBQUNWMXZDLFVBRFUsa0JBQ0hzdUIsT0FERyxFQUNNOGdCLE1BRE4sRUFDY0MsV0FEZCxFQUMyQjtBQUNwQyxVQUFNTSxVQUFVLEdBQUcsVUFBQTVtRCxDQUFDO0FBQUEsZUFBSXFtRCxNQUFNLENBQUNybUQsQ0FBRCxDQUFOLEdBQVksQ0FBaEI7QUFBQSxPQUFwQjs7QUFFQSxhQUFPdWxDLE9BQU8sQ0FBQzNpQyxNQUFSLENBQWUsTUFBZixFQUNMQyxJQURLLENBQ0EsT0FEQSxFQUNTLEtBQUt1dkMsZ0JBQUwsQ0FBc0IvNkIsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FEVCxFQUVMeFUsSUFGSyxDQUVBLE9BRkEsRUFFUytqRCxVQUZULEVBR0wvakQsSUFISyxDQUdBLFFBSEEsRUFHVStqRCxVQUhWLEVBSUwzdEMsS0FKSyxDQUlDLE1BSkQsRUFJU3F0QyxXQUpULEVBS0xya0QsSUFMSyxFQUFQO0FBTUEsS0FWUztBQVlWcXpDLFVBWlUsa0JBWUgvUCxPQVpHLEVBWU1naEIsTUFaTixFQVljQyxNQVpkLEVBWXNCRixXQVp0QixFQWFUcGtDLGNBYlMsRUFhTzBCLElBYlAsRUFhYXYxQixlQWJiLEVBYThCO0FBQUEsVUFDakM2bEIsRUFBRSxHQUFHLElBRDRCO0FBQUEsVUFFakNxRyxDQUFDLEdBQUdyRyxFQUFFLENBQUNySyxNQUFILENBQVUyQixPQUZtQjtBQUFBLFVBR2pDcTdDLFVBQVUsR0FBRyxVQUFBN21ELENBQUM7QUFBQSxlQUFJdW1ELE1BQU0sQ0FBQ3ZtRCxDQUFELENBQU4sR0FBWXVhLENBQWhCO0FBQUEsT0FIbUI7QUFBQSxVQU1uQ29xQyxXQUFXLEdBQUdwZixPQU5xQjs7QUFRdkMsVUFBSXJqQixjQUFKLEVBQW9CO0FBQ25CLFlBQU13a0MsY0FBYyxHQUFHeHlDLEVBQUUsQ0FBQ2t5QyxpQkFBSCxFQUF2QjtBQUVBeGlDLFlBQUksSUFBSStnQyxXQUFXLENBQUM5aEQsSUFBWixDQUFpQixHQUFqQixFQUFzQmdrRCxVQUF0QixDQUhXLEVBS25CbEMsV0FBVyxHQUFHQSxXQUFXLENBQUN4dUMsVUFBWixDQUF1QnV3QyxjQUF2QixDQUxLLEVBTW5CcjRELGVBQWUsQ0FBQzhuQixVQUFoQixDQUEyQmpDLEVBQUUsQ0FBQ2t5QyxpQkFBSCxFQUEzQixDQU5tQjtBQU9uQjs7QUFFRCxhQUFPekIsV0FBVyxDQUNoQjloRCxJQURLLENBQ0EsR0FEQSxFQUNLZ2tELFVBREwsRUFFTGhrRCxJQUZLLENBRUEsR0FGQSxFQWJZLG9CQUFBN0MsQ0FBQztBQUFBLGVBQUl3bUQsTUFBTSxDQUFDeG1ELENBQUQsQ0FBTixHQUFZdWEsQ0FBaEI7QUFBQSxPQWFiLEVBR0x0QixLQUhLLENBR0MsTUFIRCxFQUdTcXRDLFdBSFQsQ0FBUDtBQUlBO0FBbENTO0FBcGJHLENBQWYsRTs7QUNiQTs7OztBQUlBO0FBb0JBO0FBQ0E7QUFDQTtBQUVlO0FBQ2Q7Ozs7O0FBS0FRLGNBTmMsMEJBTUM7QUFDUixRQUFBNXlDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQStILFNBREEsR0FDWS9ILEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVWMsWUFEdEI7QUFBQSxRQUVDbzhDLFFBRkQsR0FFYTd5QyxFQUZiLENBRUM2eUMsUUFGRDtBQUFBLFFBR0F6NEQsS0FIQSxHQUdRO0FBQUNxVixVQUFJLEVBQUUsRUFBUDtBQUFXaWlDLGFBQU8sRUFBRSxFQUFwQjtBQUF3QjFyQixTQUFHLEVBQUU7QUFBN0IsS0FIUjs7QUFLTjtBQUNBLFFBQUloRyxFQUFFLENBQUNvM0IsU0FBSCxDQUFhLE1BQWIsS0FBd0JwM0IsRUFBRSxDQUFDa1csT0FBSCxDQUFXLFFBQVgsQ0FBeEIsSUFBZ0RsVyxFQUFFLENBQUNrVyxPQUFILENBQVcsU0FBWCxDQUFwRCxFQUEyRTtBQUMxRSxVQUFNd2IsT0FBTyxHQUFHMXhCLEVBQUUsQ0FBQzJ3QyxlQUFILENBQW1CM3dDLEVBQUUsQ0FBQ3d5QixVQUF0QixDQUFoQjs7QUFLQSxVQUhBcDRDLEtBQUssQ0FBQ3MzQyxPQUFOLENBQWM1M0MsSUFBZCxHQUFxQjQzQyxPQUdyQixFQUZBdDNDLEtBQUssQ0FBQ3FWLElBQU4sQ0FBVzNWLElBQVgsR0FBa0JrbUIsRUFBRSxDQUFDb3NDLGdCQUFILEdBQXNCcHNDLEVBQUUsQ0FBQ29zQyxnQkFBSCxDQUFvQjFhLE9BQXBCLEtBQXRCLEdBQTREanhDLFNBRTlFLEVBQUl1ZixFQUFFLENBQUNvM0IsU0FBSCxDQUFhLE1BQWIsQ0FBSixFQUEwQjtBQUN6QixZQUFNMUYsUUFBTyxHQUFHMXhCLEVBQUUsQ0FBQzJ3QyxlQUFILENBQW1CM3dDLEVBQUUsQ0FBQ2d5QixVQUF0QixDQUFoQjs7QUFFQTUzQyxhQUFLLENBQUNzM0MsT0FBTixDQUFjcDdDLElBQWQsR0FBcUJvN0MsUUFISSxFQUl6QnQzQyxLQUFLLENBQUNxVixJQUFOLENBQVduWixJQUFYLEdBQWtCMHBCLEVBQUUsQ0FBQ2t2QyxnQkFBSCxHQUFzQmx2QyxFQUFFLENBQUNrdkMsZ0JBQUgsQ0FBb0J4ZCxRQUFwQixLQUF0QixHQUE0RGp4QyxTQUpyRDtBQUt6QjtBQUNEOztBQUVELFFBQUl1ZixFQUFFLENBQUNrVyxPQUFILENBQVcsS0FBWCxDQUFKLEVBQXVCO0FBQ3RCLFVBQU13YixTQUFPLEdBQUcxeEIsRUFBRSxDQUFDMndDLGVBQUgsQ0FBbUIzd0MsRUFBRSxDQUFDa2IsU0FBdEIsQ0FBaEI7O0FBRUE5Z0MsV0FBSyxDQUFDczNDLE9BQU4sQ0FBYzM2QyxHQUFkLEdBQW9CMjZDLFNBSEUsRUFJdEJ0M0MsS0FBSyxDQUFDcVYsSUFBTixDQUFXMVksR0FBWCxHQUFpQmlwQixFQUFFLENBQUNncEMsZUFBSCxHQUFxQmhwQyxFQUFFLENBQUNncEMsZUFBSCxDQUFtQnRYLFNBQW5CLENBQXJCLEdBQW1EanhDLFNBSjlDO0FBS3RCOztBQWFELFlBWEksQ0FBQ3VmLEVBQUUsQ0FBQ21RLFVBQUgsRUFBRCxJQUFvQjBpQyxRQVd4QixNQVZDejRELEtBQUssQ0FBQzRyQixHQUFOLEdBQVk7QUFDWG8zQixjQUFRLEVBQUVwOUIsRUFBRSxDQUFDeXhCLGlCQUFILENBQXFCcjNDLEtBQUssQ0FBQ3MzQyxPQUEzQixLQURDO0FBRVhsckIsY0FBUSxFQUFFeEcsRUFBRSxDQUFDeXhCLGlCQUFILENBQXFCcjNDLEtBQUssQ0FBQ3MzQyxPQUEzQixLQUZDO0FBSVg7QUFDQXdMLFFBQUUsRUFBRSxDQUFDMlYsUUFBUSxHQUFHN3lDLEVBQUUsQ0FBQzh5QyxZQUFOLEdBQXNCL3FDLFNBQVMsR0FBRy9ILEVBQUUsQ0FBQ3diLE9BQU4sR0FBZ0J4YixFQUFFLENBQUN5bkMsT0FBM0QsRUFBcUV0a0MsSUFBckUsQ0FBMEVuRCxFQUExRSxDQUxPO0FBTVhtOUIsUUFBRSxFQUFFLENBQUMwVixRQUFRLEdBQUc3eUMsRUFBRSxDQUFDK3lDLFlBQU4sR0FBc0JockMsU0FBUyxHQUFHL0gsRUFBRSxDQUFDeW5DLE9BQU4sR0FBZ0J6bkMsRUFBRSxDQUFDd2IsT0FBM0QsRUFBcUVyWSxJQUFyRSxDQUEwRW5ELEVBQTFFO0FBTk8sS0FVYixHQUFPNWxCLEtBQVA7QUFDQSxHQTlDYTtBQWdEZHUyRCxpQkFoRGMsMkJBZ0RFcUMsVUFoREYsRUFnRGM7QUFDckIsUUFBQWh6QyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQTJlLEVBRkEsR0FFSzNlLE1BQU0sQ0FBQy9RLE9BRlo7QUFBQSxRQUdBcXVELEtBSEEsR0FHUTNtRCxRQUFRLENBQUNnb0IsRUFBRCxDQUhoQjtBQUFBLFFBSUFvZCxPQUpBLEdBSVUsRUFKVjtBQUFBLFFBS0ZqakMsQ0FMRSxHQUtPd2tELEtBQUssR0FBRyxFQUFILEdBQVEsQ0FMcEI7QUF1Q04sV0FoQ0lBLEtBZ0NKLElBL0JDL2dELFNBQVMsQ0FBQy9GLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZa29CLEVBQVosRUFBZ0JsbUIsR0FBaEIsQ0FBb0IsVUFBQW5ELENBQUM7QUFBQSxhQUFJcXBCLEVBQUUsQ0FBQ3JwQixDQUFELENBQU47QUFBQSxLQUFyQixDQUFELENBQVQsQ0FDRW9DLE9BREYsQ0FDVSxVQUFBcEMsQ0FBQyxFQUFJO0FBQ2J3RCxPQUFDLENBQUN4RCxDQUFELENBQUQsR0FBTyxDQURNLEVBRWJ5bUMsT0FBTyxDQUFDem1DLENBQUQsQ0FBUCxHQUFhLEVBRkE7QUFHYixLQUpGLENBK0JELEVBeEJBK1UsRUFBRSxDQUFDNE4sbUJBQUgsQ0FBdUI1TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCdk4sTUFBaEIsQ0FBdUIwZ0QsVUFBdkIsRUFBbUNoekMsRUFBbkMsQ0FBdkIsRUFDRTNTLE9BREYsQ0FDVSxVQUFBdkIsQ0FBQyxFQUFJO0FBSWIsZUFBZ0JzdEMsTUFBaEIsRUFITTdrQixJQUFJLEdBQUcsQ0FBQXpvQixDQUFDLENBQUN6TixFQUFGLElBQVFpMkIsRUFBUixJQUFhQSxFQUFFLENBQUN4b0IsQ0FBQyxDQUFDek4sRUFBSCxDQUFmLEdBQXdCLEVBR3JDLEVBRk02MEQsR0FBRyxHQUFHMytCLElBQUksR0FBR21kLE9BQU8sQ0FBQ25kLElBQUQsQ0FBVixHQUFtQm1kLE9BRW5DLEVBQVM1ZCxDQUFDLEdBQUcsQ0FBYixFQUF5QnNsQixNQUFNLEdBQUd6akMsTUFBTSxDQUFDM1EsV0FBUCxDQUFtQjh1QixDQUFuQixDQUFsQyxFQUEwREEsQ0FBQyxFQUEzRCxFQUNDLE1BQUlzbEIsTUFBTSxDQUFDbHJDLE9BQVAsQ0FBZXBDLENBQUMsQ0FBQ3pOLEVBQWpCLElBQXVCLENBQTNCLEdBSUEsS0FBSyxJQUFXdzFCLEtBQVgsRUFBSUQsR0FBQyxHQUFHLENBQWIsRUFBc0JDLEtBQUcsR0FBR3VsQixNQUFNLENBQUN4bEIsR0FBRCxDQUFsQyxFQUF3Q0EsR0FBQyxFQUF6QyxFQUNDLElBQUlDLEtBQUcsSUFBSXEvQixHQUFYLEVBQWdCO0FBQ2ZBLFdBQUcsQ0FBQ3BuRCxDQUFDLENBQUN6TixFQUFILENBQUgsR0FBWTYwRCxHQUFHLENBQUNyL0IsS0FBRCxDQURBO0FBRWY7QUFDQTs7QUFJQ3hvQixpQkFBVyxDQUFDNm5ELEdBQUcsQ0FBQ3BuRCxDQUFDLENBQUN6TixFQUFILENBQUosQ0FqQkYsS0FrQlo2MEQsR0FBRyxDQUFDcG5ELENBQUMsQ0FBQ3pOLEVBQUgsQ0FBSCxHQUFZazJCLElBQUksR0FBRzlsQixDQUFDLENBQUM4bEIsSUFBRCxDQUFELEVBQUgsR0FBZTlsQixDQUFDLEVBbEJwQixFQW1CWnlrRCxHQUFHLENBQUNDLE9BQUosR0FBYyxDQUFDNStCLElBQUksR0FBRzlsQixDQUFDLENBQUM4bEIsSUFBRCxDQUFKLEdBQWE5bEIsQ0FBbEIsSUFBdUIsQ0FuQnpCO0FBcUJiLEtBdEJGLENBd0JBLEVBQU9pakMsT0FBUDtBQUNBLEdBekZhOztBQTJGZDs7Ozs7OztBQU9BMGhCLFlBbEdjLHNCQWtHSDFoQixPQWxHRyxFQWtHTXJ6QyxFQWxHTixFQWtHVTtBQUN2QixRQUFNaTJCLEVBQUUsR0FBRyxLQUFLM2UsTUFBTCxDQUFZL1EsT0FBdkI7QUFFQSxXQUFPMEgsUUFBUSxDQUFDZ29CLEVBQUQsQ0FBUixHQUNOb2QsT0FBTyxDQUFDcGQsRUFBRSxDQUFDajJCLEVBQUQsQ0FBSCxDQURELEdBQ1lxekMsT0FEbkI7QUFFQSxHQXZHYTs7QUF5R2Q7Ozs7OztBQU1BbVksZUEvR2MseUJBK0dBblksT0EvR0EsRUErR1M7QUFDdEIsV0FBT3BsQyxRQUFRLENBQUMsS0FBS3FKLE1BQUwsQ0FBWS9RLE9BQWIsQ0FBUixHQUNOO0FBQ0F1SCxVQUFNLENBQUNDLElBQVAsQ0FBWXNsQyxPQUFaLEVBQ0V0akMsR0FERixDQUNNLFVBQUFuRCxDQUFDO0FBQUEsYUFBSXltQyxPQUFPLENBQUN6bUMsQ0FBRCxDQUFQLENBQVdrb0QsT0FBWCxJQUFzQixDQUExQjtBQUFBLEtBRFAsRUFFRTNnRCxNQUZGLENBRVMsVUFBQ3FxQixHQUFELEVBQU1DLElBQU47QUFBQSxhQUFlRCxHQUFHLEdBQUdDLElBQXJCO0FBQUEsS0FGVCxDQUZNLEdBSWdDNFUsT0FBTyxDQUFDeWhCLE9BSi9DO0FBS0EsR0FySGE7QUF1SGRwSixXQXZIYyxxQkF1SEpuZCxNQXZISSxFQXVISThFLE9BdkhKLEVBdUhhd1gsS0F2SGIsRUF1SG9CO0FBQzNCLFFBQUFscEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNrQnFLLEVBRGxCLENBQ0NySyxNQUREO0FBQUEsUUFDUzBLLEtBRFQsR0FDa0JMLEVBRGxCLENBQ1NLLEtBRFQ7QUFBQSxRQUVBZ25DLFNBRkEsR0FFWTZCLEtBQUssR0FBRzdvQyxLQUFLLENBQUNxSCxJQUFULEdBQWlCckgsS0FBSyxDQUFDekMsSUFBTixJQUFjeUMsS0FBSyxDQUFDMWlCLENBRnREO0FBQUEsUUFHQTAxRCxVQUhBLEdBR2ExOUMsTUFBTSxDQUFDcUQsV0FIcEI7QUFBQSxRQUlBMmUsR0FKQSxHQUlNLFVBQUNwbkIsQ0FBRCxFQUFJeUIsQ0FBSjtBQUFBLGFBQVV6QixDQUFDLEdBQUd5QixDQUFkO0FBQUEsS0FKTjtBQUFBLFFBS0FzaEQsU0FMQSxHQUtZdm5ELFlBQVksQ0FBQzZnQyxNQUFELENBQVosSUFBd0JBLE1BQU0sQ0FBQzlVLEtBQVAsQ0FBYTdyQixNQUFyQyxHQUE4QzJnQyxNQUFNLENBQUM5VSxLQUFQLENBQWF0bEIsTUFBYixDQUFvQm1sQixHQUFwQixJQUEyQixDQUF6RSxHQUE2RSxDQUx6Rjs7QUFPTixXQUFPLFVBQUE3ckIsQ0FBQyxFQUFJO0FBQUEsVUFDTG9uRCxHQUFHLEdBQUdsekMsRUFBRSxDQUFDb3pDLFVBQUgsQ0FBYzFoQixPQUFkLEVBQXVCNWxDLENBQUMsQ0FBQ3pOLEVBQXpCLENBREQ7QUFBQSxVQUVMZ25CLEtBQUssR0FBR3ZaLENBQUMsQ0FBQ3pOLEVBQUYsSUFBUTYwRCxHQUFSLEdBQWNBLEdBQUcsQ0FBQ3BuRCxDQUFDLENBQUN6TixFQUFILENBQWpCLEdBQTBCLENBRjdCO0FBQUEsVUFHTGsxRCxVQUFVLEdBQUcsQ0FBQ0wsR0FBRyxDQUFDQyxPQUFKLElBQWUsQ0FBaEIsSUFBcUIsQ0FIN0I7QUFBQSxVQUlQeDFELENBQUMsR0FBRyxDQUpHOztBQU1YLFVBQUkyTyxRQUFRLENBQUNSLENBQUMsQ0FBQ25PLENBQUgsQ0FBWixFQUFtQjtBQUNsQixZQUFNMDBDLElBQUksR0FBR2dWLFNBQVMsQ0FBQ3Y3QyxDQUFDLENBQUNuTyxDQUFILENBQXRCO0FBR0NBLFNBSmlCLEdBR2QyMUQsU0FIYyxHQUliamhCLElBQUksSUFBSXpGLE1BQU0sQ0FBQzlnQyxDQUFDLENBQUN6TixFQUFILENBQU4sSUFBZ0J1dUMsTUFBTSxDQUFDendDLEtBQTNCLENBQUosR0FDSHl3QyxNQUFNLENBQUM5VSxLQUFQLENBQWFsbkIsS0FBYixDQUFtQixDQUFuQixFQUFzQnlVLEtBQUssR0FBRyxDQUE5QixFQUFpQzdTLE1BQWpDLENBQXdDbWxCLEdBQXhDLENBREcsR0FFSDI3QixTQU5nQixHQVFiamhCLElBQUksR0FBRyxDQUFDam5DLFFBQVEsQ0FBQ3doQyxNQUFELENBQVIsR0FBbUJBLE1BQW5CLEdBQTRCQSxNQUFNLENBQUN6d0MsS0FBcEMsS0FBOENvM0QsVUFBVSxHQUFHLENBQWIsR0FBaUJsdUMsS0FBL0QsQ0FSTTtBQVVsQixPQWhCVSxDQWtCWDs7O0FBYUEsYUFaSXVuQixNQUFNLElBQUlqdkMsQ0FBVixJQUFlNDFELFVBQVUsR0FBRyxDQUE1QixJQUFpQ0YsVUFZckMsS0FYS2h1QyxLQVdMLEtBVkUxbkIsQ0FBQyxJQUFJMDFELFVBQVUsR0FBR2h1QyxLQVVwQixHQVBLa3VDLFVBQVUsR0FBRyxDQU9sQixHQU5FNTFELENBQUMsSUFBSSxDQUFDNDFELFVBQVUsR0FBRyxDQUFkLElBQW1CRixVQUFuQixHQUFnQyxDQU12QyxHQUxZRSxVQUFVLEtBQUssQ0FLM0IsS0FKRTUxRCxDQUFDLElBQUkwMUQsVUFBVSxHQUFHLENBSXBCLElBQU8xMUQsQ0FBUDtBQUNBLEtBaENEO0FBaUNBLEdBaEthO0FBa0tkc3NELFdBbEtjLHFCQWtLSmYsS0FsS0ksRUFrS0c7QUFBQSxRQUNWbHBDLEVBQUUsR0FBRyxJQURLO0FBQUEsUUFFVmdLLGlCQUFpQixHQUFHaEssRUFBRSxDQUFDZ0ssaUJBQUgsRUFGVjtBQUloQixXQUFPLFVBQUFsZSxDQUFDLEVBQUk7QUFDWCxVQUFNcUIsS0FBSyxHQUFHNmMsaUJBQWlCLEdBQUdoSyxFQUFFLENBQUNvYyxRQUFILENBQVksT0FBWixFQUFxQnR3QixDQUFyQixLQUFILEdBQzlCa1UsRUFBRSxDQUFDZ1gsYUFBSCxDQUFpQmxyQixDQUFqQixJQUFzQmtVLEVBQUUsQ0FBQ2lYLGNBQUgsQ0FBa0JuckIsQ0FBQyxDQUFDcUIsS0FBcEIsRUFBMkIsR0FBM0IsQ0FBdEIsR0FBd0RyQixDQUFDLENBQUNxQixLQUQzRDtBQUlBLGFBQU8sQ0FBQys3QyxLQUFLLEdBQUdscEMsRUFBRSxDQUFDb3RCLFlBQUgsQ0FBZ0J0aEMsQ0FBQyxDQUFDek4sRUFBbEIsQ0FBSCxHQUEyQjJoQixFQUFFLENBQUNtdEIsU0FBSCxDQUFhcmhDLENBQUMsQ0FBQ3pOLEVBQWYsQ0FBakMsRUFBcUQ4TyxLQUFyRCxDQUFQO0FBQ0EsS0FORDtBQU9BLEdBN0thOztBQStLZDs7Ozs7O0FBTUFxbUQsb0JBckxjLDhCQXFMS1IsVUFyTEwsRUFxTGlCO0FBQUEsUUFDeEJoekMsRUFBRSxHQUFHLElBRG1CO0FBQUEsUUFFeEJILE9BQU8sR0FBR0csRUFBRSxDQUFDc1osWUFBSCxDQUFnQnRaLEVBQUUsQ0FBQzROLG1CQUFILENBQXVCNU4sRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQnZOLE1BQWhCLENBQXVCMGdELFVBQXZCLEVBQW1DaHpDLEVBQW5DLENBQXZCLENBQWhCLENBRmM7QUFBQSxRQUd4Qnl6QyxrQkFBa0IsR0FBRzV6QyxPQUFPLENBQUN6UixHQUFSLENBQVksVUFBQXpULE1BQU0sRUFBSTtBQUNoRCxVQUFJKzRELFNBQVMsR0FBRy80RCxNQUFNLENBQUN1bEIsTUFBdkI7QUFFSUYsUUFBRSxDQUFDeTNCLFVBQUgsQ0FBYzk4QyxNQUFkLENBSDRDLEtBSS9DKzRELFNBQVMsR0FBRzF6QyxFQUFFLENBQUMyYixtQkFBSCxDQUF1QiszQixTQUF2QixDQUptQztBQUFBLFVBTTFDQyxtQkFBbUIsR0FBR0QsU0FBUyxDQUFDbGhELE1BQVYsQ0FBaUIsVUFBQzJxQixHQUFELEVBQU1od0IsS0FBTixFQUFnQjtBQUU1RCxlQURBZ3dCLEdBQUcsRUFBUWh3QixLQUFLLENBQUN4UCxDQUFkLENBQUgsR0FBdUJ3UCxLQUN2QixFQUFPZ3dCLEdBQVA7QUFDQSxPQUgyQixFQUd6QixFQUh5QixDQU5vQjtBQUFBLFVBVzFDamQsTUFBTSxHQUFHd3pDLFNBQVMsQ0FBQ3RsRCxHQUFWLENBQ2Q0UixFQUFFLENBQUNnSyxpQkFBSCxLQUNDLFVBQUEvZSxDQUFDO0FBQUEsZUFBSStVLEVBQUUsQ0FBQ29jLFFBQUgsQ0FBWSxPQUFaLEVBQXFCbnhCLENBQXJCLEtBQUo7QUFBQSxPQURGLEdBRUM7QUFBQSxZQUFFa0MsS0FBRixRQUFFQSxLQUFGO0FBQUEsZUFBYUEsS0FBYjtBQUFBLE9BSGEsQ0FYaUM7QUFpQmhELGFBQU87QUFDTjlPLFVBQUUsRUFBRTFELE1BQU0sQ0FBQzBELEVBREw7QUFFTnExRCxpQkFBUyxFQUFUQSxTQUZNO0FBR05DLDJCQUFtQixFQUFuQkEsbUJBSE07QUFJTnp6QyxjQUFNLEVBQU5BO0FBSk0sT0FBUDtBQU1BLEtBdkIwQixDQUhHO0FBQUEsUUEyQnhCMHpDLGtCQUFrQixHQUFHL3pDLE9BQU8sQ0FBQ3JOLE1BQVIsQ0FBZSxVQUFDMnFCLEdBQUQsU0FBWTlYLEtBQVosRUFBc0I7QUFBQSxVQUFmaG5CLEVBQWUsU0FBZkEsRUFBZTtBQUUvRCxhQURBOCtCLEdBQUcsQ0FBQzkrQixFQUFELENBQUgsR0FBVWduQixLQUNWLEVBQU84WCxHQUFQO0FBQ0EsS0FIMEIsRUFHeEIsRUFId0IsQ0EzQkc7QUFnQzlCLFdBQU87QUFBQ3kyQix3QkFBa0IsRUFBbEJBLGtCQUFEO0FBQXFCSCx3QkFBa0IsRUFBbEJBO0FBQXJCLEtBQVA7QUFDQSxHQXROYTtBQXdOZHRKLGdCQXhOYywwQkF3TkM2SSxVQXhORCxFQXdOYXRoQixPQXhOYixFQXdOc0J3WCxLQXhOdEIsRUF3TjZCO0FBQ3BDLFFBQUFscEMsRUFBRSxHQUFHLElBQUw7QUFBQSxnQ0FDMkNBLEVBQUUsQ0FBQ3d6QyxrQkFBSCxDQUFzQlIsVUFBdEIsQ0FEM0M7QUFBQSxRQUNDUyxrQkFERCx5QkFDQ0Esa0JBREQ7QUFBQSxRQUNxQkcsa0JBRHJCLHlCQUNxQkEsa0JBRHJCOztBQUdOLFdBQU8sVUFBQzluRCxDQUFELEVBQUltZ0MsR0FBSixFQUFZO0FBQUEsVUFDWmluQixHQUFHLEdBQUdsekMsRUFBRSxDQUFDb3pDLFVBQUgsQ0FBYzFoQixPQUFkLEVBQXVCNWxDLENBQUMsQ0FBQ3pOLEVBQXpCLENBRE07QUFBQSxVQUVaZ2lCLEtBQUssR0FBRzZvQyxLQUFLLEdBQUdscEMsRUFBRSxDQUFDb3RCLFlBQUgsQ0FBZ0J0aEMsQ0FBQyxDQUFDek4sRUFBbEIsQ0FBSCxHQUEyQjJoQixFQUFFLENBQUNtdEIsU0FBSCxDQUFhcmhDLENBQUMsQ0FBQ3pOLEVBQWYsQ0FGNUI7QUFBQSxVQUdaZ3NELEVBQUUsR0FBR2hxQyxLQUFLLENBQUMsQ0FBRCxDQUhFO0FBQUEsVUFJWnd6QyxhQUFhLElBQVUvbkQsQ0FBQyxDQUFDbk8sQ0FKYjtBQUFBLFVBS2RpdkMsTUFBTSxHQUFHeWQsRUFMSztBQThCbEIsYUF2QkFvSixrQkFBa0IsQ0FDaEJwbUQsT0FERixDQUNVLFVBQUFtYSxDQUFDLEVBQUk7QUFBQSxZQUNQa3NDLFNBQVMsR0FBR2xzQyxDQUFDLENBQUNrc0MsU0FEUDtBQUFBLFlBRVB4ekMsTUFBTSxHQUFHc0gsQ0FBQyxDQUFDdEgsTUFGSjs7QUFJYixZQUFJc0gsQ0FBQyxDQUFDbnBCLEVBQUYsS0FBU3lOLENBQUMsQ0FBQ3pOLEVBQVgsSUFBaUI2MEQsR0FBRyxDQUFDMXJDLENBQUMsQ0FBQ25wQixFQUFILENBQUgsS0FBYzYwRCxHQUFHLENBQUNwbkQsQ0FBQyxDQUFDek4sRUFBSCxDQUF0QyxJQUlJdTFELGtCQUFrQixDQUFDcHNDLENBQUMsQ0FBQ25wQixFQUFILENBQWxCLEdBQTJCdTFELGtCQUFrQixDQUFDOW5ELENBQUMsQ0FBQ3pOLEVBQUgsQ0FKakQsRUFJeUQ7QUFDeEQsY0FBSXkxRCxTQUFRLEdBQUdKLFNBQVMsQ0FBQ3puQixHQUFELENBQXhCLENBRHdELENBR3hEOztBQUNLNm5CLG1CQUFELElBQWEsQ0FBT0EsU0FBUSxDQUFDbjJELENBQWhCLEtBQXVCazJELGFBSmdCLEtBS3ZEQyxTQUFRLEdBQUd0c0MsQ0FBQyxDQUFDbXNDLG1CQUFGLENBQXNCRSxhQUF0QixDQUw0QyxHQVFwREMsU0FBUSxJQUFJQSxTQUFRLENBQUMzbUQsS0FBVCxHQUFpQnJCLENBQUMsQ0FBQ3FCLEtBQW5CLElBQTRCLENBUlksS0FTdkR5L0IsTUFBTSxJQUFJdnNCLEtBQUssQ0FBQ0gsTUFBTSxDQUFDNHpDLFNBQVEsQ0FBQ3p1QyxLQUFWLENBQVAsQ0FBTCxHQUFnQ2dsQyxFQVRhO0FBV3hEO0FBQ0QsT0FyQkYsQ0F1QkEsRUFBT3pkLE1BQVA7QUFDQSxLQS9CRDtBQWdDQSxHQTVQYTtBQThQZHJPLGVBOVBjLHlCQThQQTBwQixJQTlQQSxFQThQTW44QyxDQTlQTixFQThQUztBQUFBLFFBR2xCOHZDLFFBSGtCO0FBQUEsUUFDaEI1N0IsRUFBRSxHQUFHLElBRFc7QUFBQSxRQUVoQjVsQixLQUFLLEdBQUdncUIsaUdBQVEsQ0FBQzZqQyxJQUFELENBRkE7QUFldEIsV0FWS2pvQyxFQUFFLENBQUNvWSxjQUFILENBQWtCdHNCLENBQUMsQ0FBQ3pOLEVBQXBCLENBVUwsR0FSVzJoQixFQUFFLENBQUNnc0IsaUJBQUgsQ0FBcUJpYyxJQUFJLENBQUMvYixRQUExQixDQVFYLEdBUEMwUCxRQUFRLEdBQUc1N0IsRUFBRSxDQUFDeTNCLFVBQUgsQ0FBYzNyQyxDQUFkLElBQ1ZrVSxFQUFFLENBQUN5dkMsWUFBSCxDQUFnQnhILElBQWhCLEVBQXNCam9DLEVBQUUsQ0FBQ210QixTQUFILENBQWFyaEMsQ0FBQyxDQUFDek4sRUFBZixFQUFtQnlOLENBQUMsQ0FBQ3FCLEtBQXJCLENBQXRCLENBRFUsR0FFVjZTLEVBQUUsQ0FBQyt3QyxjQUFILENBQWtCOUksSUFBbEIsRUFBd0Jqb0MsRUFBRSxDQUFDMHlCLFlBQUgsQ0FBZ0I1bUMsQ0FBaEIsSUFBcUJrVSxFQUFFLENBQUMwbkMsWUFBSCxDQUFnQjU3QyxDQUFoQixJQUFxQixHQUExQyxHQUFnRCxDQUF4RSxDQUtGLEdBSldtOEMsSUFBSSxDQUFDL2IsUUFBTCxLQUFrQixNQUk3QixLQUhDMFAsUUFBUSxJQUFHeGhELEtBQUssQ0FBQzJzQyxPQUFOLENBQWNwM0IsY0FBSyxDQUFDNVksR0FBcEIsQ0FBSCxJQUE4QmlwQixFQUFFLENBQUNvYixXQUFILENBQWU2c0IsSUFBZixDQUd2QyxJQVRDck0sUUFBUSxLQVNULEVBQU9BLFFBQVA7QUFDQSxHQTlRYTtBQWdSZCtQLGdCQWhSYywwQkFnUkM3L0MsQ0FoUkQsRUFnUkk7QUFBQSxRQUNYa1UsRUFBRSxHQUFHLElBRE07QUFBQSxRQUVYK3pDLGFBQWEsR0FBRy96QyxFQUFFLENBQUNnMEMsa0JBQUgsQ0FBc0Jsb0QsQ0FBdEIsQ0FGTDtBQUlqQixXQUFPO0FBQ04sZUFBU21vRCxpRkFESDtBQUVOLHNCQUFnQkMsdUZBRlY7QUFHTixvQkFBY0MscUZBSFI7QUFJTixnQkFBVUMsa0ZBSko7QUFLTixrQkFBWUMsb0ZBTE47QUFNTix5QkFBbUJDLDBGQU5iO0FBT04sdUJBQWlCQyx3RkFQWDtBQVFOLHFCQUFlQyxzRkFSVDtBQVNOLDRCQUFzQkMsNEZBVGhCO0FBVU4sMEJBQW9CQywwRkFWZDtBQVdOLG9CQUFjQyxxRkFYUjtBQVlOLG9CQUFjQyxxRkFaUjtBQWFOLGlCQUFXQyxtRkFiTDtBQWNOLHVCQUFpQkMsd0ZBZFg7QUFlTixnQkFBVUMsa0ZBZko7QUFnQk4sY0FBUUMsZ0ZBaEJGO0FBaUJOLG9CQUFjQyxxRkFqQlI7QUFrQk4scUJBQWVDLHNGQUFpQkE7QUFsQjFCLE1BbUJMbkIsYUFuQkssQ0FBUDtBQW9CQSxHQXhTYTtBQTBTZEMsb0JBMVNjLDhCQTBTS2xvRCxDQTFTTCxFQTBTUTtBQUNmLFFBQUFrVSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQWxHLElBRkEsR0FFT2tHLE1BQU0sQ0FBQ29FLHlCQUZkO0FBQUEsUUFHQWc2QyxhQUhBLEdBR2dCL3pDLEVBQUUsQ0FBQ280QixtQkFBSCxDQUF1QjNvQyxJQUF2QixJQUErQkEsSUFBL0IsR0FBc0MsVUFIdEQ7QUFLTixXQUFPdVEsRUFBRSxDQUFDMDNCLFlBQUgsQ0FBZ0I1ckMsQ0FBaEIsSUFDTmlvRCxhQURNLEdBRUwvekMsRUFBRSxDQUFDeTNCLFVBQUgsQ0FBYzNyQyxDQUFkLElBQ0M2SixNQUFNLENBQUNnRSxjQURSLEdBQ3lCLFFBSDNCO0FBS0E7QUFyVGEsQ0FBZixFOztBQzVCQTs7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFZTtBQUNkcVAsS0FBRyxFQUFFLENBQ0ptc0MsUUFESSxFQUVKQyxRQUZJLEVBR0pDLFFBSEksRUFJSkMsTUFKSSxFQUtKQyxNQUxJLEVBTUpDLEtBTkksRUFPSkMsV0FQSSxFQVFKQyxhQVJJLEVBU0pDLEtBVEksRUFVSkMsUUFWSSxDQURTO0FBYWQxZixVQUFRLEVBQUUsQ0FDVG9DLGtCQURTLEVBRVQxWixpQkFGUyxFQUdUbFAsaUJBSFMsRUFJVGxnQixxQkFKUyxFQUtUb08saUJBTFMsRUFPVHhmLGNBUFMsRUFRVGpGLGNBUlMsRUFTVGEsTUFUUyxFQVVUbVYsbUJBVlMsRUFXVDBtRCxTQVhTLEVBYVQ5K0QsdUJBYlMsRUFjVDhtQixZQWRTLEVBZVQvakIsd0JBZlMsRUFnQlQ2akIsV0FoQlMsRUFpQlR2akIsV0FqQlM7QUFiSSxDQUFmLEU7Ozs7O0FDdENBOzs7O0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRWU7QUFDZDA3RCxTQURjLHFCQUNKO0FBQ0gsUUFBQTkxQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFQTJoQyxRQUZBLEdBRVczaEMsTUFBTSxDQUFDblYsU0FGbEI7QUFBQSxRQUdBK3RCLE9BSEEsR0FHVTVZLE1BQU0sQ0FBQ3lHLFdBSGpCO0FBQUEsUUFJQTI1QyxhQUpBLEdBSWdCcGdELE1BQU0sQ0FBSTJoQyxRQUFKLG9CQUFOLElBQXVDLENBSnZEO0FBQUEsUUFLQTdhLFFBTEEsR0FLVyxDQUNoQnpjLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxLQUFYLEtBQXFCM0gsT0FBckIsR0FBK0JBLE9BQU8sR0FBRyxHQUF6QyxHQUNDNVksTUFBTSxDQUFJMmhDLFFBQUosZUFGUyxLQUdaLENBUkM7QUFBQSxRQVNBMWtDLFNBVEEsR0FTaUJvTixFQUFFLENBQUNxWixVQUFILE1BQW1CclosRUFBRSxDQUFDb1osV0FBSCxFQUFuQixHQUN0QixVQUFDdG5CLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGFBQVdpTyxFQUFFLENBQUNxWixVQUFILEtBQWtCdm5CLENBQUMsR0FBR0MsQ0FBdEIsR0FBMEJBLENBQUMsR0FBR0QsQ0FBekM7QUFBQSxLQURzQixHQUN3QixJQVZ6QztBQVlOa08sTUFBRSxDQUFDekMsR0FBSCxHQUFTeTRDLGtGQUFLLEdBQ1pyNUIsVUFETyxDQUNJbzVCLGFBREosRUFFUHI1QixRQUZPLENBRUVxNUIsYUFBYSxHQUFJLElBQUl0cUQsSUFBSSxDQUFDMFAsRUFGNUIsRUFHUHNoQixRQUhPLENBR0VBLFFBSEYsRUFJUHc1QixVQUpPLENBSUlyakQsU0FKSixFQUtQekYsS0FMTyxDQUtELFVBQUNyQixDQUFEO0FBQUEsYUFBWUEsQ0FBQyxDQUFDb1UsTUFBRixDQUFTMU4sTUFBVCxDQUFnQixVQUFDVixDQUFELEVBQUlDLENBQUo7QUFBQSxlQUFVRCxDQUFDLEdBQUdDLENBQUMsQ0FBQzVFLEtBQWhCO0FBQUEsT0FBaEIsRUFBdUMsQ0FBdkMsQ0FBWjtBQUFBLEtBTEMsQ0FiQTtBQW1CVCxHQXBCYTtBQXNCZG1qQyxjQXRCYywwQkFzQkM7QUFDUixRQUFBdHdCLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ2tCOGpCLEVBRGxCLENBQ1M5akIsS0FEVDtBQUFBLFFBRUEwRCxNQUZBLEdBRVMrVixNQUFNLENBQUN1RyxlQUZoQjtBQUFBLFFBR0FxUyxPQUhBLEdBR1U1WSxNQUFNLENBQUN5RyxXQUhqQjtBQUFBLFFBSUF5RSxDQUpBLEdBSUlsTCxNQUFNLENBQUMyRixXQUFQLElBQXNCM0YsTUFBTSxDQUFDeUUsV0FKakM7QUFBQSxRQUtBcmEsYUFMQSxHQUtnQmlnQixFQUFFLENBQUM0TixtQkFBSCxDQUF1QjVOLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQS9CLEVBQXdDNVQsTUFBeEMsR0FDckIwSixNQUFNLENBQUM0RixtQkFORjtBQVFOcmYsU0FBSyxDQUFDOEQsY0FBTixHQUF1QnlMLElBQUksQ0FBQ3dELEdBQUwsQ0FBUy9TLEtBQUssQ0FBQ1ksUUFBZixFQUF5QlosS0FBSyxDQUFDYSxTQUEvQixJQUE0QyxDQUE1QyxJQUFpRGlqQixFQUFFLENBQUN3M0IsZ0JBQUgsS0FBd0IsR0FBeEIsR0FBK0IsQ0FBaEYsQ0FUVCxFQVVkdDdDLEtBQUssQ0FBQzBELE1BQU4sR0FBZTFELEtBQUssQ0FBQzhELGNBQU4sR0FBdUIsR0FWeEIsRUFXZDlELEtBQUssQ0FBQzRELGdCQUFOLEdBQXlCK2dCLENBQUMsR0FBRyxDQUFDM2tCLEtBQUssQ0FBQzBELE1BQU4sR0FBZWloQixDQUFoQixJQUFxQjNrQixLQUFLLENBQUMwRCxNQUE5QixHQUF1QyxFQVhuRCxFQVlkMUQsS0FBSyxDQUFDNkQsYUFBTixHQUFzQjhnQixDQUFDLEtBQ3RCOWdCLGFBQWEsSUFBSTdELEtBQUssQ0FBQzBELE1BQU4sR0FBZTFELEtBQUssQ0FBQzJELFdBQXRDLEdBQ0MzRCxLQUFLLENBQUMwRCxNQUFOLEdBQWUxRCxLQUFLLENBQUMyRCxXQUR0QixHQUVFRSxhQUFhLElBQUk3RCxLQUFLLENBQUMwRCxNQUF2QixHQUFnQ0csYUFBaEMsR0FBZ0Q3RCxLQUFLLENBQUMwRCxNQUhsQyxDQVpUO0FBa0JkLFFBQU1DLFdBQVcsR0FBR0QsTUFBTSxLQUN6QjJ1QixPQUFPLEdBQUdBLE9BQU8sSUFBSXJ5QixLQUFLLENBQUM0RCxnQkFBTixHQUF5QixFQUE3QixDQUFWLEdBQThDLENBRDVCLENBQTFCLENBbEJjLENBc0JkOztBQUNBNUQsU0FBSyxDQUFDMkQsV0FBTixHQUFvQm1nQixFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxLQUF1QmxXLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLENBQXZCLEdBQ25CaDZCLEtBQUssQ0FBQzBELE1BQU4sR0FBZTFELEtBQUssQ0FBQzRELGdCQURGLEdBQ3FCRCxXQXhCM0I7QUF5QmQsR0EvQ2E7QUFpRGRxMkQsZ0JBakRjLDBCQWlEQ3BxRCxDQWpERCxFQWlESTtBQUNYLFFBQUFrVSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0RuZ0IsV0FEQyxHQUNjbWdCLEVBQUUsQ0FBQzlqQixLQURqQixDQUNEMkQsV0FEQztBQU9OLFdBSkksQ0FBQ3VMLFFBQVEsQ0FBQ3ZMLFdBQUQsQ0FBVCxJQUEwQmlNLENBSTlCLEtBSENqTSxXQUFXLEdBQUdBLFdBQVcsQ0FBQ2lNLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQVIsQ0FBWCxJQUEwQixDQUd6QyxHQUFPd0IsV0FBUDtBQUNBLEdBMURhO0FBNERkeXRDLFdBNURjLHVCQTRERjtBQUNYLFFBQU10dEIsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDbTJDLE1BQUgsR0FBWW4yQyxFQUFFLENBQUNvMkMsU0FBSCxFQUhELEVBSVhwMkMsRUFBRSxDQUFDcTJDLGNBQUgsR0FBb0JyMkMsRUFBRSxDQUFDczJDLGlCQUFILEVBSlQ7QUFLWCxHQWpFYTtBQW1FZEMsYUFuRWMsdUJBbUVGQyxNQW5FRSxFQW1FTTtBQUNiLFFBQUF4MkMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUY0SCxHQUZFLEdBRUl5QyxFQUFFLENBQUN6QyxHQUZQO0FBQUEsUUFHRnpSLENBSEUsR0FHRTBxRCxNQUhGO0FBQUEsUUFJRnBwRCxLQUpFO0FBTU4sUUFBSSxDQUFDdUksTUFBTCxFQUNDLE9BQU8sSUFBUDtBQVJrQixRQVdiL1YsTUFBTSxHQUFHNkwsSUFBSSxDQUFDMFAsRUFBTCxJQUFXeEYsTUFBTSxDQUFDZ0YsZ0JBQVAsR0FBMEIsQ0FBMUIsR0FBOEIsQ0FBekMsQ0FYSTtBQUFBLFFBWWI4N0MsTUFBTSxHQUFHOWdELE1BQU0sQ0FBQ3VGLG1CQVpIOztBQWNuQixRQUFJcFAsQ0FBQyxDQUFDcUcsSUFBRixJQUFVNk4sRUFBRSxDQUFDNDNCLFdBQUgsQ0FBZTlyQyxDQUFDLENBQUNxRyxJQUFqQixDQUFkLEVBQXNDO0FBQ3JDLFVBQU11a0QsUUFBUSxHQUFHMTJDLEVBQUUsQ0FBQzRYLGVBQUgsRUFBakIsQ0FEcUMsQ0FHckM7O0FBQ0k4K0IsY0FBUSxHQUFHL2dELE1BQU0sQ0FBQ3FGLFNBSmUsS0FLcENyRixNQUFNLENBQUNxRixTQUFQLEdBQW1CMDdDLFFBTGlCO0FBUXJDLFVBQU1DLElBQUksR0FBRy8yRCxNQUFNLElBQUk4MkQsUUFBUSxJQUFJL2dELE1BQU0sQ0FBQ3FGLFNBQVAsR0FBbUJyRixNQUFNLENBQUNvRixTQUE5QixDQUFaLENBQW5CO0FBRUF3QyxTQUFHLEdBQUdBLEdBQUcsQ0FDUG9mLFVBREksQ0FDTzg1QixNQURQLEVBRUovNUIsUUFGSSxDQUVLaTZCLElBQUksR0FBR0YsTUFGWixDQVYrQjtBQWFyQzs7QUFtQkQsUUFqQkFsNUMsR0FBRyxDQUFDeUMsRUFBRSxDQUFDNE4sbUJBQUgsRUFBRCxDQUFILENBQ0V2Z0IsT0FERixDQUNVLFVBQUNtYSxDQUFELEVBQUkvWSxDQUFKLEVBQVU7QUFDYnJCLFdBQUQsSUFBVW9hLENBQUMsQ0FBQ3JWLElBQUYsQ0FBTzlULEVBQVAsS0FBY3lOLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBRGpCLEtBRWpCK08sS0FBSyxLQUZZLEVBR2pCdEIsQ0FBQyxHQUFHMGIsQ0FIYSxFQUlqQjFiLENBQUMsQ0FBQ3VaLEtBQUYsR0FBVTVXLENBSk87QUFNbEIsS0FQRixDQWlCQSxFQVJJcEMsS0FBSyxDQUFDUCxDQUFDLENBQUM2d0IsVUFBSCxDQVFULEtBUEM3d0IsQ0FBQyxDQUFDNndCLFVBQUYsR0FBZSxDQU9oQixHQUpJdHdCLEtBQUssQ0FBQ1AsQ0FBQyxDQUFDNHdCLFFBQUgsQ0FJVCxLQUhDNXdCLENBQUMsQ0FBQzR3QixRQUFGLEdBQWE1d0IsQ0FBQyxDQUFDNndCLFVBR2hCLEdBQUk3d0IsQ0FBQyxDQUFDcUcsSUFBRixJQUFVNk4sRUFBRSxDQUFDdzNCLGdCQUFILEVBQWQsRUFBcUM7QUFDcEMsVUFBTXhhLFFBQVEsR0FBR2hkLEVBQUUsQ0FBQ21YLGFBQUgsR0FBbUJ2VSxHQUFuQixDQUF1QixDQUF2QixFQUEwQnpWLEtBQTNDLENBRG9DLENBR3BDOztBQUNJNnZCLGNBQVEsR0FBR3JuQixNQUFNLENBQUNxRixTQUpjLEtBS25DckYsTUFBTSxDQUFDcUYsU0FBUCxHQUFtQmdpQixRQUxnQjtBQUFBLFVBUTlCNDVCLElBQUksR0FBR2poRCxNQUFNLENBQUNvRixTQVJnQjtBQUFBLFVBUzlCODdDLElBQUksR0FBR2xoRCxNQUFNLENBQUNxRixTQVRnQjtBQUFBLFVBVzlCODdDLE1BQU0sR0FBR2hyRCxDQUFDLENBQUNxQixLQUFGLEdBQVV5cEQsSUFBVixHQUFpQixDQUFqQixHQUFxQjlxRCxDQUFDLENBQUNxQixLQUFGLEdBQVUwcEQsSUFBVixHQUFpQi9xRCxDQUFDLENBQUNxQixLQUFGLEdBQVV5cEQsSUFBM0IsR0FBbUNDLElBQUksR0FBR0QsSUFYMUM7QUFhcEM5cUQsT0FBQyxDQUFDNndCLFVBQUYsR0FBZTg1QixNQWJxQixFQWNwQzNxRCxDQUFDLENBQUM0d0IsUUFBRixHQUFhKzVCLE1BQU0sR0FKTjcyRCxNQUFNLElBQUlpM0QsSUFBSSxHQUFHRCxJQUFYLENBSUcsR0FBT0UsTUFkTztBQWVwQzs7QUFFRCxXQUFPMXBELEtBQUssR0FBR3RCLENBQUgsR0FBTyxJQUFuQjtBQUNBLEdBbklhO0FBcUlkc3FELFdBckljLHVCQXFJRjtBQUNMLFFBQUFwMkMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDOWpCLEtBREQsR0FDVThqQixFQURWLENBQ0M5akIsS0FERDtBQUFBLFFBRUE2NkQsRUFGQSxHQUVLLzJDLEVBQUUsQ0FBQ2syQyxjQUFILEVBRkw7QUFBQSxRQUdBYyxjQUhBLEdBR2lCOTZELEtBQUssQ0FBQzZELGFBQU4sR0FBc0JpZ0IsRUFBRSxDQUFDNE4sbUJBQUgsQ0FBdUI1TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUEvQixFQUF3QzVULE1BSC9FO0FBQUEsUUFJQXVyQyxnQkFKQSxHQUltQngzQixFQUFFLENBQUN3M0IsZ0JBQUgsRUFKbkI7QUFBQSxRQU1GcmhELEdBTkUsR0FNSThnRSxrRkFBSyxHQUNiQyxXQURRLENBQ0ksVUFBQ3ByRCxDQUFEO0FBQUEsYUFBYTByQyxnQkFBZ0IsR0FBSXQ3QyxLQUFLLENBQUMwRCxNQUFOLEdBQWVvM0QsY0FBYyxHQUFHbHJELENBQUMsQ0FBQ3VaLEtBQXRDLEdBQStDbnBCLEtBQUssQ0FBQzBELE1BQWxGO0FBQUEsS0FESixFQUVSQyxXQUZRLENBRUksVUFBQ2lNLENBQUQ7QUFBQSxhQUFhMHJDLGdCQUFnQixHQUN6Q3Q3QyxLQUFLLENBQUMwRCxNQUFOLEdBQWVvM0QsY0FBYyxJQUFJbHJELENBQUMsQ0FBQ3VaLEtBQUYsR0FBVSxDQUFkLENBRFksR0FFekNqYSxRQUFRLENBQUMyckQsRUFBRCxDQUFSLEdBQWVBLEVBQWYsR0FBb0IsQ0FGUjtBQUFBLEtBRkosQ0FOSjtBQUFBLFFBWUFJLE1BWkEsR0FZUyxVQUFTcnJELENBQVQsRUFBWXU1QyxhQUFaLEVBQTJCO0FBQ3pDLFVBQUkzbUQsSUFBbUIsR0FBRyxPQUExQjs7QUFFQSxVQUFJb04sQ0FBQyxDQUFDcUIsS0FBRixJQUFXckIsQ0FBQyxDQUFDcUcsSUFBakIsRUFBdUI7QUFDakIvRyxnQkFBUSxDQUFDMnJELEVBQUQsQ0FEUyxLQUVyQjVnRSxHQUFHLEdBQUdBLEdBQUcsQ0FBQzBKLFdBQUosQ0FBZ0JtZ0IsRUFBRSxDQUFDazJDLGNBQUgsQ0FBa0JwcUQsQ0FBbEIsQ0FBaEIsQ0FGZTtBQUt0QixZQUFNc3JELE9BQU8sR0FBRyxDQUFDL1IsYUFBRCxJQUFrQnJsQyxFQUFFLENBQUN1MkMsV0FBSCxDQUFlenFELENBQWYsQ0FBbEM7QUFFSXU1QyxxQkFQa0IsR0FRckIzbUQsSUFBSSxHQUFHdkksR0FBRyxDQUFDMlYsQ0FBRCxDQVJXLEdBU1hzckQsT0FUVyxLQVVyQjE0RCxJQUFJLEdBQUd2SSxHQUFHLENBQUNpaEUsT0FBRCxDQVZXO0FBWXRCOztBQUVELGFBQU8xNEQsSUFBUDtBQUNBLEtBOUJLOztBQW1DTixXQUZBeTRELE1BQU0sQ0FBQ0UsUUFBUCxHQUFrQmxoRSxHQUFHLENBQUNraEUsUUFFdEIsRUFBT0YsTUFBUDtBQUNBLEdBMUthO0FBNEtkYixtQkE1S2MsNkJBNEtJZ0IsSUE1S0osRUE0S1U7QUFDakIsUUFBQXQzQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0M5akIsS0FERCxHQUNVOGpCLEVBRFYsQ0FDQzlqQixLQUREO0FBQUEsUUFFQXE3RCxPQUZBLEdBRVVELElBQUksSUFBSSxDQUZsQjtBQUFBLFFBR0FOLGNBSEEsR0FHaUI5NkQsS0FBSyxDQUFDNkQsYUFBTixHQUFzQmlnQixFQUFFLENBQUM0TixtQkFBSCxDQUF1QjVOLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQS9CLEVBQXdDNVQsTUFIL0U7QUFBQSxRQUlBdXJDLGdCQUpBLEdBSW1CeDNCLEVBQUUsQ0FBQ3czQixnQkFBSCxFQUpuQjtBQUFBLFFBS0FnZ0IsV0FMQSxHQUtjL3JELElBQUksQ0FBQ3dELEdBQUwsQ0FBUy9TLEtBQUssQ0FBQzhELGNBQU4sR0FBdUJ1M0QsT0FBdkIsR0FBaUNyN0QsS0FBSyxDQUFDMEQsTUFBaEQsRUFDbkJvM0QsY0FBYyxHQUFHLEVBQWpCLEdBQXVCLENBQUMsSUFBSU8sT0FBTCxJQUFnQixHQURwQixDQUxkO0FBQUEsUUFTQXBoRSxHQVRBLEdBU004Z0Usa0ZBQUssR0FDZkMsV0FEVSxDQUNFLFVBQUNwckQsQ0FBRDtBQUFBLGFBQWEwckMsZ0JBQWdCLEdBQ3pDdDdDLEtBQUssQ0FBQzBELE1BQU4sR0FBZW8zRCxjQUFjLEdBQUdsckQsQ0FBQyxDQUFDdVosS0FBbEMsR0FBMENteUMsV0FERCxHQUV6Q3Q3RCxLQUFLLENBQUM4RCxjQUFOLEdBQXVCdTNELE9BRlg7QUFBQSxLQURGLEVBS1YxM0QsV0FMVSxDQUtFLFVBQUNpTSxDQUFEO0FBQUEsYUFBYTByQyxnQkFBZ0IsR0FDekN0N0MsS0FBSyxDQUFDMEQsTUFBTixHQUFlbzNELGNBQWMsSUFBSWxyRCxDQUFDLENBQUN1WixLQUFGLEdBQVUsQ0FBZCxDQURZLEdBQ09ucEIsS0FBSyxDQUFDMkQsV0FEMUM7QUFBQSxLQUxGLENBVE47QUFpQk4sV0FBTyxVQUFTaU0sQ0FBVCxFQUFZO0FBQ2xCLFVBQU1zckQsT0FBTyxHQUFHcDNDLEVBQUUsQ0FBQ3UyQyxXQUFILENBQWV6cUQsQ0FBZixDQUFoQjtBQURrQixhQUdkc3JELE9BSGMsR0FJVixDQUNONWYsZ0JBQWdCLEdBQUdyaEQsR0FBSCxHQUFTQSxHQUFHLENBQUMwSixXQUFKLENBQWdCbWdCLEVBQUUsQ0FBQ2syQyxjQUFILENBQWtCcHFELENBQWxCLENBQWhCLENBRG5CLEVBRUxzckQsT0FGSyxDQUpVLEdBUVYsT0FSVTtBQVVsQixLQVZEO0FBV0EsR0F6TWE7QUEyTWRLLFFBM01jLGtCQTJNUDNyRCxDQTNNTyxFQTJNSnU1QyxhQTNNSSxFQTJNV3R3QyxLQTNNWCxFQTJNa0I7QUFDL0IsV0FBT0EsS0FBSyxJQUFJLEtBQUsraUMsU0FBTCxDQUFlaHNDLENBQUMsQ0FBQ3FHLElBQWpCLENBQVQsR0FBa0MsS0FBS2drRCxNQUFMLENBQVlycUQsQ0FBWixFQUFldTVDLGFBQWYsQ0FBbEMsR0FBa0UsT0FBekU7QUFDQSxHQTdNYTtBQStNZHFTLHNCQS9NYyxnQ0ErTU81ckQsQ0EvTVAsRUErTVU7QUFDakIsUUFBQWtVLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDNENxSyxFQUQ1QyxDQUNDckssTUFERDtBQUFBLG9CQUM0Q3FLLEVBRDVDLENBQ1M5akIsS0FEVDtBQUFBLFFBQ2lCMEQsTUFEakIsYUFDaUJBLE1BRGpCO0FBQUEsUUFDeUJJLGNBRHpCLGFBQ3lCQSxjQUR6QjtBQUFBLFFBR0FvM0QsT0FIQSxHQUdVcDNDLEVBQUUsQ0FBQ3UyQyxXQUFILENBQWV6cUQsQ0FBZixDQUhWO0FBQUEsUUFJRmluQyxTQUpFLEdBSVUsRUFKVjtBQU1OLFFBQUlxa0IsT0FBSixFQUNDLElBQUlwM0MsRUFBRSxDQUFDdzNCLGdCQUFILEVBQUosRUFBMkI7QUFBQSxVQUNwQnAzQyxFQUFFLEdBQUdxTCxJQUFJLENBQUNnYSxHQUFMLENBQVMyeEMsT0FBTyxDQUFDMTZCLFFBQVIsR0FBbUJqeEIsSUFBSSxDQUFDMFAsRUFBTCxHQUFVLENBQXRDLENBRGU7QUFBQSxVQUdwQnhkLENBQUMsR0FBRzhOLElBQUksQ0FBQ3lqQyxHQUFMLENBQVNrb0IsT0FBTyxDQUFDMTZCLFFBQVIsR0FBbUJqeEIsSUFBSSxDQUFDMFAsRUFBTCxHQUFVLENBQXRDLEtBQTRDbmIsY0FBYyxHQUFHLEVBQTdELENBSGdCO0FBQUEsVUFJcEJsQyxDQUFDLEdBQUdzQyxFQUFFLElBQUlKLGNBQWMsR0FBRyxFQUFqQixHQUFzQnlMLElBQUksQ0FBQ291QixHQUFMLENBQVN6NUIsRUFBRSxHQUFHLEVBQWQsQ0FBMUIsQ0FBRixHQUFpRCxDQUpqQztBQU0xQjJ5QyxlQUFTLGtCQUFnQnAxQyxDQUFoQixTQUFxQkcsQ0FBckIsTUFOaUI7QUFPMUIsS0FQRCxNQU9PLElBQUksQ0FBQ2tpQixFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxDQUFELElBQXdCbFcsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQjVULE1BQWhCLEdBQXlCLENBQXJELEVBQXdEO0FBQUEsVUFDeEQrRixDQUFDLEdBQUcsS0FBS21rRCxNQUFMLENBQVlrQixRQUFaLENBQXFCRCxPQUFyQixDQURvRDtBQUFBLFVBRXhEejVELENBQUMsR0FBRzBPLEtBQUssQ0FBQzJGLENBQUMsQ0FBQyxDQUFELENBQUYsQ0FBTCxHQUFjLENBQWQsR0FBa0JBLENBQUMsQ0FBQyxDQUFELENBRmlDO0FBQUEsVUFHeERsVSxDQUFDLEdBQUd1TyxLQUFLLENBQUMyRixDQUFDLENBQUMsQ0FBRCxDQUFGLENBQUwsR0FBYyxDQUFkLEdBQWtCQSxDQUFDLENBQUMsQ0FBRCxDQUhpQztBQUFBLFVBSXhEOE8sQ0FBQyxHQUFHclYsSUFBSSxDQUFDZ3dCLElBQUwsQ0FBVTk5QixDQUFDLEdBQUdBLENBQUosR0FBUUcsQ0FBQyxHQUFHQSxDQUF0QixDQUpvRDtBQUFBLFVBTTFEdytCLEtBQUssR0FBSXRjLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLEtBQXVCdmdCLE1BQU0sQ0FBQ3dFLGlCQUEvQixJQUNWNkYsRUFBRSxDQUFDa1csT0FBSCxDQUFXLEtBQVgsS0FBcUJ2Z0IsTUFBTSxDQUFDbUcsZUFQZ0M7QUFVN0R3Z0IsV0FWNkQsR0FTMURBLEtBVDBELEdBVXJEcHhCLFVBQVUsQ0FBQ294QixLQUFELENBQVYsR0FBb0JBLEtBQUssQ0FBQ25aLElBQU4sQ0FBV25ELEVBQUUsQ0FBQ2dKLEdBQWQsRUFBbUJsZCxDQUFuQixFQUFzQmxNLE1BQXRCLEVBQThCa2hCLENBQTlCLENBQXBCLEdBQXVEd2IsS0FWRixHQVlyRDE4QixNQUFNLEtBQ2JraEIsQ0FBQyxHQUFHLENBQUMsS0FBS2xoQixNQUFMLEdBQWMsSUFBZCxHQUFzQixRQUFRLEtBQUtBLE1BQW5DLEdBQTRDLEVBQTdDLElBQW9EQSxNQUFwRCxHQUE2RGtoQixDQUFoRSxHQUFvRSxDQUR4RCxDQVorQyxFQWlCOURpeUIsU0FBUyxrQkFBZ0JwMUMsQ0FBQyxHQUFHMitCLEtBQXBCLFNBQTZCeCtCLENBQUMsR0FBR3crQixLQUFqQyxNQWpCcUQ7QUFrQjlEO0FBR0YsV0FBT3lXLFNBQVA7QUFDQSxHQXBQYTtBQXNQZDRrQixrQkF0UGMsNEJBc1BHN3JELENBdFBILEVBc1BNO0FBQ25CLFdBQU8sS0FBS3FxQixPQUFMLENBQWE7QUFDbkI5M0IsUUFBRSxFQUFFeU4sQ0FBQyxDQUFDcUcsSUFBRixDQUFPOVQsRUFEUTtBQUVuQjhPLFdBQUssRUFBRXJCLENBQUMsQ0FBQ3FCLEtBRlU7QUFHbkJtdkIsV0FBSyxFQUFFLEtBQUtGLFFBQUwsQ0FBYyxLQUFkLEVBQXFCdHdCLENBQXJCLENBSFk7QUFJbkJ1WixXQUFLLEVBQUV2WixDQUFDLENBQUN1WjtBQUpVLEtBQWIsQ0FBUDtBQU1BLEdBN1BhO0FBK1BkdXlDLGlCQS9QYywyQkErUEV6b0QsU0EvUEYsRUErUGE7QUFDMUIsUUFBTTZRLEVBQUUsR0FBRyxJQUFYO0FBRUlBLE1BQUUsQ0FBQzYzQyxrQkFBSCxFQUhzQixJQUl6QjFvRCxTQUFTLENBQUNnVixJQUFWLENBQWUsVUFBU3JZLENBQVQsRUFBWTtBQUFBLFVBQ3BCaUMsSUFBSSxHQUFHcVcsaUdBQVEsQ0FBQyxJQUFELENBREs7QUFBQSxVQUVwQmd6QyxPQUFPLEdBQUdwM0MsRUFBRSxDQUFDdTJDLFdBQUgsQ0FBZXpxRCxDQUFmLENBRlU7QUFBQSxVQUdwQnFCLEtBQUssR0FBR2lxRCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2pxRCxLQUFYLEdBQW1CckIsQ0FBQyxDQUFDcUIsS0FIaEI7QUFBQSxVQUlwQm12QixLQUFLLEdBQUd0YyxFQUFFLENBQUNvYyxRQUFILENBQVksS0FBWixFQUFtQmc3QixPQUFuQixDQUpZO0FBQUEsVUFLcEIvNEQsRUFBRSxHQUFHeU4sQ0FBQyxDQUFDcUcsSUFBRixDQUFPOVQsRUFMUTtBQUFBLFVBTXBCZ3JDLFFBQVEsR0FBR3JwQixFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxDQU5TO0FBQUEsVUFPcEI0aEMsZ0JBQWdCLEdBQ3BCenVCLFFBQUQsSUFBY3JwQixFQUFFLENBQUMrM0Msc0JBQUgsQ0FBMEJ6N0IsS0FBMUIsQ0FSVzs7QUFXMUIsVUFBSXc3QixnQkFBSixFQUFzQjtBQUNyQixZQUFNbDlELElBQUksR0FBRyxDQUNab2xCLEVBQUUsQ0FBQ2c0QyxpQkFBSCxNQUEwQmg0QyxFQUFFLENBQUNzbUIscUJBRGpCLEVBRVhuNUIsS0FGVyxFQUVKbXZCLEtBRkksRUFFR2orQixFQUZILEVBRU9tVCxRQUZQLEVBQWI7QUFJQTFELG9CQUFZLENBQUNDLElBQUQsRUFBT25ULElBQVAsRUFBYSxDQUFDLENBQUMsQ0FBRixFQUFLLENBQUwsQ0FBYixFQUFzQnl1QyxRQUF0QixDQUxTO0FBTXJCO0FBQ0QsS0FsQkQsQ0FKeUI7QUF3QjFCLEdBdlJhO0FBeVJkNHVCLG9CQXpSYyw4QkF5Uks5cUQsS0F6UkwsRUF5UlkrcUQsS0F6UlosRUF5Um1CO0FBQzFCLFFBQUFsNEMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUFDLE1BRkEsR0FFU0QsTUFBTSxDQUFDbUYsbUJBRmhCO0FBSU4sV0FBTzVQLFVBQVUsQ0FBQzBLLE1BQUQsQ0FBVixHQUFxQkEsTUFBTSxDQUFDdU4sSUFBUCxDQUFZbkQsRUFBRSxDQUFDZ0osR0FBZixFQUFvQjdiLEtBQXBCLEVBQTJCK3FELEtBQTNCLENBQXJCLEdBQXlEL3FELEtBQWhFO0FBQ0EsR0EvUmE7QUFpU2RnckQsV0FqU2MscUJBaVNKMy9CLFNBalNJLEVBaVNPO0FBQ2QsUUFBQXhZLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDUzVnQixVQURULEdBQzZCNGdCLEVBRDdCLENBQ0M5akIsS0FERCxDQUNTa0QsVUFEVDtBQUFBLFFBQ3NCZ1EsR0FEdEIsR0FDNkI0USxFQUQ3QixDQUNzQjVRLEdBRHRCOztBQUdOO0FBQ0EsUUFBSWhRLFVBQUosRUFBZ0I7QUFDZixVQUFNaWlCLFFBQVEsR0FBRysyQyxXQUFXLENBQUMsWUFBTTtBQUM3Qmg1RCxrQkFENkIsS0FFakNpNUQsYUFBYSxDQUFDaDNDLFFBQUQsQ0FGb0IsRUFJakNqUyxHQUFHLENBQUNnTyxNQUFKLENBQVdxSCxTQUFYLE9BQXlCOVUsY0FBSyxDQUFDblcsaUJBQS9CLEVBQW9Eb0UsSUFBcEQsS0FBNkQsQ0FBN0QsSUFDQ29pQixFQUFFLENBQUNtNEMsU0FBSCxDQUFhMy9CLFNBQWIsQ0FMZ0M7QUFPbEMsT0FQMkIsRUFPekIsRUFQeUIsQ0FBNUI7QUFTQTtBQUNBOztBQUVELFFBQU04L0IsWUFBWSxHQUFHdDRDLEVBQUUsQ0FBQ2lZLGNBQUgsQ0FBa0JPLFNBQWxCLENBQXJCO0FBRUFwcEIsT0FBRyxDQUFDbWUsR0FBSixDQUFROUksU0FBUixDQUFrQnpFLEVBQUUsQ0FBQ21oQixlQUFILENBQW1CbTNCLFlBQW5CLFFBQXFDM29ELGNBQUssQ0FBQ3RZLFFBQTNDLENBQWxCLEVBQ0U4c0IsSUFERixDQUNPLFVBQVNyWSxDQUFULEVBQVk7QUFDakIsVUFBS2tVLEVBQUUsQ0FBQ3U0QyxZQUFILENBQWdCenNELENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQXZCLENBQUw7QUFBQSxZQUlNbTZELGNBQWMsR0FBR3g0QyxFQUFFLENBQUN5NEMsZUFBSCxDQUFtQjNzRCxDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUExQixFQUE4QixVQUE5QixDQUp2QjtBQUFBLFlBS01xNkQsaUJBQWlCLEdBQUcxNEMsRUFBRSxDQUFDczJDLGlCQUFILENBQXFCdDJDLEVBQUUsQ0FBQ3k0QyxlQUFILENBQW1CM3NELENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQTFCLEVBQThCLE1BQTlCLENBQXJCLENBTDFCO0FBT0ErbEIseUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZUssU0FBZixDQUF5QixNQUF6QixFQUNFeEMsVUFERixHQUVFOE0sUUFGRixDQUVXeXBDLGNBRlgsRUFHRTdwRCxJQUhGLENBR08sR0FIUCxFQUdZcVIsRUFBRSxDQUFDcTJDLGNBSGYsRUFJRXAwQyxVQUpGLEdBS0U4TSxRQUxGLENBS1d5cEMsY0FBYyxHQUFHLENBTDVCLEVBTUU3cEQsSUFORixDQU1PLEdBTlAsRUFNWStwRCxpQkFOWixDQVBBO0FBQUE7QUFjQSxLQWhCRixDQXBCb0I7QUFxQ3BCLEdBdFVhO0FBd1VkQyxhQXhVYyx1QkF3VUZuZ0MsU0F4VUUsRUF3VVM7QUFDaEIsUUFBQXhZLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDUzVnQixVQURULEdBQ29DNGdCLEVBRHBDLENBQ0M5akIsS0FERCxDQUNTa0QsVUFEVDtBQUFBLFFBQzRCbXVCLEdBRDVCLEdBQ29Ddk4sRUFEcEMsQ0FDc0I1USxHQUR0QixDQUM0Qm1lLEdBRDVCOztBQUdOLFNBQUludUIsVUFBSjtBQUlBLFVBQU1rNUQsWUFBWSxHQUFHdDRDLEVBQUUsQ0FBQ2lZLGNBQUgsQ0FBa0JPLFNBQWxCLENBQXJCO0FBRUFqTCxTQUFHLENBQUM5SSxTQUFKLENBQWN6RSxFQUFFLENBQUNtaEIsZUFBSCxDQUFtQm0zQixZQUFuQixRQUFxQzNvRCxjQUFLLENBQUN0WSxRQUEzQyxDQUFkLEVBQ0VvdEIsU0FERixDQUNZLE1BRFosRUFFRXhDLFVBRkYsR0FHRThNLFFBSEYsQ0FHVyxVQUFBampCLENBQUM7QUFBQSxlQUFJa1UsRUFBRSxDQUFDeTRDLGVBQUgsQ0FBbUIzc0QsQ0FBQyxDQUFDcUcsSUFBRixDQUFPOVQsRUFBMUIsRUFBOEIsVUFBOUIsQ0FBSjtBQUFBLE9BSFosRUFJRXNRLElBSkYsQ0FJTyxHQUpQLEVBSVlxUixFQUFFLENBQUNtMkMsTUFKZixDQU5BLEVBWUE1b0MsR0FBRyxDQUFDOUksU0FBSixNQUFpQjlVLGNBQUssQ0FBQ3haLEdBQXZCLEVBQ0U0dUIsS0FERixDQUNRLFNBRFIsRUFDbUIsR0FEbkIsQ0FaQTtBQUFBO0FBY0EsR0ExVmE7O0FBNFZkOzs7Ozs7O0FBT0EwekMsaUJBbldjLDJCQW1XRXA2RCxFQW5XRixFQW1XTTBPLEdBbldOLEVBbVdXO0FBT3BCLFFBQUEwQyxJQUFJO0FBQUEsUUFORnVRLEVBTUUsR0FORyxJQU1IO0FBQUEsUUFMRHJLLE1BS0MsR0FMU3FLLEVBS1QsQ0FMRHJLLE1BS0M7QUFVUixXQVJJcUssRUFBRSxDQUFDNjNCLFdBQUgsQ0FBZXg1QyxFQUFmLENBUUosR0FQQ29SLElBQUksR0FBRyxPQU9SLEdBTld1USxFQUFFLENBQUM0M0IsV0FBSCxDQUFldjVDLEVBQWYsQ0FNWCxHQUxDb1IsSUFBSSxHQUFHLE9BS1IsR0FKV3VRLEVBQUUsQ0FBQzIzQixTQUFILENBQWF0NUMsRUFBYixDQUlYLEtBSENvUixJQUFJLEdBQUcsS0FHUixHQUFPQSxJQUFJLEdBQUdrRyxNQUFNLENBQUlsRyxJQUFKLGdCQUFtQjFDLEdBQW5CLENBQVQsR0FkQztBQUNYZ2lCLGNBQVEsRUFBRSxFQURDO0FBRVh1b0MsVUFBSSxFQUFFO0FBRkssS0Fjb0MsQ0FBSXZxRCxHQUFKLENBQWhEO0FBQ0EsR0FyWGE7QUF1WGR3ckQsY0F2WGMsd0JBdVhEbDZELEVBdlhDLEVBdVhHO0FBQ1YsUUFBQTJoQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBR04sV0FBUXFLLEVBQUUsQ0FBQzYzQixXQUFILENBQWV4NUMsRUFBZixLQUFzQnNYLE1BQU0sQ0FBQzJFLFlBQTlCLElBQ0wwRixFQUFFLENBQUM0M0IsV0FBSCxDQUFldjVDLEVBQWYsS0FBc0JzWCxNQUFNLENBQUM2RixZQUR4QixJQUVMd0UsRUFBRSxDQUFDMjNCLFNBQUgsQ0FBYXQ1QyxFQUFiLEtBQW9Cc1gsTUFBTSxDQUFDb0csVUFGN0I7QUFHQSxHQTlYYTtBQWdZZDg3QyxvQkFoWWMsZ0NBZ1lPO0FBQ2QsUUFBQTczQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBR04sV0FBTyxDQUFDLEtBQUQsRUFBUSxPQUFSLEVBQWlCLE9BQWpCLEVBQ0xnZSxJQURLLENBQ0EsVUFBQTFvQixDQUFDO0FBQUEsYUFBSStVLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBV2pyQixDQUFYLEtBQWlCMEssTUFBTSxDQUFJMUssQ0FBSixpQkFBM0I7QUFBQSxLQURELENBQVA7QUFFQSxHQXRZYTtBQXdZZDhzRCx3QkF4WWMsa0NBd1lTejdCLEtBeFlULEVBd1lnQjtBQUN2QixRQUFBdGMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUFBLFFBRUFzdEIsU0FGQSxHQUVZampCLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLElBQXNCdmdCLE1BQU0sQ0FBQ3VFLHFCQUE3QixHQUFxRHZFLE1BQU0sQ0FBQ2tHLG1CQUZ4RTtBQUlOLFdBQU95Z0IsS0FBSyxJQUFJMkcsU0FBaEI7QUFDQSxHQTlZYTtBQWdaZCswQixtQkFoWmMsK0JBZ1pNO0FBQ2IsUUFBQWg0QyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsUUFFRkMsTUFGRSxHQUVPRCxNQUFNLENBQUNpRyxnQkFGZDtBQVVOLFdBTklvRSxFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxDQU1KLEdBTEN0Z0IsTUFBTSxHQUFHRCxNQUFNLENBQUNrRixrQkFLakIsR0FKV21GLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLENBSVgsS0FIQ3RnQixNQUFNLEdBQUdELE1BQU0sQ0FBQ3NFLGtCQUdqQixHQUFPL08sVUFBVSxDQUFDMEssTUFBRCxDQUFWLEdBQXFCQSxNQUFNLENBQUN1TixJQUFQLENBQVluRCxFQUFFLENBQUNnSixHQUFmLENBQXJCLEdBQTJDcFQsTUFBbEQ7QUFDQSxHQTVaYTtBQThaZGdqRCxhQTlaYyx5QkE4WkE7QUFBQSxRQUNQNTRDLEVBQUUsR0FBRyxJQURFO0FBQUEsUUFFUHZRLElBQUksR0FBSXVRLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLEtBQXVCLE9BQXhCLElBQXFDbFcsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsS0FBdUIsT0FGNUQ7QUFJYixXQUFPem1CLElBQUksR0FBR3VRLEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBYWxHLElBQWIsWUFBSCxHQUFnQyxFQUEzQztBQUNBLEdBbmFhO0FBcWFkb3BELHFCQXJhYywrQkFxYU1oNUMsT0FyYU4sRUFxYWU7QUFDdEIsUUFBQUcsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDelEsSUFERCxHQUNTeVEsRUFBRSxDQUFDNVEsR0FEWixDQUNDRyxJQUREO0FBQUEsUUFFQTg1QixRQUZBLEdBRVdycEIsRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsQ0FGWDtBQUFBLFFBR0E4SyxhQUhBLEdBR2dCaGhCLEVBQUUsQ0FBQ2doQixhQUFILENBQWlCN2QsSUFBakIsQ0FBc0JuRCxFQUF0QixDQUhoQjtBQUFBLFFBSUFpZ0IsU0FKQSxHQUlZamdCLEVBQUUsQ0FBQ2lnQixTQUFILENBQWE5YyxJQUFiLENBQWtCbkQsRUFBbEIsQ0FKWjtBQUFBLFFBS0EwZ0IsVUFMQSxHQUthMWdCLEVBQUUsQ0FBQzBnQixVQUFILENBQWN2ZCxJQUFkLENBQW1CbkQsRUFBbkIsQ0FMYjtBQUFBLFFBTUE4NEMsYUFOQSxHQU1nQnZwRCxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ3JZLFNBQXRCLEVBQ3BCbXRCLFNBRG9CLE9BQ045VSxjQUFLLENBQUN0WSxRQURBLEVBRXBCOGEsSUFGb0IsQ0FFZjZOLEVBQUUsQ0FBQ3pDLEdBQUgsQ0FBT3NDLE9BQVAsQ0FGZSxFQUdwQmxSLElBSG9CLENBR2YsT0FIZSxFQUdOLFVBQUE3QyxDQUFDO0FBQUEsYUFBSWsxQixhQUFhLENBQUNsMUIsQ0FBRCxDQUFiLEdBQW1CNDBCLFVBQVUsQ0FBQzUwQixDQUFDLENBQUNxRyxJQUFILENBQWpDO0FBQUEsS0FISyxDQU5oQjtBQUFBLFFBV0E0bUQsWUFYQSxHQVdlRCxhQUFhLENBQUNwMEMsS0FBZCxHQUFzQmhXLE1BQXRCLENBQTZCLEdBQTdCLEVBQ25CQyxJQURtQixDQUNkLE9BRGMsRUFDTHF5QixhQURLLENBWGY7QUFjTiszQixnQkFBWSxDQUFDcnFELE1BQWIsQ0FBb0IsR0FBcEIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JzeEIsU0FEaEIsRUFFRXRiLEtBRkYsQ0FFUW0wQyxhQUZSLENBZjRCLEVBbUI1QkMsWUFBWSxDQUFDcnFELE1BQWIsQ0FBb0IsTUFBcEIsRUFDRUMsSUFERixDQUNPLElBRFAsRUFDYTA2QixRQUFRLElBQUksQ0FBQ3JwQixFQUFFLENBQUNnWixlQUFILEVBQWIsR0FBb0MsT0FBcEMsR0FBOEMsT0FEM0QsRUFFRWpVLEtBRkYsQ0FFUSxTQUZSLEVBRW1CLEdBRm5CLEVBR0VBLEtBSEYsQ0FHUSxhQUhSLEVBR3VCLFFBSHZCLEVBSUVBLEtBSkYsQ0FJUSxnQkFKUixFQUkwQixNQUoxQixDQW5CNEI7QUEwQjVCLEdBL2JhO0FBaWNkaTBDLFNBamNjLHFCQWljSjtBQUNILFFBQUFoNUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDNVEsR0FERCxHQUNRNFEsRUFEUixDQUNDNVEsR0FERDtBQUdOQSxPQUFHLENBQUMvWSxJQUFKLEdBQVcrWSxHQUFHLENBQUNHLElBQUosQ0FBU0csTUFBVCxPQUFvQkMsY0FBSyxDQUFDdlksS0FBMUIsRUFDVHNYLE1BRFMsQ0FDRixHQURFLEVBRVRDLElBRlMsQ0FFSixPQUZJLEVBRUtnQixjQUFLLENBQUNyWSxTQUZYLEVBR1RxWCxJQUhTLENBR0osV0FISSxFQUdTcVIsRUFBRSxDQUFDb0ksWUFBSCxDQUFnQixLQUFoQixDQUhULENBSkYsRUFTVHBJLEVBQUUsQ0FBQ2k1QyxXQUFILEVBVFM7QUFVVCxHQTNjYTs7QUE2Y2Q7Ozs7QUFJQUEsYUFqZGMseUJBaWRBO0FBQUEsUUFDUGo1QyxFQUFFLEdBQUcsSUFERTtBQUFBLFFBRVBsbEIsS0FBSyxHQUFHa2xCLEVBQUUsQ0FBQzQ0QyxXQUFILEVBRkQ7QUFBQSxRQUdQdnZCLFFBQVEsR0FBR3JwQixFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxDQUhKOztBQUtiLFFBQUlwN0IsS0FBSixFQUFXO0FBQ1YsVUFBTUYsSUFBSSxHQUFHb2xCLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBTy9ZLElBQVAsQ0FBWXFZLE1BQVosQ0FBbUIsTUFBbkIsRUFDWEMsSUFEVyxDQUNOLE9BRE0sRUFDR2dCLGNBQUssQ0FBQzA1QixRQUFRLEdBQUcscUJBQUgsR0FBMkIsZ0JBQXBDLENBRFIsRUFFWHRrQixLQUZXLENBRUwsYUFGSyxFQUVVLFFBRlYsQ0FBYjtBQUlJc2tCLGNBTE0sSUFNVHp1QyxJQUFJLENBQ0YrVCxJQURGLENBQ08sSUFEUCxFQUNhLFFBRGIsRUFFRW9XLEtBRkYsQ0FFUSxXQUZSLEVBRXFCLE1BRnJCLENBTlMsRUFXVmpYLFlBQVksQ0FBQ2xULElBQUQsRUFBT0UsS0FBUCxFQUFjdXVDLFFBQVEsR0FBRzVvQyxTQUFILEdBQWUsQ0FBQyxDQUFDLEVBQUYsRUFBTyxJQUFQLENBQXJDLEtBWEY7QUFZVjtBQUNELEdBbmVhO0FBcWVkeTRELFdBcmVjLHFCQXFlSm5xQyxRQXJlSSxFQXFlTThoQixlQXJlTixFQXFldUJsSyxhQXJldkIsRUFxZXNDO0FBQzdDLFFBQUEzbUIsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUMrQnFLLEVBRC9CLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDK0I4akIsRUFEL0IsQ0FDUzlqQixLQURUO0FBQUEsUUFDc0JxVCxJQUR0QixHQUMrQnlRLEVBRC9CLENBQ2dCNVEsR0FEaEIsQ0FDc0JHLElBRHRCO0FBQUEsUUFFQTRwRCxjQUZBLEdBRWlCeGpELE1BQU0sQ0FBQzFULG1CQUZ4QjtBQUFBLFFBSUZtM0QsT0FKRSxHQUlRN3BELElBQUksQ0FBQ2tWLFNBQUwsT0FBbUI5VSxjQUFLLENBQUN0WixJQUF6QixFQUNab3VCLFNBRFksT0FDRTlVLGNBQUssQ0FBQ3haLEdBRFIsRUFFWmdjLElBRlksQ0FFUDZOLEVBQUUsQ0FBQ2k0QixPQUFILENBQVc5MEIsSUFBWCxDQUFnQm5ELEVBQWhCLENBRk8sQ0FKUjtBQStGTjtBQXZGQW81QyxXQUFPLENBQUNuMEMsSUFBUixHQUFlaEQsVUFBZixHQUNFOE0sUUFERixDQUNXOGhCLGVBRFgsRUFFRTlyQixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFcEYsTUFIRixFQVRtRCxFQWNuRHk1QyxPQUFPLEdBQUdBLE9BQU8sQ0FBQzEwQyxLQUFSLEdBQWdCaFcsTUFBaEIsQ0FBdUIsTUFBdkIsRUFDUkMsSUFEUSxDQUNILE9BREcsRUFDTXFSLEVBQUUsQ0FBQ2dnQixRQUFILENBQVk3YyxJQUFaLENBQWlCbkQsRUFBakIsQ0FETixFQUVSK0UsS0FGUSxDQUVGLE1BRkUsRUFFTSxVQUFBalosQ0FBQztBQUFBLGFBQUlrVSxFQUFFLENBQUM5QyxLQUFILENBQVNwUixDQUFDLENBQUNxRyxJQUFYLENBQUo7QUFBQSxLQUZQLEVBR1I0UyxLQUhRLENBR0YsUUFIRSxFQUdRLFVBQUFqWixDQUFDO0FBQUEsYUFBS3F0RCxjQUFjLElBQUl4akQsTUFBTSxDQUFDbFEsMkJBQVAsQ0FBbUMwZCxJQUFuQyxDQUF3Q25ELEVBQUUsQ0FBQ2dKLEdBQTNDLEVBQWdEbGQsQ0FBaEQsQ0FBbEIsR0FBdUUsU0FBdkUsR0FBbUYsSUFBeEY7QUFBQSxLQUhULEVBSVJpWixLQUpRLENBSUYsU0FKRSxFQUlTLEdBSlQsRUFLUlosSUFMUSxDQUtILFVBQVNyWSxDQUFULEVBQVk7QUFDYmtVLFFBQUUsQ0FBQzQzQixXQUFILENBQWU5ckMsQ0FBQyxDQUFDcUcsSUFBakIsQ0FEYSxLQUVoQnJHLENBQUMsQ0FBQzZ3QixVQUFGLEdBQWVobkIsTUFBTSxDQUFDdUYsbUJBRk4sRUFHaEJwUCxDQUFDLENBQUM0d0IsUUFBRixHQUFhL21CLE1BQU0sQ0FBQ3VGLG1CQUhKLEdBTWpCLEtBQUttK0MsUUFBTCxHQUFnQnZ0RCxDQU5DO0FBT2pCLEtBWlEsRUFhUjZZLEtBYlEsQ0FhRnkwQyxPQWJFLENBZHlDLEVBNkJuRHA1QyxFQUFFLENBQUN3M0IsZ0JBQUgsTUFBeUJ4M0IsRUFBRSxDQUFDczVDLG1CQUFILEVBN0IwQixFQStCbkRGLE9BQU8sQ0FDTHpxRCxJQURGLENBQ08sV0FEUCxFQUNvQixVQUFBN0MsQ0FBQztBQUFBLGFBQUssQ0FBQ2tVLEVBQUUsQ0FBQzQzQixXQUFILENBQWU5ckMsQ0FBQyxDQUFDcUcsSUFBakIsQ0FBRCxJQUEyQncwQixhQUEzQixHQUEyQyxVQUEzQyxHQUF3RCxFQUE3RDtBQUFBLEtBRHJCLEVBRUU1aEIsS0FGRixDQUVRLFNBRlIsRUFFbUIsVUFBU2paLENBQVQsRUFBWTtBQUM3QixhQUFPQSxDQUFDLEtBQUssS0FBS3V0RCxRQUFYLEdBQXNCLEdBQXRCLEdBQTRCLEdBQW5DO0FBQ0EsS0FKRixFQUtFbDFDLElBTEYsQ0FLTyxZQUFNO0FBQ1hqb0IsV0FBSyxDQUFDa0QsVUFBTixLQURXO0FBRVgsS0FQRixFQVFFNmlCLFVBUkYsR0FTRThNLFFBVEYsQ0FTV0EsUUFUWCxFQVVFd3FDLFNBVkYsQ0FVWSxHQVZaLEVBVWlCLFVBQVN6dEQsQ0FBVCxFQUFZO0FBQzNCLFVBQU1zckQsT0FBTyxHQUFHcDNDLEVBQUUsQ0FBQ3UyQyxXQUFILENBQWV6cUQsQ0FBZixDQUFoQjtBQUVBLFVBQUksQ0FBQ3NyRCxPQUFMLEVBQ0MsT0FBTztBQUFBLGVBQU0sT0FBTjtBQUFBLE9BQVA7QUFHRy9xRCxXQUFLLENBQUMsS0FBS2d0RCxRQUFMLENBQWMxOEIsVUFBZixDQVBrQixLQVExQixLQUFLMDhCLFFBQUwsQ0FBYzE4QixVQUFkLEdBQTJCLENBUkQsR0FXdkJ0d0IsS0FBSyxDQUFDLEtBQUtndEQsUUFBTCxDQUFjMzhCLFFBQWYsQ0FYa0IsS0FZMUIsS0FBSzI4QixRQUFMLENBQWMzOEIsUUFBZCxHQUF5QixLQUFLMjhCLFFBQUwsQ0FBYzE4QixVQVpiO0FBZTNCLFVBQU02OEIsV0FBVyxHQUFHQyw0R0FBYSxDQUFDLEtBQUtKLFFBQU4sRUFBZ0JqQyxPQUFoQixDQUFqQztBQUlBLGFBRkEsS0FBS2lDLFFBQUwsR0FBZ0JHLFdBQVcsQ0FBQyxDQUFELENBRTNCLEVBQU8sVUFBU2h5QyxDQUFULEVBQVk7QUFDbEIsWUFBTWt5QyxZQUFZLEdBQUdGLFdBQVcsQ0FBQ2h5QyxDQUFELENBQWhDO0FBRTRCO0FBQzVCLGVBREFreUMsWUFBWSxDQUFDdm5ELElBQWIsR0FBb0JyRyxDQUFDLENBQUNxRyxJQUN0QixFQUFPNk4sRUFBRSxDQUFDeTNDLE1BQUgsQ0FBVWlDLFlBQVYsS0FBUDtBQUNBLE9BTEQ7QUFNQSxLQW5DRixFQW9DRS9xRCxJQXBDRixDQW9DTyxXQXBDUCxFQW9Db0JnNEIsYUFBYSxHQUFHLFVBQUgsR0FBZ0IsRUFwQ2pELEVBcUNFNWhCLEtBckNGLENBcUNRLE1BckNSLEVBcUNnQixVQUFBalosQ0FBQyxFQUFJO0FBQ25CLFVBQUlvUixLQUFKO0FBV0EsYUFUSThDLEVBQUUsQ0FBQ3VzQixVQVNQLElBUkNydkIsS0FBSyxHQUFHOEMsRUFBRSxDQUFDdXNCLFVBQUgsQ0FBY3pnQyxDQUFDLENBQUNxRyxJQUFGLENBQU8rTixNQUFQLENBQWMsQ0FBZCxFQUFpQi9TLEtBQS9CLENBUVQsRUFMQ3dJLE1BQU0sQ0FBQzlVLFdBQVAsQ0FBbUJpTCxDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUExQixJQUFnQzZlLEtBS2pDLElBSENBLEtBQUssR0FBRzhDLEVBQUUsQ0FBQzlDLEtBQUgsQ0FBU3BSLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQWhCLENBR1QsRUFBTzZlLEtBQVA7QUFDQSxLQWxERixFQW1EQztBQW5ERCxLQW9ERTZILEtBcERGLENBb0RRLFNBcERSLEVBb0RtQixHQXBEbkIsRUFxREVyWCxJQXJERixDQXFET3NTLEVBQUUsQ0FBQ2llLE1BckRWLEVBcURrQixZQUFXO0FBQzNCLFVBQUlqZSxFQUFFLENBQUN1c0IsVUFBUCxFQUFtQjtBQUFBLFlBQ1o3dEMsSUFBSSxHQUFHMGxCLGlHQUFRLENBQUMsSUFBRCxDQURIO0FBQUEsWUFFWnRZLENBQU0sR0FBR3BOLElBQUksQ0FBQzgvQixLQUFMLEVBRkc7QUFJbEJ4ZSxVQUFFLENBQUNxb0IscUJBQUgsQ0FBeUJ2OEIsQ0FBQyxDQUFDcUcsSUFBRixDQUFPOVQsRUFBaEMsRUFBb0NLLElBQUksQ0FBQ3FtQixLQUFMLENBQVcsTUFBWCxDQUFwQyxDQUprQjtBQUtsQjs7QUFFRDdvQixXQUFLLENBQUNrRCxVQUFOLEtBUjJCLEVBUzNCa08sTUFBTSxDQUFDcUksTUFBTSxDQUFDc0osVUFBUixFQUFvQmUsRUFBRSxDQUFDZ0osR0FBdkIsQ0FUcUI7QUFVM0IsS0EvREYsQ0EvQm1ELEVBaUduRG13QyxjQUFjLElBQUluNUMsRUFBRSxDQUFDMjVDLFlBQUgsQ0FBZ0JQLE9BQWhCLENBakdpQyxFQW1HbkRwNUMsRUFBRSxDQUFDNDVDLGFBQUgsQ0FBaUI3cUMsUUFBakIsQ0FuR21EO0FBb0duRCxHQXprQmE7QUEya0JkdXFDLHFCQTNrQmMsaUNBMmtCUTtBQUNmLFFBQUF0NUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN1QnFLLEVBRHZCLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDdUI4akIsRUFEdkIsQ0FDUzlqQixLQURUO0FBQUEsUUFDZ0JrVCxHQURoQixHQUN1QjRRLEVBRHZCLENBQ2dCNVEsR0FEaEI7QUFBQSxRQUVDNVAsZUFGRCxHQUVvQndnQixFQUFFLENBQUM5akIsS0FGdkIsQ0FFQ3NELGVBRkQ7QUFBQSxRQUlBcTZELGFBSkEsR0FJZ0J6cUQsR0FBRyxDQUFDRyxJQUFKLENBQVNrVixTQUFULE9BQXVCOVUsY0FBSyxDQUFDdFosSUFBN0IsRUFDcEJvdUIsU0FEb0IsT0FDTjlVLGNBQUssQ0FBQ3ZaLFlBREEsRUFFcEIrYixJQUZvQixDQUVmNk4sRUFBRSxDQUFDaTRCLE9BQUgsQ0FBVzkwQixJQUFYLENBQWdCbkQsRUFBaEIsQ0FGZSxDQUpoQjtBQUFBLFFBUUE4NUMsZ0JBUkEsR0FRbUJELGFBQWEsQ0FBQ24xQyxLQUFkLEdBQ3ZCaFcsTUFEdUIsQ0FDaEIsTUFEZ0IsRUFFdkJDLElBRnVCLENBRWxCLE9BRmtCLEVBRVQsVUFBQTdDLENBQUM7QUFBQSxhQUFPNkQsY0FBSyxDQUFDdlosWUFBYixTQUE2QnVaLGNBQUssQ0FBQ2hWLE1BQW5DLFNBQTZDZ1YsY0FBSyxDQUFDaFYsTUFBbkQsU0FBNkRtUixDQUFDLENBQUNxRyxJQUFGLENBQU85VCxFQUFwRTtBQUFBLEtBRlEsRUFHdkJzbUIsS0FIdUIsQ0FHakJrMUMsYUFIaUIsQ0FSbkI7QUFhTkMsb0JBQWdCLENBQ2QvMEMsS0FERixDQUNRLE1BRFIsRUFDZ0IsVUFBQWpaLENBQUM7QUFBQSxhQUFLa1UsRUFBRSxDQUFDdXNCLFVBQUgsR0FBZ0J2c0IsRUFBRSxDQUFDdXNCLFVBQUgsQ0FBY3pnQyxDQUFDLENBQUNxRyxJQUFGLENBQU8rTixNQUFQLENBQWMsQ0FBZCxFQUFpQi9TLEtBQS9CLENBQWhCLEdBQXdENlMsRUFBRSxDQUFDOUMsS0FBSCxDQUFTcFIsQ0FBQyxDQUFDcUcsSUFBWCxDQUE3RDtBQUFBLEtBRGpCLEVBRUU0UyxLQUZGLENBRVEsU0FGUixFQUVtQnBQLE1BQU0sQ0FBQ2lGLGdCQUFQLEdBQTBCLEVBQTFCLEdBQStCLE1BRmxELEVBR0V1SixJQUhGLENBR08sVUFBU3JZLENBQVQsRUFBWTtBQUFBLFVBQ2JpdUQsVUFBVSxHQUFHLENBREE7QUFBQSxVQUVYQyxhQUFhLEdBQUcsQ0FGTDtBQUFBLFVBR2JyOEQsQ0FBQyxHQUFHLENBSFM7QUFBQSxVQUliRyxDQUFDLEdBQUcsQ0FKUztBQUFBLFVBS2I0VCxTQUFTLEdBQUcsRUFMQzs7QUFPakIsVUFBSWxTLGVBQWUsQ0FBQzBPLE9BQWhCLENBQXdCcEMsQ0FBQyxDQUFDcUcsSUFBRixDQUFPOVQsRUFBL0IsSUFBcUMsQ0FBekMsRUFBNEM7QUFBQSxZQUNyQys0RCxPQUFPLEdBQUdwM0MsRUFBRSxDQUFDdTJDLFdBQUgsQ0FBZXpxRCxDQUFmLENBRDJCO0FBQUEsWUFFckNtdUQsZUFBZSxHQUFHLzlELEtBQUssQ0FBQzZELGFBQU4sR0FBc0JpZ0IsRUFBRSxDQUFDNE4sbUJBQUgsQ0FBdUI1TixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUEvQixFQUF3QzVULE1BQTlELElBQ3RCbXJELE9BQU8sQ0FBQy94QyxLQUFSLEdBQWdCLENBRE0sQ0FGbUI7QUFBQSxZQUlyQzYwQyxTQUFTLEdBQUc5QyxPQUFPLENBQUMxNkIsUUFBUixHQUFtQmp4QixJQUFJLENBQUMwUCxFQUFMLEdBQVUsQ0FKSjtBQUFBLFlBS3JDZy9DLGNBQWMsR0FBR2orRCxLQUFLLENBQUMwRCxNQUFOLEdBQWVxNkQsZUFMSztBQUFBLFlBTXJDRyxvQkFBb0IsR0FBR0YsU0FBUyxJQUFJQyxjQUFjLEtBQUssQ0FBbkIsR0FBdUIsQ0FBdkIsR0FBNEIsSUFBSUEsY0FBcEMsQ0FOSztBQVEzQ0osa0JBQVUsR0FBRzc5RCxLQUFLLENBQUM4RCxjQUFOLEdBQXVCOUQsS0FBSyxDQUFDMEQsTUFBN0IsR0FBc0NxNkQsZUFSUixFQVMzQ3Q4RCxDQUFDLEdBQUc4TixJQUFJLENBQUN5akMsR0FBTCxDQUFTa3JCLG9CQUFULElBQWlDRCxjQVRNLEVBVTNDcjhELENBQUMsR0FBRzJOLElBQUksQ0FBQ2dhLEdBQUwsQ0FBUzIwQyxvQkFBVCxJQUFpQ0QsY0FWTSxFQVczQ3pvRCxTQUFTLGVBQWF3b0QsU0FBUyxHQUFHLEdBQVosR0FBa0J6dUQsSUFBSSxDQUFDMFAsRUFBcEMsVUFBMkN4ZCxDQUEzQyxVQUFpREcsQ0FBakQsTUFYa0M7QUFZM0M7O0FBRURzbUIsdUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FDRXpWLElBREYsQ0FDTyxHQURQLEVBQ1loUixDQURaLEVBRUVnUixJQUZGLENBRU8sR0FGUCxFQUVZN1EsQ0FGWixFQUdFNlEsSUFIRixDQUdPLE9BSFAsRUFHZ0JvckQsVUFIaEIsRUFJRXByRCxJQUpGLENBSU8sUUFKUCxFQUlpQnFyRCxhQUpqQixFQUtFcnJELElBTEYsQ0FLTyxXQUxQLEVBS29CK0MsU0FMcEIsRUFNRXFULEtBTkYsQ0FNUSxrQkFOUixXQU1rQ2cxQyxVQUFVLEdBQUdDLGFBTi9DLFVBckJpQjtBQTRCakIsS0EvQkYsQ0FkcUI7QUE4Q3JCLEdBem5CYTtBQTJuQmRMLGNBM25CYyx3QkEybkJEeGpFLEdBM25CQyxFQTJuQkk7QUFNakIsYUFBU2trRSxTQUFULENBQW1CQyxLQUFuQixFQUEwQnJpQixPQUExQixFQUFtQzU1QyxFQUFuQyxFQUF1QztBQUV0QzJoQixRQUFFLENBQUNtNEMsU0FBSCxDQUFhOTVELEVBQWIsQ0FGc0MsRUFHdEMyaEIsRUFBRSxDQUFDZ0osR0FBSCxDQUFPMmYsS0FBUCxDQUFhdHFDLEVBQWIsQ0FIc0MsRUFJdEMyaEIsRUFBRSxDQUFDMG9CLGlCQUFILENBQXFCcnFDLEVBQXJCLEtBSnNDLEVBS3RDMmhCLEVBQUUsQ0FBQzAxQixXQUFILENBQWUsQ0FBQ3VDLE9BQUQsQ0FBZixFQUEwQnFpQixLQUExQixDQUxzQztBQU10Qzs7QUFFRCxhQUFTQyxXQUFULENBQXFCdGlCLE9BQXJCLEVBQStCO0FBQzlCLFVBQU01NUMsRUFBRSxHQUFJNDVDLE9BQU8sSUFBSUEsT0FBTyxDQUFDNTVDLEVBQXBCLElBQTJCb0MsU0FBdEM7QUFFQXVmLFFBQUUsQ0FBQzI0QyxXQUFILENBQWV0NkQsRUFBZixDQUg4QixFQUk5QjJoQixFQUFFLENBQUNnSixHQUFILENBQU8yZ0IsTUFBUCxFQUo4QixFQUs5QjNwQixFQUFFLENBQUM2b0IsWUFBSCxFQUw4QixFQU05QjdvQixFQUFFLENBQUM0cEIsV0FBSCxFQU44QjtBQU85Qjs7QUFwQkssUUFBQTVwQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2tCcUssRUFEbEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTelosS0FEVCxHQUNrQjhqQixFQURsQixDQUNTOWpCLEtBRFQ7QUFBQSxRQUVBa3RDLE9BRkEsR0FFVWx0QyxLQUFLLENBQUNnQyxTQUFOLEtBQW9CLE9BRjlCO0FBQUEsUUFHQXM4RCxPQUhBLEdBR1V0K0QsS0FBSyxDQUFDZ0MsU0FBTixLQUFvQixPQUg5Qjs7QUFxRU47QUFDQSxRQWhEQS9ILEdBQUcsQ0FDRDJvQyxFQURGLENBQ0ssT0FETCxFQUNjLFVBQVNoekIsQ0FBVCxFQUFZMkMsQ0FBWixFQUFlO0FBQUEsVUFFdkJ3cEMsT0FGdUI7QUFBQSxVQUNyQm1mLE9BQU8sR0FBR3AzQyxFQUFFLENBQUN1MkMsV0FBSCxDQUFlenFELENBQWYsQ0FEVztBQUl2QnNyRCxhQUp1QixLQUsxQm5mLE9BQU8sR0FBR2o0QixFQUFFLENBQUMyM0MsZ0JBQUgsQ0FBb0JQLE9BQXBCLENBTGdCLEVBTzFCcDNDLEVBQUUsQ0FBQ28vQixXQUFILElBQWtCcC9CLEVBQUUsQ0FBQ28vQixXQUFILENBQWUsSUFBZixFQUFxQm5ILE9BQXJCLEVBQThCeHBDLENBQTlCLENBUFEsRUFRMUJrSCxNQUFNLENBQUMzVSxZQUFQLENBQW9CbWlCLElBQXBCLENBQXlCbkQsRUFBRSxDQUFDZ0osR0FBNUIsRUFBaUNpdkIsT0FBakMsRUFBMEMsSUFBMUMsQ0FSMEI7QUFVM0IsS0FYRixDQWdEQSxFQWxDSXVpQixPQWtDSixJQWpDQ3JrRSxHQUFHLENBQ0Qyb0MsRUFERixDQUNLLFdBREwsRUFDa0IsVUFBU2h6QixDQUFULEVBQVk7QUFDNUIsV0FBSTVQLEtBQUssQ0FBQ2tELFVBQVYsRUFBd0I7QUFBeEI7QUFBQSxjQUlNZzRELE9BQU8sR0FBR3AzQyxFQUFFLENBQUN1MkMsV0FBSCxDQUFlenFELENBQWYsQ0FKaEI7QUFBQSxjQUtNbXNDLE9BQU8sR0FBR21mLE9BQU8sR0FBR3AzQyxFQUFFLENBQUMyM0MsZ0JBQUgsQ0FBb0JQLE9BQXBCLENBQUgsR0FBa0MsSUFMekQ7QUFBQSxjQU1NLzRELEVBQUUsR0FBSTQ1QyxPQUFPLElBQUlBLE9BQU8sQ0FBQzU1QyxFQUFwQixJQUEyQm9DLFNBTnRDO0FBUUE0NUQsbUJBQVMsQ0FBQyxJQUFELEVBQU9waUIsT0FBUCxFQUFnQjU1QyxFQUFoQixDQVJULEVBU0EyaEIsRUFBRSxDQUFDa2UsVUFBSCxLQUFvQitaLE9BQXBCLENBVEE7QUFBQTtBQVVBLEtBWkYsRUFhRW5aLEVBYkYsQ0FhSyxVQWJMLEVBYWlCLFVBQUFoekIsQ0FBQyxFQUFJO0FBQ3BCLFdBQUk1UCxLQUFLLENBQUNrRCxVQUFWLEVBQXdCO0FBQXhCO0FBQUEsY0FJTWc0RCxPQUFPLEdBQUdwM0MsRUFBRSxDQUFDdTJDLFdBQUgsQ0FBZXpxRCxDQUFmLENBSmhCO0FBQUEsY0FLTW1zQyxPQUFPLEdBQUdtZixPQUFPLEdBQUdwM0MsRUFBRSxDQUFDMjNDLGdCQUFILENBQW9CUCxPQUFwQixDQUFILEdBQWtDLElBTHpEO0FBT0FtRCxxQkFBVyxFQVBYLEVBUUF2NkMsRUFBRSxDQUFDa2UsVUFBSCxLQUFxQitaLE9BQXJCLENBUkE7QUFBQTtBQVNBLEtBdkJGLEVBd0JFblosRUF4QkYsQ0F3QkssV0F4QkwsRUF3QmtCLFVBQVNoekIsQ0FBVCxFQUFZO0FBQUEsVUFDdEJzckQsT0FBTyxHQUFHcDNDLEVBQUUsQ0FBQ3UyQyxXQUFILENBQWV6cUQsQ0FBZixDQURZO0FBQUEsVUFFdEJtc0MsT0FBTyxHQUFHbWYsT0FBTyxHQUFHcDNDLEVBQUUsQ0FBQzIzQyxnQkFBSCxDQUFvQlAsT0FBcEIsQ0FBSCxHQUFrQyxJQUY3QjtBQUk1QnAzQyxRQUFFLENBQUMwMUIsV0FBSCxDQUFlLENBQUN1QyxPQUFELENBQWYsRUFBMEIsSUFBMUIsQ0FKNEI7QUFLNUIsS0E3QkYsQ0FpQ0QsRUFBSTdPLE9BQU8sSUFBSXBwQixFQUFFLENBQUNtUSxVQUFILEVBQVgsSUFBOEIsQ0FBQ25RLEVBQUUsQ0FBQ3k2QyxNQUF0QyxFQUE4QztBQUFBLFVBQ3ZDQyxXQUFXLEdBQUcsWUFBTTtBQUFBLFlBQ25Cbm1ELEtBQUssR0FBR2pGLHdGQUFPLENBQUM4RixjQUFSLENBQXVCLENBQXZCLENBRFc7QUFBQSxZQUVuQnVsRCxRQUFRLEdBQUd2MkMsaUdBQVEsQ0FBQ3JaLFdBQVEsQ0FBQ3l6QyxnQkFBVCxDQUEwQmpxQyxLQUFLLENBQUNWLE9BQWhDLEVBQXlDVSxLQUFLLENBQUNULE9BQS9DLENBQUQsQ0FGQTtBQUl6QixlQUFPNm1ELFFBQVA7QUFDQSxPQU40QztBQUFBLFVBUXZDQyxPQUFPLEdBQUcsWUFBVztBQUMxQixhQUFJMStELEtBQUssQ0FBQ2tELFVBQVYsRUFBd0I7QUFBeEI7QUFBQSxnQkFJTXU3RCxRQUFRLEdBQUdELFdBQVcsRUFKNUI7QUFBQSxnQkFLTWw4QixLQUFVLEdBQUdtOEIsUUFBUSxDQUFDbjhCLEtBQVQsRUFMbkI7QUFBQSxnQkFNTTQ0QixPQUFPLEdBQUk1NEIsS0FBSyxJQUFJQSxLQUFLLENBQUNyc0IsSUFBZixJQUF1QnFzQixLQUFLLENBQUNyc0IsSUFBTixDQUFXOVQsRUFBbkMsR0FBeUMyaEIsRUFBRSxDQUFDdTJDLFdBQUgsQ0FBZS8zQixLQUFmLENBQXpDLEdBQWlFLElBTmpGO0FBQUEsZ0JBT015WixPQUFPLEdBQUdtZixPQUFPLEdBQUdwM0MsRUFBRSxDQUFDMjNDLGdCQUFILENBQW9CUCxPQUFwQixDQUFILEdBQWtDLElBUHpEO0FBQUEsZ0JBUU0vNEQsRUFBRSxHQUFJNDVDLE9BQU8sSUFBSUEsT0FBTyxDQUFDNTVDLEVBQXBCLElBQTJCb0MsU0FSdEM7QUFVQXVmLGNBQUUsQ0FBQzBlLG1CQUFILENBQXVCdVosT0FBdkIsQ0FWQSxFQVlBNXNDLFdBQVcsQ0FBQ2hOLEVBQUQsQ0FBWCxHQUNDazhELFdBQVcsRUFEWixHQUNpQkYsU0FBUyxDQUFDLElBQUQsRUFBT3BpQixPQUFQLEVBQWdCNTVDLEVBQWhCLENBYjFCO0FBQUE7QUFjQSxPQXZCNEM7O0FBeUI3QzJoQixRQUFFLENBQUM1USxHQUFILENBQU9tZSxHQUFQLENBQ0V1UixFQURGLENBQ0ssWUFETCxFQUNtQjg3QixPQURuQixFQUVFOTdCLEVBRkYsQ0FFSyxXQUZMLEVBRWtCODdCLE9BRmxCLENBekI2QztBQTRCN0M7QUFDRCxHQS90QmE7QUFpdUJkaEIsZUFqdUJjLHlCQWl1QkE3cUMsUUFqdUJBLEVBaXVCVTtBQUtuQixRQUFBbjBCLElBQUk7QUFBQSxRQUpGb2xCLEVBSUUsR0FKRyxJQUlIO0FBQUEsUUFIRHJLLE1BR0MsR0FIbUNxSyxFQUduQyxDQUhEckssTUFHQztBQUFBLFFBSE96WixLQUdQLEdBSG1DOGpCLEVBR25DLENBSE85akIsS0FHUDtBQUFBLGtCQUhtQzhqQixFQUduQyxDQUhjNVEsR0FHZDtBQUFBLFFBSG9CRyxJQUdwQixXQUhvQkEsSUFHcEI7QUFBQSxRQUgwQmxaLElBRzFCLFdBSDBCQSxJQUcxQjtBQUFBLFFBRkZnekMsUUFFRSxHQUZTcnBCLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLENBRVQ7QUFBQSxRQURGc2hCLGdCQUNFLEdBRGlCeDNCLEVBQUUsQ0FBQ3czQixnQkFBSCxFQUNqQjs7QUF3QlIsUUFyQk1uTyxRQUFRLElBQUlycEIsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQjVULE1BQWhCLEtBQTJCLENBQXZDLElBQTRDMEosTUFBTSxDQUFDeUYsV0FxQnpELEtBcEJDeGdCLElBQUksR0FBRzJVLElBQUksQ0FBQ2tWLFNBQUwsT0FBbUI5VSxjQUFLLENBQUN0WSxRQUF6QixFQUNMcVksTUFESyxDQUNFLE1BREYsRUFFTHFWLEtBRkssQ0FFQyxTQUZELEVBRVksR0FGWixFQUdMcFcsSUFISyxDQUdBLE9BSEEsRUFHUyxVQUFBN0MsQ0FBQztBQUFBLGFBQUtrVSxFQUFFLENBQUM0M0IsV0FBSCxDQUFlOXJDLENBQUMsQ0FBQ3FHLElBQWpCLElBQXlCeEMsY0FBSyxDQUFDelcsVUFBL0IsR0FBNEMsSUFBakQ7QUFBQSxLQUhWLEVBSUx3VSxJQUpLLENBSUFzUyxFQUFFLENBQUM0M0MsZUFBSCxDQUFtQnowQyxJQUFuQixDQUF3Qm5ELEVBQXhCLENBSkEsRUFLTHJSLElBTEssQ0FLQSxXQUxBLEVBS2FxUixFQUFFLENBQUMwM0Msb0JBQUgsQ0FBd0J2MEMsSUFBeEIsQ0FBNkJuRCxFQUE3QixDQUxiLEVBTUwrRSxLQU5LLENBTUMsV0FORCxFQU1jLFVBQUFqWixDQUFDO0FBQUEsYUFDcEJrVSxFQUFFLENBQUM0M0IsV0FBSCxDQUFlOXJDLENBQUMsQ0FBQ3FHLElBQWpCLEtBQTBCNk4sRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixDQUFnQjVULE1BQWhCLEtBQTJCLENBQXJELElBQTBELENBQUN1ckMsZ0JBQTNELEdBQ0kvckMsSUFBSSxDQUFDOFYsS0FBTCxDQUFXcmxCLEtBQUssQ0FBQzBELE1BQU4sR0FBZSxDQUExQixDQURKLFVBQ3VDLElBRm5CO0FBQUEsS0FOZixFQVVMcWlCLFVBVkssR0FXTDhNLFFBWEssQ0FXSUEsUUFYSixFQVlMaEssS0FaSyxDQVlDLFNBWkQsRUFZWSxVQUFBalosQ0FBQztBQUFBLGFBQUtrVSxFQUFFLENBQUNvWSxjQUFILENBQWtCdHNCLENBQUMsQ0FBQ3FHLElBQUYsQ0FBTzlULEVBQXpCLEtBQWdDMmhCLEVBQUUsQ0FBQzgzQixTQUFILENBQWFoc0MsQ0FBQyxDQUFDcUcsSUFBZixDQUFoQyxHQUF1RCxHQUF2RCxHQUE2RCxHQUFsRTtBQUFBLEtBWmIsQ0FvQlIsRUFOQ3FsQyxnQkFBZ0IsSUFBSTU4QyxJQUFJLENBQUMrVCxJQUFMLENBQVUsSUFBVixFQUFnQixPQUFoQixDQU1yQixHQUhBWSxJQUFJLENBQUNHLE1BQUwsT0FBZ0JDLGNBQUssQ0FBQ2hZLGNBQXRCLEVBQ0VvdEIsS0FERixDQUNRLFNBRFIsRUFDbUIvRSxFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxLQUF1Qm1ULFFBQXZCLEdBQWtDLEdBQWxDLEdBQXdDLEdBRDNELENBR0EsRUFBSUEsUUFBSixFQUFjO0FBQUEsVUFDUHd4QixZQUFZLEdBQUdsbEQsTUFBTSxDQUFDZ0YsZ0JBRGY7QUFBQSxVQUVQZ2lCLFVBQVUsR0FBRyxDQUFDLENBQUQsR0FBS2x4QixJQUFJLENBQUMwUCxFQUFWLEdBQWUsQ0FGckI7QUFBQSxVQUdQdWhCLFFBQVEsR0FBRyxDQUFDbStCLFlBQVksR0FBRyxDQUFDLENBQUosR0FBUSxDQUFDLENBQXRCLElBQTJCbCtCLFVBSC9CO0FBS2JrK0Isa0JBQVksSUFBSWpnRSxJQUFoQixJQUF3QkEsSUFBSSxDQUFDK1QsSUFBTCxDQUFVLElBQVYsT0FBbUJsRCxJQUFJLENBQUM4VixLQUFMLENBQVdybEIsS0FBSyxDQUFDMEQsTUFBTixHQUFlLEVBQTFCLENBQW5CLENBTFg7QUFPYixVQUFJazdELGFBQWEsR0FBRzk2QyxFQUFFLENBQUM1USxHQUFILENBQU8vWSxJQUFQLENBQVlxWixNQUFaLEVBQ2hCOG5DLGdCQUFnQixHQUFHLEdBQUgsR0FBUyxFQURULFVBQ2U3bkMsY0FBSyxDQUFDcFksbUJBRHJCLENBQXBCOztBQUlBLFVBQUlpZ0QsZ0JBQUosRUFBc0I7QUFDckIsWUFBSW55QixLQUFLLEdBQUcsQ0FBWjtBQUVBeTFDLHFCQUFhLEdBQUdBLGFBQWEsQ0FDM0JyMkMsU0FEYyxXQUNJOVUsY0FBSyxDQUFDcFksbUJBRFYsRUFFZDRhLElBRmMsQ0FFVDZOLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BRkMsQ0FISyxFQU9yQmk3QyxhQUFhLENBQUNwMkMsS0FBZCxHQUNFaFcsTUFERixDQUNTLE1BRFQsRUFFRUMsSUFGRixDQUVPLE9BRlAsRUFFZ0IsVUFBQzdDLENBQUQsRUFBSTJDLENBQUo7QUFBQSxpQkFBYWtCLGNBQUssQ0FBQ3BZLG1CQUFuQixTQUEwQ29ZLGNBQUssQ0FBQ3BZLG1CQUFoRCxTQUF1RWtYLENBQXZFO0FBQUEsU0FGaEIsRUFHRWtXLEtBSEYsQ0FHUW0yQyxhQUhSLEVBSUVuc0QsSUFKRixDQUlPLEdBSlAsRUFJWSxVQUFBcy9DLEVBQUUsRUFBSTtBQUNoQixjQUFJL3hELEtBQUssQ0FBQ3NELGVBQU4sQ0FBc0IwTyxPQUF0QixDQUE4QisvQyxFQUFFLENBQUM1dkQsRUFBakMsS0FBd0MsQ0FBNUMsRUFDQyxPQUFPLE9BQVA7QUFHRCxjQUFNeU4sQ0FBQyxHQUFHO0FBQ1RxRyxnQkFBSSxFQUFFLENBQUM7QUFBQ2hGLG1CQUFLLEVBQUV3SSxNQUFNLENBQUNxRjtBQUFmLGFBQUQsQ0FERztBQUVUMmhCLHNCQUFVLEVBQVZBLFVBRlM7QUFHVEQsb0JBQVEsRUFBUkEsUUFIUztBQUlUclgsaUJBQUssRUFBRUEsS0FBSztBQUpILFdBQVY7QUFPQSxpQkFBT3JGLEVBQUUsQ0FBQ3kzQyxNQUFILENBQVUzckQsQ0FBVixTQUFQO0FBQ0EsU0FqQkYsQ0FQcUIsRUEwQnJCZ3ZELGFBQWEsQ0FBQzcxQyxJQUFkLEdBQXFCdEYsTUFBckIsRUExQnFCO0FBMkJyQixPQTNCRCxNQTRCQ203QyxhQUFhLENBQUNuc0QsSUFBZCxDQUFtQixHQUFuQixFQUF3QixZQUFNO0FBQzdCLFlBQU03QyxDQUFDLEdBQUc7QUFDVHFHLGNBQUksRUFBRSxDQUFDO0FBQUNoRixpQkFBSyxFQUFFd0ksTUFBTSxDQUFDcUY7QUFBZixXQUFELENBREc7QUFFVDJoQixvQkFBVSxFQUFWQSxVQUZTO0FBR1RELGtCQUFRLEVBQVJBO0FBSFMsU0FBVjtBQU1BLGVBQU8xYyxFQUFFLENBQUN5M0MsTUFBSCxDQUFVM3JELENBQVYsU0FBUDtBQUNBLE9BUkQsQ0E1QkQ7O0FBdUNBelYsVUFBSSxDQUFDcVosTUFBTCxPQUFnQkMsY0FBSyxDQUFDalksa0JBQXRCLEVBQ0VpWCxJQURGLENBQ08sSUFEUCxFQUNhLE9BRGIsRUFFRS9ULElBRkYsQ0FFTythLE1BQU0sQ0FBQ2lGLGdCQUFQLEdBQTBCakYsTUFBTSxDQUFDMEYsV0FBakMsR0FBK0MsRUFGdEQsQ0FsRGEsRUFzRFQxRixNQUFNLENBQUNpRixnQkF0REUsS0F1RFp2a0IsSUFBSSxDQUFDcVosTUFBTCxPQUFnQkMsY0FBSyxDQUFDbFksaUJBQXRCLEVBQ0VrWCxJQURGLENBQ08sSUFEUCxFQUNnQixDQUFDLENBQUQsSUFBTXpTLEtBQUssQ0FBQzJELFdBQU4sR0FBcUIsQ0FBQzNELEtBQUssQ0FBQzBELE1BQU4sR0FBZTFELEtBQUssQ0FBQzJELFdBQXRCLEtBQXNDZzdELFlBQVksR0FBRyxDQUFILEdBQU8sQ0FBekQsQ0FBM0IsQ0FEaEIsU0FFRWxzRCxJQUZGLENBRU8sSUFGUCxFQUVhLE9BRmIsRUFHRS9ULElBSEYsQ0FHT29sQixFQUFFLENBQUNpNEMsa0JBQUgsQ0FBc0J0aUQsTUFBTSxDQUFDb0YsU0FBN0IsS0FIUCxDQXZEWSxFQTZEWixDQUFDOC9DLFlBQUQsSUFBaUJ4a0UsSUFBSSxDQUFDcVosTUFBTCxPQUFnQkMsY0FBSyxDQUFDblksaUJBQXRCLEVBQ2ZtWCxJQURlLENBQ1YsSUFEVSxFQUNEelMsS0FBSyxDQUFDMkQsV0FBTixHQUFxQixDQUFDM0QsS0FBSyxDQUFDMEQsTUFBTixHQUFlMUQsS0FBSyxDQUFDMkQsV0FBdEIsSUFBcUMsQ0FEekQsU0FFZjhPLElBRmUsQ0FFVixJQUZVLEVBRUosT0FGSSxFQUdmL1QsSUFIZSxDQUdWb2xCLEVBQUUsQ0FBQ2k0QyxrQkFBSCxDQUFzQnRpRCxNQUFNLENBQUNxRixTQUE3QixLQUhVLENBN0RMO0FBa0ViO0FBQ0QsR0FqMEJhO0FBbTBCZCsvQyxXQW4wQmMsdUJBbTBCRjtBQUNMLFFBQUEvNkMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN3QnFLLEVBRHhCLENBQ0NySyxNQUREO0FBQUEsUUFDZXRmLElBRGYsR0FDd0IycEIsRUFEeEIsQ0FDUzVRLEdBRFQsQ0FDZS9ZLElBRGY7QUFBQSxRQUVBMmtFLFVBRkEsR0FFYSxVQUFBMXhDLFNBQVMsRUFBSTtBQUMvQmp6QixVQUFJLENBQUNxWSxNQUFMLENBQVksTUFBWixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQjJhLFNBRGhCLEVBRUV2RSxLQUZGLENBRVEsYUFGUixFQUV1QixRQUZ2QixFQUdFQSxLQUhGLENBR1EsZ0JBSFIsRUFHMEIsTUFIMUIsQ0FEK0I7QUFLL0IsS0FQSzs7QUFTRi9FLE1BQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLENBVk8sS0FXVjcvQixJQUFJLENBQUNxWSxNQUFMLENBQVlzUixFQUFFLENBQUN3M0IsZ0JBQUgsS0FBd0IsR0FBeEIsR0FBOEIsTUFBMUMsRUFDRTdvQyxJQURGLENBQ08sT0FEUCxFQUNnQmdCLGNBQUssQ0FBQ3BZLG1CQUR0QixDQVhVLEVBY1ZvZSxNQUFNLENBQUMwRixXQUFQLElBQXNCMi9DLFVBQVUsQ0FBQ3JyRCxjQUFLLENBQUNqWSxrQkFBUCxDQWR0QixFQWdCTmllLE1BQU0sQ0FBQ2lGLGdCQWhCRCxLQWlCVG9nRCxVQUFVLENBQUNyckQsY0FBSyxDQUFDbFksaUJBQVAsQ0FqQkQsRUFrQlQsQ0FBQ2tlLE1BQU0sQ0FBQ2dGLGdCQUFSLElBQTRCcWdELFVBQVUsQ0FBQ3JyRCxjQUFLLENBQUNuWSxpQkFBUCxDQWxCN0I7QUFxQlgsR0F4MUJhO0FBMDFCZDY0QyxxQkExMUJjLGlDQTAxQlE7QUFDckIsV0FBTyxLQUFLMTZCLE1BQUwsQ0FBWWlGLGdCQUFaLEdBQStCLEVBQS9CLEdBQW9DLENBQTNDO0FBQ0E7QUE1MUJhLENBQWYsRTs7QUNqQkE7Ozs7QUFJQTtBQUlBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBV0EsU0FBU3FnRCxXQUFULENBQXFCQyxXQUFyQixFQUFrQ3pyRCxJQUFsQyxFQUF3QzByRCxJQUF4QyxFQUE4Q24xQyxHQUE5QyxFQUFtRHZGLEtBQW5ELEVBQTBENmIsS0FBMUQsRUFBaUU7QUFBQSxNQUMxRGpYLEtBQUssR0FBRzYxQyxXQUFXLElBQUlsMUMsR0FBRyxHQUFHLENBQXJCLEdBQXlCbTFDLElBQUksR0FBR24xQyxHQUFoQyxHQUFzQ0EsR0FEWTtBQUFBLE1BRTFESyxDQUFDLEdBQUcsSUFBSTVhLElBQUksQ0FBQzBQLEVBRjZDO0FBQUEsTUFHMURpZ0QsSUFBSSxHQUFHM3JELElBQUksS0FBSyxHQUFULEdBQWVoRSxJQUFJLENBQUNnYSxHQUFwQixHQUEwQmhhLElBQUksQ0FBQ3lqQyxHQUhvQjtBQUtoRSxTQUFPenVCLEtBQUssSUFBSSxJQUFJNmIsS0FBSyxHQUFHOCtCLElBQUksQ0FBQy8xQyxLQUFLLEdBQUdnQixDQUFSLEdBQVk4MEMsSUFBYixDQUFwQixDQUFaO0FBQ0EsQyxDQUVEOzs7QUFDQSxJQUFNL2pDLGNBQVEsR0FBRyxjQUFqQjtBQUVlO0FBQ2Rpa0MsV0FEYyx1QkFDRjtBQUNMLFFBQUFyN0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdGcUssTUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsQ0FKTyxLQUtWbFcsRUFBRSxDQUFDeTZDLE1BQUgsR0FBWXo2QyxFQUFFLENBQUM1USxHQUFILENBQU9HLElBQVAsQ0FBWUcsTUFBWixPQUF1QkMsY0FBSyxDQUFDdlksS0FBN0IsRUFBc0NzWCxNQUF0QyxDQUE2QyxHQUE3QyxFQUNWQyxJQURVLENBQ0wsT0FESyxFQUNJZ0IsY0FBSyxDQUFDeFgsV0FEVixDQUxGLEVBU1Y2bkIsRUFBRSxDQUFDeTZDLE1BQUgsQ0FBVTVnRSxNQUFWLEdBQW1CbW1CLEVBQUUsQ0FBQ3k2QyxNQUFILENBQVUvckQsTUFBVixDQUFpQixHQUFqQixFQUNqQkMsSUFEaUIsQ0FDWixPQURZLEVBQ0hnQixjQUFLLENBQUM5VixNQURILENBVFQsRUFhVm1tQixFQUFFLENBQUN5NkMsTUFBSCxDQUFVaHlDLElBQVYsR0FBaUJ6SSxFQUFFLENBQUN5NkMsTUFBSCxDQUFVL3JELE1BQVYsQ0FBaUIsR0FBakIsRUFDZkMsSUFEZSxDQUNWLE9BRFUsRUFDRGdCLGNBQUssQ0FBQ25aLElBREwsQ0FiUCxFQWlCVndwQixFQUFFLENBQUN5NkMsTUFBSCxDQUFVcGdFLE1BQVYsR0FBbUIybEIsRUFBRSxDQUFDeTZDLE1BQUgsQ0FBVS9yRCxNQUFWLENBQWlCLEdBQWpCLEVBQ2pCQyxJQURpQixDQUNaLE9BRFksRUFDSGdCLGNBQUssQ0FBQ3RWLE1BREgsQ0FqQlQsRUFvQlYybEIsRUFBRSxDQUFDZ2QsUUFBSCxHQUFjcm5CLE1BQU0sQ0FBQzJHLGNBQVAsSUFBeUIwRCxFQUFFLENBQUNtWCxhQUFILEdBQW1CdlUsR0FBbkIsQ0FBdUIsQ0FBdkIsRUFBMEJ6VixLQXBCdkQ7QUFzQlgsR0F2QmE7QUF5QmRvcEMsY0F6QmMsMEJBeUJDO0FBQ1IsUUFBQXYyQixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ3lDcUssRUFEekMsQ0FDQ3JLLE1BREQ7QUFBQSxvQkFDeUNxSyxFQUR6QyxDQUNTOWpCLEtBRFQ7QUFBQSxRQUNpQlksUUFEakIsYUFDaUJBLFFBRGpCO0FBQUEsUUFDMkJDLFNBRDNCLGFBQzJCQSxTQUQzQjtBQUFBLFFBRUF3eEIsT0FGQSxHQUVVNVksTUFBTSxDQUFDelAsaUJBQVAsQ0FBeUIrRixNQUF6QixHQUFrQyxDQUFsQyxHQUFzQyxDQUFDLEVBQXZDLEdBQTRDLEVBRnREO0FBQUEsUUFHQXJPLElBSEEsR0FHTyxDQUFDNk4sSUFBSSxDQUFDd0QsR0FBTCxDQUFTblMsUUFBVCxFQUFtQkMsU0FBbkIsSUFBZ0N3eEIsT0FBakMsSUFBNEMsQ0FIbkQ7QUFLTixXQUFPLENBQUMzd0IsSUFBRCxFQUFPQSxJQUFQLENBQVA7QUFDQSxHQWhDYTtBQWtDZDA5RCx1QkFsQ2MsaUNBa0NRejdDLE9BbENSLEVBa0NpQjtBQUN4QixRQUFBRyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBR0YzSixXQUFPLENBQUMySixNQUFNLENBQUN6UCxpQkFBUixDQUptQixLQUs3QnlQLE1BQU0sQ0FBQ3pQLGlCQUFQLEdBQTJCZ04sUUFBUSxDQUFDLENBQUQsRUFBSUYsU0FBUyxDQUFDLEtBQUQsRUFBUTZNLE9BQU8sQ0FBQ3pSLEdBQVIsQ0FBWSxVQUFBbkQsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ2lWLE1BQUYsQ0FBU2pVLE1BQWI7QUFBQSxLQUFiLENBQVIsQ0FBYixDQUxOLEdBUTlCK1QsRUFBRSxDQUFDdTdDLG1CQUFILEVBUjhCO0FBUzlCLEdBM0NhO0FBNkNkQyxrQkE3Q2MsNEJBNkNHL3JELElBN0NILEVBNkNTNFYsS0E3Q1QsRUE2Q2dCNUUsS0E3Q2hCLEVBNkN1QjZiLEtBN0N2QixFQTZDOEI7QUFDckMsUUFBQXRjLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFBQSwyQkFFa0JxSyxFQUFFLENBQUN1MkIsWUFBSCxFQUZsQjtBQUFBLFFBRUNwNkMsS0FGRDtBQUFBLFFBRVFFLE1BRlI7QUFBQSxRQUdBOCtELElBSEEsR0FHT3hsRCxNQUFNLENBQUN6UCxpQkFBUCxDQUF5QitGLE1BSGhDO0FBQUEsUUFJQWl2RCxXQUpBLEdBSWN2bEQsTUFBTSxDQUFDcUgseUJBSnJCO0FBQUEsUUFNQWdKLEdBTkEsR0FNTW5WLE9BQU8sQ0FBQ3BCLElBQUQsQ0FBUCxDQUFjckIsR0FBZCxDQUFrQixVQUFBbkQsQ0FBQztBQUFBLGFBQUlnd0QsV0FBVyxDQUM3Q0MsV0FENkMsRUFFN0Nqd0QsQ0FGNkMsRUFHN0Nrd0QsSUFINkMsRUFJN0M5MUMsS0FKNkMsRUFLN0MvWixTQUFTLENBQUNtVixLQUFELENBQVQsR0FBbUJBLEtBQW5CLEdBQTRCaFIsSUFBSSxLQUFLLEdBQVQsR0FBZXRULEtBQWYsR0FBdUJFLE1BTE4sRUFNN0MrTyxRQUFRLENBQUNreEIsS0FBRCxDQUFSLEdBQWtCQSxLQUFsQixHQUEwQjNtQixNQUFNLENBQUNvSCxnQkFOWSxDQUFmO0FBQUEsS0FBbkIsQ0FOTjs7QUFlTixXQUFPaUosR0FBRyxDQUFDL1osTUFBSixLQUFlLENBQWYsR0FBbUIrWixHQUFHLENBQUMsQ0FBRCxDQUF0QixHQUE0QkEsR0FBbkM7QUFDQSxHQTlEYTs7QUFnRWQ7Ozs7QUFJQXUxQyxxQkFwRWMsaUNBb0VRO0FBQ2YsUUFBQXY3QyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0FILE9BREEsR0FDVUcsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FEbEI7QUFBQSw0QkFHa0JHLEVBQUUsQ0FBQ3UyQixZQUFILEVBSGxCO0FBQUEsUUFHQ3A2QyxLQUhEO0FBQUEsUUFHUUUsTUFIUjtBQUFBLFFBSUF1MUMsTUFKQSxHQUlTNXhCLEVBQUUsQ0FBQ1AsS0FBSCxDQUFTRyxHQUFULENBQWF3WCxjQUFiLEtBQTBCLEVBSm5DO0FBQUEsUUFLQXg1QixJQUxBLEdBS09nMEMsTUFBTSxDQUFDNnBCLEtBTGQ7O0FBUUQ3OUQsUUFBRCxLQUFVQSxJQUFJLENBQUN6QixLQUFMLEtBQWVBLEtBQWYsSUFBd0J5QixJQUFJLENBQUN2QixNQUFMLEtBQWdCQSxNQUFsRCxDQVRpQixLQVVwQndqQixPQUFPLENBQUN4UyxPQUFSLENBQWdCLFVBQUF2QixDQUFDLEVBQUk7QUFDcEI4bEMsWUFBTSxDQUFDOWxDLENBQUMsQ0FBQ3pOLEVBQUgsQ0FBTixHQUFleU4sQ0FBQyxDQUFDb1UsTUFBRixDQUFTOVIsR0FBVCxDQUFhLFVBQUNuRCxDQUFELEVBQUl3RCxDQUFKO0FBQUEsZUFDM0J1UixFQUFFLENBQUN3N0MsZ0JBQUgsQ0FBb0IsQ0FBQyxHQUFELEVBQU0sR0FBTixDQUFwQixFQUFnQy9zRCxDQUFoQyxFQUFtQ2hPLFNBQW5DLEVBQThDdWYsRUFBRSxDQUFDb2MsUUFBSCxDQUFZLE9BQVosRUFBcUJueEIsQ0FBckIsQ0FBOUMsQ0FEMkI7QUFBQSxPQUFiLENBREs7QUFJcEIsS0FKRCxDQVZvQixFQWdCcEIybUMsTUFBTSxDQUFDNnBCLEtBQVAsR0FBZTtBQUFDdC9ELFdBQUssRUFBTEEsS0FBRDtBQUFRRSxZQUFNLEVBQU5BO0FBQVIsS0FoQkssRUFpQnBCMmpCLEVBQUUsQ0FBQ1AsS0FBSCxDQUFTRixHQUFULENBQWE2WCxjQUFiLEVBQXVCd2EsTUFBdkIsQ0FqQm9CO0FBbUJyQixHQXZGYTtBQXlGZDhwQixhQXpGYyx1QkF5RkY3cUIsZUF6RkUsRUF5RmU7QUFDdEIsUUFBQTd3QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0N6USxJQURELEdBQ1N5USxFQUFFLENBQUM1USxHQURaLENBQ0NHLElBREQ7QUFBQSxRQUVBd2pDLFNBRkEsR0FFWS95QixFQUFFLENBQUNvSSxZQUFILENBQWdCLE9BQWhCLENBRlo7QUFLRjJxQixhQU53QixLQU8zQi95QixFQUFFLENBQUN5NkMsTUFBSCxDQUFVOXJELElBQVYsQ0FBZSxXQUFmLEVBQTRCb2tDLFNBQTVCLENBUDJCLEVBUTNCeGpDLElBQUksQ0FBQ2tWLFNBQUwsT0FBbUI5VSxjQUFLLENBQUNwWCxPQUF6QixFQUFvQ29XLElBQXBDLENBQXlDLFdBQXpDLEVBQXNEb2tDLFNBQXRELENBUjJCLEVBUzNCeGpDLElBQUksQ0FBQ0csTUFBTCxPQUFnQkMsY0FBSyxDQUFDdFgsVUFBdEIsRUFBb0NzVyxJQUFwQyxDQUF5QyxXQUF6QyxFQUFzRG9rQyxTQUF0RCxDQVQyQixFQVczQi95QixFQUFFLENBQUN1N0MsbUJBQUgsRUFYMkIsRUFZM0J2N0MsRUFBRSxDQUFDMjdDLGdCQUFILEVBWjJCLEVBYTNCMzdDLEVBQUUsQ0FBQzQ3QyxlQUFILEVBYjJCLEVBYzNCNTdDLEVBQUUsQ0FBQzY3QyxnQkFBSCxDQUFvQmhyQixlQUFwQixDQWQyQjtBQWdCNUIsR0F6R2E7QUEyR2RpckIsd0JBM0djLG9DQTJHVztBQUN4QixRQUFNbHFCLE1BQU0sR0FBRyxLQUFLbnlCLEtBQUwsQ0FBV0csR0FBWCxDQUFld1gsY0FBZixDQUFmO0FBRUEsV0FBTyxVQUFDdHJCLENBQUQsRUFBSTJDLENBQUosRUFBVTtBQUNoQixVQUFNa1AsS0FBSyxHQUFHaTBCLE1BQU0sQ0FBQzlsQyxDQUFDLENBQUN6TixFQUFILENBQU4sQ0FBYW9RLENBQWIsQ0FBZDtBQUVBLGFBQU8sQ0FDTmtQLEtBRE0sRUFFTkEsS0FGTSxFQUdOQSxLQUhNLEVBSU5BLEtBSk0sQ0FBUDtBQU1BLEtBVEQ7QUFVQSxHQXhIYTtBQTBIZGcrQyxrQkExSGMsOEJBMEhLO0FBQ1osUUFBQTM3QyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBQUEsNEJBRWtCcUssRUFBRSxDQUFDdTJCLFlBQUgsRUFGbEI7QUFBQSxRQUVDcDZDLEtBRkQ7QUFBQSxRQUVRRSxNQUZSO0FBQUEsUUFHQTAvRCxLQUhBLEdBR1FwbUQsTUFBTSxDQUFDK0csaUJBSGY7QUFBQSxRQUlBeStDLElBSkEsR0FJT3hsRCxNQUFNLENBQUN6UCxpQkFBUCxDQUF5QitGLE1BSmhDO0FBQUEsUUFLQSt2RCxRQUxBLEdBS1dybUQsTUFBTSxDQUFDbUgscUJBTGxCO0FBQUEsUUFPQW0vQyxXQVBBLEdBT2NqOEMsRUFBRSxDQUFDeTZDLE1BQUgsQ0FBVTVnRSxNQVB4QjtBQUFBLFFBUUFxaUUsU0FSQSxHQVFZaHBELFFBQVEsQ0FBQyxDQUFELEVBQUk2b0QsS0FBSixDQVJwQjtBQUFBLFFBVUFuOEQsTUFWQSxHQVVTK1YsTUFBTSxDQUFDb0gsZ0JBQVAsR0FBMEJ0UixJQUFJLENBQUN3RCxHQUFMLENBQVM5UyxLQUFULEVBQWdCRSxNQUFoQixDQVZuQztBQUFBLFFBV0E4L0QsVUFYQSxHQVdhRCxTQUFTLENBQUM5dEQsR0FBVixDQUFjLFVBQUFnMUIsQ0FBQztBQUFBLGFBQUl4akMsTUFBTSxJQUFJLENBQUN3akMsQ0FBQyxHQUFHLENBQUwsSUFBVTI0QixLQUFkLENBQVY7QUFBQSxLQUFmLENBWGI7QUFBQSxRQVlBSyxlQVpBLEdBWWtCLENBQUN6bUQsTUFBTSxDQUFDaUgsdUJBQVAsSUFBa0MsWUFBVSxDQUFFLENBQS9DLEVBQWlEdUcsSUFBakQsQ0FBc0RuRCxFQUFFLENBQUNnSixHQUF6RCxDQVpsQjtBQUFBLFFBZUE0b0IsTUFmQSxHQWVTc3FCLFNBQVMsQ0FBQzl0RCxHQUFWLENBQWMsVUFBQW5ELENBQUMsRUFBSTtBQUFBLFVBQzNCd1YsS0FBSyxHQUFHMDdDLFVBQVUsQ0FBQ2x4RCxDQUFELENBRFM7QUFBQSxVQUUzQithLEdBQUcsR0FBRzlTLFFBQVEsQ0FBQyxDQUFELEVBQUlpb0QsSUFBSixDQUFSLENBQWtCL3NELEdBQWxCLENBQXNCLFVBQUFLLENBQUM7QUFBQSxlQUNsQ3VSLEVBQUUsQ0FBQ3c3QyxnQkFBSCxDQUFvQixDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXBCLEVBQWdDL3NELENBQWhDLEVBQW1DZ1MsS0FBbkMsRUFBMEMsQ0FBMUMsQ0FEc0MsQ0FDUTQ3QyxJQURSLENBQ2EsR0FEYixDQUFKO0FBQUEsT0FBdkIsQ0FGcUI7QUFNakMsYUFBT3IyQyxHQUFHLENBQUNxMkMsSUFBSixDQUFTLEdBQVQsQ0FBUDtBQUNBLEtBUGMsQ0FmVDtBQUFBLFFBd0JBemlFLEtBeEJBLEdBd0JRcWlFLFdBQVcsQ0FDdkJ4M0MsU0FEWSxPQUNFOVUsY0FBSyxDQUFDL1YsS0FEUixFQUVadVksSUFGWSxDQUVQK3BELFNBRk8sQ0F4QlI7O0FBNEJOdGlFLFNBQUssQ0FBQ3FyQixJQUFOLEdBQWF0RixNQUFiLEVBN0JrQjtBQStCbEIsUUFBTTI4QyxVQUFVLEdBQUcxaUUsS0FBSyxDQUFDOHFCLEtBQU4sR0FBY2hXLE1BQWQsQ0FBcUIsR0FBckIsRUFDakJDLElBRGlCLENBQ1osT0FEWSxFQUNILFVBQUM3QyxDQUFELEVBQUkyQyxDQUFKO0FBQUEsYUFBYWtCLGNBQUssQ0FBQy9WLEtBQW5CLFNBQTRCK1YsY0FBSyxDQUFDL1YsS0FBbEMsU0FBMkM2VSxDQUEzQztBQUFBLEtBREcsQ0FBbkI7QUFHQTZ0RCxjQUFVLENBQUM1dEQsTUFBWCxDQUFrQixTQUFsQixFQUNFcVcsS0FERixDQUNRLFlBRFIsRUFDc0JwUCxNQUFNLENBQUNnSCxnQkFBUCxHQUEwQixJQUExQixHQUFpQyxRQUR2RCxDQWxDa0IsRUFxQ2RxL0MsUUFyQ2MsS0FzQ2JDLFdBQVcsQ0FBQ3ZzRCxNQUFaLENBQW1CLE1BQW5CLEVBQTJCOVcsS0FBM0IsRUF0Q2EsSUF1Q2hCcWpFLFdBQVcsQ0FDVHZ0RCxNQURGLENBQ1MsTUFEVCxFQUVFQyxJQUZGLENBRU8sSUFGUCxFQUVhLE9BRmIsRUFHRUEsSUFIRixDQUdPLElBSFAsRUFHYSxPQUhiLEVBSUVvVyxLQUpGLENBSVEsYUFKUixFQUl1QixLQUp2QixFQUtFbnFCLElBTEYsQ0FLTztBQUFBLGFBQU13aEUsZUFBZSxDQUFDLENBQUQsQ0FBckI7QUFBQSxLQUxQLENBdkNnQixFQStDakJFLFVBQVUsQ0FBQzV0RCxNQUFYLENBQWtCLE1BQWxCLEVBQ0VDLElBREYsQ0FDTyxJQURQLEVBQ2EsT0FEYixFQUVFb1csS0FGRixDQUVRLGFBRlIsRUFFdUIsS0FGdkIsRUFHRW5xQixJQUhGLENBR08sVUFBQWtSLENBQUM7QUFBQSxhQUFJc3dELGVBQWUsQ0FDekJwOEMsRUFBRSxDQUFDZ2QsUUFBSCxHQUFjay9CLFNBQVMsQ0FBQ2p3RCxNQUF4QixJQUFrQ0gsQ0FBQyxHQUFHLENBQXRDLENBRHlCLENBQW5CO0FBQUEsS0FIUixDQS9DaUIsR0F1RGxCd3dELFVBQVUsQ0FDUjMzQyxLQURGLENBQ1EvcUIsS0FEUixFQUVFK1UsSUFGRixDQUVPLFdBRlAsRUFFb0IsVUFBQTdDLENBQUM7QUFBQSw2QkFBaUIzUCxLQUFLLEdBQUdnZ0UsVUFBVSxDQUFDcndELENBQUQsQ0FBbkMsWUFBMkN6UCxNQUFNLEdBQUc4L0QsVUFBVSxDQUFDcndELENBQUQsQ0FBOUQ7QUFBQSxLQUZyQixFQUdFMlksU0FIRixDQUdZLFNBSFosRUFJRTlWLElBSkYsQ0FJTyxRQUpQLEVBSWlCLFVBQUE3QyxDQUFDO0FBQUEsYUFBSThsQyxNQUFNLENBQUM5bEMsQ0FBRCxDQUFWO0FBQUEsS0FKbEIsQ0F2RGtCLEVBOERka3dELFFBOURjLElBK0RqQkMsV0FBVyxDQUFDeDNDLFNBQVosQ0FBc0IsTUFBdEIsRUFDRTlWLElBREYsQ0FDTyxHQURQLEVBQ1ksVUFBQTdDLENBQUM7QUFBQSxhQUFLVCxXQUFXLENBQUNTLENBQUQsQ0FBWCxHQUFpQjNQLEtBQWpCLEdBQXlCeTFDLE1BQU0sQ0FBQzlsQyxDQUFELENBQU4sQ0FBVXdDLEtBQVYsQ0FBZ0IsR0FBaEIsRUFBcUIsQ0FBckIsQ0FBOUI7QUFBQSxLQURiLEVBRUVLLElBRkYsQ0FFTyxHQUZQLEVBRVksVUFBQTdDLENBQUM7QUFBQSxhQUFLVCxXQUFXLENBQUNTLENBQUQsQ0FBWCxHQUFpQnpQLE1BQWpCLEdBQTBCLENBQS9CO0FBQUEsS0FGYixDQS9EaUI7QUFtRWxCLEdBN0xhO0FBK0xkdS9ELGlCQS9MYyw2QkErTEk7QUFDWCxRQUFBNTdDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDV3FLLEVBRFgsQ0FDQ3JLLE1BREQ7QUFBQSw0QkFFa0JxSyxFQUFFLENBQUN1MkIsWUFBSCxFQUZsQjtBQUFBLFFBRUNwNkMsS0FGRDtBQUFBLFFBRVFFLE1BRlI7QUFBQSxRQUdBd3RCLFVBSEEsR0FHYWxVLE1BQU0sQ0FBQ3pQLGlCQUhwQjtBQUFBLFFBS0YxUCxJQUxFLEdBS0t3cEIsRUFBRSxDQUFDeTZDLE1BQUgsQ0FBVWh5QyxJQUFWLENBQWVoRSxTQUFmLENBQXlCLEdBQXpCLEVBQ1R0UyxJQURTLENBQ0owWCxVQURJLENBTEw7O0FBUU5yekIsUUFBSSxDQUFDeXVCLElBQUwsR0FBWXRGLE1BQVosRUFUaUI7QUFXakIsUUFBTTQ4QyxTQUFTLEdBQUcvbEUsSUFBSSxDQUFDa3VCLEtBQUwsR0FBYWhXLE1BQWIsQ0FBb0IsR0FBcEIsRUFDaEJDLElBRGdCLENBQ1gsT0FEVyxFQUNGLFVBQUM3QyxDQUFELEVBQUkyQyxDQUFKO0FBQUEsYUFBYWtCLGNBQUssQ0FBQ25aLElBQW5CLFNBQTJCaVksQ0FBM0I7QUFBQSxLQURFLENBQWxCOztBQWlCQTtBQUNBLFFBZkFrSCxNQUFNLENBQUM0RyxvQkFBUCxJQUErQmdnRCxTQUFTLENBQUM3dEQsTUFBVixDQUFpQixNQUFqQixDQWUvQixFQWRBaUgsTUFBTSxDQUFDNkcsb0JBQVAsSUFBK0IrL0MsU0FBUyxDQUFDN3RELE1BQVYsQ0FBaUIsTUFBakIsQ0FjL0IsRUFaQWxZLElBQUksR0FBRytsRSxTQUFTLENBQUM1M0MsS0FBVixDQUFnQm51QixJQUFoQixDQVlQLEVBVEltZixNQUFNLENBQUM0RyxvQkFTWCxJQVJDL2xCLElBQUksQ0FBQ2taLE1BQUwsQ0FBWSxNQUFaLEVBQ0VmLElBREYsQ0FDTyxJQURQLEVBQ2F4UyxLQURiLEVBRUV3UyxJQUZGLENBRU8sSUFGUCxFQUVhdFMsTUFGYixFQUdFc1MsSUFIRixDQUdPLElBSFAsRUFHYSxVQUFDN0MsQ0FBRCxFQUFJMkMsQ0FBSjtBQUFBLGFBQVV1UixFQUFFLENBQUN3N0MsZ0JBQUgsQ0FBb0IsR0FBcEIsRUFBeUIvc0QsQ0FBekIsQ0FBVjtBQUFBLEtBSGIsRUFJRUUsSUFKRixDQUlPLElBSlAsRUFJYSxVQUFDN0MsQ0FBRCxFQUFJMkMsQ0FBSjtBQUFBLGFBQVV1UixFQUFFLENBQUN3N0MsZ0JBQUgsQ0FBb0IsR0FBcEIsRUFBeUIvc0QsQ0FBekIsQ0FBVjtBQUFBLEtBSmIsQ0FRRCxFQUFJa0gsTUFBTSxDQUFDNkcsb0JBQVgsRUFBaUM7QUFBQSxrQ0FDVDdHLE1BQU0sQ0FBQzhHLHdCQURFO0FBQUEseURBQ3pCOWUsQ0FEeUI7QUFBQSxVQUN6QkEsQ0FEeUIsdUNBQ3JCLENBRHFCO0FBQUEseURBQ2xCRyxDQURrQjtBQUFBLFVBQ2xCQSxDQURrQix1Q0FDZCxDQURjO0FBR2hDdEgsVUFBSSxDQUFDa1osTUFBTCxDQUFZLE1BQVosRUFDRXFWLEtBREYsQ0FDUSxhQURSLEVBQ3VCLFFBRHZCLEVBRUVwVyxJQUZGLENBRU8sSUFGUCxFQUVhLE1BRmIsRUFHRWpCLElBSEYsQ0FHTyxVQUFBeUIsU0FBUyxFQUFJO0FBQ2xCQSxpQkFBUyxDQUFDZ1YsSUFBVixDQUFlLFVBQVNyWSxDQUFULEVBQVk7QUFDMUJnQyxzQkFBWSxDQUFDc1csaUdBQVEsQ0FBQyxJQUFELENBQVQsRUFBd0J0WSxDQUF4QixPQUE0QixDQUFDLENBQUMsRUFBRixFQUFPLEdBQVAsQ0FBNUIsQ0FEYztBQUUxQixTQUZELENBRGtCO0FBSWxCLE9BUEYsRUFRRTB5QixLQVJGLENBUVEsVUFBQzF5QixDQUFELEVBQUkyQyxDQUFKO0FBQUEsZUFBVztBQUFDNFcsZUFBSyxFQUFFNVc7QUFBUixTQUFYO0FBQUEsT0FSUixFQVNFRSxJQVRGLENBU08sV0FUUCxFQVNvQixVQUFTN0MsQ0FBVCxFQUFZO0FBQzFCVCxtQkFBVyxDQUFDLEtBQUtsUCxLQUFOLENBRGUsS0FHN0IsS0FBS0EsS0FBTCxHQUFhLEtBQUs0UyxxQkFBTCxHQUE2QjVTLEtBQTdCLEdBQXFDLENBSHJCO0FBQUEsWUFNMUJtdUQsSUFBSSxHQUFHdHFDLEVBQUUsQ0FBQ3c3QyxnQkFBSCxDQUFvQixHQUFwQixFQUF5QjF2RCxDQUFDLENBQUN1WixLQUEzQixFQUFrQzVrQixTQUFsQyxFQUE2QyxDQUE3QyxDQU5tQjtBQUFBLFlBTzFCOHBELElBQUksR0FBRzkrQyxJQUFJLENBQUM4VixLQUFMLENBQVd2QixFQUFFLENBQUN3N0MsZ0JBQUgsQ0FBb0IsR0FBcEIsRUFBeUIxdkQsQ0FBQyxDQUFDdVosS0FBM0IsRUFBa0M1a0IsU0FBbEMsRUFBNkMsQ0FBN0MsQ0FBWCxDQVBtQjtBQTBCOUIsZUFqQkk2cEQsSUFBSSxHQUFHbnVELEtBaUJYLEdBaEJDbXVELElBQUksSUFBSSxLQUFLbnVELEtBQUwsR0FBYXdCLENBZ0J0QixHQWZXOE4sSUFBSSxDQUFDOFYsS0FBTCxDQUFXK29DLElBQVgsSUFBbUJudUQsS0FlOUIsS0FkQ211RCxJQUFJLElBQUksS0FBS251RCxLQUFMLEdBQWF3QixDQWN0QixHQVhJNHNELElBQUksR0FBR2x1RCxNQVdYLElBVEtrdUQsSUFBSSxHQUFHLENBQVAsS0FBYWx1RCxNQUFiLElBQXVCLEtBQUttZ0UsVUFBTCxDQUFnQmx1QixPQUFoQixLQUE0QixPQVN4RCxJQVJFLEtBQUtrdUIsVUFBTCxDQUFnQm5MLFlBQWhCLENBQTZCLElBQTdCLEVBQW1DLEtBQW5DLENBUUYsRUFMQzlHLElBQUksSUFBSXpzRCxDQUtULElBSld5c0QsSUFBSSxHQUFHbHVELE1BSWxCLEtBSENrdUQsSUFBSSxJQUFJenNELENBR1Qsa0JBQW9Cd3NELElBQXBCLFNBQTRCQyxJQUE1QjtBQUNBLE9BcENGLENBSGdDO0FBd0NoQzs7QUFFRHZxQyxNQUFFLENBQUN5OEMsU0FBSCxFQXZFaUI7QUF3RWpCLEdBdlFhO0FBeVFkQSxXQXpRYyx1QkF5UUY7QUFBQTtBQUFBLFFBQ0x6OEMsRUFESyxHQUNBLElBREE7QUFBQSxRQUVKckssTUFGSSxHQUVrRHFLLEVBRmxELENBRUpySyxNQUZJO0FBQUEscUJBRWtEcUssRUFGbEQsQ0FFSTlqQixLQUZKO0FBQUEsUUFFWWdDLFNBRlosY0FFWUEsU0FGWjtBQUFBLFFBRXVCa0IsVUFGdkIsY0FFdUJBLFVBRnZCO0FBQUEsUUFFMENtdUIsR0FGMUMsR0FFa0R2TixFQUZsRCxDQUVvQzVRLEdBRnBDLENBRTBDbWUsR0FGMUM7O0FBSVgsUUFBSTVYLE1BQU0sQ0FBQzFULG1CQUFYLEVBQWdDO0FBQUEsVUFDekJ1NEQsT0FBTyxHQUFHdDhELFNBQVMsS0FBSyxPQURDO0FBQUEsVUFFekJ1Z0QsUUFBUSxHQUFHLFlBQU07QUFDdEIsWUFBSTlqRCxNQUFNLEdBQUcyVSx3RkFBTyxDQUFDM1UsTUFBckIsQ0FEc0IsQ0FHdEI7O0FBQ0ksaUJBQVM2VixJQUFULENBQWM3VixNQUFNLENBQUMyekMsT0FBckIsQ0FKa0IsS0FLckIzekMsTUFBTSxHQUFHQSxNQUFNLENBQUN3bkMsVUFMSztBQVF0QixZQUFNcjJCLENBQU0sR0FBR3NZLGlHQUFRLENBQUN6cEIsTUFBRCxDQUFSLENBQWlCNmpDLEtBQWpCLEVBQWY7QUFFQSxlQUFPMXlCLENBQUMsSUFBSUssTUFBTSxDQUFDQyxJQUFQLENBQVlOLENBQVosRUFBZUcsTUFBZixLQUEwQixDQUEvQixHQUFtQ0gsQ0FBQyxDQUFDdVosS0FBckMsR0FBNkM1a0IsU0FBcEQ7QUFDQSxPQWI4QjtBQUFBLFVBY3pCK29DLElBQUksR0FBRyxZQUFNO0FBQUEsWUFDWm5rQixLQUFLLEdBQUdvNUIsUUFBUSxFQURKO0FBQUEsWUFFWmllLE9BQU8sR0FBR3J4RCxXQUFXLENBQUNnYSxLQUFELENBRlQ7QUFBQSxTQUlkbTFDLE9BQU8sSUFBSWtDLE9BSkcsTUFLakIsS0FBSSxDQUFDOXlCLFdBQUwsRUFMaUIsRUFNakIsS0FBSSxDQUFDb1csZUFBTCxFQU5pQixFQVFid2EsT0FSYSxHQVNoQng2QyxFQUFFLENBQUNrZSxVQUFILEtBQXFCN1ksS0FBckIsQ0FUZ0IsR0FVTnEzQyxPQVZNLElBV2hCMThDLEVBQUUsQ0FBQzBlLG1CQUFILEVBWGdCO0FBY2xCLE9BNUI4Qjs7QUE4Qi9CMWUsUUFBRSxDQUFDeTZDLE1BQUgsQ0FBVS9xRCxNQUFWLE9BQXFCQyxjQUFLLENBQUNuWixJQUEzQixFQUNFc29DLEVBREYsQ0FDSzA3QixPQUFPLEdBQUcsWUFBSCxHQUFrQixZQUQ5QixFQUM0QyxZQUFNO0FBQ2hELGFBQUlwN0QsVUFBSixFQUFrQjtBQUFsQjtBQUlBLGdCQUFNaW1CLEtBQUssR0FBR281QixRQUFRLEVBQXRCO0FBRUF6K0IsY0FBRSxDQUFDOCtCLG1CQUFILENBQXVCdnhCLEdBQUcsQ0FBQ3hmLElBQUosRUFBdkIsRUFBbUMsSUFBbkMsRUFBeUNzWCxLQUF6QyxDQU5BLEVBT0FtMUMsT0FBTyxHQUFHeDZDLEVBQUUsQ0FBQ2tlLFVBQUgsS0FBb0I3WSxLQUFwQixDQUFILEdBQWdDckYsRUFBRSxDQUFDMGUsbUJBQUgsQ0FBdUJyWixLQUF2QixDQVB2QztBQUFBO0FBUUEsT0FWRixFQVdFeVosRUFYRixDQVdLLFVBWEwsRUFXaUIwN0IsT0FBTyxHQUFHaHhCLElBQUgsR0FBVSxJQVhsQyxDQTlCK0IsRUEyQzFCZ3hCLE9BM0MwQixJQTRDOUJqdEMsR0FBRyxDQUFDdVIsRUFBSixDQUFPLFlBQVAsRUFBcUIwSyxJQUFyQixDQTVDOEI7QUE4Qy9CO0FBQ0QsR0E1VGE7QUE4VGRxeUIsa0JBOVRjLDRCQThUR2hyQixlQTlUSCxFQThUb0I7QUFBQSxRQUMzQjd3QixFQUFFLEdBQUcsSUFEc0I7QUFBQSxRQUUzQkgsT0FBTyxHQUFHRyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUZTO0FBQUEsUUFHM0IreEIsTUFBTSxHQUFHNXhCLEVBQUUsQ0FBQ1AsS0FBSCxDQUFTRyxHQUFULENBQWF3WCxjQUFiLENBSGtCO0FBQUEsUUFLM0I3Z0MsS0FBSyxHQUFHeXBCLEVBQUUsQ0FBQ3k2QyxNQUFILENBQVVwZ0UsTUFBVixDQUNab3FCLFNBRFksQ0FDRixTQURFLEVBRVp0UyxJQUZZLENBRVAwTixPQUZPLENBTG1CO0FBQUEsUUFTM0I4OEMsVUFBVSxHQUFHcG1FLEtBQUssQ0FBQ211QixLQUFOLEdBQWNoVyxNQUFkLENBQXFCLEdBQXJCLEVBQ2pCQyxJQURpQixDQUNaLE9BRFksRUFDSHFSLEVBQUUsQ0FBQ2loQixlQUFILENBQW1COWQsSUFBbkIsQ0FBd0JuRCxFQUF4QixDQURHLENBVGM7QUFZakN6cEIsU0FBSyxDQUFDMHVCLElBQU4sR0FBYWhELFVBQWIsR0FDRThNLFFBREYsQ0FDVzhoQixlQURYLEVBRUVseEIsTUFGRixFQVppQyxFQWdCakNnOUMsVUFBVSxDQUNSanVELE1BREYsQ0FDUyxTQURULEVBRUVpVyxLQUZGLENBRVFwdUIsS0FGUixFQUdFd3VCLEtBSEYsQ0FHUSxNQUhSLEVBR2dCL0UsRUFBRSxDQUFDOUMsS0FIbkIsRUFJRTZILEtBSkYsQ0FJUSxRQUpSLEVBSWtCL0UsRUFBRSxDQUFDOUMsS0FKckIsRUFLRXZPLElBTEYsQ0FLTyxRQUxQLEVBS2lCLFVBQUE3QyxDQUFDO0FBQUEsYUFBSThsQyxNQUFNLENBQUM5bEMsQ0FBQyxDQUFDek4sRUFBSCxDQUFOLENBQWFnK0QsSUFBYixDQUFrQixHQUFsQixDQUFKO0FBQUEsS0FMbEIsQ0FoQmlDO0FBc0JqQyxHQXBWYTs7QUFzVmQ7Ozs7OztBQU1BdkosY0E1VmMsd0JBNFZEaG5ELENBNVZDLEVBNFZFO0FBQ2YsV0FBTyxLQUFLMlQsS0FBTCxDQUFXRyxHQUFYLENBQWV3WCxjQUFmLEVBQXlCdHJCLENBQUMsQ0FBQ3pOLEVBQTNCLEVBQStCeU4sQ0FBQyxDQUFDdVosS0FBakMsRUFBd0MsQ0FBeEMsQ0FBUDtBQUNBLEdBOVZhOztBQWdXZDs7Ozs7O0FBTUEwdEMsY0F0V2Msd0JBc1dEam5ELENBdFdDLEVBc1dFO0FBQ2YsV0FBTyxLQUFLMlQsS0FBTCxDQUFXRyxHQUFYLENBQWV3WCxjQUFmLEVBQXlCdHJCLENBQUMsQ0FBQ3pOLEVBQTNCLEVBQStCeU4sQ0FBQyxDQUFDdVosS0FBakMsRUFBd0MsQ0FBeEMsQ0FBUDtBQUNBO0FBeFdhLENBQWYsRTs7QUNqQ0E7Ozs7O0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVlO0FBQ2Q2d0IsVUFBUSxFQUFFLENBQ1QvL0MsU0FEUyxFQUVUcW5CLFdBRlM7QUFESSxDQUFmLEU7Ozs7QUNYQTs7Ozs7QUFLQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0NBR0E7O0FBR0E7Q0FHQTs7QUFDQTtBQUNBO0NBR0E7O0NBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFLQTs7Ozs7OztJQU9xQm8vQywyQjs7O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBRXRCO0FBTUE7QUErQ0E7QUFDYTtBQUViO0FBV0E7QUFNQTtBQU9BO0FBWUEseUJBQVk1ekMsR0FBWixFQUFpQjtBQUFBLDhRQTNGSDtBQUNic0wsUUFBRSxFQUFFLEVBRFM7QUFFYnpVLGFBQU8sRUFBRTtBQUZJLEtBMkZHLGdDQW5GYjtBQUNIem9CLFdBQUssRUFBRSxJQURKO0FBRUhtWSxVQUFJLEVBQUUsSUFGSDtBQUdIZ2UsU0FBRyxFQUFFLElBSEY7QUFJSC8yQixVQUFJLEVBQUU7QUFBRztBQUNSbUgsU0FBQyxFQUFFLElBREU7QUFFTEcsU0FBQyxFQUFFLElBRkU7QUFHTEMsVUFBRSxFQUFFLElBSEM7QUFJTDJwQixZQUFJLEVBQUU7QUFKRCxPQUpIO0FBVUg4NUIsVUFBSSxFQUFFLElBVkg7QUFXSHptRCxhQUFPLEVBQUUsSUFYTjtBQVlIcWlCLFlBQU0sRUFBRSxJQVpMO0FBYUh0aUIsV0FBSyxFQUFFLElBYko7QUFjSDBVLGNBQVEsRUFBRTtBQUNURCxZQUFJLEVBQUUsSUFERztBQUNHO0FBQ1p4WSxXQUFHLEVBQUUsSUFGSTtBQUVFO0FBQ1grQyxZQUFJLEVBQUUsSUFIRztBQUdHO0FBQ1p4RCxZQUFJLEVBQUUsSUFKRyxDQUlFOztBQUpGLE9BZFA7QUFxQkhELFVBQUksRUFBRSxJQXJCSDtBQXNCSFUsU0FBRyxFQUFFLElBdEJGO0FBc0JRO0FBQ1grQyxVQUFJLEVBQUUsSUF2Qkg7QUF1QlM7QUFDWnhELFVBQUksRUFBRSxJQXhCSDtBQXdCUztBQUNaZ0MsWUFBTSxFQUFFLElBekJMO0FBeUJXO0FBQ2RzQyxVQUFJLEVBQUUsSUExQkg7QUEwQlM7QUFDWnpCLFVBQUksRUFBRTtBQUNMb1csWUFBSSxFQUFFLElBREQ7QUFDUTtBQUNiNVIsU0FBQyxFQUFFLElBRkU7QUFFSTtBQUNURyxTQUFDLEVBQUUsSUFIRSxDQUdJOztBQUhKLE9BM0JIO0FBZ0NIMUUsZUFBUyxFQUFFO0FBQ1ZtVyxZQUFJLEVBQUUsSUFESTtBQUNHO0FBQ2I1UixTQUFDLEVBQUUsSUFGTztBQUVEO0FBQ1RHLFNBQUMsRUFBRSxJQUhPLENBR0Q7O0FBSEMsT0FoQ1I7QUFxQ0g5RCxZQUFNLEVBQUU7QUFDUHVWLFlBQUksRUFBRSxJQURDO0FBQ0s7QUFDWnkzQyxZQUFJLEVBQUUsSUFGQyxDQUVJOztBQUZKLE9BckNMO0FBeUNIbnVELGVBQVMsRUFBRTtBQXpDUixLQW1GYSx5RUFuQ0Y7QUFDZDhFLE9BQUMsRUFBRSxJQURXO0FBRWRHLE9BQUMsRUFBRSxJQUZXO0FBR2RDLFFBQUUsRUFBRSxJQUhVO0FBSWQycEIsVUFBSSxFQUFFLElBSlE7QUFLZDZJLFVBQUksRUFBRSxJQUxRO0FBTWRDLFdBQUssRUFBRSxJQU5PO0FBT2Q1UyxVQUFJLEVBQUU7QUFQUSxLQW1DRSxnQ0F4Qko7QUFDWm84QixZQUFNLEVBQUUsSUFESTtBQUVaOWYsYUFBTyxFQUFFO0FBRkcsS0F3QkksbVBBWEQ7QUFDZm94QixzQkFBZ0IsRUFBRSxJQURIO0FBRWYzaEMsZUFBUyxFQUFFLElBRkk7QUFHZjlULGNBQVEsRUFBRSxJQUhLO0FBR0M7QUFDaEI0VSxxQkFBZSxFQUFFLElBSkY7QUFJUTtBQUN2QkQsY0FBUSxFQUFFLElBTEssQ0FLQTs7QUFMQSxLQVdDO0FBQ2hCLFFBQU14SyxFQUFFLEdBQUcsSUFBWDtBQUVBQSxNQUFFLENBQUNnSixHQUFILEdBQVNBLEdBSE8sRUFJaEJoSixFQUFFLENBQUNySyxNQUFILEdBQVksSUFBSXNILE9BQUosRUFKSSxFQUtoQitDLEVBQUUsQ0FBQ1AsS0FBSCxHQUFXLElBQUlILFdBQUosRUFMSyxFQU1oQlUsRUFBRSxDQUFDOWpCLEtBQUgsR0FBVyxJQUFJMmdFLFdBQUosRUFOSztBQU9oQjs7O2dCQUVEQyxVLEdBQUEsc0JBQWE7QUFDWixRQUFNOThDLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQys4QyxjQUFILENBQWtCLGFBQWxCLENBSFksRUFNWnp2RCxNQUFNLENBQUMwUyxFQUFFLENBQUNySyxNQUFILENBQVVtSixZQUFYLEVBQXlCa0IsRUFBRSxDQUFDZ0osR0FBNUIsQ0FOTTtBQU9aLEcsU0FFRGcwQyxTLEdBQUEscUJBQVk7QUFDWCxRQUFNaDlDLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQys4QyxjQUFILENBQWtCLFlBQWxCLENBSFcsRUFNWHp2RCxNQUFNLENBQUMwUyxFQUFFLENBQUNySyxNQUFILENBQVVxSixXQUFYLEVBQXdCZ0IsRUFBRSxDQUFDZ0osR0FBM0IsQ0FOSztBQU9YLEcsU0FFRGhCLEksR0FBQSxnQkFBTztBQUNBLFFBQUFoSSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ2dCcUssRUFEaEIsQ0FDQ3JLLE1BREQ7QUFBQSxRQUNTdkcsR0FEVCxHQUNnQjRRLEVBRGhCLENBQ1M1USxHQURUO0FBR040USxNQUFFLENBQUM2VyxPQUFILEdBQWEsQ0FBQzdXLEVBQUUsQ0FBQ21RLFVBQUgsRUFKUixFQUtOblEsRUFBRSxDQUFDNnlDLFFBQUgsR0FBYyxDQUFDN3lDLEVBQUUsQ0FBQzZXLE9BQUosSUFBZTdXLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxPQUFYLENBTHZCLEVBT05sVyxFQUFFLENBQUNpOUMsVUFBSCxFQVBNO0FBU04sUUFBTWwvQyxNQUFNLEdBQUc7QUFDZHN6QixhQUFPLEVBQUUxN0IsTUFBTSxDQUFDb0ksTUFERjtBQUVkbS9DLGVBQVMsRUFBRTtBQUZHLEtBQWY7QUFLSXh3RCxZQUFRLENBQUNpSixNQUFNLENBQUNvSSxNQUFSLENBZE4sS0FlTEEsTUFBTSxDQUFDc3pCLE9BQVAsR0FBaUIxN0IsTUFBTSxDQUFDb0ksTUFBUCxDQUFjc3pCLE9BQWQsSUFBeUIsUUFmckMsRUFnQkx0ekIsTUFBTSxDQUFDbS9DLFNBQVAsR0FBbUJ2bkQsTUFBTSxDQUFDb0ksTUFBUCxDQUFjbS9DLFNBQWQsSUFBMkJuL0MsTUFBTSxDQUFDbS9DLFNBaEJoRCxHQW9CTjl0RCxHQUFHLENBQUNoWSxLQUFKLEdBQVk4VCxVQUFVLENBQUM2UyxNQUFNLENBQUNzekIsT0FBUCxDQUFldGpDLElBQWhCLENBQVYsR0FDWDRILE1BQU0sQ0FBQ29JLE1BQVAsQ0FBY3N6QixPQURILEdBQ2FqdEIsaUdBQVEsQ0FBQ3JHLE1BQU0sQ0FBQ3N6QixPQUFQLElBQWtCLEVBQW5CLENBckIzQixFQXVCRmppQyxHQUFHLENBQUNoWSxLQUFKLENBQVV3QixLQUFWLEVBdkJFLEtBd0JMd1csR0FBRyxDQUFDaFksS0FBSixHQUFZZ3RCLGlHQUFRLENBQUNyWixXQUFRLENBQUM2MkIsSUFBVCxDQUFjRyxXQUFkLENBQTBCaDNCLFdBQVEsQ0FBQysyQixhQUFULENBQXVCLEtBQXZCLENBQTFCLENBQUQsQ0F4QmYsR0EyQk4xeUIsR0FBRyxDQUFDaFksS0FBSixDQUFVb1gsSUFBVixDQUFlLEVBQWYsRUFBbUJ1NEIsT0FBbkIsQ0FBMkJocEIsTUFBTSxDQUFDbS9DLFNBQWxDLEtBM0JNLEVBNkJObDlDLEVBQUUsQ0FBQ205QyxZQUFILEVBN0JNO0FBOEJOO0FBRUQ7Ozs7O1dBS0FBLFksR0FBQSxzQkFBYUMsTUFBYixFQUErQjtBQUN4QixRQUFBcDlDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDZ0NxSyxFQURoQyxDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ2dDOGpCLEVBRGhDLENBQ1M5akIsS0FEVDtBQUFBLFFBQ3NCOUUsS0FEdEIsR0FDZ0M0b0IsRUFEaEMsQ0FDZ0I1USxHQURoQixDQUNzQmhZLEtBRHRCO0FBQUEsUUFFQWc0QixRQUZBLEdBRVc7QUFBQSxhQUFNaDRCLEtBQUssQ0FBQzJ0QixLQUFOLENBQVksU0FBWixNQUEyQixNQUEzQixJQUFxQzN0QixLQUFLLENBQUMydEIsS0FBTixDQUFZLFlBQVosTUFBOEIsUUFBekU7QUFBQSxLQUZYO0FBQUEsUUFJQXM0QyxNQUpBLEdBSVMxbkQsTUFBTSxDQUFDMEosTUFBUCxDQUFjaStDLElBQWQsSUFBc0JsdUMsUUFBUSxFQUp2QztBQUFBLFFBS0FtdUMsZ0JBTEEsR0FLbUI3eUQsR0FBTSxDQUFDNnlELGdCQUwxQjs7QUFtQk4sUUFaSUYsTUFBTSxJQUFJRSxnQkFBVixJQUE4QjVuRCxNQUFNLENBQUMwSixNQUFQLENBQWNtK0MsT0FBZCxPQUE5QixJQUFpRSxDQUFDSixNQVl0RSxJQVhDLElBQUlHLGdCQUFKLENBQXFCLFVBQUNFLFFBQUQsRUFBV0MsUUFBWCxFQUF3QjtBQUN2Q3R1QyxjQUFRLEVBRCtCLEtBRTNDc3VDLFFBQVEsQ0FBQ0MsVUFBVCxFQUYyQyxFQUczQyxDQUFDemhFLEtBQUssQ0FBQ2lELFFBQVAsSUFBbUI2Z0IsRUFBRSxDQUFDbTlDLFlBQUgsSUFId0I7QUFLNUMsS0FMRCxFQUtHSyxPQUxILENBS1dwbUUsS0FBSyxDQUFDMlcsSUFBTixFQUxYLEVBS3lCO0FBQ3hCcWpELGdCQUFVLElBRGM7QUFFeEJ3TSxxQkFBZSxFQUFFLENBQUMsT0FBRCxFQUFVLE9BQVY7QUFGTyxLQUx6QixDQVdELEVBQUksQ0FBQ1AsTUFBRCxJQUFXRCxNQUFmLEVBQXVCO0FBQ3RCLFVBQU1TLGFBQWEsR0FBRzc5QyxFQUFFLENBQUM4USxXQUFILENBQWVuYixNQUFmLEVBQXVCcUssRUFBRSxDQUFDODlDLFlBQTFCLENBQXRCO0FBRUFELG1CQUFhLElBQUk3OUMsRUFBRSxDQUFDODlDLFlBQUgsQ0FBZ0JELGFBQWhCLENBSEs7QUFJdEI7QUFDRCxHLFNBRURaLFUsR0FBQSxzQkFBYTtBQUNOLFFBQUFqOUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUMwQnFLLEVBRDFCLENBQ0NySyxNQUREO0FBQUEsUUFDU0MsTUFEVCxHQUMwQm9LLEVBRDFCLENBQ1NwSyxNQURUO0FBQUEsUUFDaUIxWixLQURqQixHQUMwQjhqQixFQUQxQixDQUNpQjlqQixLQURqQjtBQUFBLFFBRUE2ckIsU0FGQSxHQUVZcFMsTUFBTSxDQUFDYyxZQUZuQjs7QUFlTixRQVZBdmEsS0FBSyxDQUFDaUMsVUFBTixXQUF5QixDQUFDLElBQUkrTixJQUFKLEVBVTFCLEVBUkE4VCxFQUFFLENBQUM5QyxLQUFILEdBQVc4QyxFQUFFLENBQUN1aUIsYUFBSCxFQVFYLEVBUEF2aUIsRUFBRSxDQUFDdXNCLFVBQUgsR0FBZ0J2c0IsRUFBRSxDQUFDZ2pCLGtCQUFILEVBT2hCLEVBSkloakIsRUFBRSxDQUFDdTNCLFlBQUgsRUFJSixLQUhDdjNCLEVBQUUsQ0FBQ3JDLEtBQUgsR0FBV3FDLEVBQUUsQ0FBQ2l3QyxhQUFILEVBR1osR0FBSWp3QyxFQUFFLENBQUM2VyxPQUFQLEVBQWdCO0FBQ2Y3VyxRQUFFLENBQUNza0MsUUFBSCxFQURlLEVBSWYxdUMsTUFBTSxDQUFDMDFDLGdCQUFQLEdBQTBCdHJDLEVBQUUsQ0FBQ3dmLHNCQUFILEVBSlgsRUFLZjVwQixNQUFNLENBQUNDLFFBQVAsR0FBa0JGLE1BQU0sQ0FBQzdRLGVBQVAsR0FBeUJpNUQsa0dBQXpCLEdBQXVDQyxpR0FMMUMsRUFNZnBvRCxNQUFNLENBQUM0VSxRQUFQLEdBQWtCN1UsTUFBTSxDQUFDMVAsZ0JBQVAsR0FBMEJnNEQsbUdBQTFCLEdBQXlDQyxrR0FONUM7QUFRZixVQUFNQyxVQUFVLEdBQUduK0MsRUFBRSxDQUFDckssTUFBSCxDQUFVd0MsWUFBVixJQUEwQjZILEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXdDLFlBQVYsQ0FBdUIxSSxJQUF2QixLQUFnQyxNQUE3RTs7QUFFQW1HLFlBQU0sQ0FBQzZVLGVBQVAsR0FBeUIsVUFBQTNlLENBQUMsRUFBSTtBQUFBLHdCQUNYa1UsRUFBRSxDQUFDSyxLQURRO0FBQUEsWUFDdEIxaUIsQ0FEc0IsYUFDdEJBLENBRHNCO0FBQUEsWUFDbkJpZ0IsSUFEbUIsYUFDbkJBLElBRG1CO0FBQUEsWUFFdkJ3Z0QsUUFGdUIsR0FFWkQsVUFBVSxHQUFHdmdELElBQUgsR0FDMUJBLElBQUksSUFBSWpnQixDQUFDLENBQUNzeUIsU0FBRixHQUFjemUsUUFBZCxPQUE2Qm9NLElBQUksQ0FBQy9mLE1BQUwsR0FBYzJULFFBQWQsRUFIVDtBQUFBLFlBS3ZCNnNELFNBTHVCLEdBS0Z2eUQsQ0FBQyxDQUFDd3lELGVBQUYsTUFBdUIsS0FBeEIsSUFDeEJ4eUQsQ0FBQyxDQUFDeXlELFVBQUYsTUFBa0IsTUFETSxJQUV4Qnp5RCxDQUFDLENBQUMweUQsVUFBRixNQUFrQixPQUZNLElBR3hCMXlELENBQUMsQ0FBQzJ5RCxRQUFGLE1BQWdCLE9BSFEsSUFJeEIzeUQsQ0FBQyxDQUFDNHlELE9BQUYsT0FBZ0IsQ0FBaEIsSUFBcUIsT0FKRyxJQUt4Qk4sUUFBUSxJQUFJdHlELENBQUMsQ0FBQzR5RCxPQUFGLE9BQWdCLENBQTVCLElBQWlDLFFBTFQsSUFNeEI1eUQsQ0FBQyxDQUFDNnlELFFBQUYsTUFBZ0IsU0FOUSxJQU1NLElBWEg7QUFhN0IsZUFBTy9vRCxNQUFNLENBQUM0VSxRQUFQLENBQWdCNnpDLFNBQWhCLEVBQTJCdnlELENBQTNCLENBQVA7QUFDQSxPQXhCYztBQXlCZjs7QUFFRDVQLFNBQUssQ0FBQ2dCLGFBQU4sR0FBc0J5WSxNQUFNLENBQUNsVCxlQUFQLEtBQTJCLE9BM0NyQyxFQTRDWnZHLEtBQUssQ0FBQ2lCLGFBQU4sR0FBc0J3WSxNQUFNLENBQUNsVCxlQUFQLEtBQTJCLE9BNUNyQyxFQThDWnZHLEtBQUssQ0FBQ2tCLFdBQU4sR0FBb0J1WSxNQUFNLENBQUNqVCxtQkFBUCxLQUErQixVQUEvQixJQUNuQmlULE1BQU0sQ0FBQ2pULG1CQUFQLEtBQStCLFdBL0NwQixFQWdEWnhHLEtBQUssQ0FBQ21CLFlBQU4sR0FBcUJzWSxNQUFNLENBQUNqVCxtQkFBUCxLQUErQixVQUEvQixJQUNwQmlULE1BQU0sQ0FBQ2pULG1CQUFQLEtBQStCLGFBakRwQixFQW1EWnhHLEtBQUssQ0FBQzBpRSxtQkFBTixHQUE0QjcyQyxTQUFTLElBQUksQ0FBQ3BTLE1BQU0sQ0FBQzVQLFdBQXJCLEdBQW1DLENBQW5DLEdBQXVDLEVBbkR2RCxFQW9EWjdKLEtBQUssQ0FBQ2dDLFNBQU4sR0FBa0I4WCxnQkFBZ0IsQ0FBQ0wsTUFBTSxDQUFDeFQsMkJBQVIsRUFBcUN3VCxNQUFNLENBQUN2VCwyQkFBNUMsQ0FwRHRCO0FBcURaLEcsU0FFRDA3RCxZLEdBQUEsc0JBQWEzckQsSUFBYixFQUFtQjtBQUNaLFFBQUE2TixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBRUxySyxNQUZLLEdBUUZxSyxFQVJFLENBRUxySyxNQUZLO0FBQUEsUUFFR3paLEtBRkgsR0FRRjhqQixFQVJFLENBRUc5akIsS0FGSDtBQUFBLFFBRVVrVCxHQUZWLEdBUUY0USxFQVJFLENBRVU1USxHQUZWO0FBQUEsUUFHTHluQixPQUhLLEdBUUY3VyxFQVJFLENBR0w2VyxPQUhLO0FBQUEscUJBUUY3VyxFQVJFLENBSUxLLEtBSks7QUFBQSxRQUtKMWlCLENBTEksY0FLSkEsQ0FMSTtBQUFBLFFBS0RHLENBTEMsY0FLREEsQ0FMQztBQUFBLFFBS0VDLEVBTEYsY0FLRUEsRUFMRjtBQUFBLFFBS00ycEIsSUFMTixjQUtNQSxJQUxOO0FBQUEsUUFLWTZJLElBTFosY0FLWUEsSUFMWjtBQUFBLFFBS2tCQyxLQUxsQixjQUtrQkEsS0FMbEI7QUFBQSxRQU9MK1UsR0FQSyxHQVFGdmxCLEVBUkUsQ0FPTHVsQixHQVBLOztBQW9FTixRQXZESXZsQixFQUFFLENBQUM2VyxPQXVEUCxLQXREQzdXLEVBQUUsQ0FBQ3hwQixJQUFILEdBQVUsSUFBSWl4QixTQUFKLENBQVN6SCxFQUFULENBc0RYLEVBckRDckssTUFBTSxDQUFDd0MsWUFBUCxJQUF1QjZILEVBQUUsQ0FBQzA2QixRQUFILEVBcUR4QixHQWpEQTE2QixFQUFFLENBQUM3TixJQUFILENBQVFtaUIsRUFBUixHQUFhLEVBaURiLEVBaERBdFUsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBUixHQUFrQkcsRUFBRSxDQUFDZ1Usb0JBQUgsQ0FBd0I3aEIsSUFBeEIsQ0FnRGxCLEVBOUNJd0QsTUFBTSxDQUFDNVUsV0E4Q1gsS0E3Q0NpZixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLEdBQWtCRyxFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFSLENBQWdCdk4sTUFBaEIsQ0FBdUJxRCxNQUFNLENBQUM1VSxXQUFQLENBQW1Cb2lCLElBQW5CLENBQXdCbkQsRUFBRSxDQUFDZ0osR0FBM0IsQ0FBdkIsQ0E2Q25CLEdBekNJclQsTUFBTSxDQUFDN1UsU0F5Q1gsSUF4Q0NrZixFQUFFLENBQUN1WSxrQkFBSCxDQUNDNWlCLE1BQU0sQ0FBQzdVLFNBQVAsVUFDQ2tmLEVBQUUsQ0FBQ3FWLFFBQUgsQ0FBWXJWLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXBCLENBREQsR0FDZ0NsSyxNQUFNLENBQUM3VSxTQUZ4QyxDQXdDRCxFQW5DSTZVLE1BQU0sQ0FBQ3JULFdBbUNYLElBbENDMGQsRUFBRSxDQUFDMFksa0JBQUgsQ0FDQy9pQixNQUFNLENBQUNyVCxXQUFQLFVBQ0MwZCxFQUFFLENBQUNxVixRQUFILENBQVlyVixFQUFFLENBQUM3TixJQUFILENBQVEwTixPQUFwQixDQURELEdBQ2dDbEssTUFBTSxDQUFDclQsV0FGeEMsQ0FrQ0QsRUEzQkEwZCxFQUFFLENBQUMrdkIsV0FBSCxFQTJCQSxFQTFCQS92QixFQUFFLENBQUNnbkIsWUFBSCxJQTBCQSxFQXZCSXJwQyxDQXVCSixLQXRCQ0EsQ0FBQyxDQUFDRSxNQUFGLENBQVMrVSxjQUFTLENBQUNvTixFQUFFLENBQUNrbEIsVUFBSCxDQUFjbGxCLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXRCLENBQUQsQ0FBbEIsQ0FzQkQsRUFyQkM2SCxJQUFJLENBQUM3cEIsTUFBTCxDQUFZRixDQUFDLENBQUNFLE1BQUYsRUFBWixDQXFCRCxFQWxCQzBuQyxHQUFHLENBQUNyTCxPQUFKLEdBQWN2OEIsQ0FBQyxDQUFDRSxNQUFGLEVBa0JmLEdBZklDLENBZUosS0FkQ0EsQ0FBQyxDQUFDRCxNQUFGLENBQVNtaUIsRUFBRSxDQUFDa1EsVUFBSCxDQUFjbFEsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBdEIsRUFBK0IsR0FBL0IsQ0FBVCxDQWNELEVBYkMwUSxJQUFJLENBQUMxeUIsTUFBTCxDQUFZQyxDQUFDLENBQUNELE1BQUYsRUFBWixDQWFELEdBVklFLEVBVUosS0FUQ0EsRUFBRSxDQUFDRixNQUFILENBQVVtaUIsRUFBRSxDQUFDa1EsVUFBSCxDQUFjbFEsRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBdEIsRUFBK0IsSUFBL0IsQ0FBVixDQVNELEVBUkMyUSxLQUFLLElBQUlBLEtBQUssQ0FBQzN5QixNQUFOLENBQWFFLEVBQUUsQ0FBQ0YsTUFBSCxFQUFiLENBUVYsR0FKQXVSLEdBQUcsQ0FBQ21lLEdBQUosR0FBVW5lLEdBQUcsQ0FBQ2hZLEtBQUosQ0FBVXNYLE1BQVYsQ0FBaUIsS0FBakIsRUFDUnFXLEtBRFEsQ0FDRixVQURFLEVBQ1UsUUFEVixFQUVSQSxLQUZRLENBRUYsU0FGRSxFQUVTLE9BRlQsQ0FJVixFQUFJcFAsTUFBTSxDQUFDMVQsbUJBQVAsSUFBOEIvRixLQUFLLENBQUNnQyxTQUF4QyxFQUFtRDtBQUNsRCxVQUFNa3JDLE9BQU8sR0FBR2x0QyxLQUFLLENBQUNnQyxTQUFOLEtBQW9CLE9BQXBDO0FBRUFrUixTQUFHLENBQUNtZSxHQUFKLENBQ0V1UixFQURGLENBQ0tzSyxPQUFPLEdBQUcsWUFBSCxHQUFrQixZQUQ5QixFQUM0QztBQUFBLGVBQU05N0IsTUFBTSxDQUFDcUksTUFBTSxDQUFDK0ksTUFBUixFQUFnQnNCLEVBQUUsQ0FBQ2dKLEdBQW5CLENBQVo7QUFBQSxPQUQ1QyxFQUVFOFYsRUFGRixDQUVLc0ssT0FBTyxHQUFHLFVBQUgsR0FBZ0IsWUFGNUIsRUFFMEM7QUFBQSxlQUFNOTdCLE1BQU0sQ0FBQ3FJLE1BQU0sQ0FBQ2dKLEtBQVIsRUFBZXFCLEVBQUUsQ0FBQ2dKLEdBQWxCLENBQVo7QUFBQSxPQUYxQyxDQUhrRDtBQU1sRDs7QUFFRHJULFVBQU0sQ0FBQ3VJLGFBQVAsSUFBd0I5TyxHQUFHLENBQUNtZSxHQUFKLENBQVE1ZSxJQUFSLENBQWEsT0FBYixFQUFzQmdILE1BQU0sQ0FBQ3VJLGFBQTdCLENBN0VOO0FBK0VsQjtBQUNBLFFBQU0yZ0QsZ0JBQWdCLEdBQUkzekQsVUFBVSxDQUFDeUssTUFBTSxDQUFDN1QsV0FBUixDQUFWLElBQWtDa2UsRUFBRSxDQUFDNmlCLFFBQS9EO0FBaEZrQixLQWtGZDdpQixFQUFFLENBQUM2VyxPQUFILElBQWNnb0MsZ0JBbEZBLE1BbUZqQnp2RCxHQUFHLENBQUNveUMsSUFBSixHQUFXcHlDLEdBQUcsQ0FBQ21lLEdBQUosQ0FBUTdlLE1BQVIsQ0FBZSxNQUFmLENBbkZNLEVBcUZic1IsRUFBRSxDQUFDNlcsT0FyRlUsSUFzRmhCLENBQUMsSUFBRCxFQUFPLFNBQVAsRUFBa0IsU0FBbEIsRUFBNkIsUUFBN0IsRUFBdUN4cEIsT0FBdkMsQ0FBK0MsVUFBQXBDLENBQUMsRUFBSTtBQUNuRCtVLFFBQUUsQ0FBQzRoQyxVQUFILENBQWN4eUMsR0FBRyxDQUFDb3lDLElBQWxCLEVBQXdCdGxELEtBQUssQ0FBQ2tDLElBQU4sQ0FBVzZNLENBQVgsQ0FBeEIsQ0FEbUQ7QUFFbkQsS0FGRCxDQXRGZ0IsRUE0RmI0ekQsZ0JBNUZhLElBNkZoQjcrQyxFQUFFLENBQUM2aUIsUUFBSCxDQUFZeDFCLE9BQVosQ0FBb0IsVUFBQWtELENBQUM7QUFBQSxhQUFJbkIsR0FBRyxDQUFDb3lDLElBQUosQ0FBUzl5QyxNQUFULENBQWdCO0FBQUEsZUFBTTZCLENBQUMsQ0FBQ3hDLElBQVI7QUFBQSxPQUFoQixDQUFKO0FBQUEsS0FBckIsQ0E3RmdCLEdBaUdsQmlTLEVBQUUsQ0FBQ2luQixhQUFILEVBakdrQjtBQW1HbEI7QUFDQSxRQUFNMTNCLElBQUksR0FBR0gsR0FBRyxDQUFDbWUsR0FBSixDQUFRN2UsTUFBUixDQUFlLEdBQWYsRUFBb0JDLElBQXBCLENBQXlCLFdBQXpCLEVBQXNDcVIsRUFBRSxDQUFDb0ksWUFBSCxDQUFnQixNQUFoQixDQUF0QyxDQUFiOztBQStFQTtBQUNBLFFBOUVBaFosR0FBRyxDQUFDRyxJQUFKLEdBQVdBLElBOEVYLEVBM0VBb0csTUFBTSxDQUFDa0MsYUFBUCxJQUF3Qm1JLEVBQUUsQ0FBQ3VoQyxZQUFILEVBMkV4QixFQXpFQXZoQyxFQUFFLENBQUMrekIsV0FBSCxJQUFrQi96QixFQUFFLENBQUMrekIsV0FBSCxFQXlFbEIsRUF4RUEvekIsRUFBRSxDQUFDd21CLFVBQUgsSUFBaUJ4bUIsRUFBRSxDQUFDd21CLFVBQUgsRUF3RWpCLEVBdkVBeG1CLEVBQUUsQ0FBQzB6QixTQUFILElBQWdCMXpCLEVBQUUsQ0FBQzB6QixTQUFILEVBdUVoQixFQWxFSS85QixNQUFNLENBQUMvVCxxQkFrRVgsSUFqRUMyTixJQUFJLENBQUNiLE1BQUwsQ0FBWSxNQUFaLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ21CZ0IsY0FBSyxDQUFDL1UsSUFEekIsU0FDaUMrVSxjQUFLLENBQUMvVyxLQUR2QyxFQUVFK1YsSUFGRixDQUVPLGFBRlAsRUFFc0IsUUFGdEIsRUFFZ0M7QUFGaEMsS0FHRUEsSUFIRixDQUdPLG1CQUhQLEVBRzRCLFFBSDVCLENBaUVELEVBM0RJcVIsRUFBRSxDQUFDNlcsT0EyRFAsS0F6REM3VyxFQUFFLENBQUM4bUMsVUFBSCxJQUFpQjltQyxFQUFFLENBQUM4bUMsVUFBSCxFQXlEbEIsRUF0REMsQ0FBQ254QyxNQUFNLENBQUNzSSxRQUFSLElBQW9CK0IsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXd4QixJQUFSLEVBc0RyQixHQWxEQXpZLElBQUksQ0FBQ2IsTUFBTCxDQUFZLEdBQVosRUFBaUJDLElBQWpCLENBQXNCLE9BQXRCLEVBQStCZ0IsY0FBSyxDQUFDdlksS0FBckMsRUFDRXVYLElBREYsQ0FDTyxXQURQLEVBQ29CelMsS0FBSyxDQUFDa0MsSUFBTixDQUFXTSxJQUQvQixDQWtEQSxFQS9DQXNoQixFQUFFLENBQUMrOEMsY0FBSCxDQUFrQixPQUFsQixDQStDQSxFQTdDSWxtQyxPQTZDSixLQTNDQzdXLEVBQUUsQ0FBQzg5QixhQUFILElBQW9COTlCLEVBQUUsQ0FBQzg5QixhQUFILEVBMkNyQixFQXhDQzk5QixFQUFFLENBQUNrbEMsUUFBSCxJQUFlbGxDLEVBQUUsQ0FBQ2tsQyxRQUFILEVBd0NoQixFQTNCQ3Z2QyxNQUFNLENBQUNzSSxRQUFQLElBQW1CK0IsRUFBRSxDQUFDeHBCLElBQXRCLElBQThCd3BCLEVBQUUsQ0FBQ3hwQixJQUFILENBQVF3eEIsSUFBUixFQTJCL0IsR0F4QkFoSSxFQUFFLENBQUM4K0MsaUJBQUgsRUF3QkEsRUFyQkE5K0MsRUFBRSxDQUFDeWQsYUFBSCxDQUFpQnpkLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXpCLENBcUJBLEVBbEJBRyxFQUFFLENBQUNvdkIsZUFBSCxFQWtCQSxFQWZBOWhDLE1BQU0sQ0FBQ3FJLE1BQU0sQ0FBQ29KLE1BQVIsRUFBZ0JpQixFQUFFLENBQUNnSixHQUFuQixDQWVOLEVBWkFoSixFQUFFLENBQUMrK0MsYUFBSCxFQVlBLEVBVkEvK0MsRUFBRSxDQUFDa1AsTUFBSCxDQUFVO0FBQ1RsQixvQkFBYyxJQURMO0FBRVQyWSxtQkFBYSxJQUZKO0FBR1RoSix1QkFBaUIsSUFIUjtBQUlURCwwQkFBb0IsSUFKWDtBQUtUc2hDLDJCQUFxQixJQUxaO0FBTVRDLGtCQUFZO0FBTkgsS0FBVixDQVVBLEVBQUl0cEQsTUFBTSxDQUFDeFUsVUFBUCxJQUFxQndVLE1BQU0sQ0FBQ3ZVLFVBQWhDLEVBQTRDO0FBQzNDLFVBQU1rMkIsTUFBTSxHQUFHdFgsRUFBRSxDQUFDbVgsYUFBSCxFQUFmO0FBRUE3cEIsWUFBTSxDQUFDcUksTUFBTSxDQUFDeFUsVUFBUixFQUFvQjZlLEVBQUUsQ0FBQ2dKLEdBQXZCLEVBQTRCc08sTUFBTSxDQUFDcm9CLEdBQW5DLENBSHFDLEVBSTNDM0IsTUFBTSxDQUFDcUksTUFBTSxDQUFDdlUsVUFBUixFQUFvQjRlLEVBQUUsQ0FBQ2dKLEdBQXZCLEVBQTRCc08sTUFBTSxDQUFDMVUsR0FBbkMsQ0FKcUM7QUFLM0MsS0F6TGlCLENBMkxsQjs7O0FBQ0E1QyxNQUFFLENBQUNrL0MsVUFBSCxFQTVMa0IsRUErTGxCbC9DLEVBQUUsQ0FBQ2dKLEdBQUgsQ0FBT3FvQixPQUFQLEdBQWlCamlDLEdBQUcsQ0FBQ2hZLEtBQUosQ0FBVTJXLElBQVYsRUEvTEMsRUFpTWxCN1IsS0FBSyxDQUFDaUQsUUFBTixLQWpNa0I7QUFrTWxCLEcsU0FFRDIvRCxpQixHQUFBLDZCQUFvQjtBQUNiLFFBQUE5K0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDNnlDLFFBREQsR0FDYTd5QyxFQURiLENBQ0M2eUMsUUFERDtBQUFBLFFBRUF0MUIsS0FGQSxHQUVRLEVBRlI7QUFJRnZkLE1BQUUsQ0FBQ28zQixTQUFILENBQWEsS0FBYixDQUxlLElBTWxCN1osS0FBSyxDQUFDbHFCLElBQU4sQ0FBVyxLQUFYLENBTmtCLEVBUWQsQ0FBQ3cvQyxRQVJhLElBU2pCdDFCLEtBQUssQ0FBQ2xxQixJQUFOLENBQVcsS0FBWCxDQVRpQixFQVlkMk0sRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsQ0FaYyxHQWFqQnFILEtBQUssQ0FBQ2xxQixJQUFOLENBQVcsT0FBWCxDQWJpQixHQWNQdy9DLFFBZE8sSUFlakJ0MUIsS0FBSyxDQUFDbHFCLElBQU4sQ0FBVyxPQUFYLENBZmlCLEtBa0JsQjJNLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxLQUFYLEtBQXFCcUgsS0FBSyxDQUFDbHFCLElBQU4sQ0FBVyxLQUFYLENBbEJILEVBbUJsQjJNLEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxRQUFYLEtBQXdCcUgsS0FBSyxDQUFDbHFCLElBQU4sQ0FBVyxRQUFYLENBbkJOLEVBb0JsQjJNLEVBQUUsQ0FBQ28zQixTQUFILENBQWEsTUFBYixLQUF3QjdaLEtBQUssQ0FBQ2xxQixJQUFOLENBQVcsTUFBWCxDQXBCTixHQXVCbkJrcUIsS0FBSyxDQUFDbHdCLE9BQU4sQ0FBYyxVQUFBcEMsQ0FBQyxFQUFJO0FBQ2xCK1UsUUFBRSxVQUFRL1UsQ0FBUixDQUFGLEVBRGtCO0FBRWxCLEtBRkQsQ0F2Qm1CLEVBMkJuQnFCLFFBQVEsQ0FBQzBULEVBQUUsQ0FBQ3JLLE1BQUgsQ0FBVXpRLFdBQVgsQ0FBUixJQUFtQzhhLEVBQUUsQ0FBQ3d3QixRQUFILEVBM0JoQjtBQTRCbkIsRyxTQUVEMnVCLGdCLEdBQUEsNEJBQW1CO0FBQ1osUUFBQW4vQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0M1USxHQURELEdBQ1E0USxFQURSLENBQ0M1USxHQUREO0FBR040USxNQUFFLENBQUNnSixHQUFILENBQU9vMkMsQ0FBUCxHQUFXO0FBQ1Zob0UsV0FBSyxFQUFFZ1ksR0FBRyxDQUFDaFksS0FERDtBQUVWbTJCLFNBQUcsRUFBRW5lLEdBQUcsQ0FBQ21lLEdBRkM7QUFHVmkwQixVQUFJLEVBQUVweUMsR0FBRyxDQUFDb3lDLElBSEE7QUFJVmp5QyxVQUFJLEVBQUVILEdBQUcsQ0FBQ0csSUFKQTtBQUtWeFUsYUFBTyxFQUFFcVUsR0FBRyxDQUFDclUsT0FMSDtBQU1WcWlCLFlBQU0sRUFBRWhPLEdBQUcsQ0FBQ2dPLE1BTkY7QUFPVnRpQixXQUFLLEVBQUVzVSxHQUFHLENBQUN0VSxLQVBEO0FBUVYzQixVQUFJLEVBQUVpVyxHQUFHLENBQUNqVyxJQVJBO0FBU1ZoRCxTQUFHLEVBQUVpWixHQUFHLENBQUMvWSxJQVRDO0FBVVZrQyxhQUFPLEVBQUU2VyxHQUFHLENBQUM5VyxNQVZIO0FBV1Z2QixTQUFHLEVBQUU7QUFDSkMsWUFBSSxFQUFFb1ksR0FBRyxDQUFDclk7QUFETixPQVhLO0FBY1YrQyxVQUFJLEVBQUU7QUFDTEMsYUFBSyxFQUFFcVYsR0FBRyxDQUFDdFYsSUFETjtBQUVMdkQsYUFBSyxFQUFFNlksR0FBRyxDQUFDOVk7QUFGTixPQWRJO0FBa0JWc0UsVUFBSSxFQUFFO0FBQ0xDLGFBQUssRUFBRXVVLEdBQUcsQ0FBQ3hVO0FBRE47QUFsQkksS0FKTztBQTBCbEI7QUFFRDs7OztXQUlBbWtFLGEsR0FBQSx5QkFBZ0I7QUFDVCxRQUFBLytDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDc0JxL0MsRUFEdEIsR0FDeUNyL0MsRUFEekMsQ0FDQ3JLLE1BREQsQ0FDVXFJLFVBRFY7QUFBQSxRQUNpQ3VQLEdBRGpDLEdBQ3lDdk4sRUFEekMsQ0FDMkI1USxHQUQzQixDQUNpQ21lLEdBRGpDOztBQUdOLFFBQUlqaEIsUUFBUSxDQUFDK3lELEVBQUQsQ0FBWixFQUFrQjtBQUNqQixVQUFNaHVCLE9BQU8sR0FBRzlqQixHQUFHLENBQUM3ZCxNQUFKLE9BQWVDLGNBQUssQ0FBQ3FRLEVBQUUsQ0FBQ21RLFVBQUgsS0FBa0IsT0FBbEIsR0FBNEIsU0FBN0IsQ0FBcEIsRUFDZHJMLE1BRGMsQ0FDUHU2QyxFQUFFLENBQUNDLE1BQUgsR0FBWSxPQUFaLEdBQXNCLE1BRGYsRUFDdUIsY0FEdkIsQ0FBaEI7QUFHSUQsUUFBRSxDQUFDQyxNQUpVLEdBS2hCanVCLE9BQU8sQ0FBQzFpQyxJQUFSLENBQWEsTUFBYixFQUFxQjB3RCxFQUFFLENBQUNDLE1BQXhCLENBTGdCLEdBTU5ELEVBQUUsQ0FBQ25pRCxLQU5HLElBT2hCbTBCLE9BQU8sQ0FBQ3RzQixLQUFSLENBQWMsTUFBZCxFQUFzQnM2QyxFQUFFLENBQUNuaUQsS0FBekIsQ0FQZ0IsRUFVakJtMEIsT0FBTyxDQUNMMWlDLElBREYsQ0FDTyxPQURQLEVBQ2dCMHdELEVBQUUsQ0FBQ2gvQixLQUFILElBQVksSUFENUIsRUFFRTF4QixJQUZGLENBRU8sT0FGUCxFQUVnQixNQUZoQixFQUdFQSxJQUhGLENBR08sUUFIUCxFQUdpQixNQUhqQixDQVZpQjtBQWNqQjtBQUNEO0FBRUQ7Ozs7O1dBS0E4dUIsYSxHQUFBLHVCQUFjNWQsT0FBZCxFQUF1QjtBQUNoQixRQUFBRyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0M2VyxPQURELEdBQ3NCN1csRUFEdEIsQ0FDQzZXLE9BREQ7QUFBQSxRQUNVZzhCLFFBRFYsR0FDc0I3eUMsRUFEdEIsQ0FDVTZ5QyxRQURWO0FBSU43eUMsTUFBRSxDQUFDeXdCLG9CQUFILENBQXdCNXdCLE9BQXhCLENBTHNCLEdBUWxCRyxFQUFFLENBQUN1M0IsWUFBSCxNQUFxQnNiLFFBUkgsS0FTckI3eUMsRUFBRSxDQUFDa3dDLHFCQUFILEVBVHFCLEVBWWxCcjVCLE9BWmtCLElBYXJCN1csRUFBRSxDQUFDa1csT0FBSCxDQUFXLEtBQVgsS0FBcUJsVyxFQUFFLENBQUNvb0MsbUJBQUgsQ0FBdUJ2b0MsT0FBdkIsQ0FiQSxFQWNyQkcsRUFBRSxDQUFDbzNCLFNBQUgsQ0FBYSxNQUFiLEtBQXdCcDNCLEVBQUUsQ0FBQ2tyQyxvQkFBSCxDQUF3QnJyQyxPQUF4QixDQWRILEVBaUJyQkcsRUFBRSxDQUFDNmhDLHdCQUFILElBQ0M3aEMsRUFBRSxDQUFDNmhDLHdCQUFILENBQTRCaGlDLE9BQTVCLENBbEJvQixJQXFCckJHLEVBQUUsQ0FBQ21RLFVBQUgsQ0FBY3RRLE9BQWQsTUFDQ2d6QyxRQUFRLEdBQ1A3eUMsRUFBRSxDQUFDczdDLHFCQUFILENBQXlCejdDLE9BQXpCLENBRE8sR0FFUEcsRUFBRSxDQUFDNjRDLG1CQUFILENBQXVCaDVDLE9BQXZCLENBSEYsQ0FyQnFCLEVBNkJ0QkcsRUFBRSxDQUFDdS9DLFdBQUgsRUE3QnNCO0FBOEJ0QjtBQUVEOzs7O1dBSUFBLFcsR0FBQSx1QkFBYztBQUNQLFFBQUF2L0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN1QnFLLEVBRHZCLENBQ0NySyxNQUREO0FBQUEsUUFDZTRYLEdBRGYsR0FDdUJ2TixFQUR2QixDQUNTNVEsR0FEVCxDQUNlbWUsR0FEZjtBQUdOQSxPQUFHLENBQUM5SSxTQUFKLE9BQWtCOVUsY0FBSyxDQUFDaFYsTUFBeEIsRUFDRTJYLE1BREYsQ0FDUyxVQUFBeEcsQ0FBQztBQUFBLGFBQUlrVSxFQUFFLENBQUNvWSxjQUFILENBQWtCdHNCLENBQUMsQ0FBQ3pOLEVBQXBCLENBQUo7QUFBQSxLQURWLEVBRUU0akIsVUFGRixHQUdFOE0sUUFIRixDQUdXcFosTUFBTSxDQUFDdUosbUJBSGxCLEVBSUU2RixLQUpGLENBSVEsU0FKUixFQUltQixHQUpuQixDQUphO0FBU2IsRyxTQUVEeTZDLGEsR0FBQSx1QkFBYzF5RCxPQUFkLEVBQXVCO0FBQ3RCLFFBQU0yeUQsV0FBVyxHQUFHO0FBQ25CdHhDLE9BQUMsSUFEa0I7QUFFbkJ1eEMsY0FBUSxJQUZXO0FBR25CdHZDLGdCQUFVLElBSFM7QUFJbkJ1dkMsZUFBUyxJQUpVO0FBS25CQyxlQUFTLElBTFU7QUFNbkI1dkMsaUJBQVcsSUFOUTtBQU9uQjZ2QyxlQUFTLElBUFU7QUFRbkIvdkMsbUJBQWEsSUFSTTtBQVNuQkMsc0JBQWdCLElBVEc7QUFVbkIrdkMsWUFBTSxJQVZhO0FBV25CenZDLGlCQUFXLEVBQUUsZUFYTTtBQVluQjB2Qyx1QkFBaUIsRUFBRSxZQVpBO0FBYW5CQyx1QkFBaUIsRUFBRTtBQWJBLEtBQXBCO0FBMEJBLFdBVkE3ekQsTUFBTSxDQUFDQyxJQUFQLENBQVlxekQsV0FBWixFQUF5QnB5RCxPQUF6QixDQUFpQyxVQUFBTixHQUFHLEVBQUk7QUFDdkMsVUFBSWt6RCxNQUFNLEdBQUdSLFdBQVcsQ0FBQzF5RCxHQUFELENBQXhCO0FBRUk1QixjQUFRLENBQUM4MEQsTUFBRCxDQUgyQixLQUl0Q0EsTUFBTSxHQUFHUixXQUFXLENBQUNRLE1BQUQsQ0FKa0IsR0FPdkNSLFdBQVcsQ0FBQzF5RCxHQUFELENBQVgsR0FBbUJGLFNBQVMsQ0FBQ0MsT0FBRCxXQUFpQkMsR0FBakIsRUFBd0JrekQsTUFBeEIsQ0FQVztBQVF2QyxLQVJELENBVUEsRUFBT1IsV0FBUDtBQUNBLEcsU0FFRHZ3QyxNLEdBQUEsZ0JBQU9waUIsT0FBUCxFQUFxQm96RCxnQkFBckIsRUFBd0M7QUFBakNwekQsV0FBaUMsZ0JBQWpDQSxPQUFpQyxHQUF2QixFQUF1QjtBQUNqQyxRQUFBa1QsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNpQ3FLLEVBRGpDLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDaUM4akIsRUFEakMsQ0FDUzlqQixLQURUO0FBQUEsUUFDZ0JrVCxHQURoQixHQUNpQzRRLEVBRGpDLENBQ2dCNVEsR0FEaEI7QUFBQSxRQUNxQnlqRCxRQURyQixHQUNpQzd5QyxFQURqQyxDQUNxQjZ5QyxRQURyQjtBQUFBLFFBRUN0akQsSUFGRCxHQUVTSCxHQUZULENBRUNHLElBRkQ7QUFBQSxRQUdBb2UsYUFIQSxHQUdnQjNOLEVBQUUsQ0FBQzROLG1CQUFILENBQXVCNU4sRUFBRSxDQUFDN04sSUFBSCxDQUFRME4sT0FBL0IsQ0FIaEI7QUFBQSxRQUtBby9DLFlBTEEsR0FLZW55RCxPQUFPLENBQUNteUQsWUFMdkI7QUFBQSxRQU1BdnZDLElBTkEsR0FNTzVpQixPQUFPLENBQUM0aUIsSUFOZjtBQUFBLFFBT0FELEdBUEEsR0FPTXpQLEVBQUUsQ0FBQ3cvQyxhQUFILENBQWlCMXlELE9BQWpCLENBUE47QUFBQSxRQVFBaWlCLFFBUkEsR0FRV1UsR0FBRyxDQUFDVyxVQUFKLEdBQWlCemEsTUFBTSxDQUFDdUosbUJBQXhCLEdBQThDLENBUnpEO0FBQUEsUUFTQTJ4QixlQVRBLEdBU2tCcGhCLEdBQUcsQ0FBQ3N3QyxpQkFBSixHQUF3Qmh4QyxRQUF4QixHQUFtQyxDQVRyRDtBQUFBLFFBVUFveEMsZUFWQSxHQVVrQjF3QyxHQUFHLENBQUN1d0MsaUJBQUosR0FBd0JqeEMsUUFBeEIsR0FBbUMsQ0FWckQ7QUFBQSxRQVdBSSxXQVhBLEdBV2Mrd0MsZ0JBQWdCLElBQUlsZ0QsRUFBRSxDQUFDeHBCLElBQUgsSUFBV3dwQixFQUFFLENBQUN4cEIsSUFBSCxDQUFRczRCLG1CQUFSLENBQTRCcXhDLGVBQTVCLENBWDdDO0FBYUpsQixnQkFBWSxJQUFJdHBELE1BQU0sQ0FBQzFSLGlCQUF6QixJQUNDL0gsS0FBSyxDQUFDZ0MsU0FBTixLQUFvQixPQURyQixJQUNnQzhoQixFQUFFLENBQUM0cEIsV0FBSCxFQWZPLEVBaUJ2QzVwQixFQUFFLENBQUMrdkIsV0FBSCxDQUFla3ZCLFlBQWYsQ0FqQnVDLEVBcUJuQ3h2QyxHQUFHLENBQUNxd0MsTUFBSixJQUFjbnFELE1BQU0sQ0FBQ3RULFdBckJjLEdBc0J0QzJkLEVBQUUsQ0FBQ3ltQixZQUFILENBQWdCem1CLEVBQUUsQ0FBQ3FWLFFBQUgsQ0FBWXJWLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXBCLENBQWhCLEVBQThDL1MsT0FBOUMsRUFBdURxaUIsV0FBdkQsQ0F0QnNDLEdBdUI1Qk0sR0FBRyxDQUFDbXdDLFNBdkJ3QixJQTBCdEM1L0MsRUFBRSxDQUFDb3ZCLGVBQUgsSUExQnNDLEVBOEJ2Q3B2QixFQUFFLENBQUNtYSxZQUFILE1BQXFCbmEsRUFBRSxDQUFDNHdCLFVBQUgsQ0FBY0MsZUFBZCxDQTlCa0IsR0FpQ25DLENBQUM3d0IsRUFBRSxDQUFDbVEsVUFBSCxFQUFELElBQW9CMGlDLFFBakNlLEtBa0N0Qzd5QyxFQUFFLENBQUMwd0MsYUFBSCxFQWxDc0MsR0FzQ25DMXdDLEVBQUUsQ0FBQ3UzQixZQUFILE1BQXFCc2IsUUF0Q2MsS0F1Q3RDN3lDLEVBQUUsQ0FBQ3F3QyxZQUFILEVBdkNzQyxFQTJDbkNyd0MsRUFBRSxDQUFDNlcsT0EzQ2dDLElBNkN0QzdXLEVBQUUsQ0FBQ3hwQixJQUFILENBQVFnNUIsVUFBUixDQUFtQjdCLGFBQW5CLEVBQWtDOEIsR0FBbEMsRUFBdUNOLFdBQXZDLEVBQW9ETyxJQUFwRCxFQUEwRHV2QyxZQUExRCxDQTdDc0MsRUFnRHRDai9DLEVBQUUsQ0FBQ3NtQyxlQUFILEVBaERzQyxFQW1EdEMzd0MsTUFBTSxDQUFDL1QscUJBQVAsSUFBZ0MyTixJQUFJLENBQUNHLE1BQUwsV0FBb0JDLGNBQUssQ0FBQy9VLElBQTFCLFNBQWtDK1UsY0FBSyxDQUFDL1csS0FBeEMsRUFDOUIrVixJQUQ4QixDQUN6QixHQUR5QixFQUNwQnpTLEtBQUssQ0FBQ0MsS0FBTixHQUFjLENBRE0sRUFFOUJ3UyxJQUY4QixDQUV6QixHQUZ5QixFQUVwQnpTLEtBQUssQ0FBQ0csTUFBTixHQUFlLENBRkssRUFHOUJ6QixJQUg4QixDQUd6QithLE1BQU0sQ0FBQy9ULHFCQUhrQixFQUk5Qm1qQixLQUo4QixDQUl4QixTQUp3QixFQUliNEksYUFBYSxDQUFDMWhCLE1BQWQsR0FBdUIsTUFBdkIsR0FBZ0MsSUFKbkIsQ0FuRE0sRUEwRHRDK1QsRUFBRSxDQUFDMGxDLFVBQUgsQ0FBYzMyQixRQUFkLENBMURzQyxFQTZEdEMvTyxFQUFFLENBQUMrbUMsWUFBSCxDQUFnQmg0QixRQUFoQixDQTdEc0MsRUFnRXRDL08sRUFBRSxDQUFDa1csT0FBSCxDQUFXLEtBQVgsS0FBcUJsVyxFQUFFLENBQUN1b0MsU0FBSCxDQUFhMVgsZUFBYixDQWhFaUIsRUFtRWxDN3dCLEVBQUUsQ0FBQ28zQixTQUFILENBQWEsTUFBYixDQW5Fa0MsSUFvRXJDcDNCLEVBQUUsQ0FBQ3FyQyxVQUFILENBQWN4YSxlQUFkLENBcEVxQyxFQXVFbEM3d0IsRUFBRSxDQUFDbzNCLFNBQUgsQ0FBYSxNQUFiLENBdkVrQyxJQXdFckNwM0IsRUFBRSxDQUFDK3VDLFVBQUgsQ0FBY2xlLGVBQWQsQ0F4RXFDLEVBNEV0Q3poQyxHQUFHLENBQUN4VSxJQUFKLElBQVkyVSxJQUFJLENBQUNrVixTQUFMLE9BQW1COVUsY0FBSyxDQUFDeFYsZUFBekIsRUFDVm1ZLE1BRFUsQ0FDSDBOLEVBQUUsQ0FBQ2tiLFNBQUgsQ0FBYS9YLElBQWIsQ0FBa0JuRCxFQUFsQixDQURHLEVBRVZ5RSxTQUZVLENBRUEsUUFGQSxFQUdWOUUsTUFIVSxFQTVFMEIsRUFrRmxDaEssTUFBTSxDQUFDMVQsbUJBQVAsSUFBOEIsQ0FBQ3l0QixJQUEvQixJQUF1Q0QsR0FBRyxDQUFDa3dDLFNBbEZULElBbUZyQzMvQyxFQUFFLENBQUN5NkIsYUFBSCxFQW5GcUMsS0F1RnRDcnJDLEdBQUcsQ0FBQy9ZLElBQUosSUFBWTJwQixFQUFFLENBQUNrNUMsU0FBSCxDQUFhbnFDLFFBQWIsRUFBdUI4aEIsZUFBdkIsRUFBd0NwaEIsR0FBRyxDQUFDb3dDLFNBQTVDLENBdkYwQixFQTBGdEM3L0MsRUFBRSxDQUFDeTZDLE1BQUgsSUFBYXo2QyxFQUFFLENBQUMwN0MsV0FBSCxDQUFlN3FCLGVBQWYsQ0ExRnlCLEdBOEZ2Qzd3QixFQUFFLENBQUMyekIsV0FBSCxJQUFrQjN6QixFQUFFLENBQUMyekIsV0FBSCxFQTlGcUIsRUFnR3ZDc3JCLFlBQVksSUFBSWovQyxFQUFFLENBQUNtL0MsZ0JBQUgsRUFoR3VCLEVBa0d2Q24vQyxFQUFFLENBQUNvZ0Qsa0JBQUgsQ0FBc0J6eUMsYUFBdEIsRUFBcUMrQixJQUFyQyxFQUEyQ1gsUUFBM0MsRUFBcURVLEdBQUcsQ0FBQ2l3QyxRQUF6RCxDQWxHdUMsRUFtR3ZDMS9DLEVBQUUsQ0FBQys4QyxjQUFILENBQWtCLFNBQWxCLEVBQTZCandELE9BQTdCLEVBQXNDaWlCLFFBQXRDLENBbkd1QztBQW9HdkM7QUFFRDs7Ozs7Ozs7V0FRQXF4QyxrQixHQUFBLDRCQUFtQnZnRCxPQUFuQixFQUE0QjZQLElBQTVCLEVBQWtDWCxRQUFsQyxFQUE0QzZ6QixZQUE1QyxFQUEwRDtBQUNuRCxRQUFBNWlDLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQ3JLLE1BREQsR0FDa0JxSyxFQURsQixDQUNDckssTUFERDtBQUFBLFFBQ1N6WixLQURULEdBQ2tCOGpCLEVBRGxCLENBQ1M5akIsS0FEVDtBQUFBLFFBRUE5QixLQUZBLEdBRVE0bEIsRUFBRSxDQUFDNHlDLFlBQUgsRUFGUjtBQUlGNXlDLE1BQUUsQ0FBQzZXLE9BTGtELElBT3hEbGhCLE1BQU0sQ0FBQ2tDLGFBQVAsSUFBd0JtSSxFQUFFLENBQUMyaUMsY0FBSCxDQUFrQkMsWUFBbEIsRUFBZ0M3ekIsUUFBaEMsRUFBMEMzMEIsS0FBMUMsQ0FQZ0M7QUFVekQ7QUFWeUQsUUFXbkRpbUUsTUFBTSxHQUFHM3dDLElBQUksSUFBSTFQLEVBQUUsQ0FBQ2k4QixZQUFILENBQWdCO0FBQ3RDcDhCLGFBQU8sRUFBUEEsT0FEc0M7QUFFdEM2UCxVQUFJLEVBQUpBLElBRnNDO0FBR3RDWCxjQUFRLEVBQUVXLElBQUksQ0FBQ1gsUUFIdUI7QUFJdEMzMEIsV0FBSyxFQUFMQSxLQUpzQztBQUt0QzZpRCxRQUFFLEVBQUVqOUIsRUFBRSxDQUFDaTlCLEVBQUgsQ0FBTTk1QixJQUFOLENBQVduRCxFQUFYO0FBTGtDLEtBQWhCLENBWGtDO0FBQUEsUUFrQm5Ec2dELFlBQVksR0FBRyxDQUFDdnhDLFFBQVEsSUFBSXN4QyxNQUFiLEtBQXdCdnFELFlBQVksRUFsQkE7QUFBQSxRQXFCbkR5cUQsVUFBVSxHQUFHdmdELEVBQUUsQ0FBQ3dnRCxhQUFILENBQWlCcG1FLEtBQWpCLEVBQXdCczFCLElBQXhCLEVBQThCMndDLE1BQTlCLEVBQXNDQyxZQUF0QyxDQXJCc0M7QUFBQSxRQXdCbkRHLFdBQVcsR0FBRy93QyxJQUFJLElBQUkvWixNQUFNLENBQUNzSixVQUFmLEdBQTRCLFlBQU07QUFDckRvaEQsWUFBTSxJQUFJQSxNQUFNLEVBRHFDLEVBRXJEL3lELE1BQU0sQ0FBQ3FJLE1BQU0sQ0FBQ3NKLFVBQVIsRUFBb0JlLEVBQUUsQ0FBQ2dKLEdBQXZCLENBRitDO0FBR3JELEtBSG1CLEdBR2hCLElBM0JxRDtBQTZCekQsUUFBSXkzQyxXQUFKLEVBQ0M7QUFDQSxVQUFJSCxZQUFZLElBQUlDLFVBQVUsQ0FBQ3QwRCxNQUEvQixFQUF1QztBQUN0QztBQUNBLFlBQU15MEQsV0FBVyxHQUFHMWdELEVBQUUsQ0FBQzA4QixZQUFILEVBQXBCLENBRnNDLENBSXRDOztBQUNBRSxnSEFBWSxHQUFHN3RCLFFBQWYsQ0FBd0JBLFFBQXhCLEVBQ0U1SyxJQURGLENBQ08sWUFBTTtBQUNYbzhDLG9CQUFVLENBQ1IvdEQsTUFERixDQUNTLFVBQUNxcUIsR0FBRCxFQUFNbkQsRUFBTjtBQUFBLG1CQUFhbUQsR0FBRyxDQUFDMXJCLE1BQUosQ0FBV3VvQixFQUFYLENBQWI7QUFBQSxXQURULEVBQ3NDLEVBRHRDLEVBRUVyc0IsT0FGRixDQUVVLFVBQUFtYSxDQUFDO0FBQUEsbUJBQUlrNUMsV0FBVyxDQUFDbmhELEdBQVosQ0FBZ0JpSSxDQUFoQixDQUFKO0FBQUEsV0FGWCxDQURXO0FBSVgsU0FMRixFQU1FOVosSUFORixDQU1PZ3pELFdBTlAsRUFNb0JELFdBTnBCLENBTHNDO0FBWXRDLE9BWkQsTUFZWXZrRSxLQUFLLENBQUNrRCxVQVpsQixJQWFDcWhFLFdBQVcsRUFiWixDQS9Cd0QsQ0FnRHpEOztBQUNBemdELE1BQUUsQ0FBQ3FWLFFBQUgsQ0FBWXJWLEVBQUUsQ0FBQzdOLElBQUgsQ0FBUTBOLE9BQXBCLEVBQTZCeFMsT0FBN0IsQ0FBcUMsVUFBQWhQLEVBQUUsRUFBSTtBQUMxQ25DLFdBQUssQ0FBQytCLGFBQU4sQ0FBb0JJLEVBQXBCLE1BRDBDO0FBRTFDLEtBRkQsQ0FqRHlEO0FBb0R6RCxHLFNBRURtaUUsYSxHQUFBLHVCQUFjcG1FLEtBQWQsRUFBcUJzMUIsSUFBckIsRUFBMkIyd0MsTUFBM0IsRUFBbUNDLFlBQW5DLEVBQWlEO0FBQzFDLFFBQUF0Z0QsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUM4QnFLLEVBRDlCLENBQ0NySyxNQUREO0FBQUEsUUFDU2toQixPQURULEdBQzhCN1csRUFEOUIsQ0FDUzZXLE9BRFQ7QUFBQSxRQUNrQmc4QixRQURsQixHQUM4Qjd5QyxFQUQ5QixDQUNrQjZ5QyxRQURsQjtBQUFBLHFCQUUrQno0RCxLQUFLLENBQUM0ckIsR0FGckM7QUFBQSxRQUVDazNCLEVBRkQsY0FFQ0EsRUFGRDtBQUFBLFFBRUtDLEVBRkwsY0FFS0EsRUFGTDtBQUFBLFFBRVNDLFFBRlQsY0FFU0EsUUFGVDtBQUFBLFFBRW1CNTJCLFFBRm5CLGNBRW1CQSxRQUZuQjtBQUFBLFFBR0F3Z0MsSUFIQSxHQUdPLEVBSFA7O0FBS04sUUFBSW53QixPQUFKLEVBQWE7QUFBQSx3QkFDY3o4QixLQUFLLENBQUNxVixJQURwQjtBQUFBLFVBQ0xuWixJQURLLGVBQ0xBLElBREs7QUFBQSxVQUNDUyxHQURELGVBQ0NBLEdBREQ7QUFBQSxVQUNNK0MsSUFETixlQUNNQSxJQUROO0FBQUEsT0FHUjZiLE1BQU0sQ0FBQ2lCLFlBQVAsQ0FBb0IzSyxNQUFwQixJQUE4QjBKLE1BQU0sQ0FBQ21CLFlBQVAsQ0FBb0I3SyxNQUgxQyxLQUlYKzZDLElBQUksQ0FBQzN6QyxJQUFMLENBQVUyTSxFQUFFLENBQUMrbEMsVUFBSCxDQUFjdWEsWUFBZCxDQUFWLENBSlcsRUFPUjNxRCxNQUFNLENBQUMxYixPQUFQLENBQWVnUyxNQVBQLElBUVgrNkMsSUFBSSxDQUFDM3pDLElBQUwsQ0FBVTJNLEVBQUUsQ0FBQ2luQyxZQUFILENBQWdCcVosWUFBaEIsQ0FBVixDQVJXLEVBV1p0Z0QsRUFBRSxDQUFDbzNCLFNBQUgsQ0FBYSxNQUFiLEtBQXdCNFAsSUFBSSxDQUFDM3pDLElBQUwsQ0FBVTJNLEVBQUUsQ0FBQ3VyQyxVQUFILENBQWN6eEQsSUFBZCxFQUFvQndtRSxZQUFwQixDQUFWLENBWFosRUFZWnRnRCxFQUFFLENBQUNvM0IsU0FBSCxDQUFhLE1BQWIsS0FBd0I0UCxJQUFJLENBQUMzekMsSUFBTCxDQUFVMk0sRUFBRSxDQUFDZ3ZDLFVBQUgsQ0FBYzE0RCxJQUFkLEVBQW9CZ3FFLFlBQXBCLENBQVYsQ0FaWixFQWFadGdELEVBQUUsQ0FBQ2tXLE9BQUgsQ0FBVyxLQUFYLEtBQXFCOHdCLElBQUksQ0FBQzN6QyxJQUFMLENBQVUyTSxFQUFFLENBQUN3b0MsU0FBSCxDQUFhenhELEdBQWIsRUFBa0J1cEUsWUFBbEIsQ0FBVixDQWJUO0FBY1o7O0FBV0QsWUFUSSxDQUFDdGdELEVBQUUsQ0FBQ21RLFVBQUgsRUFBRCxJQUFvQjBpQyxRQVN4QixLQVJDdm1ELFFBQVEsQ0FBQ3FKLE1BQU0sQ0FBQ3pRLFdBQVIsQ0FBUixJQUNDOGhELElBQUksQ0FBQzN6QyxJQUFMLENBQVUyTSxFQUFFLENBQUNteEIsVUFBSCxDQUFjaU0sUUFBZCxFQUF3QjUyQixRQUF4QixFQUFrQ2tKLElBQWxDLEVBQXdDNHdDLFlBQXhDLENBQVYsQ0FPRixHQUpJdGdELEVBQUUsQ0FBQ3UzQixZQUFILE1BQXFCc2IsUUFJekIsS0FIQzdMLElBQUksQ0FBQzN6QyxJQUFMLENBQVUyTSxFQUFFLENBQUNzd0MsWUFBSCxDQUFnQnBULEVBQWhCLEVBQW9CQyxFQUFwQixFQUF3Qm1qQixZQUF4QixFQUFzQ0QsTUFBdEMsQ0FBVixDQUdELEVBQU9yWixJQUFQO0FBQ0EsRyxTQUVEck0sZSxHQUFBLHlCQUFnQjd0QyxPQUFoQixFQUE4QjtBQUFkQSxXQUFjLGdCQUFkQSxPQUFjLEdBQUosRUFBSTtBQUd6QixRQUFBcWlCLFdBQVc7QUFBQSxRQUZUblAsRUFFUyxHQUZKLElBRUk7QUFBQSxRQURSckssTUFDUSxHQURFcUssRUFDRixDQURSckssTUFDUTtBQUdmN0ksV0FBTyxDQUFDa2hCLGNBQVIsR0FBeUJuaEIsU0FBUyxDQUFDQyxPQUFELEVBQVUsZ0JBQVYsS0FOTCxFQU83QkEsT0FBTyxDQUFDNjVCLGFBQVIsR0FBd0I5NUIsU0FBUyxDQUFDQyxPQUFELEVBQVUsZUFBVixLQVBKLEVBUTdCQSxPQUFPLENBQUNxdkIsVUFBUixHQUFxQnR2QixTQUFTLENBQUNDLE9BQUQsRUFBVSxZQUFWLEtBUkQsRUFXN0JBLE9BQU8sQ0FBQzZ3QixpQkFBUixLQVg2QixFQVk3Qjd3QixPQUFPLENBQUM0d0Isb0JBQVIsS0FaNkIsRUFhN0I1d0IsT0FBTyxDQUFDNnpELHFCQUFSLEtBYjZCLEVBYzdCN3pELE9BQU8sQ0FBQzg1QiwwQkFBUixHQUFxQy81QixTQUFTLENBQUNDLE9BQUQsRUFBVSw0QkFBVixFQUF3Q0EsT0FBTyxDQUFDa2hCLGNBQWhELENBZGpCLEVBaUJ2QmxoQixPQUFPLENBQUNxdkIsVUFBUixJQUFzQnhtQixNQUFNLENBQUN0VCxXQWpCTixLQWtCNUI4c0IsV0FBVyxHQUFHblAsRUFBRSxDQUFDeHBCLElBQUgsQ0FBUXM0QixtQkFBUixDQUNiaGlCLE9BQU8sQ0FBQ2t5RCxxQkFBUixHQUFnQ3JwRCxNQUFNLENBQUN1SixtQkFBdkMsR0FBNkQsQ0FEaEQsQ0FsQmMsRUF1QjVCYyxFQUFFLENBQUNnbkIsWUFBSCxFQXZCNEIsRUF3QjVCaG5CLEVBQUUsQ0FBQ2luQixhQUFILEVBeEI0QixFQTJCNUJqbkIsRUFBRSxDQUFDa25CLFlBQUgsQ0FBZ0JwNkIsT0FBTyxDQUFDODVCLDBCQUF4QixFQUFvRHpYLFdBQXBELENBM0I0QixHQStCN0JuUCxFQUFFLENBQUNrUCxNQUFILENBQVVwaUIsT0FBVixFQUFtQnFpQixXQUFuQixDQS9CNkI7QUFnQzdCLEcsU0FFRDhwQixvQixHQUFBLGdDQUF1QjtBQUN0QixTQUFLL3BCLE1BQUwsQ0FBWTtBQUNYaXJCLFdBQUssSUFETTtBQUVYeUksa0JBQVksSUFGRDtBQUdYaUIsbUJBQWEsSUFIRjtBQUlYbWIsMkJBQXFCO0FBSlYsS0FBWixDQURzQjtBQU90QixHLFNBRUR0MUMsYSxHQUFBLHlCQUFnQjtBQUNmLFdBQU8sS0FBSy9ULE1BQUwsQ0FBWTNQLFdBQVosQ0FBd0JrSSxPQUF4QixDQUFnQyxVQUFoQyxLQUErQyxDQUEvQyxJQUFvRCxLQUFLMmtELFFBQWhFO0FBQ0EsRyxTQUVEcCtCLFMsR0FBQSxxQkFBWTtBQUNMLFFBQUF6VSxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0NySyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBR04sV0FBTyxDQUFDcUssRUFBRSxDQUFDOEosWUFBSCxFQUFELEtBQXVCblUsTUFBTSxDQUFDaFIsTUFBUCxJQUFpQjJILFFBQVEsQ0FBQ3FKLE1BQU0sQ0FBQy9RLE9BQVIsQ0FBaEQsQ0FBUDtBQUNBLEcsU0FFRGtsQixZLEdBQUEsc0JBQWF6ckIsRUFBYixFQUF1QjtBQUN0QixXQURZQSxFQUNaLGdCQURZQSxFQUNaLEdBRGlCLEdBQ2pCLEdBQU8sS0FBS3NYLE1BQUwsV0FBb0J0WCxFQUFwQixnQkFBbUMsWUFBMUM7QUFDQSxHLFNBRUQwckIsYSxHQUFBLHlCQUFnQjtBQUNmLFdBQU8sS0FBS0QsWUFBTCxDQUFrQixHQUFsQixDQUFQO0FBQ0EsRyxTQUVEbzRCLGMsR0FBQSx3QkFBZXAyQyxDQUFmLEVBQWtCO0FBQUEsUUFDVjdOLGFBRFUsR0FDTyxLQUFLL0IsS0FEWixDQUNWK0IsYUFEVTtBQUdqQixXQUFPLEtBQUsyNEIsWUFBTCxDQUFrQjlxQixDQUFsQixNQUF5QixJQUF6QixJQUNON04sYUFBYSxDQUFDNk4sQ0FBQyxDQUFDek4sRUFBSCxDQURQLEdBQ2dCLEdBRGhCLEdBQ3NCLEdBRDdCO0FBRUE7QUFFRDs7Ozs7V0FLQThuRCxFLEdBQUEsWUFBR3I2QyxDQUFILEVBQU07QUFDQyxRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUM2QnFLLEVBRDdCLENBQ0NySyxNQUREO0FBQUEscUJBQzZCcUssRUFEN0IsQ0FDU0ssS0FEVDtBQUFBLFFBQ2lCMWlCLENBRGpCLGNBQ2lCQSxDQURqQjtBQUFBLFFBQ29CaWdCLElBRHBCLGNBQ29CQSxJQURwQjtBQUFBLFFBRUFyUSxFQUZBLEdBRUtvSSxNQUFNLENBQUN3QyxZQUFQLElBQXVCeUYsSUFBdkIsR0FDVkEsSUFEVSxHQUNIamdCLENBSEY7QUFLTixXQUFPbU8sQ0FBQyxHQUFHeUIsRUFBRSxDQUFDdkMsT0FBTyxDQUFDYyxDQUFDLENBQUNuTyxDQUFILENBQVAsR0FBZW1PLENBQUMsQ0FBQ25PLENBQWpCLEdBQXFCbU8sQ0FBdEIsQ0FBTCxHQUFnQyxJQUF4QztBQUNBLEcsU0FFRG14QyxFLEdBQUEsWUFBR254QyxDQUFILEVBQU07QUFDQyxRQUFBa1UsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUN1QnFLLEVBRHZCLENBQ0NySyxNQUREO0FBQUEsUUFDaUJoWSxDQURqQixHQUN1QnFpQixFQUR2QixDQUNTSyxLQURULENBQ2lCMWlCLENBRGpCO0FBQUEsUUFFRndQLEtBRkUsR0FFTTZTLEVBQUUsQ0FBQzRXLFlBQUgsQ0FBZ0I5cUIsQ0FBaEIsQ0FGTjtBQVVOLFdBTklrVSxFQUFFLENBQUM4SixZQUFILEVBTUosR0FMQzNjLEtBQUssR0FBR3FJLFNBQVMsQ0FBQzlILElBQVYsQ0FBZXNTLEVBQWYsRUFBbUI3UyxLQUFuQixDQUtULEdBSlc2UyxFQUFFLENBQUMwSixhQUFILE1BQXNCdmUsUUFBUSxDQUFDZ0MsS0FBRCxDQUl6QyxLQUhDQSxLQUFLLEdBQUd3SSxNQUFNLENBQUN6UCxpQkFBUCxDQUF5QmdJLE9BQXpCLENBQWlDZixLQUFqQyxDQUdULEdBQU8xQixJQUFJLENBQUNDLElBQUwsQ0FBVS9OLENBQUMsQ0FBQ3dQLEtBQUQsQ0FBWCxDQUFQO0FBQ0EsRyxTQUVEMjRDLEUsR0FBQSxZQUFHaDZDLENBQUgsRUFBTTtBQUNDLFFBQUFrVSxFQUFFLEdBQUcsSUFBTDtBQUFBLHFCQUNtQkEsRUFEbkIsQ0FDQ0ssS0FERDtBQUFBLFFBQ1N2aUIsQ0FEVCxjQUNTQSxDQURUO0FBQUEsUUFDWUMsRUFEWixjQUNZQSxFQURaO0FBQUEsUUFFQXFzRCxNQUZBLEdBRVN0K0MsQ0FBQyxDQUFDdFYsSUFBRixJQUFVc1YsQ0FBQyxDQUFDdFYsSUFBRixLQUFXLElBQXJCLEdBQTRCdUgsRUFBNUIsR0FBaUNELENBRjFDO0FBSU4sV0FBTzJOLElBQUksQ0FBQ0MsSUFBTCxDQUFVMCtDLE1BQU0sQ0FBQ3BxQyxFQUFFLENBQUM0VyxZQUFILENBQWdCOXFCLENBQWhCLENBQUQsQ0FBaEIsQ0FBUDtBQUNBLEcsU0FFRDRnRCxLLEdBQUEsZUFBTTVnRCxDQUFOLEVBQVM7QUFDUixXQUFPQSxDQUFDLEdBQUcsS0FBS3VVLEtBQUwsQ0FBV3FILElBQVgsQ0FBZ0I1YixDQUFDLENBQUNuTyxDQUFsQixDQUFILEdBQTBCLElBQWxDO0FBQ0EsRyxTQUVEdWhFLFUsR0FBQSxzQkFBYTtBQUNOLFFBQUFsL0MsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNDckssTUFERCxHQUNXcUssRUFEWCxDQUNDckssTUFERDtBQUdOcUssTUFBRSxDQUFDNGdELGNBQUgsR0FBb0I1Z0QsRUFBRSxDQUFDNmdELGNBQUgsRUFKUixFQUtaN2dELEVBQUUsQ0FBQzRnRCxjQUFILENBQWtCcmhELEdBQWxCLENBQXNCO0FBQUEsYUFBTWpTLE1BQU0sQ0FBQ3FJLE1BQU0sQ0FBQ2lKLFFBQVIsRUFBa0JvQixFQUFFLENBQUNnSixHQUFyQixDQUFaO0FBQUEsS0FBdEIsQ0FMWSxFQU9SclQsTUFBTSxDQUFDOEksV0FQQyxJQVFYdUIsRUFBRSxDQUFDNGdELGNBQUgsQ0FBa0JyaEQsR0FBbEIsQ0FBc0IsWUFBTTtBQUN2QlMsUUFBRSxDQUFDOGdELGFBRG9CLEtBRTFCcDJELEdBQU0sQ0FBQ3cyQyxZQUFQLENBQW9CbGhDLEVBQUUsQ0FBQzhnRCxhQUF2QixDQUYwQixFQUcxQjlnRCxFQUFFLENBQUM4Z0QsYUFBSCxHQUFtQixJQUhPLEdBTTNCOWdELEVBQUUsQ0FBQzhnRCxhQUFILEdBQW1CcDJELEdBQU0sQ0FBQ3kyQyxVQUFQLENBQWtCLFlBQU07QUFDMUNuaEMsVUFBRSxDQUFDZ0osR0FBSCxDQUFPKzNDLEtBQVAsUUFEMEM7QUFFMUMsT0FGa0IsRUFFaEIsR0FGZ0IsQ0FOUTtBQVMzQixLQVRELENBUlcsRUFvQlovZ0QsRUFBRSxDQUFDNGdELGNBQUgsQ0FBa0JyaEQsR0FBbEIsQ0FBc0I7QUFBQSxhQUFNalMsTUFBTSxDQUFDcUksTUFBTSxDQUFDa0osU0FBUixFQUFtQm1CLEVBQUUsQ0FBQ2dKLEdBQXRCLENBQVo7QUFBQSxLQUF0QixDQXBCWSxFQXVCWnRlLEdBQU0sQ0FBQ3MyRCxnQkFBUCxDQUF3QixRQUF4QixFQUFrQ2hoRCxFQUFFLENBQUM0Z0QsY0FBckMsQ0F2Qlk7QUF3QlosRyxTQUVEQyxjLEdBQUEsMEJBQWlCO0FBR2hCLGFBQVNJLG1CQUFULEdBQStCO0FBQzlCQyxxQkFBZSxDQUFDN3pELE9BQWhCLENBQXdCLFVBQUE0RSxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxFQUFMO0FBQUEsT0FBekIsQ0FEOEI7QUFFOUI7O0FBSkQsUUFBTWl2RCxlQUFlLEdBQUcsRUFBeEI7QUFTQSxXQUhBRCxtQkFBbUIsQ0FBQzFoRCxHQUFwQixHQUEwQixVQUFBdE4sQ0FBQztBQUFBLGFBQUlpdkQsZUFBZSxDQUFDN3RELElBQWhCLENBQXFCcEIsQ0FBckIsQ0FBSjtBQUFBLEtBRzNCLEVBRkFndkQsbUJBQW1CLENBQUN0aEQsTUFBcEIsR0FBNkIsVUFBQTFOLENBQUM7QUFBQSxhQUFJaXZELGVBQWUsQ0FBQzFqQyxNQUFoQixDQUF1QjBqQyxlQUFlLENBQUNoekQsT0FBaEIsQ0FBd0IrRCxDQUF4QixDQUF2QixFQUFtRCxDQUFuRCxDQUFKO0FBQUEsS0FFOUIsRUFBT2d2RCxtQkFBUDtBQUNBLEcsU0FFRGhqQyxNLEdBQUEsZ0JBQU9oYyxVQUFQLEVBQW1COE8sUUFBbkIsRUFBNkI7QUFDNUIsUUFBSW5sQixDQUFDLEdBQUcsQ0FBUjtBQUVBcVcsY0FBVSxDQUNSa0MsSUFERixDQUNPO0FBQUEsYUFBTSxFQUFFdlksQ0FBUjtBQUFBLEtBRFAsRUFFRWt6QixFQUZGLENBRUssS0FGTCxFQUVZLFlBQWtCO0FBQUEsd0NBQU5yeEIsSUFBTSwrQ0FBTkEsSUFBTTs7QUFDM0IsUUFBRTdCLENBQUgsSUFBUW1sQixRQUFRLENBQUNwRyxLQUFULE9BQUFvRyxRQUFRLEdBQU8sSUFBUCxTQUFnQnRqQixJQUFoQixFQURZO0FBRTVCLEtBSkYsQ0FINEI7QUFRNUIsRyxTQUVEaXZDLFksR0FBQSx3QkFBZTtBQUFBLFFBQ1Z5a0IsaUJBQWlCLEdBQUcsRUFEVjtBQUFBLFFBRVJsdkQsQ0FBQyxHQUFHLFVBQVN1VixDQUFULEVBQVl1SixRQUFaLEVBQXNCO0FBRy9CLGVBQVNxd0MsSUFBVCxHQUFnQjtBQUdmLGlCQUFnQjU1QyxFQUFoQixFQUZJbUssSUFBSSxHQUFHLENBRVgsRUFBU2xqQixDQUFDLEdBQUcsQ0FBYixFQUFvQitZLEVBQUMsR0FBRzI1QyxpQkFBaUIsQ0FBQzF5RCxDQUFELENBQXpDLEVBQStDQSxDQUFDLEVBQWhELEVBQW9EO0FBQ25ELGNBQUkrWSxFQUFDLENBQUM1dUIsS0FBRixFQUFKLEVBQWU7QUFDZCs0QixnQkFBSSxFQURVO0FBRWQ7QUFDQTs7QUFFRCxjQUFJO0FBQ0huSyxjQUFDLENBQUN2RixVQUFGLEVBREc7QUFFSCxXQUZELENBRUUsT0FBTzdRLENBQVAsRUFBVTtBQUNYdWdCLGdCQUFJLEVBRE87QUFFWDtBQUNEOztBQUVEMHZDLGFBQUssSUFBSW5nQixZQUFZLENBQUNtZ0IsS0FBRCxDQWhCTixFQWtCWDF2QyxJQUFJLEtBQUt3dkMsaUJBQWlCLENBQUNsMUQsTUFsQmhCLEdBbUJkOGtCLFFBQVEsSUFBSUEsUUFBUSxFQW5CTixHQXFCZHN3QyxLQUFLLEdBQUdsZ0IsVUFBVSxDQUFDaWdCLElBQUQsRUFBTyxFQUFQLENBckJKO0FBdUJmOztBQXpCRCxVQUFJQyxLQUFKO0FBMkJBRCxVQUFJLEVBNUIyQjtBQTZCL0IsS0EvQmE7O0FBdUNkLFdBTkFudkQsQ0FBQyxDQUFDc04sR0FBRixHQUFRLFVBQVNpSSxDQUFULEVBQVk7QUFDbkJqYixhQUFPLENBQUNpYixDQUFELENBQVAsR0FDRTI1QyxpQkFBaUIsR0FBR0EsaUJBQWlCLENBQUNod0QsTUFBbEIsQ0FBeUJxVyxDQUF6QixDQUR0QixHQUVDMjVDLGlCQUFpQixDQUFDOXRELElBQWxCLENBQXVCbVUsQ0FBdkIsQ0FIa0I7QUFJbkIsS0FFRCxFQUFPdlYsQ0FBUDtBQUNBO0FBRUQ7Ozs7O1dBS0E4cUQsYyxHQUFBLHdCQUFldUUsS0FBZixFQUErQjtBQUFBLHFEQUFON3pELElBQU0sd0VBQU5BLElBQU07O0FBQzlCLFNBQUtrSSxNQUFMLENBQVl5SixPQUFaLENBQW9CL1IsT0FBcEIsQ0FBNEIsVUFBQXBDLENBQUMsRUFBSTtBQUM1QnEyRCxXQUFLLEtBQUssYUFEa0IsS0FFL0JyMkQsQ0FBQyxDQUFDK1UsRUFBRixHQUFPLEtBRndCLEVBRy9CLEtBQUksQ0FBQ2dKLEdBQUwsQ0FBUzVKLE9BQVQsQ0FBaUIvTCxJQUFqQixDQUFzQnBJLENBQXRCLENBSCtCLEdBTWhDQSxDQUFDLENBQUNxMkQsS0FBRCxDQUFELE9BQUFyMkQsQ0FBQyxFQUFXd0MsSUFBWCxDQU4rQjtBQU9oQyxLQVBELENBRDhCO0FBUzlCLEc7Ozs7QUFHRjRDLE1BQU0sQ0FBQ3VzRCwyQkFBYSxDQUFDMkUsU0FBZixHQUNMO0FBQ0FDLFlBRkssRUFHTHJ2RCx1QkFISyxFQUlMc3ZELFNBSkssRUFLTEMsZUFMSyxFQU1MeGtELGVBTkssRUFPTHJmLGdCQVBLLEVBUUxzZix3QkFSSyxFQVNMdkgsZ0JBVEssRUFVTHdILGdCQVZLLEVBV0xpRCxlQVhLLEVBWUx6aUIsY0FaSyxFQWFMaEQsY0FiSyxFQWNMRSxlQWRLLEVBZUxDLGlCQWZLLEVBZ0JMMlcsbUJBaEJLLEVBaUJMakMsY0FqQkssU0FrQkZreUQsWUFBUyxDQUFDenJCLFFBbEJSLEVBbUJGMHJCLGFBQVUsQ0FBQzFyQixRQW5CVCxFOztBQzNqQ047Ozs7QUFJQTtBQUVBO0FBRUE7Ozs7OztBQUtBLFNBQVMyckIsVUFBVCxDQUFvQmxzRCxNQUFwQixFQUE0QjtBQUFBLE1BRXZCaGIsTUFGdUI7QUFBQSxNQUd2QnlSLElBSHVCO0FBQUEsTUFJdkIwMUQsSUFKdUI7QUFBQSxNQUNyQkMsVUFBVSxHQUFHLEtBQUtwc0QsTUFERztBQUFBLE1BTXJCcXNELElBQUksR0FBRyxZQUFNO0FBQ2xCLFFBQU1qMUQsR0FBRyxHQUFHWCxJQUFJLENBQUN1RyxLQUFMLEVBQVo7QUFEa0IsV0FHZDVGLEdBQUcsSUFBSXBTLE1BQVAsSUFBaUJvUixZQUFZLENBQUNwUixNQUFELENBQTdCLElBQXlDb1MsR0FBRyxJQUFJcFMsTUFIbEMsSUFJakJBLE1BQU0sR0FBR0EsTUFBTSxDQUFDb1MsR0FBRCxDQUpFLEVBS1ZpMUQsSUFBSSxFQUxNLElBTU5qMUQsR0FOTSxHQVVYdE0sU0FWVyxHQU9WOUYsTUFQVTtBQVdsQixHQWpCMEI7O0FBbUIzQndSLFFBQU0sQ0FBQ0MsSUFBUCxDQUFZMjFELFVBQVosRUFBd0IxMEQsT0FBeEIsQ0FBZ0MsVUFBQU4sR0FBRyxFQUFJO0FBQ3RDcFMsVUFBTSxHQUFHZ2IsTUFENkIsRUFFdEN2SixJQUFJLEdBQUdXLEdBQUcsQ0FBQ3VCLEtBQUosQ0FBVSxHQUFWLENBRitCLEVBR3RDd3pELElBQUksR0FBR0UsSUFBSSxFQUgyQixFQUtsQzEyRCxTQUFTLENBQUN3MkQsSUFBRCxDQUx5QixLQU1yQ0MsVUFBVSxDQUFDaDFELEdBQUQsQ0FBVixHQUFrQiswRCxJQU5tQjtBQVF0QyxHQVJELENBbkIyQjtBQTRCM0IsQzs7QUN6Q0Q7Ozs7QUFJQTtBQUNBO0FBRWU7QUFDZDs7Ozs7Ozs7Ozs7OztBQWFBRyxRQWRjLGtCQWNQcmtFLElBZE8sRUFjbUM7QUFBQSxRQUN6QytYLE1BRHlDLEdBQy9CLEtBQUt1Z0MsUUFEMEIsQ0FDekN2Z0MsTUFEeUM7QUFHaERBLFVBQU0sQ0FBQ3dJLFVBQVAsR0FBb0J2Z0IsSUFBSSxHQUFHQSxJQUFJLENBQUN6QixLQUFSLEdBQWdCLElBSFEsRUFJaER3WixNQUFNLENBQUN5SSxXQUFQLEdBQXFCeGdCLElBQUksR0FBR0EsSUFBSSxDQUFDdkIsTUFBUixHQUFpQixJQUpNLEVBTWhELEtBQUswa0UsS0FBTCxRQU5nRDtBQU9oRCxHQXJCYTs7QUF1QmQ7Ozs7Ozs7Ozs7OztBQVlBQSxPQW5DYyxpQkFtQ1JtQixJQW5DUSxFQW1DUUMsYUFuQ1IsRUFtQ2lDO0FBQzlDLFFBQU1uaUQsRUFBRSxHQUFHLEtBQUtrMkIsUUFBaEI7QUFHSWwyQixNQUFFLENBQUM5akIsS0FBSCxDQUFTaUQsUUFKaUMsSUFNekNnakUsYUFOeUMsR0FPNUNuaUQsRUFBRSxDQUFDL29CLEtBQUgsSUFBWStvQixFQUFFLENBQUMvb0IsS0FBSCxDQUFTZ3FELFlBQVQsRUFQZ0MsR0FVNUNqaEMsRUFBRSxDQUFDeHBCLElBQUgsSUFBV3dwQixFQUFFLENBQUN4cEIsSUFBSCxDQUFRbXhCLFNBQVIsRUFWaUMsRUFhN0MzSCxFQUFFLENBQUNLLEtBQUgsQ0FBU3pDLElBQVQsR0FBZ0IsSUFiNkIsRUFlN0Nza0QsSUFBSSxHQUFHbGlELEVBQUUsQ0FBQ2tQLE1BQUgsQ0FBVTtBQUNoQnlYLG1CQUFhLElBREc7QUFFaEJoSix1QkFBaUIsSUFGRDtBQUdoQkQsMEJBQW9CLElBSEo7QUFJaEJ2QixnQkFBVTtBQUpNLEtBQVYsQ0FBSCxHQUtDbmMsRUFBRSxDQUFDMjZCLGVBQUgsQ0FBbUI7QUFDdkJ4ZSxnQkFBVSxJQURhO0FBRXZCbk8sb0JBQWMsSUFGUztBQUd2QjRZLGdDQUEwQjtBQUhILEtBQW5CLENBcEJ3QyxJQTBCN0M1bUIsRUFBRSxDQUFDbTlDLFlBQUgsSUExQjZDO0FBNEI5QyxHQS9EYTs7QUFpRWQ7Ozs7Ozs7O0FBUUFpRixTQXpFYyxxQkF5RUU7QUFBQTtBQUFBLFFBQ1RwaUQsRUFEUyxHQUNKLEtBQUtrMkIsUUFERDtBQUFBLGtCQUVhbDJCLEVBRmIsQ0FFUjVRLEdBRlE7QUFBQSxRQUVGaFksS0FGRSxXQUVGQSxLQUZFO0FBQUEsUUFFS20yQixHQUZMLFdBRUtBLEdBRkw7O0FBMEJmLFdBdEJJamhCLFFBQVEsQ0FBQzBULEVBQUQsQ0FzQlosS0FyQkNBLEVBQUUsQ0FBQys4QyxjQUFILENBQWtCLGNBQWxCLENBcUJELEVBcEJDLzhDLEVBQUUsQ0FBQ2cyQixNQUFILENBQVV4WSxNQUFWLENBQWlCeGQsRUFBRSxDQUFDZzJCLE1BQUgsQ0FBVTluQyxPQUFWLENBQWtCLElBQWxCLENBQWpCLEVBQTBDLENBQTFDLENBb0JELEVBakJDcWYsR0FBRyxDQUFDN2QsTUFBSixDQUFXLEdBQVgsRUFBZ0JzUyxTQUFoQixFQWlCRCxFQWhCQzFXLFNBQVMsQ0FBQzBVLEVBQUUsQ0FBQzhnRCxhQUFKLENBQVQsSUFBK0JwMkQsR0FBTSxDQUFDdzJDLFlBQVAsQ0FBb0JsaEMsRUFBRSxDQUFDOGdELGFBQXZCLENBZ0JoQyxFQWRDcDJELEdBQU0sQ0FBQzIzRCxtQkFBUCxDQUEyQixRQUEzQixFQUFxQ3JpRCxFQUFFLENBQUM0Z0QsY0FBeEMsQ0FjRCxFQWJDeHBFLEtBQUssQ0FBQzJ2QyxPQUFOLENBQWMsSUFBZCxNQUEyQnY0QixJQUEzQixDQUFnQyxFQUFoQyxDQWFELEVBVkNyQyxNQUFNLENBQUNDLElBQVAsQ0FBWSxJQUFaLEVBQWtCaUIsT0FBbEIsQ0FBMEIsVUFBQU4sR0FBRyxFQUFJO0FBQ2hDQSxTQUFHLEtBQUssVUFBUixJQUFzQlosTUFBTSxDQUFDQyxJQUFQLENBQVk0VCxFQUFaLEVBQWdCM1MsT0FBaEIsQ0FBd0IsVUFBQXVtQixDQUFDLEVBQUk7QUFDbEQ1VCxVQUFFLENBQUM0VCxDQUFELENBQUYsR0FBUSxJQUQwQztBQUVsRCxPQUZxQixDQURVLEVBS2hDLEtBQUksQ0FBQzdtQixHQUFELENBQUosR0FBWSxJQUxvQixFQU1oQyxPQUFPLEtBQUksQ0FBQ0EsR0FBRCxDQU5xQjtBQU9oQyxLQVBELENBVUQsR0FBTyxJQUFQO0FBQ0EsR0FwR2E7O0FBc0dkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBNEksUUF6SGMsWUF5SFBrTyxJQXpITyxFQXlITzFXLEtBekhQLEVBeUhvQitoQixNQXpIcEIsRUF5SDJDO0FBSXBELFFBQUFqYyxHQUFHO0FBQUEsUUFIRCtNLEVBR0MsR0FISSxLQUFLazJCLFFBR1Q7QUFBQSxRQUZBdmdDLE1BRUEsR0FGVXFLLEVBRVYsQ0FGQXJLLE1BRUE7QUFBQSxRQURENUksR0FDQyxHQURLOFcsSUFBSSxJQUFJQSxJQUFJLENBQUNoVyxPQUFMLENBQWEsS0FBYixFQUFvQixHQUFwQixDQUNiO0FBYVAsV0FYSWQsR0FBRyxJQUFJNEksTUFXWCxLQVZLckssU0FBUyxDQUFDNkIsS0FBRCxDQVVkLElBVEV3SSxNQUFNLENBQUM1SSxHQUFELENBQU4sR0FBY0ksS0FTaEIsRUFSRThGLEdBQUcsR0FBRzlGLEtBUVIsRUFORStoQixNQUFNLElBQUksS0FBSzZ4QyxLQUFMLEVBTVosSUFKRTl0RCxHQUFHLEdBQUcwQyxNQUFNLENBQUM1SSxHQUFELENBSWQsR0FBT2tHLEdBQVA7QUFDQTtBQTNJYSxDQUFmLEU7O0FDUEE7Ozs7QUFJZTtBQUNkOzs7Ozs7Ozs7QUFTQWlLLE9BVmMsaUJBVVI3ZSxFQVZRLEVBVUk7QUFDakIsV0FBTyxLQUFLNjNDLFFBQUwsQ0FBY2g1QixLQUFkLENBQW9CN2UsRUFBcEIsQ0FBUCxDQURpQixDQUNlO0FBQ2hDO0FBWmEsQ0FBZixFOztBQ0pBOzs7O0FBSUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxTQUFTOFQsYUFBVCxDQUFjcW1CLFNBQWQsRUFBeUI7QUFBQSxNQUNqQjNZLE9BRGlCLEdBQ04sS0FBS3EyQixRQUFMLENBQWMvakMsSUFEUixDQUNqQjBOLE9BRGlCOztBQUd4QixNQUFJLENBQUN4VSxXQUFXLENBQUNtdEIsU0FBRCxDQUFoQixFQUE2QjtBQUM1QixRQUFNcEUsR0FBRyxHQUFHN25CLE9BQU8sQ0FBQ2lzQixTQUFELENBQVAsR0FBcUJBLFNBQXJCLEdBQWlDLENBQUNBLFNBQUQsQ0FBN0M7QUFFQSxXQUFPM1ksT0FBTyxDQUFDdk4sTUFBUixDQUFlLFVBQUFrVixDQUFDO0FBQUEsYUFBSTRNLEdBQUcsQ0FBQ1QsSUFBSixDQUFTLFVBQUExb0IsQ0FBQztBQUFBLGVBQUlBLENBQUMsS0FBS3VjLENBQUMsQ0FBQ25wQixFQUFaO0FBQUEsT0FBVixDQUFKO0FBQUEsS0FBaEIsQ0FBUDtBQUNBOztBQUVELFNBQU93aEIsT0FBUDtBQUNBOztBQUVEeFAsTUFBTSxDQUFDOEIsYUFBRCxFQUFPO0FBQ1o7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQW9xQixPQUFLLEVBQUUsZUFBUy9ELFNBQVQsRUFBdUM7QUFDN0MsV0FBTyxLQUFLMGQsUUFBTCxDQUFjdG9CLG1CQUFkLENBQWtDLEtBQUt6YixJQUFMLENBQVVxbUIsU0FBVixDQUFsQyxDQUFQO0FBQ0EsR0FyQlc7O0FBdUJaOzs7Ozs7Ozs7Ozs7QUFZQXRZLFFBQU0sRUFBRSxVQUFTbVksUUFBVCxFQUF1Q2lxQyxJQUF2QyxFQUE2RDtBQUF0QkEsUUFBc0IsZ0JBQXRCQSxJQUFzQjtBQUNwRSxRQUFJcGlELE1BQUo7O0FBRUEsUUFBSW1ZLFFBQUosRUFBYztBQUNiLFVBQU14WSxPQUFPLEdBQUcsS0FBSzFOLElBQUwsQ0FBVWttQixRQUFWLENBQWhCO0FBRUl4WSxhQUFPLElBQUl0VCxPQUFPLENBQUNzVCxPQUFELENBSFQsS0FJWkssTUFBTSxHQUFHLEVBSkcsRUFNWkwsT0FBTyxDQUFDeFMsT0FBUixDQUFnQixVQUFBcEMsQ0FBQyxFQUFJO0FBQ3BCLFlBQU1zM0QsU0FBUyxHQUFHdDNELENBQUMsQ0FBQ2lWLE1BQUYsQ0FBUzlSLEdBQVQsQ0FBYSxVQUFBdEMsQ0FBQztBQUFBLGlCQUFJQSxDQUFDLENBQUNxQixLQUFOO0FBQUEsU0FBZCxDQUFsQjtBQUVBbTFELFlBQUksR0FBSXBpRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQy9PLE1BQVAsQ0FBY294RCxTQUFkLENBQWIsR0FBeUNyaUQsTUFBTSxDQUFDN00sSUFBUCxDQUFZa3ZELFNBQVosQ0FIekI7QUFJcEIsT0FKRCxDQU5ZO0FBWWI7O0FBRUQsV0FBT3JpRCxNQUFQO0FBQ0EsR0FyRFc7O0FBdURaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkFzaUQsT0FBSyxFQUFFLGVBQVNBLE1BQVQsRUFBNkU7QUFDbkYsUUFBTXhpRCxFQUFFLEdBQUcsS0FBS2syQixRQUFoQixDQURtRixDQUduRjs7QUFHQSxXQUZBbDJCLEVBQUUsQ0FBQ2dwQixvQkFBSCxFQUVBLEVBQU9ocEIsRUFBRSxDQUFDZ2Msb0JBQUgsQ0FBd0IsT0FBeEIsRUFBaUN3bUMsTUFBakMsQ0FBUDtBQUNBLEdBaEZXOztBQWtGWjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBaGdDLFFBQU0sRUFBRSxnQkFBU0EsT0FBVCxFQUFxRDtBQUM1RCxXQUFPLEtBQUswVCxRQUFMLENBQWNsYSxvQkFBZCxDQUFtQyxRQUFuQyxFQUE2Q3dHLE9BQTdDLENBQVA7QUFDQSxHQXRHVzs7QUF3R1o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEvWixNQUFJLEVBQUUsY0FBU0EsS0FBVCxFQUE2RTtBQUNsRixXQUFPLEtBQUt5dEIsUUFBTCxDQUFjbGEsb0JBQWQsQ0FBbUMsTUFBbkMsRUFBMkN2VCxLQUEzQyxDQUFQO0FBQ0EsR0E3SFc7O0FBK0haOzs7Ozs7Ozs7OztBQVdBeFosS0FBRyxFQUFFLGVBQXNFO0FBQzFFLFdBQU8sS0FBS2luQyxRQUFMLENBQWMvZSxhQUFkLEdBQThCbG9CLEdBQXJDO0FBQ0EsR0E1SVc7O0FBOElaOzs7Ozs7Ozs7OztBQVdBMlQsS0FBRyxFQUFFLGVBQW9FO0FBQ3hFLFdBQU8sS0FBS3N6QixRQUFMLENBQWMvZSxhQUFkLEdBQThCdlUsR0FBckM7QUFDQTtBQTNKVyxDQUFQLEM7QUE4SlM7QUFBQ3pRLE1BQUksRUFBSkEsYUFBSUE7QUFBTCxDQUFmLEU7O0FDbE1BOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0EsSUFBTXN3RCxnQkFBZ0IsR0FBRyxVQUFDNzBELEdBQUQ7QUFBQSxTQUF5QjgwRCxJQUFJLENBQ3JEQyxrQkFBa0IsQ0FBQy8wRCxHQUFELENBQWxCLENBQ0VDLE9BREYsQ0FDVSxpQkFEVixFQUM2QixVQUFDKzBELEtBQUQsRUFBUXJ5RCxDQUFSO0FBQUEsV0FBdUNzeUQsTUFBTSxDQUFDQyxZQUFQLFVBQWdDdnlELENBQWhDLEVBQXZDO0FBQUEsR0FEN0IsQ0FEcUQsQ0FBN0I7QUFBQSxDQUF6QjtBQUtBOzs7Ozs7Ozs7QUFPQSxTQUFTd3lELGdCQUFULENBQTBCaDFELElBQTFCLEVBQWdDblEsSUFBaEMsRUFBc0M7QUFBQSxNQUMvQm9sRSxVQUFVLEdBQUcsSUFBSUMsYUFBSixFQURrQjtBQUFBLE1BRS9CdlIsS0FBSyxHQUFHM2pELElBQUksQ0FBQzB6QixTQUFMLElBRnVCO0FBQUEsTUFHL0J5aEMsT0FBTyxHQUFHcHlELFdBQVcsQ0FBQ0QsT0FBTyxDQUFDOUYsV0FBUSxDQUFDZ0csV0FBVixDQUFSLENBQVgsQ0FDZHVCLE1BRGMsQ0FDUCxVQUFDK1QsQ0FBRDtBQUFBLFdBQW1CQSxDQUFDLENBQUM2OEMsT0FBckI7QUFBQSxHQURPLEVBRWQ5MEQsR0FGYyxDQUVWLFVBQUNpWSxDQUFEO0FBQUEsV0FBa0JBLENBQUMsQ0FBQzY4QyxPQUFwQjtBQUFBLEdBRlUsQ0FIcUI7QUFPckN4UixPQUFLLENBQUNMLFlBQU4sQ0FBbUIsT0FBbkIsRUFBNEJ0bEIsNkZBQVksQ0FBQ28zQixLQUF6QyxDQVBxQztBQUFBLE1BUy9CQyxPQUFPLEdBQUdKLFVBQVUsQ0FBQ0ssaUJBQVgsQ0FBNkIzUixLQUE3QixDQVRxQjtBQUFBLE1BWS9CM3NDLEtBQUssR0FBR2hhLFdBQVEsQ0FBQysyQixhQUFULENBQXVCLE9BQXZCLENBWnVCLEVBV3JDOztBQUdBL2MsT0FBSyxDQUFDZ2QsV0FBTixDQUFrQmgzQixXQUFRLENBQUN1NEQsY0FBVCxDQUF3QkosT0FBTyxDQUFDN0csSUFBUixDQUFhLElBQWIsQ0FBeEIsQ0FBbEIsQ0FkcUM7QUFBQSxNQWdCL0JrSCxRQUFRLEdBQUdQLFVBQVUsQ0FBQ0ssaUJBQVgsQ0FBNkJ0K0MsS0FBN0IsQ0FoQm9CO0FBQUEsTUFvQi9CNndCLE9BQU8sR0FBRyxtQkFBZTdKLDZGQUFZLENBQUN4ZSxHQUE1QixtQkFBMkMzdkIsSUFBSSxDQUFDekIsS0FBaEQsb0JBQWtFeUIsSUFBSSxDQUFDdkIsTUFBdkUsMkVBRVhrbkUsUUFGVyxrQkFHWEgsT0FBTyxDQUFDdjFELE9BQVIsQ0FBZ0IsZUFBaEIsRUFBaUMsSUFBakMsQ0FIVyxxQ0FLZEEsT0FMYyxDQUtOLE9BTE0sRUFLRyxLQUxILENBcEJxQixFQWtCckM7QUFDQTs7QUFRQSx3Q0FBb0M0MEQsZ0JBQWdCLENBQUM3c0IsT0FBRCxDQUFwRDtBQUNBOztBQUVjO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBNHRCLFFBM0JjLG1CQTJCUHR5QyxRQTNCTyxFQTJCWUgsUUEzQlosRUEyQjBEO0FBQUE7QUFBQSxRQUNqRS9RLEVBRGlFLEdBQzVELEtBQUtrMkIsUUFEdUQ7QUFBQSxvQkFFbEJsMkIsRUFBRSxDQUFDOWpCLEtBRmU7QUFBQSxRQUVsREMsS0FGa0QsYUFFaEVhLFlBRmdFO0FBQUEsUUFFNUJYLE1BRjRCLGFBRTNDWSxhQUYyQztBQUFBLFFBR2pFVyxJQUhpRSxHQUcxRDtBQUFDekIsV0FBSyxFQUFMQSxLQUFEO0FBQVFFLFlBQU0sRUFBTkE7QUFBUixLQUgwRDtBQUFBLFFBSWpFb25FLFVBSmlFLEdBSXBEVixnQkFBZ0IsQ0FBQyxLQUFLMXhCLE9BQU4sRUFBZXp6QyxJQUFmLENBSm9DOztBQU12RSxRQUFJbXpCLFFBQVEsSUFBSTdsQixVQUFVLENBQUM2bEIsUUFBRCxDQUExQixFQUFzQztBQUNyQyxVQUFNMnlDLEdBQUcsR0FBRyxJQUFJQyxLQUFKLEVBQVo7QUFFQUQsU0FBRyxDQUFDRSxXQUFKLEdBQWtCLFdBSG1CLEVBSXJDRixHQUFHLENBQUNHLE1BQUosR0FBYSxZQUFNO0FBQUEsWUFDWkMsTUFBTSxHQUFHLzRELFdBQVEsQ0FBQysyQixhQUFULENBQXVCLFFBQXZCLENBREc7QUFBQSxZQUVaMXhCLEdBQUcsR0FBRzB6RCxNQUFNLENBQUNDLFVBQVAsQ0FBa0IsSUFBbEIsQ0FGTTtBQUlsQkQsY0FBTSxDQUFDM25FLEtBQVAsR0FBZXlCLElBQUksQ0FBQ3pCLEtBSkYsRUFLbEIybkUsTUFBTSxDQUFDem5FLE1BQVAsR0FBZ0J1QixJQUFJLENBQUN2QixNQUxILEVBTWxCK1QsR0FBRyxDQUFDNHpELFNBQUosQ0FBY04sR0FBZCxFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQU5rQixFQVFsQjN5QyxRQUFRLENBQUM1TixJQUFULENBQWMsS0FBZCxFQUFvQjJnRCxNQUFNLENBQUNHLFNBQVAsQ0FBaUIveUMsUUFBakIsQ0FBcEIsQ0FSa0I7QUFTbEIsT0Fib0MsRUFlckN3eUMsR0FBRyxDQUFDUSxHQUFKLEdBQVVULFVBZjJCO0FBZ0JyQzs7QUFFRCxXQUFPQSxVQUFQO0FBQ0E7QUFwRGEsQ0FBZixFOztBQ3pEQTs7OztBQUlBO0FBQ0E7QUFFZTtBQUNkOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTk2QixPQWxCYyxpQkFrQlJ3N0IsY0FsQlEsRUFrQjRCO0FBQ25DLFFBQUFua0QsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0NoNkMsS0FERCxHQUNVOGpCLEVBRFYsQ0FDQzlqQixLQUREO0FBQUEsUUFFQXM4QixTQUZBLEdBRVl4WSxFQUFFLENBQUNpWSxjQUFILENBQWtCa3NDLGNBQWxCLENBRlo7QUFBQSxRQUdBcnBDLFVBSEEsR0FHYTlhLEVBQUUsQ0FBQzVRLEdBQUgsQ0FBT21lLEdBQVAsQ0FBVzlJLFNBQVgsQ0FDbEJ6RSxFQUFFLENBQUNtaEIsZUFBSCxDQUFtQjNJLFNBQVMsQ0FBQ2xtQixNQUFWLENBQWlCME4sRUFBRSxDQUFDb1ksY0FBcEIsRUFBb0NwWSxFQUFwQyxDQUFuQixDQURrQixDQUhiO0FBT04sU0FBSzJwQixNQUFMLEVBUnlDLEVBU3pDLEtBQUt5NkIsT0FBTCxFQVR5QyxFQVd6Q3RwQyxVQUFVLENBQUNpTSxPQUFYLENBQW1CcDNCLGNBQUssQ0FBQzFXLE9BQXpCLE1BQXdDOHRDLE9BQXhDLENBQWdEcDNCLGNBQUssQ0FBQ2pYLFNBQXRELEtBWHlDLEVBYXJDc25CLEVBQUUsQ0FBQ21RLFVBQUgsTUFBbUIsQ0FBQ25RLEVBQUUsQ0FBQzZ5QyxRQWJjLEtBY3hDN3lDLEVBQUUsQ0FBQ200QyxTQUFILENBQWEzL0IsU0FBYixDQWR3QyxFQWdCeEN4WSxFQUFFLENBQUNrVyxPQUFILENBQVcsT0FBWCxLQUNDbFcsRUFBRSxDQUFDOHBCLGNBQUgsQ0FBa0JxNkIsY0FBbEIsRUFBa0Nua0QsRUFBbEMsUUFBMENyUSxjQUFLLENBQUN6VyxVQUFoRCxDQWpCdUMsR0FvQnpDOG1CLEVBQUUsQ0FBQzBvQixpQkFBSCxDQUFxQmxRLFNBQXJCLEtBcEJ5QyxFQXNCekN0OEIsS0FBSyxDQUFDd0QsZ0JBQU4sR0FBeUI4NEIsU0F0QmdCLEVBdUJ6Q3Q4QixLQUFLLENBQUN5RCxrQkFBTixHQUEyQnpELEtBQUssQ0FBQ3lELGtCQUFOLENBQXlCMlMsTUFBekIsQ0FBZ0MsVUFBQWpVLEVBQUU7QUFBQSxhQUFJbTZCLFNBQVMsQ0FBQ3RxQixPQUFWLENBQWtCN1AsRUFBbEIsSUFBd0IsQ0FBNUI7QUFBQSxLQUFsQyxDQXZCYztBQXdCekMsR0ExQ2E7O0FBNENkOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQStsRSxTQTdEYyxtQkE2RE5ELGNBN0RNLEVBNkQ4QjtBQUNyQyxRQUFBbmtELEVBQUUsR0FBRyxLQUFLazJCLFFBQVY7QUFBQSxRQUNDaDZDLEtBREQsR0FDVThqQixFQURWLENBQ0M5akIsS0FERDtBQUFBLFFBRUFzOEIsU0FGQSxHQUVZeFksRUFBRSxDQUFDaVksY0FBSCxDQUFrQmtzQyxjQUFsQixDQUZaO0FBQUEsUUFHQXJwQyxVQUhBLEdBR2E5YSxFQUFFLENBQUM1USxHQUFILENBQU9tZSxHQUFQLENBQVc5SSxTQUFYLENBQ2xCekUsRUFBRSxDQUFDbWhCLGVBQUgsQ0FBbUIzSSxTQUFTLENBQUNsbUIsTUFBVixDQUFpQjBOLEVBQUUsQ0FBQ29ZLGNBQXBCLEVBQW9DcFksRUFBcEMsQ0FBbkIsQ0FEa0IsQ0FIYjtBQU9OOGEsY0FBVSxDQUFDaU0sT0FBWCxDQUFtQnAzQixjQUFLLENBQUMxVyxPQUF6QixNQUF5Qzh0QyxPQUF6QyxDQUFpRHAzQixjQUFLLENBQUNqWCxTQUF2RCxLQVIyQyxFQVV2Q3NuQixFQUFFLENBQUNtUSxVQUFILEVBVnVDLEtBVzFDblEsRUFBRSxDQUFDMjRDLFdBQUgsQ0FBZW5nQyxTQUFmLENBWDBDLEVBYTFDeFksRUFBRSxDQUFDa1csT0FBSCxDQUFXLE9BQVgsS0FDQ2xXLEVBQUUsQ0FBQzZwQixrQkFBSCxDQUFzQjdwQixFQUF0QixRQUE4QnJRLGNBQUssQ0FBQ3pXLFVBQXBDLENBZHlDLEdBaUIzQzhtQixFQUFFLENBQUMwb0IsaUJBQUgsQ0FBcUJsUSxTQUFyQixLQWpCMkMsRUFtQjNDdDhCLEtBQUssQ0FBQ3dELGdCQUFOLEdBQXlCeEQsS0FBSyxDQUFDd0QsZ0JBQU4sQ0FBdUI0UyxNQUF2QixDQUE4QixVQUFBalUsRUFBRTtBQUFBLGFBQUltNkIsU0FBUyxDQUFDdHFCLE9BQVYsQ0FBa0I3UCxFQUFsQixJQUF3QixDQUE1QjtBQUFBLEtBQWhDLENBbkJrQixFQW9CM0NuQyxLQUFLLENBQUN5RCxrQkFBTixHQUEyQjY0QixTQXBCZ0I7QUFxQjNDLEdBbEZhOztBQW9GZDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFtUixRQXJHYyxrQkFxR1B3NkIsY0FyR08sRUFxRzZCO0FBQ3BDLFFBQUFua0QsRUFBRSxHQUFHLEtBQUtrMkIsUUFBVjtBQUFBLFFBQ0N2Z0MsTUFERCxHQUN1QnFLLEVBRHZCLENBQ0NySyxNQUREO0FBQUEsUUFDU3paLEtBRFQsR0FDdUI4akIsRUFEdkIsQ0FDUzlqQixLQURUO0FBQUEsUUFDZ0JrVCxHQURoQixHQUN1QjRRLEVBRHZCLENBQ2dCNVEsR0FEaEI7QUFBQSxRQUVBb3BCLFNBRkEsR0FFWXhZLEVBQUUsQ0FBQ2lZLGNBQUgsQ0FBa0Jrc0MsY0FBbEIsQ0FGWjtBQUFBLFFBR0FycEMsVUFIQSxHQUdhMXJCLEdBQUcsQ0FBQ21lLEdBQUosQ0FBUTlJLFNBQVIsQ0FBa0J6RSxFQUFFLENBQUNtaEIsZUFBSCxDQUFtQjNJLFNBQW5CLENBQWxCLENBSGI7QUFHK0Q7QUFFckVzQyxjQUFVLENBQUNpTSxPQUFYLENBQW1CcDNCLGNBQUssQ0FBQzFXLE9BQXpCLE1BQXlDOHRDLE9BQXpDLENBQWlEcDNCLGNBQUssQ0FBQ2pYLFNBQXZELEtBTjBDLEVBTzFDc25CLEVBQUUsQ0FBQ21RLFVBQUgsTUFBbUJuUSxFQUFFLENBQUMyNEMsV0FBSCxDQUFlbmdDLFNBQWYsQ0FQdUIsRUFTdEM3aUIsTUFBTSxDQUFDdFQsV0FUK0IsS0FVekMyZCxFQUFFLENBQUM4b0IsVUFBSCxDQUFjdFEsU0FBUyxDQUFDbG1CLE1BQVYsQ0FBaUIwTixFQUFFLENBQUNzWSxjQUFILENBQWtCblYsSUFBbEIsQ0FBdUJuRCxFQUF2QixDQUFqQixDQUFkLENBVnlDLEVBV3pDNVEsR0FBRyxDQUFDZ08sTUFBSixDQUFXcUgsU0FBWCxDQUFxQnpFLEVBQUUsQ0FBQ3NoQixlQUFILENBQW1COUksU0FBbkIsQ0FBckIsRUFDRWxtQixNQURGLENBQ1MsWUFBVztBQUNsQixhQUFPOFIsaUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZTJpQixPQUFmLENBQXVCcDNCLGNBQUssQ0FBQ25XLGlCQUE3QixDQUFQO0FBQ0EsS0FIRixFQUlFdXRDLE9BSkYsQ0FJVXAzQixjQUFLLENBQUNuVyxpQkFKaEIsS0FYeUMsR0FrQjFDMEMsS0FBSyxDQUFDd0QsZ0JBQU4sR0FBeUIsRUFsQmlCLEVBbUIxQ3hELEtBQUssQ0FBQ3lELGtCQUFOLEdBQTJCLEVBbkJlO0FBb0IxQztBQXpIYSxDQUFmLEU7O0FDUEE7Ozs7O0FBSUE7Ozs7QUFJQSxJQUFNeWQsYUFBTSxHQUFHO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFxc0IsTUFBSSxFQUFFLGNBQVNqUixTQUFULEVBQXdDO0FBQzdDLFFBQU14WSxFQUFFLEdBQUcsS0FBS2syQixRQUFoQjtBQUVBbDJCLE1BQUUsQ0FBQzhvQixVQUFILENBQWM5b0IsRUFBRSxDQUFDaVksY0FBSCxDQUFrQk8sU0FBbEIsQ0FBZCxDQUg2QyxFQUk3Q3hZLEVBQUUsQ0FBQzI2QixlQUFILENBQW1CO0FBQUN4ZSxnQkFBVTtBQUFYLEtBQW5CLENBSjZDO0FBSzdDLEdBekJhOztBQTJCZDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQXFOLE1BQUksRUFBRSxjQUFTaFIsU0FBVCxFQUF3QztBQUM3QyxRQUFNeFksRUFBRSxHQUFHLEtBQUtrMkIsUUFBaEI7QUFFQWwyQixNQUFFLENBQUMrb0IsVUFBSCxDQUFjL29CLEVBQUUsQ0FBQ2lZLGNBQUgsQ0FBa0JPLFNBQWxCLENBQWQsQ0FINkMsRUFJN0N4WSxFQUFFLENBQUMyNkIsZUFBSCxDQUFtQjtBQUFDeGUsZ0JBQVU7QUFBWCxLQUFuQixDQUo2QztBQUs3QztBQW5EYSxDQUFmO0FBc0RlO0FBQUMvZSxRQUFNLEVBQU5BLGFBQU1BO0FBQVAsQ0FBZixFOztBQzlEQTs7OztBQUlBO0FBRWU7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUVBaWdCLE1BdEVjLGdCQXNFVDV2QixJQXRFUyxFQXNFSDtBQUNKLFFBQUF1UyxFQUFFLEdBQUcsS0FBS2syQixRQUFWO0FBQUEsUUFDQ3ZnQyxNQURELEdBQ1dxSyxFQURYLENBQ0NySyxNQUREO0FBR047QUFHQTtBQUdBO0FBVUE7QUFLQTtBQXBCQWxJLFFBQUksQ0FBQzZtQixFQUFMLElBQVd0VSxFQUFFLENBQUNnVyxLQUFILENBQVN2b0IsSUFBSSxDQUFDNm1CLEVBQWQsQ0FMRCxFQVFWLFdBQVc3bUIsSUFBWCxJQUFtQixLQUFLMEUsSUFBTCxDQUFVcXdELEtBQVYsQ0FBZ0IvMEQsSUFBSSxDQUFDKzBELEtBQXJCLENBUlQsRUFXVixhQUFhLzBELElBQWIsSUFBcUJ0QixNQUFNLENBQUNDLElBQVAsQ0FBWXFCLElBQUksQ0FBQ2d5QixPQUFqQixFQUEwQnB5QixPQUExQixDQUFrQyxVQUFBaFAsRUFBRSxFQUFJO0FBQzVEc1gsWUFBTSxDQUFDcFYsWUFBUCxDQUFvQmxDLEVBQXBCLElBQTBCb1AsSUFBSSxDQUFDZ3lCLE9BQUwsQ0FBYXBoQyxFQUFiLENBRGtDO0FBRTVELEtBRm9CLENBWFgsRUFnQk4sZ0JBQWdCb1AsSUFBaEIsSUFBd0J1UyxFQUFFLENBQUMwSixhQUFILEVBaEJsQixLQWlCVC9ULE1BQU0sQ0FBQ3pQLGlCQUFQLEdBQTJCdUgsSUFBSSxDQUFDb2MsVUFqQnZCLEdBcUJWLFVBQVVwYyxJQUFWLElBQWtCdEIsTUFBTSxDQUFDQyxJQUFQLENBQVlxQixJQUFJLENBQUNnYixJQUFqQixFQUF1QnBiLE9BQXZCLENBQStCLFVBQUFoUCxFQUFFLEVBQUk7QUFDdERzWCxZQUFNLENBQUMxUSxTQUFQLENBQWlCNUcsRUFBakIsSUFBdUJvUCxJQUFJLENBQUNnYixJQUFMLENBQVVwcUIsRUFBVixDQUQrQjtBQUV0RCxLQUZpQixDQXJCUixFQTBCVixZQUFZb1AsSUFBWixJQUFvQnRCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZcUIsSUFBSSxDQUFDKzBCLE1BQWpCLEVBQXlCbjFCLE9BQXpCLENBQWlDLFVBQUFoUCxFQUFFLEVBQUk7QUFDMURzWCxZQUFNLENBQUM5VSxXQUFQLENBQW1CeEMsRUFBbkIsSUFBeUJvUCxJQUFJLENBQUMrMEIsTUFBTCxDQUFZbmtDLEVBQVosQ0FEaUM7QUFFMUQsS0FGbUIsQ0ExQlYsRUErQk4sWUFBWW9QLElBQVosSUFBb0JBLElBQUksQ0FBQ293QixNQUFMLE9BL0JkLEdBaUNUN2QsRUFBRSxDQUFDNmQsTUFBSCxDQUFVN2QsRUFBRSxDQUFDaVksY0FBSCxDQUFrQnhxQixJQUFJLENBQUNvd0IsTUFBTCxVQUF1QixJQUF2QixHQUE4QnB3QixJQUFJLENBQUNvd0IsTUFBckQsQ0FBVixFQUF3RTtBQUFBLGFBQ3ZFN2QsRUFBRSxDQUFDNGQsWUFBSCxDQUFnQm53QixJQUFoQixDQUR1RTtBQUFBLEtBQXhFLENBakNTLEdBcUNUdVMsRUFBRSxDQUFDNGQsWUFBSCxDQUFnQm53QixJQUFoQixDQXJDUztBQXVDVixHQTdHYTs7QUErR2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBb3dCLFFBdEljLGtCQXNJUHdtQyxTQXRJTyxFQXNJSTtBQUFBO0FBQUEsUUFDWHJrRCxFQUFFLEdBQUcsS0FBS2syQixRQURDO0FBQUEsUUFFYnpvQyxJQUFJLEdBQUc0MkQsU0FBUyxJQUFJLEVBRlA7O0FBSWI5M0QsV0FBTyxDQUFDa0IsSUFBRCxDQUpNLEdBS2hCQSxJQUFJLEdBQUc7QUFBQzJtQixTQUFHLEVBQUUzbUI7QUFBTixLQUxTLEdBTU50QyxRQUFRLENBQUNzQyxJQUFELENBTkYsS0FPaEJBLElBQUksR0FBRztBQUFDMm1CLFNBQUcsRUFBRSxDQUFDM21CLElBQUQ7QUFBTixLQVBTO0FBVWpCLFFBQU0ybUIsR0FBRyxHQUFHcFUsRUFBRSxDQUFDaVksY0FBSCxDQUFrQnhxQixJQUFJLENBQUMybUIsR0FBdkIsQ0FBWjtBQUVBcFUsTUFBRSxDQUFDNmQsTUFBSCxDQUFVekosR0FBVixFQUFlLFlBQU07QUFDcEJwVSxRQUFFLENBQUNrUCxNQUFILENBQVU7QUFDVHdPLDRCQUFvQixJQURYO0FBRVRDLHlCQUFpQixJQUZSO0FBR1R4QixrQkFBVTtBQUhELE9BQVYsQ0FEb0IsRUFPcEJuYyxFQUFFLENBQUNQLEtBQUgsQ0FBU0UsTUFBVCxDQUFnQnlVLEdBQWhCLENBUG9CLEVBUXBCM21CLElBQUksQ0FBQ2trQixJQUFMLElBQWFsa0IsSUFBSSxDQUFDa2tCLElBQUwsQ0FBVWprQixJQUFWLENBQWUsS0FBZixDQVJPO0FBU3BCLEtBVEQsQ0FaaUI7QUFzQmpCO0FBNUphLENBQWYsRTs7QUNOQTs7Ozs7QUFLQTs7OztBQUlBLFNBQVM0MkQsUUFBVCxDQUFrQjc2QixJQUFsQixFQUF3QjA2QixjQUF4QixFQUF3Q3IzRCxPQUF4QyxFQUFpRDtBQUFBLE1BQzFDa1QsRUFBRSxHQUFHLEtBQUtrMkIsUUFEZ0M7QUFBQSxNQUUxQzFkLFNBQVMsR0FBR3hZLEVBQUUsQ0FBQ2lZLGNBQUgsQ0FBa0Jrc0MsY0FBbEIsQ0FGOEI7QUFJaERua0QsSUFBRSxFQUFJeXBCLElBQUksR0FBRyxRQUFILEdBQWMsS0FBdEIsc0JBQUYsQ0FBZ0RqUixTQUFoRCxDQUpnRDtBQUFBLE1BTTFDM1ksT0FBTyxHQUFHRyxFQUFFLENBQUM1USxHQUFILENBQU9tZSxHQUFQLENBQVc5SSxTQUFYLENBQXFCekUsRUFBRSxDQUFDbWhCLGVBQUgsQ0FBbUIzSSxTQUFuQixDQUFyQixDQU5nQztBQUFBLE1BTzFDbEosT0FBTyxHQUFHbWEsSUFBSSxHQUFHLEdBQUgsR0FBUyxHQVBtQjtBQVNoRDVwQixTQUFPLENBQUNvQyxVQUFSLEdBQ0U4QyxLQURGLENBQ1EsU0FEUixFQUNtQnVLLE9BRG5CLEVBQzRCLFdBRDVCLEVBRUU1aEIsSUFGRixDQUVPc1MsRUFBRSxDQUFDaWUsTUFGVixFQUVrQixZQUFNO0FBQ3RCcGUsV0FBTyxDQUFDa0YsS0FBUixDQUFjLFNBQWQsRUFBeUIsSUFBekIsRUFBK0JBLEtBQS9CLENBQXFDLFNBQXJDLEVBQWdEdUssT0FBaEQsQ0FEc0I7QUFFdEIsR0FKRixDQVRnRCxFQWVoRHhpQixPQUFPLENBQUNxdkIsVUFBUixJQUFzQm5jLEVBQUUsRUFBSXlwQixJQUFJLEdBQUcsTUFBSCxHQUFZLE1BQXBCLGFBQUYsQ0FBc0NqUixTQUF0QyxDQWYwQixFQWlCaER4WSxFQUFFLENBQUNrUCxNQUFILENBQVU7QUFDVHdPLHdCQUFvQixJQURYO0FBRVRDLHFCQUFpQixJQUZSO0FBR1R4QixjQUFVO0FBSEQsR0FBVixDQWpCZ0Q7QUFzQmhEOztBQUVjO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFzTixNQXBCYyxnQkFvQlQwNkIsY0FwQlMsRUFvQjJCcjNELE9BcEIzQixFQW9CeUM7QUFBZEEsV0FBYyxnQkFBZEEsT0FBYyxHQUFKLEVBQUksR0FDdER3M0QsUUFBUSxDQUFDNTJELElBQVQsQ0FBYyxJQUFkLE1BQTBCeTJELGNBQTFCLEVBQTBDcjNELE9BQTFDLENBRHNEO0FBRXRELEdBdEJhOztBQXdCZDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTA4QixNQTNDYyxnQkEyQ1QyNkIsY0EzQ1MsRUEyQ09yM0QsT0EzQ1AsRUEyQ3FCO0FBQWRBLFdBQWMsZ0JBQWRBLE9BQWMsR0FBSixFQUFJLEdBQ2xDdzNELFFBQVEsQ0FBQzUyRCxJQUFULENBQWMsSUFBZCxNQUEyQnkyRCxjQUEzQixFQUEyQ3IzRCxPQUEzQyxDQURrQztBQUVsQyxHQTdDYTs7QUErQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE0OEIsUUFsRWMsa0JBa0VQbFIsU0FsRU8sRUFrRUkxckIsT0FsRUosRUFrRWtCO0FBQUE7O0FBQWRBLFdBQWMsZ0JBQWRBLE9BQWMsR0FBSixFQUFJO0FBQUEsUUFDekJrVCxFQUFFLEdBQUcsS0FBS2syQixRQURlO0FBQUEsUUFFekJyMkIsT0FBTyxHQUFHO0FBQUM0cEIsVUFBSSxFQUFFLEVBQVA7QUFBV0QsVUFBSSxFQUFFO0FBQWpCLEtBRmU7QUFJL0I7QUFJQTtBQUNBO0FBSkF4cEIsTUFBRSxDQUFDaVksY0FBSCxDQUFrQk8sU0FBbEIsRUFDRW5yQixPQURGLENBQ1UsVUFBQ2hQLEVBQUQ7QUFBQSxhQUFnQndoQixPQUFPLENBQUNHLEVBQUUsQ0FBQ29ZLGNBQUgsQ0FBa0IvNUIsRUFBbEIsSUFBd0IsTUFBeEIsR0FBaUMsTUFBbEMsQ0FBUCxDQUFpRGdWLElBQWpELENBQXNEaFYsRUFBdEQsQ0FBaEI7QUFBQSxLQURWLENBTCtCLEVBVS9Cd2hCLE9BQU8sQ0FBQzRwQixJQUFSLENBQWF4OUIsTUFBYixJQUF1QixLQUFLdzlCLElBQUwsQ0FBVTVwQixPQUFPLENBQUM0cEIsSUFBbEIsRUFBd0IzOEIsT0FBeEIsQ0FWUSxFQVcvQitTLE9BQU8sQ0FBQzJwQixJQUFSLENBQWF2OUIsTUFBYixJQUF1QmsxQyxVQUFVLENBQUM7QUFBQSxhQUFNLEtBQUksQ0FBQzNYLElBQUwsQ0FBVTNwQixPQUFPLENBQUMycEIsSUFBbEIsRUFBd0IxOEIsT0FBeEIsQ0FBTjtBQUFBLEtBQUQsRUFBeUMsQ0FBekMsQ0FYRjtBQVkvQjtBQTlFYSxDQUFmLEU7O0FDakNBOzs7O0FBSUE7QUFFQTs7Ozs7QUFJQSxJQUFNL1IsZUFBTyxHQUFHO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREEwdUMsTUFBSSxFQUFFLGNBQVNoOEIsSUFBVCxFQUFlO0FBR2hCLFFBQUE0WCxLQUFLO0FBQUEsUUFDTDlSLEtBREs7QUFBQSxRQUZIeU0sRUFFRyxHQUZFLEtBQUtrMkIsUUFFUDtBQUFBLFFBREZ2Z0MsTUFDRSxHQUQ0QnFLLEVBQzVCLENBREZySyxNQUNFO0FBQUEsUUFEY3pYLFNBQ2QsR0FENEI4aEIsRUFDNUIsQ0FETTlqQixLQUNOLENBRGNnQyxTQUNkOztBQVFUO0FBQ0EsUUFMSXVQLElBQUksQ0FBQzhGLEtBS1QsS0FKQ0EsS0FBSyxHQUFHOUYsSUFBSSxDQUFDOEYsS0FJZCxHQUFJOUYsSUFBSSxDQUFDMEUsSUFBVCxFQUFlO0FBQ2QsVUFBTXJVLENBQUMsR0FBR2tpQixFQUFFLENBQUNtdEIsU0FBSCxDQUFhMS9CLElBQUksQ0FBQzBFLElBQUwsQ0FBVTlULEVBQXZCLEVBQTJCb1AsSUFBSSxDQUFDMEUsSUFBTCxDQUFVaEYsS0FBckMsQ0FBVjtBQUVJNlMsUUFBRSxDQUFDaVcsV0FBSCxFQUhVLEdBS2IxaUIsS0FBSyxHQUFHLENBQUN5TSxFQUFFLENBQUNLLEtBQUgsQ0FBUzFpQixDQUFULENBQVc4UCxJQUFJLENBQUMwRSxJQUFMLENBQVV4VSxDQUFyQixDQUFELEVBQTBCRyxDQUExQixDQUxLLElBT1QsQ0FBQzZYLE1BQU0sQ0FBQ2hTLGVBUEMsS0FRWjRQLEtBQUssR0FBRyxDQUFDLENBQUQsRUFBSXpWLENBQUosQ0FSSSxHQVdidW5CLEtBQUssR0FBR3JhLE9BQU8sQ0FBQ3lDLElBQUksQ0FBQzBFLElBQUwsQ0FBVWtULEtBQVgsQ0FBUCxHQUEyQjVYLElBQUksQ0FBQzBFLElBQUwsQ0FBVWtULEtBQXJDLEdBQTZDckYsRUFBRSxDQUFDMFYsV0FBSCxDQUFlam9CLElBQUksQ0FBQzBFLElBQUwsQ0FBVXhVLENBQXpCLENBWHhDO0FBYWQsS0FiRCxNQWFXMk4sU0FBUyxDQUFDbUMsSUFBSSxDQUFDOVAsQ0FBTixDQWJwQixHQWNDMG5CLEtBQUssR0FBR3JGLEVBQUUsQ0FBQzBWLFdBQUgsQ0FBZWpvQixJQUFJLENBQUM5UCxDQUFwQixDQWRULEdBZVcyTixTQUFTLENBQUNtQyxJQUFJLENBQUM0WCxLQUFOLENBZnBCLEtBZ0JDQSxLQUFLLEdBQUc1WCxJQUFJLENBQUM0WCxLQWhCZCxFQVpvQixDQStCcEI7OztBQUNBLEtBQUNubkIsU0FBUyxLQUFLLE9BQWQsR0FDQSxDQUFDLFdBQUQsRUFBYyxXQUFkLENBREEsR0FDNkIsQ0FBQyxZQUFELENBRDlCLEVBRUVtUCxPQUZGLENBRVUsVUFBQWszRCxTQUFTLEVBQUk7QUFDdEJ2a0QsUUFBRSxDQUFDN0wsYUFBSCxDQUFpQm93RCxTQUFqQixFQUE0QmwvQyxLQUE1QixFQUFtQzlSLEtBQW5DLENBRHNCO0FBRXRCLEtBSkQsQ0FoQ29CO0FBcUNwQixHQXZGYzs7QUF5RmY7Ozs7OztBQU1BaTJCLE1BQUksRUFBRSxnQkFBVztBQUNoQixRQUFNeHBCLEVBQUUsR0FBRyxLQUFLazJCLFFBQWhCO0FBRUFsMkIsTUFBRSxDQUFDNHBCLFdBQUgsSUFIZ0IsRUFJaEI1cEIsRUFBRSxDQUFDcThCLGFBQUgsRUFKZ0IsRUFLaEJyOEIsRUFBRSxDQUFDZ2dDLGVBQUgsRUFMZ0IsRUFNaEJoZ0MsRUFBRSxDQUFDb2dDLFlBQUgsRUFOZ0I7QUFPaEI7QUF0R2MsQ0FBaEI7QUF5R2U7QUFBQ3JsRCxTQUFPLEVBQVBBLGVBQU9BO0FBQVIsQ0FBZixFOzs7O0FDbkhBOzs7O0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTRCcUJ5cEUsVztBQUNwQjs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxlQUFZMTNELE9BQVosRUFBcUI7QUFBQSxtQ0FISixFQUdJO0FBQ2QsTUFBQXNELEdBQUcsR0FBRyxJQUFOO0FBQUEsc0JBQ2dCdEQsT0FBTyxDQUFDcUYsSUFEeEI7QUFBQSxNQUNDMUMsSUFERCxpQkFDQ0EsSUFERDtBQUFBLE1BQ084dEIsS0FEUCxpQkFDT0EsS0FEUDtBQUFBLE1BZUF2ZCxFQWZBLEdBZUssSUFBSTQ4QywyQkFBSixDQUFrQnhzRCxHQUFsQixDQWZMO0FBbUJOO0FBRkEsT0FBSzhsQyxRQUFMLEdBQWdCbDJCLEVBbEJJLEVBcUJuQixTQUFTeWtELFFBQVQsQ0FBa0JsM0QsRUFBbEIsRUFBc0I1UyxNQUF0QixFQUE4QitwRSxPQUE5QixFQUF1QztBQUN2Q3Y0RCxVQUFNLENBQUNDLElBQVAsQ0FBWW1CLEVBQVosRUFBZ0JGLE9BQWhCLENBQXdCLFVBQUFOLEdBQUcsRUFBSTtBQUFBLFVBQ3hCNDNELE1BQU0sR0FBR3o1RCxVQUFVLENBQUNxQyxFQUFFLENBQUNSLEdBQUQsQ0FBSCxDQURLO0FBQUEsVUFFeEI2M0QsT0FBTyxHQUFHanFFLE1BQU0sS0FBSytwRSxPQUZHO0FBQUEsVUFHeEJHLFFBQVEsR0FBRzE0RCxNQUFNLENBQUNDLElBQVAsQ0FBWW1CLEVBQUUsQ0FBQ1IsR0FBRCxDQUFkLEVBQXFCZCxNQUFyQixHQUE4QixDQUhqQjtBQUsxQjA0RCxZQUFNLEtBQU0sQ0FBQ0MsT0FBRCxJQUFZQyxRQUFiLElBQTBCRCxPQUEvQixDQUxvQixHQU03QmpxRSxNQUFNLENBQUNvUyxHQUFELENBQU4sR0FBY1EsRUFBRSxDQUFDUixHQUFELENBQUYsQ0FBUW9XLElBQVIsQ0FBYXVoRCxPQUFiLENBTmUsR0FPbkIsQ0FBQ0MsTUFQa0IsS0FRN0JocUUsTUFBTSxDQUFDb1MsR0FBRCxDQUFOLEdBQWMsRUFSZSxHQVc5QjgzRCxRQUFRLElBQUlKLFFBQVEsQ0FBQ2wzRCxFQUFFLENBQUNSLEdBQUQsQ0FBSCxFQUFVcFMsTUFBTSxDQUFDb1MsR0FBRCxDQUFoQixFQUF1QjIzRCxPQUF2QixDQVhVO0FBWTlCLEtBWkQsQ0FEdUM7QUFjdkMsR0FkRCxDQWNHRixLQUFLLENBQUNqRCxTQWRULEVBY29CLElBZHBCLEVBYzBCLElBZDFCLENBckJvQixFQXFDcEJNLFVBQVUsQ0FBQ24wRCxJQUFYLENBQWdCc1MsRUFBaEIsRUFBb0JsVCxPQUFwQixDQXJDb0IsRUF1Q3BCa1QsRUFBRSxDQUFDODhDLFVBQUgsRUF2Q29CLEVBd0NwQjk4QyxFQUFFLENBQUNnSSxJQUFILEVBeENvQixFQXlDcEJoSSxFQUFFLENBQUNnOUMsU0FBSCxFQXpDb0I7QUEwQ3BCLEMsRUFHRjs7OztBQUNBM3NELE1BQU0sQ0FBQ20wRCxXQUFLLENBQUNqRCxTQUFQLEdBQ0x1RCxTQURLLEVBRUxDLFNBRkssRUFHTEMsUUFISyxFQUlMQyxVQUpLLEVBS0xDLFNBTEssRUFNTEMsVUFOSyxFQU9MQyxJQVBLLEVBUUxDLFFBUkssRUFTTEMsV0FUSyxTQVVGMUQsYUFBVSxDQUFDNTRDLEdBVlQsRTs7QUNsSU47QUFBQTtBQUFBOzs7O0FBSUE7Q0FHQTs7QUFDQTtJQUVJdThDLFNBQVEsR0FBRyxFO0lBTVRDLEVBQUUsR0FBRztBQUNWOzs7Ozs7O0FBT0FDLFNBQU8sRUFBRSxhQVJDOztBQVVWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQUMsVUFwQ1Usb0JBb0NEL3ZELE1BcENDLEVBb0NPO0FBQUEsUUFDVjdJLE9BQU8sR0FBRzJGLFFBQVEsQ0FBQyxFQUFELEVBQUs4eUQsU0FBTCxFQUFlNXZELE1BQWYsQ0FEUjtBQUFBLFFBRVZnd0QsSUFBSSxHQUFHLElBQUluQixXQUFKLENBQVUxM0QsT0FBVixDQUZHO0FBT2hCLFdBSEE2NEQsSUFBSSxDQUFDenZCLFFBQUwsQ0FBY0YsTUFBZCxHQUF1QixLQUFLNHZCLFFBRzVCLEVBRkEsS0FBS0EsUUFBTCxDQUFjdnlELElBQWQsQ0FBbUJzeUQsSUFBbkIsQ0FFQSxFQUFPQSxJQUFQO0FBQ0EsR0E1Q1M7O0FBOENWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBSixVQXBFVSxvQkFvRUR6NEQsT0FwRUMsRUFvRVE7QUFLakIsV0FKSUosUUFBUSxDQUFDSSxPQUFELENBSVosS0FIQ3k0RCxTQUFRLEdBQUd6NEQsT0FHWixHQUFPeTRELFNBQVA7QUFDQSxHQTFFUzs7QUE0RVY7Ozs7Ozs7Ozs7O0FBV0FLLFVBQVEsRUFBRSxFQXZGQTs7QUF5RlY7Ozs7Ozs7O0FBUUFDLFFBQU0sRUFBRTtBQWpHRSxDO0FBSlgiLCJmaWxlIjoiYmlsbGJvYXJkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiZDMtdGltZS1mb3JtYXRcIiksIHJlcXVpcmUoXCJkMy1zZWxlY3Rpb25cIiksIHJlcXVpcmUoXCJkMy10cmFuc2l0aW9uXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtc2NhbGVcIiksIHJlcXVpcmUoXCJkMy1kc3ZcIiksIHJlcXVpcmUoXCJkMy1kcmFnXCIpLCByZXF1aXJlKFwiZDMtem9vbVwiKSwgcmVxdWlyZShcImQzLWVhc2VcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiZDMtdGltZS1mb3JtYXRcIiwgXCJkMy1zZWxlY3Rpb25cIiwgXCJkMy10cmFuc2l0aW9uXCIsIFwiZDMtYnJ1c2hcIiwgXCJkMy1heGlzXCIsIFwiZDMtc2NhbGVcIiwgXCJkMy1kc3ZcIiwgXCJkMy1kcmFnXCIsIFwiZDMtem9vbVwiLCBcImQzLWVhc2VcIiwgXCJkMy1jb2xvclwiLCBcImQzLXNoYXBlXCIsIFwiZDMtaW50ZXJwb2xhdGVcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLWJydXNoXCIpLCByZXF1aXJlKFwiZDMtYXhpc1wiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpKSA6IGZhY3Rvcnkocm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM2X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM3X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQxX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQyX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ1X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ2X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ4X18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxuLyogZXNsaW50IHByZWZlci1kZXN0cnVjdHVyaW5nOiBvZmYgKi9cblxudmFyIHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcblxudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbnZhciBvdmVybGF5ID0gcmVxdWlyZSgnLi9vdmVybGF5Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nLFxuICAgIHNldExvZ0xldmVsID0gX3JlcXVpcmUuc2V0TG9nTGV2ZWw7XG5cbnZhciBzZW5kTWVzc2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMvc2VuZE1lc3NhZ2UnKTtcblxudmFyIHJlbG9hZEFwcCA9IHJlcXVpcmUoJy4vdXRpbHMvcmVsb2FkQXBwJyk7XG5cbnZhciBjcmVhdGVTb2NrZXRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVNvY2tldFVybCcpO1xuXG52YXIgc3RhdHVzID0ge1xuICBpc1VubG9hZGluZzogZmFsc2UsXG4gIGN1cnJlbnRIYXNoOiAnJ1xufTtcbnZhciBvcHRpb25zID0ge1xuICBob3Q6IGZhbHNlLFxuICBob3RSZWxvYWQ6IHRydWUsXG4gIGxpdmVSZWxvYWQ6IGZhbHNlLFxuICBpbml0aWFsOiB0cnVlLFxuICB1c2VXYXJuaW5nT3ZlcmxheTogZmFsc2UsXG4gIHVzZUVycm9yT3ZlcmxheTogZmFsc2UsXG4gIHVzZVByb2dyZXNzOiBmYWxzZVxufTtcbnZhciBzb2NrZXRVcmwgPSBjcmVhdGVTb2NrZXRVcmwoX19yZXNvdXJjZVF1ZXJ5KTtcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIG9wdGlvbnMuaG90UmVsb2FkID0gcXMuaW5kZXhPZignaG90cmVsb2FkPWZhbHNlJykgPT09IC0xO1xufVxuXG52YXIgb25Tb2NrZXRNZXNzYWdlID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBvcHRpb25zLmhvdCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC4nKTtcbiAgfSxcbiAgbGl2ZVJlbG9hZDogZnVuY3Rpb24gbGl2ZVJlbG9hZCgpIHtcbiAgICBvcHRpb25zLmxpdmVSZWxvYWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBMaXZlIFJlbG9hZGluZyBlbmFibGVkLicpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi4nKTsgLy8gZml4ZXMgIzEwNDIuIG92ZXJsYXkgZG9lc24ndCBjbGVhciBpZiBlcnJvcnMgYXJlIGZpeGVkIGJ1dCB3YXJuaW5ncyByZW1haW4uXG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBzdGF0dXMuY3VycmVudEhhc2ggPSBfaGFzaDtcbiAgfSxcbiAgJ3N0aWxsLW9rJzogZnVuY3Rpb24gc3RpbGxPaygpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gTm90aGluZyBjaGFuZ2VkLicpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcblxuICAgIGlmIChob3RDdHgua2V5cygpLmluZGV4T2YoJy4vbG9nJykgIT09IC0xKSB7XG4gICAgICBob3RDdHgoJy4vbG9nJykuc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH1cblxuICAgIHNldExvZ0xldmVsKGxldmVsKTtcbiAgfSxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLnVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy51c2VQcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJbV0RTXSBcIi5jb25jYXQoZGF0YS5wZXJjZW50LCBcIiUgLSBcIikuY29uY2F0KGRhdGEubXNnLCBcIi5cIikpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdQcm9ncmVzcycsIGRhdGEpO1xuICB9LFxuICBvazogZnVuY3Rpb24gb2soKSB7XG4gICAgc2VuZE1lc3NhZ2UoJ09rJyk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2kod2FybmluZyk7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZSgnV2FybmluZ3MnLCBzdHJpcHBlZFdhcm5pbmdzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4oc3RyaXBwZWRXYXJuaW5nc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX3dhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2koZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF9lcnJvcnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgbG9nLmVycm9yKF9lcnJvcik7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIERpc2Nvbm5lY3RlZCEnKTtcbiAgICBzZW5kTWVzc2FnZSgnQ2xvc2UnKTtcbiAgfVxufTtcbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TWVzc2FnZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZVxuICBjYW1lbGNhc2VcbiovXG4vLyB0aGlzIFNvY2tKU0NsaWVudCBpcyBoZXJlIGFzIGEgZGVmYXVsdCBmYWxsYmFjaywgaW4gY2FzZSBpbmxpbmUgbW9kZVxuLy8gaXMgb2ZmIG9yIHRoZSBjbGllbnQgaXMgbm90IGluamVjdGVkLiBUaGlzIHdpbGwgYmUgc3dpdGNoZWQgdG9cbi8vIFdlYnNvY2tldENsaWVudCB3aGVuIGl0IGJlY29tZXMgdGhlIGRlZmF1bHRcbi8vIGltcG9ydGFudDogdGhlIHBhdGggdG8gU29ja0pTQ2xpZW50IGhlcmUgaXMgbWFkZSB0byB3b3JrIGluIHRoZSAnY2xpZW50J1xuLy8gZGlyZWN0b3J5LCBidXQgaXMgdXBkYXRlZCB2aWEgdGhlIHdlYnBhY2sgY29tcGlsYXRpb24gd2hlbiBjb21waWxlZCBmcm9tXG4vLyB0aGUgJ2NsaWVudC1zcmMnIGRpcmVjdG9yeVxuXG52YXIgQ2xpZW50ID0gdHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5yZXF1aXJlKCcuL2NsaWVudHMvU29ja0pTQ2xpZW50Jyk7XG52YXIgcmV0cmllcyA9IDA7XG52YXIgY2xpZW50ID0gbnVsbDtcblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xuICBjbGllbnQgPSBuZXcgQ2xpZW50KHVybCk7XG4gIGNsaWVudC5vbk9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICB9KTtcbiAgY2xpZW50Lm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXRyaWVzID09PSAwKSB7XG4gICAgICBoYW5kbGVycy5jbG9zZSgpO1xuICAgIH0gLy8gVHJ5IHRvIHJlY29ubmVjdC5cblxuXG4gICAgY2xpZW50ID0gbnVsbDsgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXG4gICAgaWYgKHJldHJpZXMgPD0gMTApIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgaWYgKGhhbmRsZXJzW21zZy50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgU29ja0pTID0gcmVxdWlyZSgnc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcycpO1xuXG52YXIgQmFzZUNsaWVudCA9IHJlcXVpcmUoJy4vQmFzZUNsaWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VDbGllbnQpIHtcbiAgX2luaGVyaXRzKFNvY2tKU0NsaWVudCwgX0Jhc2VDbGllbnQpO1xuXG4gIGZ1bmN0aW9uIFNvY2tKU0NsaWVudCh1cmwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29ja0pTQ2xpZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNvY2tKU0NsaWVudCkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMuc29jayA9IG5ldyBTb2NrSlModXJsKTtcblxuICAgIF90aGlzLnNvY2sub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsvLyBUT0RPOiB1c2UgbG9nZ2VyIHRvIGxvZyB0aGUgZXJyb3IgZXZlbnQgb25jZSBjbGllbnQgYW5kIGNsaWVudC1zcmNcbiAgICAgIC8vIGFyZSByZW9yZ2FuaXplZCB0byBoYXZlIHRoZSBzYW1lIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tKU0NsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLnNvY2sub25vcGVuID0gZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbmNsb3NlID0gZjtcbiAgICB9IC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoJy4vU29ja0pTQ2xpZW50Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tKU0NsaWVudDtcbn0oQmFzZUNsaWVudCk7IiwiLyogc29ja2pzLWNsaWVudCB2MS40LjAgfCBodHRwOi8vc29ja2pzLm9yZyB8IE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5Tb2NrSlMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHA6J1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbn1cblxudmFyIHRyYW5zcG9ydHM7XG5cbi8vIGZvbGxvdyBjb25zdHJ1Y3RvciBzdGVwcyBkZWZpbmVkIGF0IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG5mdW5jdGlvbiBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1NvY2tKUzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50XCIpO1xuICB9XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNPTk5FQ1RJTkc7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCA9IG9wdGlvbnMudHJhbnNwb3J0cztcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAwO1xuXG4gIHZhciBzZXNzaW9uSWQgPSBvcHRpb25zLnNlc3Npb25JZCB8fCA4O1xuICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XG5cbiAgLy8gU3RlcCAxIG9mIFdTIHNwZWMgLSBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIHVybC4gSXNzdWUgIzhcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCB8fCAhcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCAnXCIgKyB1cmwgKyBcIicgaXMgaW52YWxpZFwiKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVGhlIFVSTCBtdXN0IG5vdCBjb250YWluIGEgZnJhZ21lbnQnKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgfVxuXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAvLyBTdGVwIDIgLSBkb24ndCBhbGxvdyBzZWN1cmUgb3JpZ2luIHdpdGggYW4gaW5zZWN1cmUgcHJvdG9jb2xcbiAgaWYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgIXNlY3VyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMyAtIGNoZWNrIHBvcnQgYWNjZXNzIC0gbm8gbmVlZCBoZXJlXG4gIC8vIFN0ZXAgNCAtIHBhcnNlIHByb3RvY29scyBhcmd1bWVudFxuICBpZiAoIXByb3RvY29scykge1xuICAgIHByb3RvY29scyA9IFtdO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgfVxuXG4gIC8vIFN0ZXAgNSAtIGNoZWNrIHByb3RvY29scyBhcmd1bWVudFxuICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcbiAgc29ydGVkUHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG8sIGkpIHtcbiAgICBpZiAoIXByb3RvKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGludmFsaWQuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IChzb3J0ZWRQcm90b2NvbHMubGVuZ3RoIC0gMSkgJiYgcHJvdG8gPT09IHNvcnRlZFByb3RvY29sc1tpICsgMV0pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgZHVwbGljYXRlZC5cIik7XG4gICAgfVxuICB9KTtcblxuICAvLyBTdGVwIDYgLSBjb252ZXJ0IG9yaWdpblxuICB2YXIgbyA9IHVybFV0aWxzLmdldE9yaWdpbihsb2MuaHJlZik7XG4gIHRoaXMuX29yaWdpbiA9IG8gPyBvLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuXG4gIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2hcbiAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuXG4gIC8vIHN0b3JlIHRoZSBzYW5pdGl6ZWQgdXJsXG4gIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XG4gIGRlYnVnKCd1c2luZyB1cmwnLCB0aGlzLnVybCk7XG5cbiAgLy8gU3RlcCA3IC0gc3RhcnQgY29ubmVjdGlvbiBpbiBiYWNrZ3JvdW5kXG4gIC8vIG9idGFpbiBzZXJ2ZXIgaW5mb1xuICAvLyBodHRwOi8vc29ja2pzLmdpdGh1Yi5pby9zb2NranMtcHJvdG9jb2wvc29ja2pzLXByb3RvY29sLTAuMy4zLmh0bWwjc2VjdGlvbi0yNlxuICB0aGlzLl91cmxJbmZvID0ge1xuICAgIG51bGxPcmlnaW46ICFicm93c2VyLmhhc0RvbWFpbigpXG4gICwgc2FtZU9yaWdpbjogdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gICwgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gIH07XG5cbiAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcbiAgdGhpcy5faXIub25jZSgnZmluaXNoJywgdGhpcy5fcmVjZWl2ZUluZm8uYmluZCh0aGlzKSk7XG59XG5cbmluaGVyaXRzKFNvY2tKUywgRXZlbnRUYXJnZXQpO1xuXG5mdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDAwIHx8IChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbn1cblxuU29ja0pTLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAvLyBTdGVwIDFcbiAgaWYgKGNvZGUgJiYgIXVzZXJTZXRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3I6IEludmFsaWQgY29kZScpO1xuICB9XG4gIC8vIFN0ZXAgMi40IHN0YXRlcyB0aGUgbWF4IGlzIDEyMyBieXRlcywgYnV0IHdlIGFyZSBqdXN0IGNoZWNraW5nIGxlbmd0aFxuICBpZiAocmVhc29uICYmIHJlYXNvbi5sZW5ndGggPiAxMjMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ3JlYXNvbiBhcmd1bWVudCBoYXMgYW4gaW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMy4xXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8gbG9vayBhdCBkb2NzIHRvIGRldGVybWluZSBob3cgdG8gc2V0IHRoaXNcbiAgdmFyIHdhc0NsZWFuID0gdHJ1ZTtcbiAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyAjMTMgLSBjb252ZXJ0IGFueXRoaW5nIG5vbi1zdHJpbmcgdG8gc3RyaW5nXG4gIC8vIFRPRE8gdGhpcyBjdXJyZW50bHkgdHVybnMgb2JqZWN0cyBpbnRvIFtvYmplY3QgT2JqZWN0XVxuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFRoZSBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCB5ZXQnKTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnQuc2VuZChlc2NhcGUucXVvdGUoZGF0YSkpO1xufTtcblxuU29ja0pTLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuU29ja0pTLk9QRU4gPSAxO1xuU29ja0pTLkNMT1NJTkcgPSAyO1xuU29ja0pTLkNMT1NFRCA9IDM7XG5cblNvY2tKUy5wcm90b3R5cGUuX3JlY2VpdmVJbmZvID0gZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gIGRlYnVnKCdfcmVjZWl2ZUluZm8nLCBydHQpO1xuICB0aGlzLl9pciA9IG51bGw7XG4gIGlmICghaW5mbykge1xuICAgIHRoaXMuX2Nsb3NlKDEwMDIsICdDYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlc3RhYmxpc2ggYSByb3VuZC10cmlwIHRpbWVvdXQgKFJUTykgYmFzZWQgb24gdGhlXG4gIC8vIHJvdW5kLXRyaXAgdGltZSAoUlRUKVxuICB0aGlzLl9ydG8gPSB0aGlzLmNvdW50UlRPKHJ0dCk7XG4gIC8vIGFsbG93IHNlcnZlciB0byBvdmVycmlkZSB1cmwgdXNlZCBmb3IgdGhlIGFjdHVhbCB0cmFuc3BvcnRcbiAgdGhpcy5fdHJhbnNVcmwgPSBpbmZvLmJhc2VfdXJsID8gaW5mby5iYXNlX3VybCA6IHRoaXMudXJsO1xuICBpbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKGluZm8sIHRoaXMuX3VybEluZm8pO1xuICBkZWJ1ZygnaW5mbycsIGluZm8pO1xuICAvLyBkZXRlcm1pbmUgbGlzdCBvZiBkZXNpcmVkIGFuZCBzdXBwb3J0ZWQgdHJhbnNwb3J0c1xuICB2YXIgZW5hYmxlZFRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzLmZpbHRlclRvRW5hYmxlZCh0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKTtcbiAgdGhpcy5fdHJhbnNwb3J0cyA9IGVuYWJsZWRUcmFuc3BvcnRzLm1haW47XG4gIGRlYnVnKHRoaXMuX3RyYW5zcG9ydHMubGVuZ3RoICsgJyBlbmFibGVkIHRyYW5zcG9ydHMnKTtcblxuICB0aGlzLl9jb25uZWN0KCk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKTsgVHJhbnNwb3J0OyBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCkpIHtcbiAgICBkZWJ1ZygnYXR0ZW1wdCcsIFRyYW5zcG9ydC50cmFuc3BvcnROYW1lKTtcbiAgICBpZiAoVHJhbnNwb3J0Lm5lZWRCb2R5KSB7XG4gICAgICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5IHx8XG4gICAgICAgICAgKHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgICAgZGVidWcoJ3dhaXRpbmcgZm9yIGJvZHknKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0cy51bnNoaWZ0KFRyYW5zcG9ydCk7XG4gICAgICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCB0aGlzLl9jb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRpbWVvdXQgYmFzZWQgb24gUlRPIGFuZCByb3VuZCB0cmlwcy4gRGVmYXVsdCB0byA1c1xuICAgIHZhciB0aW1lb3V0TXMgPSBNYXRoLm1heCh0aGlzLl90aW1lb3V0LCAodGhpcy5fcnRvICogVHJhbnNwb3J0LnJvdW5kVHJpcHMpIHx8IDUwMDApO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydCAmJiB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkV2ZW50U291cmNlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuaWYgKERyaXZlcikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgRXZlbnRTb3VyY2VSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvZXZlbnRzb3VyY2UnKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFFdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xufTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2V2ZW50c291cmNlXCI6MjksXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9odG1sZmlsZVwiOjMwLFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXG4vLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuLy8gcmVtb3RlIGRvbWFpbi4gTmV3IGJyb3dzZXJzIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pZnJhbWUnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnRyYW5zcG9ydDppZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSWZyYW1lVHJhbnNwb3J0KHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgdGhpcy50cmFuc1VybCA9IHRyYW5zVXJsO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy53aW5kb3dJZCA9IHJhbmRvbS5zdHJpbmcoOCk7XG5cbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgZGVidWcodHJhbnNwb3J0LCB0cmFuc1VybCwgaWZyYW1lVXJsKTtcblxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcbiAgICBkZWJ1ZygnZXJyIGNhbGxiYWNrJyk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XG4gIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbn1cblxuaW5oZXJpdHMoSWZyYW1lVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGUub3JpZ2luLCB0aGlzLm9yaWdpbikpIHtcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcbiAgICAgIHZlcnNpb25cbiAgICAsIHRoaXMudHJhbnNwb3J0XG4gICAgLCB0aGlzLnRyYW5zVXJsXG4gICAgLCB0aGlzLmJhc2VVcmxcbiAgICBdKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3QnOlxuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2MnOlxuICAgIHZhciBjZGF0YTtcbiAgICB0cnkge1xuICAgICAgY2RhdGEgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gIHRoaXMuaWZyYW1lT2JqLnBvc3QoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi91dGlscy9yYW5kb21cIjo1MCxcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9saWIvc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCIuL3JlY2VpdmVyL2pzb25wXCI6MzEsXCIuL3NlbmRlci9qc29ucFwiOjMzLFwiaW5oZXJpdHNcIjo1N31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdjcmVhdGUgYWpheCBzZW5kZXInLCB1cmwsIHBheWxvYWQpO1xuICAgIHZhciBvcHQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuaGVhZGVycyA9IHsnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vaWZyYW1lJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblxuICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgfVxuXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24odXJsLCBpbmZvKSB7XG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgaWZyYW1lSW5mby5zYW1lT3JpZ2luID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbiAgfTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQucm91bmRUcmlwcyA9IElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzICsgdHJhbnNwb3J0LnJvdW5kVHJpcHMgLSAxOyAvLyBodG1sLCBqYXZhc2NyaXB0ICgyKSArIHRyYW5zcG9ydCAtIG5vIENPUlMgKDEpXG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5mYWNhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9vYmplY3RcIjo0OSxcIi4uL2lmcmFtZVwiOjIyLFwiaW5oZXJpdHNcIjo1N31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcbn1cblxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgdGhpcy5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xufVxuXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWNlaXZlciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9sbCA9IHRoaXMucG9sbCA9IG5ldyB0aGlzLlJlY2VpdmVyKHRoaXMucmVjZWl2ZVVybCwgdGhpcy5BamF4T2JqZWN0KTtcblxuICBwb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgc2VsZi5wb2xsID0gcG9sbCA9IG51bGw7XG5cbiAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlIHx8IDEwMDYsIHJlYXNvbik7XG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlcyA9IHRoaXMuZXMgPSBuZXcgRXZlbnRTb3VyY2VEcml2ZXIodXJsKTtcbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gIH07XG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yJywgZXMucmVhZHlTdGF0ZSwgZSk7XG4gICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgdmFyIHJlYXNvbiA9IChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xuICB9O1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgdmFyIGVzID0gdGhpcy5lcztcbiAgaWYgKGVzKSB7XG4gICAgZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgZXMuY2xvc2UoKTtcbiAgICB0aGlzLmVzID0gbnVsbDtcbiAgfVxufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSwgMjAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XG59XG5cbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmcmFtZVV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZGVjb2RlVVJJQ29tcG9uZW50KGlmcmFtZVV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xuICB2YXIgY29uc3RydWN0RnVuYyA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID9cbiAgICAgIGlmcmFtZVV0aWxzLmNyZWF0ZUh0bWxmaWxlIDogaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lO1xuXG4gIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcbiAgICAgIHNlbGYuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIH1cbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgfVxuICAsIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0b3AnKTtcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIHNlbGYuX2Nsb3NlKCduZXR3b3JrJyk7XG4gICAgfVxuICB9O1xuICB0aGlzLmlmcmFtZU9iaiA9IGNvbnN0cnVjdEZ1bmModXJsLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnY2FsbGJhY2snKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UoJ3Blcm1hbmVudCcpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSHRtbGZpbGVSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ19jbG9zZScsIHJlYXNvbik7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoYXhvIGluIGdsb2JhbCkge1xuICB0cnkge1xuICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gISFuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cbn1cblxuSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbn1cblxuaW5oZXJpdHMoWEhSQ29yc09iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi94ZHItc3RyZWFtaW5nJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbmZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhkclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItcG9sbGluZyc7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcIi4veGRyLXN0cmVhbWluZ1wiOjQwLFwiaW5oZXJpdHNcIjo1N31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcImluaGVyaXRzXCI6NTd9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1wb2xsaW5nJztcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBleHRyYUVzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nXG4gICwgZXh0cmFMb29rdXA7XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gIHZhciBpO1xuICB2YXIgdW5yb2xsZWQgPSB7fTtcbiAgdmFyIGMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgfVxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHF1b3RlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG5cbn0se1wianNvbjNcIjo1OH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbnZhciBvblVubG9hZCA9IHt9XG4gICwgYWZ0ZXJVbmxvYWQgPSBmYWxzZVxuICAgIC8vIGRldGVjdCBnb29nbGUgY2hyb21lIHBhY2thZ2VkIGFwcHMgYmVjYXVzZSB0aGV5IGRvbid0IGFsbG93IHRoZSAndW5sb2FkJyBldmVudFxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIGRldGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICBnbG9iYWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgdW5sb2FkQWRkOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gcmFuZG9tLnN0cmluZyg4KTtcbiAgICBvblVubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMudHJpZ2dlclVubG9hZENhbGxiYWNrcywgMCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxuXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG52YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhZnRlclVubG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZnRlclVubG9hZCA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbn07XG5cbi8vICd1bmxvYWQnIGFsb25lIGlzIG5vdCByZWxpYWJsZSBpbiBvcGVyYSB3aXRoaW4gYW4gaWZyYW1lLCBidXQgd2Vcbi8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICBtb2R1bGUuZXhwb3J0cy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkVHJpZ2dlcmVkKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9icm93c2VyXCI6NDQsXCIuL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NDN9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gJzEuNC4wJztcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC0/XFxkP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2NvbW1vblwiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cblxufSx7XCJtc1wiOjU0fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbCAmJiBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV19LHt9LFsxXSkoMSlcbn0pO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tqcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNsaWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5lZWRzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDbGllbnQ7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKSxcbiAgICBBbGxIdG1sRW50aXRpZXMgPSBfcmVxdWlyZS5BbGxIdG1sRW50aXRpZXM7XG5cbnZhciBlbnRpdGllcyA9IG5ldyBBbGxIdG1sRW50aXRpZXMoKTtcbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXG4gIGJsYWNrOiAnMTgxODE4JyxcbiAgcmVkOiAnRTM2MDQ5JyxcbiAgZ3JlZW46ICdCM0NCNzQnLFxuICB5ZWxsb3c6ICdGRkQwODAnLFxuICBibHVlOiAnN0NBRkMyJyxcbiAgbWFnZW50YTogJzdGQUNDQScsXG4gIGN5YW46ICdDM0MyRUYnLFxuICBsaWdodGdyZXk6ICdFQkU3RTMnLFxuICBkYXJrZ3JleTogJzZENzg5MSdcbn07XG52YXIgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG52YXIgb3ZlcmxheURpdiA9IG51bGw7XG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGlmcmFtZS5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXknO1xuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lLnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLmJvdHRvbSA9IDA7XG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcbiAgaWZyYW1lLm9ubG9hZCA9IG9uSWZyYW1lTG9hZDtcbiAgcmV0dXJuIGlmcmFtZTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKG9uT3ZlcmxheURpdlJlYWR5KSB7XG4gIGlmIChvdmVybGF5RGl2KSB7XG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cbiAgICBvbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRpbmcgYW4gaWZyYW1lIG1heSBiZSBhc3luY2hyb25vdXMgc28gd2UnbGwgc2NoZWR1bGUgdGhlIGNhbGxiYWNrLlxuICAvLyBJbiBjYXNlIG9mIG11bHRpcGxlIGNhbGxzLCBsYXN0IGNhbGxiYWNrIHdpbnMuXG5cblxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcblxuICBpZiAob3ZlcmxheUlmcmFtZSkge1xuICAgIC8vIFdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBpdC5cbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRlIGlmcmFtZSBhbmQsIHdoZW4gaXQgaXMgcmVhZHksIGEgZGl2IGluc2lkZSBpdC5cblxuXG4gIG92ZXJsYXlJZnJhbWUgPSBjcmVhdGVPdmVybGF5SWZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICBvdmVybGF5RGl2ID0gYWRkT3ZlcmxheURpdlRvKG92ZXJsYXlJZnJhbWUpOyAvLyBOb3cgd2UgY2FuIHRhbGshXG5cbiAgICBsYXN0T25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gIH0pOyAvLyBaYWxnbyBhbGVydDogb25JZnJhbWVMb2FkKCkgd2lsbCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHlcbiAgLy8gb3IgYXN5bmNocm9ub3VzbHkgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyLlxuICAvLyBXZSBkZWxheSBhZGRpbmcgaXQgc28gYG92ZXJsYXlJZnJhbWVgIGlzIHNldCB3aGVuIGBvbklmcmFtZUxvYWRgIGZpcmVzLlxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG59IC8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5cblxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGlmICghb3ZlcmxheURpdikge1xuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgcmV0dXJuO1xuICB9IC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cblxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn0gLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2UobWVzc2FnZXMpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI1wiLmNvbmNhdChjb2xvcnMucmVkLCBcIlxcXCI+RmFpbGVkIHRvIGNvbXBpbGUuPC9zcGFuPjxicj48YnI+XCIpLmNvbmNhdChhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZXNbMF0pKSk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xlYXI6IGNsZWFyLFxuICBzaG93TWVzc2FnZTogc2hvd01lc3NhZ2Vcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgWG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL3htbC1lbnRpdGllcy5qcycpLFxuICBIdG1sNEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNC1lbnRpdGllcy5qcycpLFxuICBIdG1sNUVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpLFxuICBBbGxIdG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJylcbn07XG4iLCJ2YXIgQUxQSEFfSU5ERVggPSB7XG4gICAgJyZsdCc6ICc8JyxcbiAgICAnJmd0JzogJz4nLFxuICAgICcmcXVvdCc6ICdcIicsXG4gICAgJyZhcG9zJzogJ1xcJycsXG4gICAgJyZhbXAnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhcG9zOyc6ICdcXCcnLFxuICAgICcmYW1wOyc6ICcmJ1xufTtcblxudmFyIENIQVJfSU5ERVggPSB7XG4gICAgNjA6ICdsdCcsXG4gICAgNjI6ICdndCcsXG4gICAgMzQ6ICdxdW90JyxcbiAgICAzOTogJ2Fwb3MnLFxuICAgIDM4OiAnYW1wJ1xufTtcblxudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBYbWxFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC88fD58XCJ8J3wmL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IENIQVJfSU5ERVhbY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ2h0ID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ2h0KSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sRW50aXRpZXM7XG4iLCJ2YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FlbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuXG52YXIgaSA9IDA7XG52YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG53aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBhID0gSFRNTF9BTFBIQVtpXTtcbiAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XG4gICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgbnVtSW5kZXhbY10gPSBhO1xuICAgIGkrKztcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImI1wiICsgY2MgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw0RW50aXRpZXM7XG4iLCJ2YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcblxuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFscGhhSW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbztcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw1RW50aXRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XG5cbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBUUkFDRSA9ICd0cmFjZSc7XG52YXIgU0lMRU5UID0gJ3NpbGVudCc7IC8vIGRlcHJlY2F0ZWRcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBhdCBtYWpvciByZWxlYXNlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMTgyNVxuXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIElORk86XG4gICAgY2FzZSBXQVJOOlxuICAgIGNhc2UgRVJST1I6XG4gICAgY2FzZSBERUJVRzpcbiAgICBjYXNlIFRSQUNFOlxuICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgV0FSTklORzpcbiAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgbG9nLnNldExldmVsKCd3YXJuJyk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIE5PTkU6XG4gICAgY2FzZSBTSUxFTlQ6XG4gICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbG9nLmVycm9yKFwiW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCAnXCIuY29uY2F0KGxldmVsLCBcIidcIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsXG59OyIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cblxuZnVuY3Rpb24gc2VuZE1zZyh0eXBlLCBkYXRhKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sICcqJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZW5kTXNnOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nO1xuXG5mdW5jdGlvbiByZWxvYWRBcHAoX3JlZiwgX3JlZjIpIHtcbiAgdmFyIGhvdFJlbG9hZCA9IF9yZWYuaG90UmVsb2FkLFxuICAgICAgaG90ID0gX3JlZi5ob3QsXG4gICAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuICB2YXIgaXNVbmxvYWRpbmcgPSBfcmVmMi5pc1VubG9hZGluZyxcbiAgICAgIGN1cnJlbnRIYXNoID0gX3JlZjIuY3VycmVudEhhc2g7XG5cbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7XG5cbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcblxuICAgIGhvdEVtaXR0ZXIuZW1pdCgnd2VicGFja0hvdFVwZGF0ZScsIGN1cnJlbnRIYXNoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi53aW5kb3cpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiLmNvbmNhdChjdXJyZW50SGFzaCksICcqJyk7XG4gICAgfVxuICB9IC8vIGFsbG93IHJlZnJlc2hpbmcgdGhlIHBhZ2Ugb25seSBpZiBsaXZlUmVsb2FkIGlzbid0IGRpc2FibGVkXG4gIGVsc2UgaWYgKGxpdmVSZWxvYWQpIHtcbiAgICAgIHZhciByb290V2luZG93ID0gc2VsZjsgLy8gdXNlIHBhcmVudCB3aW5kb3cgZm9yIHJlbG9hZCAoaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUgd2l0aCBubyB2YWxpZCBzcmMpXG5cbiAgICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xuICAgICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcblxuICAgICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICByb290V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVsb2FkQXBwOyIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBzZWxmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgPSByZXF1aXJlKCcuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UnKTtcblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VXJsKHJlc291cmNlUXVlcnksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgdXJsUGFydHM7XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZVF1ZXJ5ICE9PSAnJykge1xuICAgIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgICAvLyBmb3JtYXQgaXMgbGlrZSBgP2h0dHA6Ly8wLjAuMC4wOjgwOTYmc29ja1BvcnQ9ODA5NyZzb2NrSG9zdD1sb2NhbGhvc3RgXG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2UocmVzb3VyY2VRdWVyeSAvLyBzdHJpcCBsZWFkaW5nIGA/YCBmcm9tIHF1ZXJ5IHN0cmluZyB0byBnZXQgYSB2YWxpZCBVUkxcbiAgICAuc3Vic3RyKDEpIC8vIHJlcGxhY2UgZmlyc3QgYCZgIHdpdGggYD9gIHRvIGhhdmUgYSB2YWxpZCBxdWVyeSBzdHJpbmdcbiAgICAucmVwbGFjZSgnJicsICc/JyksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7XG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2Uoc2NyaXB0SG9zdCB8fCAnLycsIHRydWUsIHRydWUpO1xuICB9IC8vIFVzZSBwYXJhbWV0ZXIgdG8gYWxsb3cgcGFzc2luZyBsb2NhdGlvbiBpbiB1bml0IHRlc3RzXG5cblxuICBpZiAodHlwZW9mIGN1cnJlbnRMb2NhdGlvbiA9PT0gJ3N0cmluZycgJiYgY3VycmVudExvY2F0aW9uICE9PSAnJykge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHVybC5wYXJzZShjdXJyZW50TG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHNlbGYubG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBjdXJyZW50TG9jYXRpb24pO1xufVxuLypcbiAqIEdldHMgc29ja2V0IFVSTCBiYXNlZCBvbiBTY3JpcHQgU291cmNlL0xvY2F0aW9uXG4gKiAoc2NyaXB0U3JjOiBVUkwsIGxvY2F0aW9uOiBVUkwpIC0+IFVSTFxuICovXG5cblxuZnVuY3Rpb24gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBsb2MpIHtcbiAgdmFyIGF1dGggPSB1cmxQYXJ0cy5hdXRoLFxuICAgICAgcXVlcnkgPSB1cmxQYXJ0cy5xdWVyeTtcbiAgdmFyIGhvc3RuYW1lID0gdXJsUGFydHMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sLFxuICAgICAgcG9ydCA9IHVybFBhcnRzLnBvcnQ7XG5cbiAgaWYgKCFwb3J0IHx8IHBvcnQgPT09ICcwJykge1xuICAgIHBvcnQgPSBsb2MucG9ydDtcbiAgfSAvLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cblxuICBpZiAoKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpICYmIGxvYy5ob3N0bmFtZSAmJiBsb2MucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAwKSB7XG4gICAgaG9zdG5hbWUgPSBsb2MuaG9zdG5hbWU7XG4gIH0gLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuICAvLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cbiAgLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4gIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuXG5cbiAgaWYgKGhvc3RuYW1lICYmIGhvc3RuYW1lICE9PSAnMTI3LjAuMC4xJyAmJiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICAgIHByb3RvY29sID0gbG9jLnByb3RvY29sO1xuICB9IC8vIGFsbCBvZiB0aGVzZSBzb2NrIHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2hcbiAgLy8gcmVzb3VyY2VRdWVyeSwgc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWZcbiAgLy8gdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja0hvc3QgPSBxdWVyeS5zb2NrSG9zdCB8fCBob3N0bmFtZTtcbiAgdmFyIHNvY2tQYXRoID0gcXVlcnkuc29ja1BhdGggfHwgJy9zb2NranMtbm9kZSc7XG4gIHZhciBzb2NrUG9ydCA9IHF1ZXJ5LnNvY2tQb3J0IHx8IHBvcnQ7XG5cbiAgaWYgKHNvY2tQb3J0ID09PSAnbG9jYXRpb24nKSB7XG4gICAgc29ja1BvcnQgPSBsb2MucG9ydDtcbiAgfVxuXG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgYXV0aDogYXV0aCxcbiAgICBob3N0bmFtZTogc29ja0hvc3QsXG4gICAgcG9ydDogc29ja1BvcnQsXG4gICAgLy8gSWYgc29ja1BhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gICAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgIHBhdGhuYW1lOiBzb2NrUGF0aFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTb2NrZXRVcmw7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICBpZiAoY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcignW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDMxXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzA7IiwidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGR1bW15KCkge31cblxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0bG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9iaWxsYm9hcmQuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxudmFyIGV4cG9ydGVkID0gY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHt9O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlZDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyotLSBDaGFydCAtLSovXFxuLmJiIHN2ZyB7XFxuICBmb250OiAxMHB4IHNhbnMtc2VyaWY7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7IH1cXG5cXG4uYmIgcGF0aCwgLmJiIGxpbmUge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzAwMDsgfVxcblxcbi5iYiB0ZXh0LCAuYmIgLmJiLWJ1dHRvbiB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLWxlZ2VuZC1pdGVtLXRpbGUsXFxuLmJiLXhncmlkLWZvY3VzLFxcbi5iYi15Z3JpZC1mb2N1cyxcXG4uYmIteWdyaWQsXFxuLmJiLWV2ZW50LXJlY3QsXFxuLmJiLWJhcnMgcGF0aCB7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7IH1cXG5cXG4uYmItY2hhcnQtYXJjIC5iYi1nYXVnZS12YWx1ZSB7XFxuICBmaWxsOiAjMDAwOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyBwYXRoIHtcXG4gIHN0cm9rZTogI2ZmZjsgfVxcblxcbi5iYi1jaGFydC1hcmMgcmVjdCB7XFxuICBzdHJva2U6ICNmZmY7XFxuICBzdHJva2Utd2lkdGg6IDE7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHRleHQge1xcbiAgZmlsbDogI2ZmZjtcXG4gIGZvbnQtc2l6ZTogMTNweDsgfVxcblxcbi8qLS0gQXhpcyAtLSovXFxuLmJiLWF4aXMge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLyotLSBHcmlkIC0tKi9cXG4uYmItZ3JpZCBsaW5lIHtcXG4gIHN0cm9rZTogI2FhYTsgfVxcblxcbi5iYi1ncmlkIHRleHQge1xcbiAgZmlsbDogI2FhYTsgfVxcblxcbi5iYi14Z3JpZCwgLmJiLXlncmlkIHtcXG4gIHN0cm9rZS1kYXNoYXJyYXk6IDMgMzsgfVxcblxcbi8qLS0gVGV4dCBvbiBDaGFydCAtLSovXFxuLmJiLXRleHQuYmItZW1wdHkge1xcbiAgZmlsbDogIzgwODA4MDtcXG4gIGZvbnQtc2l6ZTogMmVtOyB9XFxuXFxuLyotLSBMaW5lIC0tKi9cXG4uYmItbGluZSB7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gUG9pbnQgLS0qL1xcbi5iYi1jaXJjbGUuX2V4cGFuZGVkXyB7XFxuICBzdHJva2Utd2lkdGg6IDFweDtcXG4gIHN0cm9rZTogd2hpdGU7IH1cXG5cXG4uYmItc2VsZWN0ZWQtY2lyY2xlIHtcXG4gIGZpbGw6IHdoaXRlO1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4vKi0tIEJhciAtLSovXFxuLmJiLWJhciB7XFxuICBzdHJva2Utd2lkdGg6IDA7IH1cXG4gIC5iYi1iYXIuX2V4cGFuZGVkXyB7XFxuICAgIGZpbGwtb3BhY2l0eTogMC43NTsgfVxcblxcbi8qLS0gRm9jdXMgLS0qL1xcbi5iYi10YXJnZXQuYmItZm9jdXNlZCwgLmJiLWNpcmNsZXMuYmItZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAxOyB9XFxuXFxuLmJiLXRhcmdldC5iYi1mb2N1c2VkIHBhdGguYmItbGluZSwgLmJiLXRhcmdldC5iYi1mb2N1c2VkIHBhdGguYmItc3RlcCwgLmJiLWNpcmNsZXMuYmItZm9jdXNlZCBwYXRoLmJiLWxpbmUsIC5iYi1jaXJjbGVzLmJiLWZvY3VzZWQgcGF0aC5iYi1zdGVwIHtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQsIC5iYi1jaXJjbGVzLmJiLWRlZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAwLjMgIWltcG9ydGFudDsgfVxcbiAgLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQgLnRleHQtb3ZlcmxhcHBpbmcsIC5iYi1jaXJjbGVzLmJiLWRlZm9jdXNlZCAudGV4dC1vdmVybGFwcGluZyB7XFxuICAgIG9wYWNpdHk6IC4wNSAhaW1wb3J0YW50OyB9XFxuXFxuLyotLSBSZWdpb24gLS0qL1xcbi5iYi1yZWdpb24ge1xcbiAgZmlsbDogc3RlZWxibHVlO1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gWm9vbSByZWdpb24gLS0qL1xcbi5iYi16b29tLWJydXNoIHtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIEJydXNoIC0tKi9cXG4uYmItYnJ1c2ggLmV4dGVudCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBTZWxlY3QgLSBEcmFnIC0tKi9cXG4vKi0tIExlZ2VuZCAtLSovXFxuLmJiLWxlZ2VuZC1pdGVtIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLWxlZ2VuZC1pdGVtLWhpZGRlbiB7XFxuICBvcGFjaXR5OiAwLjE1OyB9XFxuXFxuLmJiLWxlZ2VuZC1iYWNrZ3JvdW5kIHtcXG4gIG9wYWNpdHk6IDAuNzU7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZTogbGlnaHRncmF5O1xcbiAgc3Ryb2tlLXdpZHRoOiAxOyB9XFxuXFxuLyotLSBUaXRsZSAtLSovXFxuLmJiLXRpdGxlIHtcXG4gIGZvbnQ6IDE0cHggc2Fucy1zZXJpZjsgfVxcblxcbi8qLS0gVG9vbHRpcCAtLSovXFxuLmJiLXRvb2x0aXAtY29udGFpbmVyIHtcXG4gIHotaW5kZXg6IDEwO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItdG9vbHRpcCB7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgZW1wdHktY2VsbHM6IHNob3c7XFxuICBvcGFjaXR5OiAwLjk7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7XFxuICAtbW96LWJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7XFxuICBib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3OyB9XFxuICAuYmItdG9vbHRpcCB0ciB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNDQ0M7IH1cXG4gIC5iYi10b29sdGlwIHRoIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2FhYTtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBwYWRkaW5nOiAycHggNXB4O1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBjb2xvcjogI0ZGRjsgfVxcbiAgLmJiLXRvb2x0aXAgdGQge1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIHBhZGRpbmc6IDNweCA2cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZG90dGVkICM5OTk7IH1cXG4gICAgLmJiLXRvb2x0aXAgdGQgPiBzcGFuLCAuYmItdG9vbHRpcCB0ZCA+IHN2ZyB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgIGhlaWdodDogMTBweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDZweDsgfVxcbiAgLmJiLXRvb2x0aXAudmFsdWUge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgfVxcblxcbi8qLS0gQXJlYSAtLSovXFxuLmJiLWFyZWEge1xcbiAgc3Ryb2tlLXdpZHRoOiAwO1xcbiAgb3BhY2l0eTogMC4yOyB9XFxuXFxuLyotLSBBcmMgLS0qL1xcbi5iYi1jaGFydC1hcmNzLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDEuM2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdGl0bGUge1xcbiAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXG4gIGZvbnQtc2l6ZTogMi43ZW07IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1iYWNrZ3JvdW5kIHtcXG4gIGZpbGw6ICNlMGUwZTA7XFxuICBzdHJva2U6ICNmZmY7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS11bml0IHtcXG4gIGZpbGw6ICMwMDA7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1tYXgge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLW1pbiB7XFxuICBmaWxsOiAjNzc3OyB9XFxuXFxuLyotLSBSYWRhciAtLSovXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItbGV2ZWxzIHBvbHlnb24ge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyB0ZXh0IHtcXG4gIGZpbGw6ICM4NDgyODI7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1heGlzIGxpbmUge1xcbiAgc3Ryb2tlOiAjODQ4MjgyO1xcbiAgc3Ryb2tlLXdpZHRoOiAuNXB4OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyB0ZXh0IHtcXG4gIGZvbnQtc2l6ZTogMS4xNWVtO1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItc2hhcGVzIHBvbHlnb24ge1xcbiAgZmlsbC1vcGFjaXR5OiAuMjtcXG4gIHN0cm9rZS13aWR0aDogMXB4OyB9XFxuXFxuLyotLSBCdXR0b24gLS0qL1xcbi5iYi1idXR0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxMHB4O1xcbiAgcmlnaHQ6IDEwcHg7IH1cXG4gIC5iYi1idXR0b24gLmJiLXpvb20tcmVzZXQge1xcbiAgICBmb250LXNpemU6IDExcHg7XFxuICAgIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zNl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzdfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDBfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQxX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Ml9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ0X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDZfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180OF9fOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIENTUyBjbGFzcyBuYW1lcyBkZWZpbml0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0YXJjOiBcImJiLWFyY1wiLFxyXG5cdGFyY0xhYmVsTGluZTogXCJiYi1hcmMtbGFiZWwtbGluZVwiLFxyXG5cdGFyY3M6IFwiYmItYXJjc1wiLFxyXG5cdGFyZWE6IFwiYmItYXJlYVwiLFxyXG5cdGFyZWFzOiBcImJiLWFyZWFzXCIsXHJcblx0YXhpczogXCJiYi1heGlzXCIsXHJcblx0YXhpc1g6IFwiYmItYXhpcy14XCIsXHJcblx0YXhpc1hMYWJlbDogXCJiYi1heGlzLXgtbGFiZWxcIixcclxuXHRheGlzWTogXCJiYi1heGlzLXlcIixcclxuXHRheGlzWTI6IFwiYmItYXhpcy15MlwiLFxyXG5cdGF4aXNZMkxhYmVsOiBcImJiLWF4aXMteTItbGFiZWxcIixcclxuXHRheGlzWUxhYmVsOiBcImJiLWF4aXMteS1sYWJlbFwiLFxyXG5cdGJhcjogXCJiYi1iYXJcIixcclxuXHRiYXJzOiBcImJiLWJhcnNcIixcclxuXHRicnVzaDogXCJiYi1icnVzaFwiLFxyXG5cdGJ1dHRvbjogXCJiYi1idXR0b25cIixcclxuXHRidXR0b25ab29tUmVzZXQ6IFwiYmItem9vbS1yZXNldFwiLFxyXG5cdGNoYXJ0OiBcImJiLWNoYXJ0XCIsXHJcblx0Y2hhcnRBcmM6IFwiYmItY2hhcnQtYXJjXCIsXHJcblx0Y2hhcnRBcmNzOiBcImJiLWNoYXJ0LWFyY3NcIixcclxuXHRjaGFydEFyY3NCYWNrZ3JvdW5kOiBcImJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZFwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlTWF4OiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4XCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VNaW46IFwiYmItY2hhcnQtYXJjcy1nYXVnZS1taW5cIixcclxuXHRjaGFydEFyY3NHYXVnZVVuaXQ6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS11bml0XCIsXHJcblx0Y2hhcnRBcmNzVGl0bGU6IFwiYmItY2hhcnQtYXJjcy10aXRsZVwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlVGl0bGU6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS10aXRsZVwiLFxyXG5cdGNoYXJ0QmFyOiBcImJiLWNoYXJ0LWJhclwiLFxyXG5cdGNoYXJ0QmFyczogXCJiYi1jaGFydC1iYXJzXCIsXHJcblx0Y2hhcnRDaXJjbGVzOiBcImJiLWNoYXJ0LWNpcmNsZXNcIixcclxuXHRjaGFydExpbmU6IFwiYmItY2hhcnQtbGluZVwiLFxyXG5cdGNoYXJ0TGluZXM6IFwiYmItY2hhcnQtbGluZXNcIixcclxuXHRjaGFydFJhZGFyOiBcImJiLWNoYXJ0LXJhZGFyXCIsXHJcblx0Y2hhcnRSYWRhcnM6IFwiYmItY2hhcnQtcmFkYXJzXCIsXHJcblx0Y2hhcnRUZXh0OiBcImJiLWNoYXJ0LXRleHRcIixcclxuXHRjaGFydFRleHRzOiBcImJiLWNoYXJ0LXRleHRzXCIsXHJcblx0Y2lyY2xlOiBcImJiLWNpcmNsZVwiLFxyXG5cdGNpcmNsZXM6IFwiYmItY2lyY2xlc1wiLFxyXG5cdGNvbG9yUGF0dGVybjogXCJiYi1jb2xvci1wYXR0ZXJuXCIsXHJcblx0Y29sb3JTY2FsZTogXCJiYi1jb2xvcnNjYWxlXCIsXHJcblx0ZGVmb2N1c2VkOiBcImJiLWRlZm9jdXNlZFwiLFxyXG5cdGRyYWdhcmVhOiBcImJiLWRyYWdhcmVhXCIsXHJcblx0ZW1wdHk6IFwiYmItZW1wdHlcIixcclxuXHRldmVudFJlY3Q6IFwiYmItZXZlbnQtcmVjdFwiLFxyXG5cdGV2ZW50UmVjdHM6IFwiYmItZXZlbnQtcmVjdHNcIixcclxuXHRldmVudFJlY3RzTXVsdGlwbGU6IFwiYmItZXZlbnQtcmVjdHMtbXVsdGlwbGVcIixcclxuXHRldmVudFJlY3RzU2luZ2xlOiBcImJiLWV2ZW50LXJlY3RzLXNpbmdsZVwiLFxyXG5cdGZvY3VzZWQ6IFwiYmItZm9jdXNlZFwiLFxyXG5cdGdhdWdlVmFsdWU6IFwiYmItZ2F1Z2UtdmFsdWVcIixcclxuXHRncmlkOiBcImJiLWdyaWRcIixcclxuXHRncmlkTGluZXM6IFwiYmItZ3JpZC1saW5lc1wiLFxyXG5cdGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcclxuXHRsZWdlbmRJdGVtOiBcImJiLWxlZ2VuZC1pdGVtXCIsXHJcblx0bGVnZW5kSXRlbUV2ZW50OiBcImJiLWxlZ2VuZC1pdGVtLWV2ZW50XCIsXHJcblx0bGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxyXG5cdGxlZ2VuZEl0ZW1IaWRkZW46IFwiYmItbGVnZW5kLWl0ZW0taGlkZGVuXCIsXHJcblx0bGVnZW5kSXRlbVBvaW50OiBcImJiLWxlZ2VuZC1pdGVtLXBvaW50XCIsXHJcblx0bGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxyXG5cdGxldmVsOiBcImJiLWxldmVsXCIsXHJcblx0bGV2ZWxzOiBcImJiLWxldmVsc1wiLFxyXG5cdGxpbmU6IFwiYmItbGluZVwiLFxyXG5cdGxpbmVzOiBcImJiLWxpbmVzXCIsXHJcblx0cmVnaW9uOiBcImJiLXJlZ2lvblwiLFxyXG5cdHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlOiBcImJiLXNlbGVjdGVkLWNpcmNsZVwiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlczogXCJiYi1zZWxlY3RlZC1jaXJjbGVzXCIsXHJcblx0c2hhcGU6IFwiYmItc2hhcGVcIixcclxuXHRzaGFwZXM6IFwiYmItc2hhcGVzXCIsXHJcblx0c3RhbmZvcmRFbGVtZW50czogXCJiYi1zdGFuZm9yZC1lbGVtZW50c1wiLFxyXG5cdHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXHJcblx0c3RhbmZvcmRMaW5lczogXCJiYi1zdGFuZm9yZC1saW5lc1wiLFxyXG5cdHN0YW5mb3JkUmVnaW9uOiBcImJiLXN0YW5mb3JkLXJlZ2lvblwiLFxyXG5cdHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXHJcblx0dGFyZ2V0OiBcImJiLXRhcmdldFwiLFxyXG5cdHRleHQ6IFwiYmItdGV4dFwiLFxyXG5cdHRleHRzOiBcImJiLXRleHRzXCIsXHJcblx0dGl0bGU6IFwiYmItdGl0bGVcIixcclxuXHR0b29sdGlwOiBcImJiLXRvb2x0aXBcIixcclxuXHR0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXHJcblx0dG9vbHRpcE5hbWU6IFwiYmItdG9vbHRpcC1uYW1lXCIsXHJcblx0eGdyaWQ6IFwiYmIteGdyaWRcIixcclxuXHR4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXHJcblx0eGdyaWRMaW5lOiBcImJiLXhncmlkLWxpbmVcIixcclxuXHR4Z3JpZExpbmVzOiBcImJiLXhncmlkLWxpbmVzXCIsXHJcblx0eGdyaWRzOiBcImJiLXhncmlkc1wiLFxyXG5cdHlncmlkOiBcImJiLXlncmlkXCIsXHJcblx0eWdyaWRGb2N1czogXCJiYi15Z3JpZC1mb2N1c1wiLFxyXG5cdHlncmlkTGluZTogXCJiYi15Z3JpZC1saW5lXCIsXHJcblx0eWdyaWRMaW5lczogXCJiYi15Z3JpZC1saW5lc1wiLFxyXG5cdHlncmlkczogXCJiYi15Z3JpZHNcIixcclxuXHR6b29tQnJ1c2g6IFwiYmItem9vbS1icnVzaFwiLFxyXG5cdHpvb21SZWN0OiBcImJiLXpvb20tcmVjdFwiLFxyXG5cdEVYUEFOREVEOiBcIl9leHBhbmRlZF9cIixcclxuXHRTRUxFQ1RFRDogXCJfc2VsZWN0ZWRfXCIsXHJcblx0SU5DTFVERUQ6IFwiX2luY2x1ZGVkX1wiLFxyXG5cdFRleHRPdmVybGFwcGluZzogXCJ0ZXh0LW92ZXJsYXBwaW5nXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBzdGF0ZSB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0d2lkdGgyOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IDAsXHJcblx0XHRcdGhlaWdodDI6IDAsXHJcblx0XHRcdG1hcmdpbjoge1xyXG5cdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRyaWdodDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtYXJnaW4yOiB7XHJcblx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdG1hcmdpbjM6IHtcclxuXHRcdFx0XHR0b3A6IDAsXHJcblx0XHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0cmlnaHQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0YXJjV2lkdGg6IDAsXHJcblx0XHRcdGFyY0hlaWdodDogMCxcclxuXHRcdFx0Y3VycmVudFdpZHRoOiAwLFxyXG5cdFx0XHRjdXJyZW50SGVpZ2h0OiAwLFxyXG5cclxuXHRcdFx0Ly8gbGVnZW5kXHJcblx0XHRcdGlzTGVnZW5kUmlnaHQ6IGZhbHNlLFxyXG5cdFx0XHRpc0xlZ2VuZEluc2V0OiBmYWxzZSxcclxuXHRcdFx0aXNMZWdlbmRUb3A6IGZhbHNlLFxyXG5cdFx0XHRpc0xlZ2VuZExlZnQ6IGZhbHNlLFxyXG5cdFx0XHRsZWdlbmRTdGVwOiAwLFxyXG5cdFx0XHRsZWdlbmRJdGVtV2lkdGg6IDAsXHJcblx0XHRcdGxlZ2VuZEl0ZW1IZWlnaHQ6IDAsXHJcblx0XHRcdGxlZ2VuZEhhc1JlbmRlcmVkOiBmYWxzZSxcclxuXHJcblx0XHRcdGN1cnJlbnRNYXhUaWNrV2lkdGhzOiB7XHJcblx0XHRcdFx0eDoge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0eToge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0eTI6IHtzaXplOiAwLCBkb21haW46IFwiXCJ9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRyb3RhdGVkUGFkZGluZzoge1xyXG5cdFx0XHRcdGxlZnQ6IDMwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRcdHRvcDogNVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0d2l0aG91dEZhZGVJbjoge30sXHJcblx0XHRcdGlucHV0VHlwZTogXCJcIixcclxuXHJcblx0XHRcdGRhdGV0aW1lSWQ6IFwiXCIsXHJcblxyXG5cdFx0XHQvLyBjbGlwIGlkIHN0cmluZ1xyXG5cdFx0XHRjbGlwOiB7XHJcblx0XHRcdFx0aWQ6IFwiXCIsXHJcblx0XHRcdFx0aWRYQXhpczogXCJcIixcclxuXHRcdFx0XHRpZFlBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdGlkR3JpZDogXCJcIixcclxuXHRcdFx0XHRpZFN1YmNoYXJ0OiBcIlwiLCAvLyBjbGlwSWRGb3JTdWJjaGFydFxyXG5cdFx0XHRcdHBhdGg6IFwiXCIsXHJcblx0XHRcdFx0cGF0aFhBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhZQXhpczogXCJcIixcclxuXHRcdFx0XHRwYXRoR3JpZDogXCJcIlxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gc3RhdHVzXHJcblx0XHRcdGRyYWdTdGFydDogbnVsbCxcclxuXHRcdFx0ZHJhZ2dpbmc6IGZhbHNlLFxyXG5cdFx0XHRmbG93aW5nOiBmYWxzZSxcclxuXHRcdFx0Y2FuY2VsQ2xpY2s6IGZhbHNlLFxyXG5cdFx0XHRtb3VzZW92ZXI6IGZhbHNlLFxyXG5cdFx0XHRyZW5kZXJlZDogZmFsc2UsXHJcblx0XHRcdHRyYW5zaXRpbmc6IGZhbHNlLFxyXG5cdFx0XHRoYXNOZWdhdGl2ZVZhbHVlOiBmYWxzZSxcclxuXHRcdFx0aGFzUG9zaXRpdmVWYWx1ZTogdHJ1ZSxcclxuXHJcblx0XHRcdG9yZ0FyZWFPcGFjaXR5OiBcIjAuMlwiLFxyXG5cclxuXHRcdFx0Ly8gSUQgc3RyaW5nc1xyXG5cdFx0XHRoaWRkZW5UYXJnZXRJZHM6IFtdLFxyXG5cdFx0XHRoaWRkZW5MZWdlbmRJZHM6IFtdLFxyXG5cdFx0XHRmb2N1c2VkVGFyZ2V0SWRzOiBbXSxcclxuXHRcdFx0ZGVmb2N1c2VkVGFyZ2V0SWRzOiBbXSxcclxuXHJcblx0XHRcdC8vIHZhbHVlIGZvciBBcmNcclxuXHRcdFx0cmFkaXVzOiAwLFxyXG5cdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0aW5uZXJSYWRpdXNSYXRpbzogMCxcclxuXHRcdFx0Z2F1Z2VBcmNXaWR0aDogMCxcclxuXHRcdFx0cmFkaXVzRXhwYW5kZWQ6IDAsXHJcblxyXG5cdFx0XHQvLyB4Z3JpZCBhdHRyaWJ1dGVcclxuXHRcdFx0eGdyaWRBdHRyOiB7XHJcblx0XHRcdFx0eDE6IG51bGwsXHJcblx0XHRcdFx0eDI6IG51bGwsXHJcblx0XHRcdFx0eTE6IG51bGwsXHJcblx0XHRcdFx0eTI6IG51bGxcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge0NoYXJ0VHlwZXN9IGZyb20gXCIuLi8uLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIGRhdGEgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgZGF0YSBpZCB2YWx1ZVxyXG4gICAgICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgKiAgICAgICAvLyB3aGVuIGlkIGlzICdkYXRhMScsIGNvbnZlcnRzIHRvIGJlICdkYXRhMidcclxuICAgICAqICAgICAgIC8vICdkYXRhMicgc2hvdWxkIGJlIGdpdmVuIGFzIHRoZSBpbml0aWFsIGRhdGEgdmFsdWVcclxuICAgICAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gXCJkYXRhMlwiO1xyXG4gICAgICogICAgICAgfSBlbHNlIHtcclxuICAgICAqICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9pZENvbnZlcnRlcjogaWQgPT4gaWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY3VzdG9tIGRhdGEgbmFtZS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRuYW1lc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU5hbWUpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBuYW1lczoge1xyXG4gICAgICogICAgIGRhdGExOiBcIkRhdGEgTmFtZSAxXCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IFwiRGF0YSBOYW1lIDJcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfbmFtZXM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY3VzdG9tIGRhdGEgY2xhc3MuPGJyPjxicj5cclxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgZyBmb3IgdGhlIGRhdGEgaGFzIGFuIGFkZGl0aW9uYWwgY2xhc3MgdGhhdCBoYXMgdGhlIHByZWZpeCAnYmItdGFyZ2V0LScgKGVnLiBiYi10YXJnZXQtYWRkaXRpb25hbC1kYXRhMS1jbGFzcykuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkY2xhc3Nlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgY2xhc3Nlczoge1xyXG4gICAgICogICAgIGRhdGExOiBcImFkZGl0aW9uYWwtZGF0YTEtY2xhc3NcIixcclxuICAgICAqICAgICBkYXRhMjogXCJhZGRpdGlvbmFsLWRhdGEyLWNsYXNzXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2NsYXNzZXM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2hhcnQgdHlwZSBhdCBvbmNlLjxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSB0eXBlIHdpbGwgYmUgYXBwbGllZCB0byBldmVyeSBkYXRhLiBUaGlzIHNldHRpbmcgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGRhdGEudHlwZXMuPGJyPjxicj5cclxuICAgICAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogLSBhcmVhXHJcbiAgICAgKiAtIGFyZWEtbGluZS1yYW5nZVxyXG4gICAgICogLSBhcmVhLXNwbGluZVxyXG4gICAgICogLSBhcmVhLXNwbGluZS1yYW5nZVxyXG4gICAgICogLSBhcmVhLXN0ZXBcclxuICAgICAqIC0gYmFyXHJcbiAgICAgKiAtIGJ1YmJsZVxyXG4gICAgICogLSBkb251dFxyXG4gICAgICogLSBnYXVnZVxyXG4gICAgICogLSBsaW5lXHJcbiAgICAgKiAtIHBpZVxyXG4gICAgICogLSByYWRhclxyXG4gICAgICogLSBzY2F0dGVyXHJcbiAgICAgKiAtIHNwbGluZVxyXG4gICAgICogLSBzdGVwXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkdHlwZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBsaW5lXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgdHlwZTogXCJiYXJcIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3R5cGU6IDxDaGFydFR5cGVzfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNoYXJ0IHR5cGUgZm9yIGVhY2ggZGF0YS48YnI+XHJcbiAgICAgKiBUaGlzIHNldHRpbmcgb3ZlcndyaXRlcyBkYXRhLnR5cGUgc2V0dGluZy5cclxuICAgICAqIC0gKipOT1RFOioqIGByYWRhcmAgdHlwZSBjYW4ndCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHR5cGVzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHR5cGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICB0eXBlczoge1xyXG4gICAgICogICAgIGRhdGExOiBcImJhclwiLFxyXG4gICAgICogICAgIGRhdGEyOiBcInNwbGluZVwiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV90eXBlczogPHtba2V5OiBzdHJpbmddOiBDaGFydFR5cGVzfT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhpcyBvcHRpb24gY2hhbmdlcyB0aGUgb3JkZXIgb2Ygc3RhY2tpbmcgZGF0YSBhbmQgcGllY2VzIG9mIHBpZS9kb251dC5cclxuICAgICAqICAtIElmIGBudWxsYCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgdGhlIG9yZGVyIHRoZSBkYXRhIGxvYWRlZC5cclxuICAgICAqICAtIElmIGZ1bmN0aW9uIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB1c2VkIGFzIFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKTxicj48YnI+XHJcbiAgICAgKlxyXG4gICAgICogICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGxvYWQgb3JkZXJcclxuICAgICAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvblxyXG4gICAgICogQG5hbWUgZGF0YeKApG9yZGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxyXG4gICAgICogQGRlZmF1bHQgZGVzY1xyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU9yZGVyKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgLy8gaW4gZGVzY2VuZGluZyBvcmRlciAoZGVmYXVsdClcclxuICAgICAqICAgb3JkZXI6IFwiZGVzY1wiXHJcbiAgICAgKlxyXG4gICAgICogICAvLyBpbiBhc2NlbmRpbmcgb3JkZXJcclxuICAgICAqICAgb3JkZXI6IFwiYXNjXCJcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIGtlZXBzIGRhdGEgaW5wdXQgb3JkZXJcclxuICAgICAqICAgb3JkZXI6IG51bGxcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxyXG4gICAgICogICBvcmRlcjogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICogICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XHJcbiAgICAgKiAgICAgICB7XHJcbiAgICAgKiAgICAgICAgICBpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcbiAgICAgKiAgICAgICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9LFxyXG4gICAgICogICAgICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICAgICAgXVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb3JkZXI6IDxcImRlc2NcInxcImFzY1wifEZ1bmN0aW9ufG51bGw+IFwiZGVzY1wiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNvbG9yIGNvbnZlcnRlciBmdW5jdGlvbi48YnI+PGJyPlxyXG4gICAgICogVGhpcyBvcHRpb24gc2hvdWxkIGEgZnVuY3Rpb24gYW5kIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgY29sb3IgKGUuZy4gJyNmZjAwMDAnKSBhbmQgZCB0aGF0IGhhcyBkYXRhIHBhcmFtZXRlcnMgbGlrZSBpZCwgdmFsdWUsIGluZGV4LCBldGMuIEFuZCBpdCBtdXN0IHJldHVybiBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgY29sb3IgKGUuZy4gJyMwMGZmMDAnKS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRjb2xvclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUNvbG9yKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgY29sb3I6IGZ1bmN0aW9uKGNvbG9yLCBkKSB7IC4uLiB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfY29sb3I6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjb2xvciBmb3IgZWFjaCBkYXRhLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGNvbG9yc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgY29sb3JzOiB7XHJcbiAgICAgKiAgICAgZGF0YTE6IFwiI2ZmMDAwMFwiLFxyXG4gICAgICogICAgIGRhdGEyOiBmdW5jdGlvbihkKSB7XHJcbiAgICAgKiAgICAgICAgcmV0dXJuIFwiIzAwMFwiO1xyXG4gICAgICogICAgIH1cclxuICAgICAqICAgICAuLi5cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2NvbG9yczogPHtba2V5OiBzdHJpbmddOiBzdHJpbmd8KCgpID0+IHN0cmluZyk7fT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlIGVhY2ggZGF0YSB3aGVuIHRoZSBjaGFydCBhcHBlYXJzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0cnVlIHNwZWNpZmllZCwgYWxsIG9mIGRhdGEgd2lsbCBiZSBoaWRkZW4uIElmIG11bHRpcGxlIGlkcyBzcGVjaWZpZWQgYXMgYW4gYXJyYXksIHRob3NlIHdpbGwgYmUgaGlkZGVuLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGhpZGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbnxBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAvLyBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlblxyXG4gICAgICogICBoaWRlOiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogICAvLyBzcGVjaWZpZWQgZGF0YSB3aWxsIGJlIGhpZGRlblxyXG4gICAgICogICBoaWRlOiBbXCJkYXRhMVwiLCAuLi5dXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfaGlkZTogPHN0cmluZ1tdfGJvb2xlYW4+IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsdGVyIHZhbHVlcyB0byBiZSBzaG93blxyXG4gICAgICogVGhlIGRhdGEgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIHJldHVybmVkIGJ5IGAuZGF0YSgpYC5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkZmlsdGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAvLyBmaWx0ZXIgZm9yIGlkIHZhbHVlXHJcbiAgICAgKiAgIGZpbHRlcjogZnVuY3Rpb24odikge1xyXG4gICAgICogICAgICAvLyB2OiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IFtcclxuICAgICAqICAgICAgLy8gICAgICB7eDogMCwgdmFsdWU6IDEzMCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDB9LCAuLi5dXHJcbiAgICAgKiAgICAgIC8vICAgIH0sIC4uLl1cclxuICAgICAqICAgICAgcmV0dXJuIHYuaWQgIT09IFwiZGF0YTFcIjtcclxuICAgICAqICAgfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2ZpbHRlcjogPCgoKSA9PiBib29sZWFuKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBjbGljayBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuICAgICAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBlYWNoIGRhdGEgcG9pbnQgY2xpY2tlZCBhbmQgd2lsbCByZWNlaXZlIGBkYCBhbmQgZWxlbWVudCBhcyB0aGUgYXJndW1lbnRzLlxyXG4gICAgICogLSBgZGAgaXMgdGhlIGRhdGEgY2xpY2tlZCBhbmQgZWxlbWVudCBpcyB0aGUgZWxlbWVudCBjbGlja2VkLlxyXG4gICAgICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcbiAgICAgKiAtIEluIHRoaXMgY2FsbGJhY2ssIGB0aGlzYCB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25jbGlja1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgb25jbGljazogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcbiAgICAgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XHJcbiAgICAgKiAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29uY2xpY2s6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvbnRvIGVhY2ggZGF0YSBwb2ludCBhbmQgd2lsbCByZWNlaXZlIGBkYCBhbmQgYGVsZW1lbnRgIGFzIHRoZSBhcmd1bWVudC5cclxuICAgICAqIC0gYGRgIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvbnRvLlxyXG4gICAgICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcbiAgICAgKiAtIEluIHRoaXMgY2FsbGJhY2ssIGB0aGlzYCB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25vdmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNH1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25vdmVyOiAoKSA9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBtb3VzZS90b3VjaCBvdXQgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvdXQgZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFzIHRoZSBhcmd1bWVudC5cclxuICAgICAqIC0gYGRgIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvdXQuXHJcbiAgICAgKiAtIGBlbGVtZW50YCBpcyB0aGUgY3VycmVudCBpbnRlcmFjdGluZyBzdmcgZWxlbWVudC5cclxuICAgICAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbm91dFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgb25vdXQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNH1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25vdXQ6ICgpID0+IHt9LFxyXG5cclxuICAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBtaW5pbXVtIGRhdGFcclxuICAgICAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxyXG4gICAgICogQG5hbWUgZGF0YeKApG9ubWluXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Pbk1pbk1heENhbGxiYWNrKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBvbm1pbjogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICogICAgLy8gZGF0YSAtIGV4KSBbe3g6IDMsIHZhbHVlOiA0MDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAzfSwgLi4uIF1cclxuICAgICAqICAgIC4uLlxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vbm1pbjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1heGltdW0gZGF0YVxyXG4gICAgICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25tYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIG9ubWF4OiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxyXG4gICAgICogICAgLi4uXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29ubWF4OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGEgQ1NWIG9yIEpTT04gZmlsZSBmcm9tIGEgVVJMLiBOT1RFIHRoYXQgdGhpcyB3aWxsIG5vdCB3b3JrIGlmIGxvYWRpbmcgdmlhIHRoZSBcImZpbGU6Ly9cIiBwcm90b2NvbCBhcyB0aGUgbW9zdCBicm93c2VycyB3aWxsIGJsb2NrIFhNTEhUVFBSZXF1ZXN0cy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR1cmxcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Mb2FkRGF0YSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCJcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV91cmw6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBYSFIgaGVhZGVyIHZhbHVlXHJcbiAgICAgKiAtICoqTk9URToqKiBTaG91bGQgYmUgdXNlZCB3aXRoIGBkYXRhLnVybGAgb3B0aW9uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkaGVhZGVyc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3NldFJlcXVlc3RIZWFkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCIsXHJcbiAgICAgKiAgICAgaGVhZGVyczoge1xyXG4gICAgICogICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC94bWxcIixcclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfaGVhZGVyczogPG9iamVjdHx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGEgSlNPTiBvYmplY3QgZm9yIGRhdGEuIFNlZSBhbHNvIGRhdGEua2V5cy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRqc29uXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtkYXRh4oCka2V5c10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cylcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkpTT05EYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBqc29uOiBbXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogMjAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNDAwfSxcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTQuY29tXCIsIHVwbG9hZDogNDAwLCBkb3dubG9hZDogMTAwLCB0b3RhbDogNTAwfVxyXG4gICAgICogICAgIF0sXHJcbiAgICAgKiAgICAga2V5czoge1xyXG4gICAgICogICAgICAgLy8geDogXCJuYW1lXCIsIC8vIGl0J3MgcG9zc2libGUgdG8gc3BlY2lmeSAneCcgd2hlbiBjYXRlZ29yeSBheGlzXHJcbiAgICAgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfanNvbjogPG9iamVjdFtdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBkYXRhIGZyb20gYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5LCB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGRhdGEgbmFtZXMsIHRoZSBmb2xsb3dpbmcgY29udGFpbmluZyByZWxhdGVkIGRhdGEgaW4gdGhhdCBvcmRlci5cclxuICAgICAqIEBuYW1lIGRhdGHigKRyb3dzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Sb3dPcmllbnRlZERhdGEpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICByb3dzOiBbXHJcbiAgICAgKiAgICAgW1wiQVwiLCBcIkJcIiwgXCJDXCJdLFxyXG4gICAgICogICAgIFs5MCwgMTIwLCAzMDBdLFxyXG4gICAgICogICAgIFs0MCwgMTYwLCAyNDBdLFxyXG4gICAgICogICAgIFs1MCwgMjAwLCAyOTBdLFxyXG4gICAgICogICAgIFsxMjAsIDE2MCwgMjMwXSxcclxuICAgICAqICAgICBbODAsIDEzMCwgMzAwXSxcclxuICAgICAqICAgICBbOTAsIDIyMCwgMzIwXVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFtoaWdoLCBtaWQsIGxvd10gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICdoaWdoJywgJ21pZCcgYW5kICdsb3cnIGtleSB2YWx1ZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICByb3dzOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXHJcbiAgICAgKiAgICAgIFtcclxuICAgICAqICAgICAgICAvLyBvciB7aGlnaDoxNTAsIG1pZDogMTQwLCBsb3c6IDExMH0sIDEyMFxyXG4gICAgICogICAgICAgIFsxNTAsIDE0MCwgMTEwXSwgMTIwXHJcbiAgICAgKiAgICAgIF0sXHJcbiAgICAgKiAgICAgIFtbMTU1LCAxMzAsIDExNV0sIDU1XSxcclxuICAgICAqICAgICAgW1sxNjAsIDEzNSwgMTIwXSwgNjBdXHJcbiAgICAgKiAgIF0sXHJcbiAgICAgKiAgIHR5cGVzOiB7XHJcbiAgICAgKiAgICAgICBkYXRhMTogXCJhcmVhLWxpbmUtcmFuZ2VcIixcclxuICAgICAqICAgICAgIGRhdGEyOiBcImxpbmVcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZm9yICdidWJibGUnIHR5cGUsIGRhdGEgY2FuIGNvbnRhaW4gZGltZW5zaW9uIHZhbHVlOlxyXG4gICAgICogLy8gLSBhbiBhcnJheSBvZiBbeSwgel0gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxyXG4gICAgICogLy8gJ3knIGlzIGZvciB5IGF4aXMgY29vcmRpbmF0aW9uIGFuZCAneicgaXMgdGhlIGJ1YmJsZSByYWRpdXMgdmFsdWVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgcm93czogW1xyXG4gICAgICogICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdLFxyXG4gICAgICogICAgICBbXHJcbiAgICAgKiAgICAgICAgLy8gb3Ige3k6MTAsIHo6IDE0MH0sIDEyMFxyXG4gICAgICogICAgICAgIFsxMCwgMTQwXSwgMTIwXHJcbiAgICAgKiAgICAgIF0sXHJcbiAgICAgKiAgICAgIFtbMTAwLCAzMF0sIDU1XSxcclxuICAgICAqICAgICAgW1s1MCwgMTAwXSwgNjBdXHJcbiAgICAgKiAgIF0sXHJcbiAgICAgKiAgIHR5cGVzOiB7XHJcbiAgICAgKiAgICAgICBkYXRhMTogXCJidWJibGVcIixcclxuICAgICAqICAgICAgIGRhdGEyOiBcImxpbmVcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfcm93czogPChzdHJpbmd8bnVtYmVyKVtdW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggZWFjaCBlbGVtZW50IGNvbnRhaW5pbmcgYW4gYXJyYXkgY29uc2lzdGluZyBvZiBhIGRhdHVtIG5hbWUgYW5kIGFzc29jaWF0ZWQgZGF0YSB2YWx1ZXMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkY29sdW1uc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ29sdW1uT3JpZW50ZWREYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgY29sdW1uczogW1xyXG4gICAgICogICAgICBbXCJkYXRhMVwiLCAzMCwgMjAsIDUwLCA0MCwgNjAsIDUwXSxcclxuICAgICAqICAgICAgW1wiZGF0YTJcIiwgMjAwLCAxMzAsIDkwLCAyNDAsIDEzMCwgMjIwXSxcclxuICAgICAqICAgICAgW1wiZGF0YTNcIiwgMzAwLCAyMDAsIDE2MCwgNDAwLCAyNTAsIDI1MF1cclxuICAgICAqICAgXVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxyXG4gICAgICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG4gICAgICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAnaGlnaCcsICdtaWQnIGFuZCAnbG93JyBrZXkgdmFsdWVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgY29sdW1uczogW1xyXG4gICAgICogICAgICBbXCJkYXRhMVwiLFxyXG4gICAgICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9XHJcbiAgICAgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sXHJcbiAgICAgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF1cclxuICAgICAqICAgICAgXVxyXG4gICAgICogICBdLFxyXG4gICAgICogICB0eXBlOiBcImFyZWEtbGluZS1yYW5nZVwiXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZm9yICdidWJibGUnIHR5cGUsIGRhdGEgY2FuIGNvbnRhaW4gZGltZW5zaW9uIHZhbHVlOlxyXG4gICAgICogLy8gLSBhbiBhcnJheSBvZiBbeSwgel0gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxyXG4gICAgICogLy8gJ3knIGlzIGZvciB5IGF4aXMgY29vcmRpbmF0aW9uIGFuZCAneicgaXMgdGhlIGJ1YmJsZSByYWRpdXMgdmFsdWVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgY29sdW1uczogW1xyXG4gICAgICogICAgICBbXCJkYXRhMVwiLFxyXG4gICAgICogICAgICAgICAgWzEwLCAxNDBdLCAgLy8gb3Ige3k6MTAsIHo6IDE0MH1cclxuICAgICAqICAgICAgICAgIFsxMDAsIDMwXSxcclxuICAgICAqICAgICAgICAgIFs1MCwgMTAwXVxyXG4gICAgICogICAgICBdXHJcbiAgICAgKiAgIF0sXHJcbiAgICAgKiAgIHR5cGU6IFwiYnViYmxlXCJcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9jb2x1bW5zOiA8KHN0cmluZ3xudW1iZXIpW11bXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgaWYgbG9hZGluZyBKU09OIHZpYSBkYXRhLnVybC5cclxuICAgICAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgIC0ganNvblxyXG4gICAgICogICAtIGNzdlxyXG4gICAgICogICAtIHRzdlxyXG4gICAgICogQG5hbWUgZGF0YeKApG1pbWVUeXBlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IGNzdlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBtaW1lVHlwZTogXCJqc29uXCJcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9taW1lVHlwZTogPFwiY3N2XCJ8XCJqc29uXCJ8XCJ0c3ZcIj4gXCJjc3ZcIixcclxuXHJcbiAgICAvKipcclxuICAgICAqIENob29zZSB3aGljaCBKU09OIG9iamVjdCBrZXlzIGNvcnJlc3BvbmQgdG8gZGVzaXJlZCBkYXRhLlxyXG4gICAgICogLSAqKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCka2V5c1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAganNvbjogW1xyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTIuY29tXCIsIHVwbG9hZDogMTAwLCBkb3dubG9hZDogMzAwLCB0b3RhbDogNDAwfSxcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cclxuICAgICAqICAgICBdLFxyXG4gICAgICogICAgIGtleXM6IHtcclxuICAgICAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xyXG4gICAgICogICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2tleXM6IDx7eD86IHN0cmluZzsgdmFsdWU/OiBzdHJpbmdbXX18dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBsYWJlbCB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGVyZSdzIG5vIGRhdGEgdG8gc2hvdy5cclxuICAgICAqIC0gZXguIFRvZ2dsaW5nIGFsbCB2aXNpYmxlIGRhdGEgdG8gbm90IGJlIHNob3duLCB1bmxvYWRpbmcgYWxsIGN1cnJlbnQgZGF0YSwgZXRjLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGVtcHR54oCkbGFiZWzigKR0ZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IFwiXCJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIGVtcHR5OiB7XHJcbiAgICAgKiAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgIHRleHQ6IFwiTm8gRGF0YVwiXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfZW1wdHlfbGFiZWxfdGV4dDogXCJcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBjb2xvciBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY29sb3Igb2YgdGhlIGRhdGEgdmFsdWVzXHJcbiAgICAgKiBAbmFtZSBjb2xvclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IFtjb2xvci5vbm92ZXJdIFNldCB0aGUgY29sb3IgdmFsdWUgZm9yIGVhY2ggZGF0YSBwb2ludCB3aGVuIG1vdXNlL3RvdWNoIG9ub3ZlciBldmVudCBvY2N1cnMuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBbY29sb3IucGF0dGVybj1bXV0gY3VzdG9tIGNvbG9yIHBhdHRlcm5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjb2xvci50aWxlc10gaWYgZGVmaW5lZCwgYWxsb3dzIHVzZSBzdmcncyBwYXR0ZXJucyB0byBmaWxsIGRhdGEgYXJlYS4gSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBbU1ZHUGF0dGVybkVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdQYXR0ZXJuRWxlbWVudCkuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogVGhlIHBhdHRlcm4gZWxlbWVudCdzIGlkIHdpbGwgYmUgZGVmaW5lZCBhcyBgYmItY29sb3JpemUtcGF0dGVybi0kQ09MT1ItVkFMVUVgLjxicj5cclxuICAgICAqICAgIGV4LiBXaGVuIGNvbG9yIHBhdHRlcm4gdmFsdWUgaXMgYFsncmVkJywgJyNmZmYnXWAgYW5kIGRlZmluZWQgMiBwYXR0ZXJucyx0aGVuIGlkcyBmb3IgcGF0dGVybiBlbGVtZW50cyBhcmU6PGJyPlxyXG4gICAgICogICAgLSBgYmItY29sb3JpemUtcGF0dGVybi1yZWRgXHJcbiAgICAgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLWZmZmBcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbY29sb3IudGhyZXNob2xkXSBjb2xvciB0aHJlc2hvbGQgZm9yIGdhdWdlIGFuZCB0b29sdGlwIGNvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbG9yLnRocmVzaG9sZC51bml0XSBJZiBzZXQgdG8gYHZhbHVlYCwgdGhlIHRocmVzaG9sZCB3aWxsIGJlIGJhc2VkIG9uIHRoZSBkYXRhIHZhbHVlLiBPdGhlcndpc2UgaXQnbGwgYmUgYmFzZWQgb24gZXF1YXRpb24gb2YgdGhlIGB0aHJlc2hvbGQubWF4YCBvcHRpb24gdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBbY29sb3IudGhyZXNob2xkLnZhbHVlc10gVGhyZXNob2xkIHZhbHVlcyBmb3IgZWFjaCBzdGVwc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb2xvci50aHJlc2hvbGQubWF4PTEwMF0gVGhlIGJhc2UgdmFsdWUgdG8gZGV0ZXJtaW5lIHRocmVzaG9sZCBzdGVwIHZhbHVlIGNvbmRpdGlvbi4gV2hlbiB0aGUgZ2l2ZW4gdmFsdWUgaXMgMTUgYW5kIG1heCAxMCwgdGhlbiB0aGUgdmFsdWUgZm9yIHRocmVzaG9sZCBpcyBgMTUqMTAwLzEwYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgY29sb3I6IHtcclxuICAgICAqICAgICAgcGF0dGVybjogW1wiIzFmNzdiNFwiLCBcIiNhZWM3ZThcIiwgLi4uXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIFNldCBjb2xvcnMnIHBhdHRlcm5zXHJcbiAgICAgKiAgICAgIC8vIGl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgU1ZHUGF0dGVybkVsZW1lbnRcclxuICAgICAqICAgICAgdGlsZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgICB2YXIgcGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0dGVyblwiKTtcclxuICAgICAqICAgICAgICAgdmFyIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XHJcbiAgICAgKiAgICAgICAgIHZhciBjaXJjbGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIik7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xyXG4gICAgICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMzJcIik7XHJcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMzJcIik7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBnLnN0eWxlLmZpbGwgPSBcIiMwMDBcIjtcclxuICAgICAqICAgICAgICAgZy5zdHlsZS5vcGFjaXR5ID0gXCIwLjJcIjtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3hcIiwgXCIzXCIpO1xyXG4gICAgICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN5XCIsIFwiM1wiKTtcclxuICAgICAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJyXCIsIFwiM1wiKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGcuYXBwZW5kQ2hpbGQoY2lyY2xlMSk7XHJcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoZyk7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZm9yIHRocmVzaG9sZCB1c2FnZSwgcGF0dGVybiB2YWx1ZXMgc2hvdWxkIGJlIHNldCBmb3IgZWFjaCBzdGVwc1xyXG4gICAgICogICAgICBwYXR0ZXJuOiBbXCJncmV5XCIsIFwiZ3JlZW5cIiwgXCJ5ZWxsb3dcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl0sXHJcbiAgICAgKiAgICAgIHRocmVzaG9sZDoge1xyXG4gICAgICogICAgICAgICAgdW5pdDogXCJ2YWx1ZVwiLFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHdoZW4gdmFsdWUgaXMgMjAgPT4gJ2dyZWVuJywgdmFsdWUgaXMgNDAgPT4gJ29yYW5nZScgd2lsbCBiZSBzZXQuXHJcbiAgICAgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwLCA0MCwgNTBdLFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHRoZSBlcXVhdGlvbiBmb3IgbWF4OlxyXG4gICAgICogICAgICAgICAgLy8gLSB1bml0ID09ICd2YWx1ZSc6IG1heCA9PiAzMFxyXG4gICAgICogICAgICAgICAgLy8gLSB1bml0ICE9ICd2YWx1ZSc6IG1heCA9PiB2YWx1ZSoxMDAvMzBcclxuICAgICAqICAgICAgICAgIG1heDogMzBcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNldCBhbGwgZGF0YSB0byAncmVkJ1xyXG4gICAgICogICAgICBvbm92ZXI6IFwicmVkXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBzZXQgZGlmZmVyZW50IGNvbG9yIGZvciBkYXRhXHJcbiAgICAgKiAgICAgIG9ub3Zlcjoge1xyXG4gICAgICogICAgICAgICAgZGF0YTE6IFwicmVkXCIsXHJcbiAgICAgKiAgICAgICAgICBkYXRhMjogXCJ5ZWxsb3dcIlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gd2lsbCBwYXNzIGRhdGEgb2JqZWN0IHRvIHRoZSBjYWxsYmFja1xyXG4gICAgICogICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICAgICAgIHJldHVybiBkLmlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJncmVlblwiO1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBjb2xvcl9wYXR0ZXJuOiA8c3RyaW5nW10+IFtdLFxyXG4gICAgY29sb3JfdGlsZXM6IDwoKCkgPT4gW10pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgY29sb3JfdGhyZXNob2xkOiA8e3VuaXQ/OiBzdHJpbmc7IHZhbHVlcz86IG51bWJlcltdOyBtYXg6IG51bWJlcjt9PiB7fSxcclxuICAgIGNvbG9yX29ub3ZlcjogPHN0cmluZ3xvYmplY3R8dW5kZWZpbmVkPiB1bmRlZmluZWRcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogaW50ZXJhY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJhY3Rpb24gb3B0aW9uc1xyXG4gICAgICogQG5hbWUgaW50ZXJhY3Rpb25cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uZW5hYmxlZD10cnVlXSBJbmRpY2F0ZSBpZiB0aGUgY2hhcnQgc2hvdWxkIGhhdmUgaW50ZXJhY3Rpb25zLjxicj5cclxuICAgICAqICAgICBJZiBgZmFsc2VgIGlzIHNldCwgYWxsIG9mIGludGVyYWN0aW9ucyAoc2hvd2luZy9oaWRpbmcgdG9vbHRpcCwgc2VsZWN0aW9uLCBtb3VzZSBldmVudHMsIGV0Yykgd2lsbCBiZSBkaXNhYmxlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmJyaWdodGVuPXRydWVdIE1ha2UgYnJpZ2h0ZXIgZm9yIHRoZSBzZWxlY3RlZCBhcmVhIChleC4gJ3BpZScgdHlwZSBkYXRhIHNlbGVjdGVkIGFyZWEpXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUubW91c2U9dHJ1ZV0gZW5hYmxlIG9yIGRpc2FibGUgbW91c2UgaW50ZXJhY3Rpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaD10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSAgdG91Y2ggaW50ZXJhY3Rpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQ9ZmFsc2VdIGVuYWJsZSBvciBkaXNhYmxlIHRvIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQgb24gdG91Y2hzdGFydCAmIHRvdWNobW92ZSBldmVudC4gSXQncyB1c3VhbGx5IHVzZWQgdG8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmcuXHJcbiAgICAgKiBAc2VlIFtEZW1vOiB0b3VjaC5wcmV2ZW50RGVmYXVsdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlByZXZlbnRTY3JvbGxPblRvdWNoKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGludGVyYWN0aW9uOiB7XHJcbiAgICAgKiAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAqICAgIGJyaWdodGVuOiBmYWxzZSxcclxuICAgICAqICAgIGlucHV0VHlwZToge1xyXG4gICAgICogICAgICAgIG1vdXNlOiB0cnVlLFxyXG4gICAgICogICAgICAgIHRvdWNoOiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqICAgICAgICAvLyBvciBkZWNsYXJlIHByZXZlbnREZWZhdWx0IGV4cGxpY2l0bHkuXHJcbiAgICAgKiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRvdWNoIGlucHV0VHlwZSBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcclxuICAgICAqICAgICAgICB0b3VjaDoge1xyXG4gICAgICogICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgLy8gb3IgdGhyZXNob2xkIHBpeGVsIHZhbHVlIChwaXhlbCBtb3ZlZCBmcm9tIHRvdWNoc3RhcnQgdG8gdG91Y2htb3ZlKVxyXG4gICAgICogICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogNVxyXG4gICAgICogICAgICAgIH1cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgaW50ZXJhY3Rpb25fZW5hYmxlZDogdHJ1ZSxcclxuICAgIGludGVyYWN0aW9uX2JyaWdodGVuOiB0cnVlLFxyXG4gICAgaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlOiB0cnVlLFxyXG4gICAgaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoOiA8Ym9vbGVhbnx7cHJldmVudERlZmF1bHQ/OiBib29sZWFufG51bWJlcn0+IHt9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGxlZ2VuZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWdlbmQgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgbGVnZW5kXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZWdlbmQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuaGlkZT1mYWxzZV0gSGlkZSBsZWdlbmRcclxuICAgICAqICBJZiB0cnVlIGdpdmVuLCBhbGwgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLiBJZiBzdHJpbmcgb3IgYXJyYXkgZ2l2ZW4sIG9ubHkgdGhlIGxlZ2VuZCB0aGF0IGhhcyB0aGUgaWQgd2lsbCBiZSBoaWRkZW4uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW2xlZ2VuZC5jb250ZW50cy5iaW5kdG89dW5kZWZpbmVkXSBTZXQgQ1NTIHNlbGVjdG9yIG9yIGVsZW1lbnQgcmVmZXJlbmNlIHRvIGJpbmQgbGVnZW5kIGl0ZW1zLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8RnVuY3Rpb259IFtsZWdlbmQuY29udGVudHMudGVtcGxhdGU9dW5kZWZpbmVkXSBTZXQgaXRlbSdzIHRlbXBsYXRlLjxicj5cclxuICAgICAqICAtIElmIHNldCBgc3RyaW5nYCB2YWx1ZSwgd2l0aGluIHRlbXBsYXRlIHRoZSAnY29sb3InIGFuZCAndGl0bGUnIGNhbiBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XHJcbiAgICAgKiAgICAtIHs9Q09MT1J9OiBkYXRhIGNvbG9yIHZhbHVlXHJcbiAgICAgKiAgICAtIHs9VElUTEV9OiBkYXRhIHRpdGxlIHZhbHVlXHJcbiAgICAgKiAgLSBJZiBzZXQgYGZ1bmN0aW9uYCB2YWx1ZSwgd2lsbCBwYXNzIGZvbGxvd2luZyBhcmd1bWVudHMgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uOlxyXG4gICAgICogICAtIHRpdGxlIHtTdHJpbmd9OiBkYXRhJ3MgaWQgdmFsdWVcclxuICAgICAqICAgLSBjb2xvciB7U3RyaW5nfTogY29sb3Igc3RyaW5nXHJcbiAgICAgKiAgIC0gZGF0YSB7QXJyYXl9OiBkYXRhIGFycmF5XHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2xlZ2VuZC5wb3NpdGlvbj1ib3R0b21dIENoYW5nZSB0aGUgcG9zaXRpb24gb2YgbGVnZW5kLjxicj5cclxuICAgICAqICBBdmFpbGFibGUgdmFsdWVzIGFyZTogYGJvdHRvbWAsIGByaWdodGAgYW5kIGBpbnNldGAgYXJlIHN1cHBvcnRlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbGVnZW5kLmluc2V0PXthbmNob3I6ICd0b3AtbGVmdCcseDogMTAseTogMCxzdGVwOiB1bmRlZmluZWR9XSBDaGFuZ2UgaW5zZXQgbGVnZW5kIGF0dHJpYnV0ZXMuPGJyPlxyXG4gICAgICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IHRoYXQgaGFzIHRoZSBrZXlzIGBhbmNob3JgLCBgeGAsIGB5YCBhbmQgYHN0ZXBgLlxyXG4gICAgICogIC0gKiphbmNob3IqKiBkZWNpZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kOlxyXG4gICAgICogICAtIHRvcC1sZWZ0XHJcbiAgICAgKiAgIC0gdG9wLXJpZ2h0XHJcbiAgICAgKiAgIC0gYm90dG9tLWxlZnRcclxuICAgICAqICAgLSBib3R0b20tcmlnaHRcclxuICAgICAqICAtICoqeCoqIGFuZCAqKnkqKjpcclxuICAgICAqICAgLSBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgYmFzZWQgb24gdGhlIGFuY2hvci5cclxuICAgICAqICAtICoqc3RlcCoqOlxyXG4gICAgICogICAtIGRlZmluZXMgdGhlIG1heCBzdGVwIHRoZSBsZWdlbmQgaGFzIChlLmcuIElmIDIgc2V0IGFuZCBsZWdlbmQgaGFzIDMgbGVnZW5kIGl0ZW0sIHRoZSBsZWdlbmQgMiBjb2x1bW5zKS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5lcXVhbGx5PWZhbHNlXSBTZXQgdG8gYWxsIGl0ZW1zIGhhdmUgc2FtZSB3aWR0aCBzaXplLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnBhZGRpbmc9MF0gU2V0IHBhZGRpbmcgdmFsdWVcclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbmNsaWNrPXVuZGVmaW5lZF0gU2V0IGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9ub3Zlcj11bmRlZmluZWRdIFNldCBtb3VzZS90b3VjaCBvdmVyIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9ub3V0PXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG91dCBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS53aWR0aD0xMF0gU2V0IHdpZHRoIG9mIGl0ZW0gdGlsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xlZ2VuZC5pdGVtLnRpbGUuaGVpZ2h0PTEwXSBTZXQgaGVpZ2h0IG9mIGl0ZW0gdGlsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQudXNlUG9pbnQ9ZmFsc2VdIFdoZXRoZXIgdG8gdXNlIGN1c3RvbSBwb2ludHMgaW4gbGVnZW5kLlxyXG4gICAgICogQHNlZSBbRGVtbzogcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kUG9zaXRpb24pXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBjb250ZW50cy50ZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC5MZWdlbmRUZW1wbGF0ZTEpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiB1c2VQb2ludF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC51c2VQb2ludClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgbGVnZW5kOiB7XHJcbiAgICAgKiAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgIGhpZGU6IHRydWUsXHJcbiAgICAgKiAgICAgIC8vb3IgaGlkZTogXCJkYXRhMVwiXHJcbiAgICAgKiAgICAgIC8vb3IgaGlkZTogW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxyXG4gICAgICogICAgICBjb250ZW50czoge1xyXG4gICAgICogICAgICAgICAgYmluZHRvOiBcIiNsZWdlbmRcIiwgICAvLyA8dWwgaWQ9J2xlZ2VuZCc+PC91bD5cclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyB3aWxsIGJlIGFzOiA8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IzFmNzdiNCc+ZGF0YTE8L2xpPlxyXG4gICAgICogICAgICAgICAgdGVtcGxhdGU6IFwiPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOns9Q09MT1J9Jz57PVRJVExFfTwvbGk+XCJcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyBvciB1c2luZyBmdW5jdGlvblxyXG4gICAgICogICAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uKGlkLCBjb2xvciwgZGF0YSkge1xyXG4gICAgICogICAgICAgICAgICAgICAvLyBpZiB5b3Ugd2FudCBvbWl0IHNvbWUgbGVnZW5kLCByZXR1cm4gZmFsc3kgdmFsdWVcclxuICAgICAqICAgICAgICAgICAgICAgaWYgKGlkICE9PSBcImRhdGExXCIpIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6XCIrIGNvbG9yICtcIj5cIisgaWQgK1wiPC9saT5cIjtcclxuICAgICAqICAgICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBwb3NpdGlvbjogXCJib3R0b21cIiwgIC8vIGJvdHRvbSwgcmlnaHQsIGluc2V0XHJcbiAgICAgKiAgICAgIGluc2V0OiB7XHJcbiAgICAgKiAgICAgICAgICBhbmNob3I6IFwidG9wLXJpZ2h0XCIgIC8vIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1sZWZ0LCBib3R0b20tcmlnaHRcclxuICAgICAqICAgICAgICAgIHg6IDIwLFxyXG4gICAgICogICAgICAgICAgeTogMTAsXHJcbiAgICAgKiAgICAgICAgICBzdGVwOiAyXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIGVxdWFsbHk6IGZhbHNlLFxyXG4gICAgICogICAgICBwYWRkaW5nOiAxMCxcclxuICAgICAqICAgICAgaXRlbToge1xyXG4gICAgICogICAgICAgICAgb25jbGljazogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcbiAgICAgKiAgICAgICAgICBvbm92ZXI6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxyXG4gICAgICogICAgICAgICAgb25vdXQ6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHNldCB0aWxlJ3Mgc2l6ZVxyXG4gICAgICogICAgICAgICAgdGlsZToge1xyXG4gICAgICogICAgICAgICAgICAgIHdpZHRoOiAyMCxcclxuICAgICAqICAgICAgICAgICAgICBoZWlnaHQ6IDE1XHJcbiAgICAgKiAgICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHVzZVBvaW50OiB0cnVlXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBsZWdlbmRfc2hvdzogdHJ1ZSxcclxuICAgIGxlZ2VuZF9oaWRlOiBmYWxzZSxcclxuICAgIGxlZ2VuZF9jb250ZW50c19iaW5kdG86IDxzdHJpbmd8SFRNTEVsZW1lbnR8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBsZWdlbmRfY29udGVudHNfdGVtcGxhdGU6IDxzdHJpbmd8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPnVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9wb3NpdGlvbjogPFwiYm90dG9tXCJ8XCJyaWdodFwifFwiaW5zZXRcIj4gXCJib3R0b21cIixcclxuICAgIGxlZ2VuZF9pbnNldF9hbmNob3I6IDxcInRvcC1sZWZ0XCJ8XCJ0b3AtcmlnaHRcInxcImJvdHRvbS1sZWZ0XCJ8XCJib3R0b20tcmlnaHRcIj4gXCJ0b3AtbGVmdFwiLFxyXG4gICAgbGVnZW5kX2luc2V0X3g6IDEwLFxyXG4gICAgbGVnZW5kX2luc2V0X3k6IDAsXHJcbiAgICBsZWdlbmRfaW5zZXRfc3RlcDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9pdGVtX29uY2xpY2s6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9pdGVtX29ub3ZlcjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgbGVnZW5kX2l0ZW1fb25vdXQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9lcXVhbGx5OiBmYWxzZSxcclxuICAgIGxlZ2VuZF9wYWRkaW5nOiAwLFxyXG4gICAgbGVnZW5kX2l0ZW1fdGlsZV93aWR0aDogMTAsXHJcbiAgICBsZWdlbmRfaXRlbV90aWxlX2hlaWdodDogMTAsXHJcbiAgICBsZWdlbmRfdXNlUG9pbnQ6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHRpdGxlIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aXRsZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSB0aXRsZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3RpdGxlLnRleHRdIFRpdGxlIHRleHQuIElmIGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbGxvd2luZyBtdWx0aWxpbmUgdGl0bGUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcudG9wPTBdIFRvcCBwYWRkaW5nIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnJpZ2h0PTBdIFJpZ2h0IHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcuYm90dG9tPTBdIEJvdHRvbSBwYWRkaW5nIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLmxlZnQ9MF0gTGVmdCBwYWRkaW5nIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0aXRsZS5wb3NpdGlvbj1jZW50ZXJdIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiAnY2VudGVyJywgJ3JpZ2h0JyBhbmQgJ2xlZnQnLlxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1RpdGxlLk11bHRpbGluZWRUaXRsZSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgdGl0bGU6IHtcclxuICAgICAqICAgICAgdGV4dDogXCJUaXRsZSBUZXh0XCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBvciBNdWx0aWxpbmUgdGl0bGUgdGV4dFxyXG4gICAgICogICAgICB0ZXh0OiBcIk1haW4gdGl0bGUgdGV4dFxcblN1YiB0aXRsZSB0ZXh0XCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBwYWRkaW5nOiB7XHJcbiAgICAgKiAgICAgICAgICB0b3A6IDEwLFxyXG4gICAgICogICAgICAgICAgcmlnaHQ6IDEwLFxyXG4gICAgICogICAgICAgICAgYm90dG9tOiAxMCxcclxuICAgICAqICAgICAgICAgIGxlZnQ6IDEwXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICB0aXRsZV90ZXh0OiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgdGl0bGVfcGFkZGluZzoge1xyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgbGVmdDogMFxyXG4gICAgfSxcclxuICAgIHRpdGxlX3Bvc2l0aW9uOiA8XCJjZW50ZXJcInxcInJpZ2h0XCJ8XCJsZWZ0XCI+IFwiY2VudGVyXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogdG9vbHRpcCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb29sdGlwIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIHRvb2x0aXBcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB0b29sdGlwLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5kb05vdEhpZGU9ZmFsc2VdIE1ha2UgdG9vbHRpcCBrZWVwIHNob3dpbmcgbm90IGhpZGluZyBvbiBpbnRlcmFjdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXAuZ3JvdXBlZD10cnVlXSBTZXQgaWYgdG9vbHRpcCBpcyBncm91cGVkIG9yIG5vdCBmb3IgdGhlIGRhdGEgcG9pbnRzLlxyXG4gICAgICogICAtICoqTk9URToqKiBUaGUgb3ZlcmxhcHBlZCBkYXRhIHBvaW50cyB3aWxsIGJlIGRpc3BsYXllZCBhcyBncm91cGVkIGV2ZW4gaWYgc2V0IGZhbHNlLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5saW5rZWQ9ZmFsc2VdIFNldCBpZiB0b29sdGlwcyBvbiBhbGwgdmlzaWJsZSBjaGFydHMgd2l0aCBsaWtlIHggcG9pbnRzIGFyZSBzaG93biB0b2dldGhlciB3aGVuIG9uZSBpcyBzaG93bi5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdG9vbHRpcC5saW5rZWQubmFtZT1cIlwiXSBHcm9waW5nIG5hbWUgZm9yIGxpbmtlZCB0b29sdGlwLjxicj5JZiBzcGVjaWZpZWQsIGxpbmtlZCB0b29sdGlwIHdpbGwgYmUgZ3JvcGVkIGludGVyYWN0aW5nIHRvIGJlIHdvcmtlZCBvbmx5IHdpdGggdGhlIHNhbWUgbmFtZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC50aXRsZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHRpdGxlIG9mIHRvb2x0aXAuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQubmFtZV0gU2V0IGZvcm1hdCBmb3IgdGhlIG5hbWUgb2YgZWFjaCBkYXRhIGluIHRvb2x0aXAuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAuZm9ybWF0LnZhbHVlXSBTZXQgZm9ybWF0IGZvciB0aGUgdmFsdWUgb2YgZWFjaCBkYXRhIGluIHRvb2x0aXAuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxyXG4gICAgICogIElmIHVuZGVmaW5lZCByZXR1cm5lZCwgdGhlIHJvdyBvZiB0aGF0IHZhbHVlIHdpbGwgYmUgc2tpcHBlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLnBvc2l0aW9uXSBTZXQgY3VzdG9tIHBvc2l0aW9uIGZ1bmN0aW9uIGZvciB0aGUgdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgVGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIHBvc2l0aW9uIGJ5IHJldHVybmluZyBvYmplY3QgdGhhdCBoYXMgdG9wIGFuZCBsZWZ0LlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLnBvc2l0aW9uLnVuaXQ9XCJweFwiXSBTZXQgdG9vbHRpcCdzIHBvc2l0aW9uIHVuaXQuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogVGhpcyBvcHRpb24gY2FuJ3QgYmUgdXNlZCBhbG9uZyB3aXRoIGB0b29sdGlwLnBvc2l0aW9uYCBjdXN0b20gZnVuY3Rpb24uIElmIHdhbnQgdG8gc3BlY2lmeSB1bml0IGluIGN1c3RvbSBmdW5jdGlvbiwgcmV0dXJuIHZhbHVlIHdpdGggZGVzaXJlZCB1bml0LlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbnxPYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzXSBTZXQgY3VzdG9tIEhUTUwgZm9yIHRoZSB0b29sdGlwLjxicj5cclxuICAgICAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgZGF0YSwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQgYW5kIGNvbG9yIG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIElmIHRvb2x0aXAuZ3JvdXBlZCBpcyB0cnVlLCBkYXRhIGluY2x1ZGVzIG11bHRpcGxlIGRhdGEgcG9pbnRzLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR9IFt0b29sdGlwLmNvbnRlbnRzLmJpbmR0bz11bmRlZmluZWRdIFNldCBDU1Mgc2VsZWN0b3Igb3IgZWxlbWVudCByZWZlcmVuY2UgdG8gYmluZCB0b29sdGlwLlxyXG4gICAgICogIC0gKipOT1RFOioqIFdoZW4gaXMgc3BlY2lmaWVkLCB3aWxsIG5vdCBiZSB1cGRhdGluZyB0b29sdGlwJ3MgcG9zaXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3Rvb2x0aXAuY29udGVudHMudGVtcGxhdGU9dW5kZWZpbmVkXSBTZXQgdG9vbHRpcCdzIHRlbXBsYXRlLjxicj48YnI+XHJcbiAgICAgKiAgV2l0aGluIHRlbXBsYXRlLCBiZWxvdyBzeW50YXggd2lsbCBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XHJcbiAgICAgKiAgICAtICoqe3sgLi4uIH19Kio6IHRoZSBkb3VibHkgY3VybHkgYnJhY2tldHMgaW5kaWNhdGUgbG9vcCBibG9jayBmb3IgZGF0YSByb3dzLlxyXG4gICAgICogICAgLSAqKns9Q0xBU1NfVE9PTFRJUH0qKjogZGVmYXVsdCB0b29sdGlwIGNsYXNzIG5hbWUgYGJiLXRvb2x0aXBgLlxyXG4gICAgICogICAgLSAqKns9Q0xBU1NfVE9PTFRJUF9OQU1FfSoqOiBkZWZhdWx0IHRvb2x0aXAgZGF0YSBjbGFzcyBuYW1lIChleC4gYGJiLXRvb2x0aXAtbmFtZS1kYXRhMWApXHJcbiAgICAgKiAgICAtICoqez1USVRMRX0qKjogdGl0bGUgdmFsdWUuXHJcbiAgICAgKiAgICAtICoqez1DT0xPUn0qKjogZGF0YSBjb2xvci5cclxuICAgICAqICAgIC0gKip7PVZBTFVFfSoqOiBkYXRhIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzLnRleHQ9dW5kZWZpbmVkXSBTZXQgYWRkaXRpb25hbCB0ZXh0IGNvbnRlbnQgd2l0aGluIGRhdGEgbG9vcCwgdXNpbmcgdGVtcGxhdGUgc3ludGF4LlxyXG4gICAgICogIC0gKipOT1RFOioqIEl0IHNob3VsZCBjb250YWluIGB7IGtleTogQXJyYXksIC4uLiB9YCB2YWx1ZVxyXG4gICAgICogICAgLSAna2V5JyBuYW1lIGlzIHVzZWQgYXMgc3Vic3RpdHV0aW9uIHdpdGhpbiB0ZW1wbGF0ZSBhcyAnez1LRVl9J1xyXG4gICAgICogICAgLSBUaGUgdmFsdWUgYXJyYXkgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5pbml0LnNob3c9ZmFsc2VdIFNob3cgdG9vbHRpcCBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3Rvb2x0aXAuaW5pdC54PTBdIFNldCB4IEF4aXMgaW5kZXggdG8gYmUgc2hvd24gYXQgdGhlIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFt0b29sdGlwLmluaXQucG9zaXRpb249e3RvcDogXCIwcHhcIixsZWZ0OiBcIjUwcHhcIn1dIFNldCB0aGUgcG9zaXRpb24gb2YgdG9vbHRpcCBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5vbnNob3ddIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGJlZm9yZSB0aGUgdG9vbHRpcCBpcyBzaG93bi5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZV0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd25dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIHNob3duXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5vbmhpZGRlbl0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8RnVuY3Rpb258bnVsbH0gW3Rvb2x0aXAub3JkZXI9bnVsbF0gU2V0IHRvb2x0aXAgZGF0YSBkaXNwbGF5IG9yZGVyLjxicj48YnI+XHJcbiAgICAgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgLSBgZGVzY2A6IEluIGRlc2NlbmRpbmcgZGF0YSB2YWx1ZSBvcmRlclxyXG4gICAgICogIC0gYGFzY2A6IEluIGFzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXHJcbiAgICAgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGRpc3BsYXkgb3JkZXI8YnI+XHJcbiAgICAgKiAgICAgKipOT1RFOioqIFdoZW4gYGRhdGEuZ3JvdXBzYCBpcyBzZXQsIHRoZSBvcmRlciB3aWxsIGZvbGxvdyBhcyB0aGUgc3RhY2tlZCBncmFwaCBvcmRlci48YnI+XHJcbiAgICAgKiAgICAgIElmIHdhbnQgdG8gb3JkZXIgYXMgZGF0YSBib3VuZCwgc2V0IGFueSB2YWx1ZSByYXRoZXIgdGhhbiBhc2MsIGRlc2Mgb3IgbnVsbC4gKGV4LiBlbXB0eSBzdHJpbmcgXCJcIilcclxuICAgICAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBbQXJyYXkuc29ydCBjb21wYXJlRnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjUGFyYW1ldGVycylcclxuICAgICAqIEBzZWUgW0RlbW86IEhpZGUgVG9vbHRpcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuSGlkZVRvb2x0aXApXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBUb29sdGlwIEdyb3VwaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwR3JvdXBpbmcpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBUb29sdGlwIEZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcEZvcm1hdClcclxuICAgICAqIEBzZWUgW0RlbW86IExpbmtlZCBUb29sdGlwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5MaW5rZWRUb29sdGlwcylcclxuICAgICAqIEBzZWUgW0RlbW86IFRvb2x0aXAgVGVtcGxhdGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBUZW1wbGF0ZSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgdG9vbHRpcDoge1xyXG4gICAgICogICAgICBzaG93OiB0cnVlLFxyXG4gICAgICogICAgICBkb05vdEhpZGU6IHRydWUsXHJcbiAgICAgKiAgICAgIGdyb3VwZWQ6IGZhbHNlLFxyXG4gICAgICogICAgICBmb3JtYXQ6IHtcclxuICAgICAqICAgICAgICAgIHRpdGxlOiBmdW5jdGlvbih4KSB7IHJldHVybiBcIkRhdGEgXCIgKyB4OyB9LFxyXG4gICAgICogICAgICAgICAgbmFtZTogZnVuY3Rpb24obmFtZSwgcmF0aW8sIGlkLCBpbmRleCkgeyByZXR1cm4gbmFtZTsgfSxcclxuICAgICAqICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkLCBpbmRleCkgeyByZXR1cm4gcmF0aW87IH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiAwfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgY29udGVudHM6IGZ1bmN0aW9uKGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xyXG4gICAgICogICAgICAgICAgcmV0dXJuIC4uLiAvLyBmb3JtYXR0ZWQgaHRtbCBhcyB5b3Ugd2FudFxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIHNwZWNpZnkgdG9vbHRpcCBjb250ZW50cyB1c2luZyB0ZW1wbGF0ZVxyXG4gICAgICogICAgICAgLy8gLSBleGFtcGxlIG9mIEhUTUwgcmV0dXJuZWQ6XHJcbiAgICAgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XHJcbiAgICAgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMVwiPjxzcGFuPjI1MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+PC9saT5cclxuICAgICAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGEyXCI+PHNwYW4+NTA8L3NwYW4+PGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6I2ZhNzE3MVwiPmRhdGEyPC9zcGFuPjwvbGk+XHJcbiAgICAgKiAgICAgICAvLyA8L3VsPlxyXG4gICAgICogICAgICAgY29udGVudHM6IHtcclxuICAgICAqICAgICAgXHRiaW5kdG86IFwiI3Rvb2x0aXBcIixcclxuICAgICAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXHJcbiAgICAgKiAgICAgIFx0XHRcdCc8bGkgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj48c3Bhbj57PVZBTFVFfTwvc3Bhbj48YnI+JyArXHJcbiAgICAgKiAgICAgIFx0XHRcdCc8c3BhbiBzdHlsZT1jb2xvcjp7PUNPTE9SfT57PU5BTUV9PC9zcGFuPjwvbGk+JyArXHJcbiAgICAgKiAgICAgIFx0XHQnfX08L3VsPidcclxuICAgICAqICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIHdpdGggYWRkaXRpb25hbCB0ZXh0IHZhbHVlXHJcbiAgICAgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcclxuICAgICAqICAgICAgIC8vIDx1bCBjbGFzcz1cImJiLXRvb2x0aXBcIj5cclxuICAgICAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGExXCI+PHNwYW4+MjUwPC9zcGFuPjxicj5jb21tZW50MTxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPnRleHQxPC9saT5cclxuICAgICAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGEyXCI+PHNwYW4+NTA8L3NwYW4+PGJyPmNvbW1lbnQyPHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+dGV4dDI8L2xpPlxyXG4gICAgICogICAgICAgLy8gPC91bD5cclxuICAgICAqICAgICAgIGNvbnRlbnRzOiB7XHJcbiAgICAgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXHJcbiAgICAgKiAgICAgIFx0dGV4dDoge1xyXG4gICAgICogICAgICBcdFx0Ly8gYSkgJ2tleScgbmFtZSBpcyB1c2VkIGFzIHN1YnN0aXR1dGlvbiB3aXRoaW4gdGVtcGxhdGUgYXMgJ3s9S0VZfSdcclxuICAgICAqICAgICAgXHRcdC8vIGIpIHRoZSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXHJcbiAgICAgKiAgICAgIFx0XHRWQVIxOiBbXCJ0ZXh0MVwiLCBcInRleHQyXCJdLFxyXG4gICAgICogICAgICBcdFx0VkFSMjogW1wiY29tbWVudDFcIiwgXCJjb21tZW50MlwiXSxcclxuICAgICAqICAgICAgXHR9LFxyXG4gICAgICogICAgICBcdHRlbXBsYXRlOiAnPHVsIGNsYXNzPXs9Q0xBU1NfVE9PTFRJUH0+e3snICtcclxuICAgICAqICAgICAgXHRcdFx0JzxsaSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPjxzcGFuPns9VkFMVUV9PC9zcGFuPns9VkFSMn08YnI+JyArXHJcbiAgICAgKiAgICAgIFx0XHRcdCc8c3BhbiBzdHlsZT1jb2xvcjp7PUNPTE9SfT57PU5BTUV9PC9zcGFuPns9VkFSMX08L2xpPicgK1xyXG4gICAgICogICAgICBcdFx0J319PC91bD4nXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNvcnQgdG9vbHRpcCBkYXRhIHZhbHVlIGRpc3BsYXkgaW4gYXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgKiAgICAgIG9yZGVyOiBcImFzY1wiLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXHJcbiAgICAgKiAgICAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgKiAgICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxyXG4gICAgICogICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn1cclxuICAgICAqICAgICAgICAgICAuLi5cclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNob3cgYXQgdGhlIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKiAgICAgIGluaXQ6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgICAgICB4OiAyLFxyXG4gICAgICogICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICAgICAgICB0b3A6IFwiMTUwcHhcIixcclxuICAgICAqICAgICAgICAgICAgICBsZWZ0OiBcIjI1MHB4XCJcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgc2hvd25cclxuICAgICAqICAgICAgb25zaG93OiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG4gICAgICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuICAgICAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxyXG4gICAgICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgaGlkZGVuXHJcbiAgICAgKiAgICAgIG9uaGlkZTogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuICAgICAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIHNob3duXHJcbiAgICAgKiAgICAgIG9uc2hvd246IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcbiAgICAgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG4gICAgICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcbiAgICAgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZmlyZXMgYWZ0ZXIgdG9vbHRpcCBpcyBoaWRkZW5cclxuICAgICAqICAgICAgb25oaWRkZW46IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcbiAgICAgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG4gICAgICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcbiAgICAgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gTGluayBhbnkgdG9vbHRpcHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgYXJlIG9uIHRoZSBzY3JlZW4gd2hlcmUgc2FtZSB4IGNvb3JkaW5hdGVzIGFyZSBhdmFpbGFibGVcclxuICAgICAqICAgICAgLy8gVXNlZnVsIGZvciB0aW1lc2VyaWVzIGNvcnJlbGF0aW9uXHJcbiAgICAgKiAgICAgIGxpbmtlZDogdHJ1ZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIFNwZWNpZnkgbmFtZSB0byBpbnRlcmFjdCB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgb25seS5cclxuICAgICAqICAgICAgbGlua2VkOiB7XHJcbiAgICAgKiAgICAgICAgICBuYW1lOiBcInNvbWUtZ3JvdXBcIlxyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICB0b29sdGlwX3Nob3c6IHRydWUsXHJcbiAgICB0b29sdGlwX2RvTm90SGlkZTogZmFsc2UsXHJcbiAgICB0b29sdGlwX2dyb3VwZWQ6IHRydWUsXHJcbiAgICB0b29sdGlwX2Zvcm1hdF90aXRsZTogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgdG9vbHRpcF9mb3JtYXRfbmFtZTogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgdG9vbHRpcF9mb3JtYXRfdmFsdWU6IDwoKCkgPT4gbnVtYmVyKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIHRvb2x0aXBfcG9zaXRpb246IDwoKCkgPT4ge3RvcDogbnVtYmVyOyBsZWZ0OiBudW1iZXI7fSl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB0b29sdGlwX2NvbnRlbnRzOiA8KCgpID0+IHN0cmluZyl8e2JpbmR0bzogc3RyaW5nOyB0ZW1wbGF0ZTogc3RyaW5nOyB0ZXh0Pzoge1trZXk6IHN0cmluZ106IHN0cmluZ1tdfX0+IHt9LFxyXG4gICAgdG9vbHRpcF9pbml0X3Nob3c6IGZhbHNlLFxyXG4gICAgdG9vbHRpcF9pbml0X3g6IDAsXHJcbiAgICB0b29sdGlwX2luaXRfcG9zaXRpb246IHtcclxuICAgICAgICB0b3A6IFwiMHB4XCIsXHJcbiAgICAgICAgbGVmdDogXCI1MHB4XCJcclxuICAgIH0sXHJcbiAgICB0b29sdGlwX2xpbmtlZDogZmFsc2UsXHJcbiAgICB0b29sdGlwX2xpbmtlZF9uYW1lOiBcIlwiLFxyXG4gICAgdG9vbHRpcF9vbnNob3c6ICgpID0+IHt9LFxyXG4gICAgdG9vbHRpcF9vbmhpZGU6ICgpID0+IHt9LFxyXG4gICAgdG9vbHRpcF9vbnNob3duOiAoKSA9PiB7fSxcclxuICAgIHRvb2x0aXBfb25oaWRkZW46ICgpID0+IHt9LFxyXG4gICAgdG9vbHRpcF9vcmRlcjogPHN0cmluZ3xGdW5jdGlvbnxudWxsPiBudWxsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIEF4aXMgYmFzZWQgY2hhcnQgZGF0YSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoZSBrZXkgb2YgeCB2YWx1ZXMgaW4gdGhlIGRhdGEuPGJyPjxicj5cclxuICAgICAqIFdlIGNhbiBzaG93IHRoZSBkYXRhIHdpdGggbm9uLWluZGV4IHggdmFsdWVzIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHRoZSB0eXBlIG9mIHggYXhpcyBpcyB0aW1lc2VyaWVzLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgb24gY2F0ZWdvcnkgYXhpcywgdGhlIHZhbHVlcyBvZiB0aGUgZGF0YSBvbiB0aGUga2V5IHdpbGwgYmUgdXNlZCBmb3IgY2F0ZWdvcnkgbmFtZXMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkeFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHg6IFwiZGF0ZVwiXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfeDogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgdGhlIGtleXMgb2YgdGhlIHggdmFsdWVzIGZvciBlYWNoIGRhdGEuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIGNhbiBiZSB1c2VkIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGUgZGF0YSB0aGF0IGhhcyBkaWZmZXJlbnQgeCB2YWx1ZXMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkeHNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHhzOiB7XHJcbiAgICAgKiAgICAgIGRhdGExOiBcIngxXCIsXHJcbiAgICAgKiAgICAgIGRhdGEyOiBcIngyXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3hzOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2Ugc3RyaW5nIHNwZWNpZmVkIGFzIHguXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkeEZvcm1hdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCAlWS0lbS0lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgIHg6IFwieFwiLFxyXG4gICAgICogICAgY29sdW1uczogW1xyXG4gICAgICogICAgICAgIFtcInhcIiwgXCIwMTAxMjAxOVwiLCBcIjAyMDEyMDE5XCIsIFwiMDMwMTIwMTlcIl0sXHJcbiAgICAgKiAgICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwXVxyXG4gICAgICogICAgXSxcclxuICAgICAqICAgIC8vIEZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2UgYXMgZGF0ZXRpbWUgZm9yIGdpdmVuICd4JyBzdHJpbmcgdmFsdWVcclxuICAgICAqICAgIHhGb3JtYXQ6IFwiJW0lZCVZXCJcclxuICAgICAqIH0sXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgICB4OiB7XHJcbiAgICAgKiAgICAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxyXG4gICAgICovXHJcbiAgICBkYXRhX3hGb3JtYXQ6IFwiJVktJW0tJWRcIixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBsb2NhbHRpbWUgZm9ybWF0IHRvIHBhcnNlIHggYXhpcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR4TG9jYWx0aW1lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICB4TG9jYWx0aW1lOiBmYWxzZVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3hMb2NhbHRpbWU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IG9uIHggYXhpcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR4U29ydFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgeFNvcnQ6IGZhbHNlXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfeFNvcnQ6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZ3JvdXBzIGZvciB0aGUgZGF0YSBmb3Igc3RhY2tpbmcuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkZ3JvdXBzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgW11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIGdyb3VwczogW1xyXG4gICAgICogICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXHJcbiAgICAgKiAgICAgW1wiZGF0YTNcIl1cclxuICAgICAqICAgXVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2dyb3VwczogPHN0cmluZ1tdW10+IFtdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHkgYXhpcyB0aGUgZGF0YSByZWxhdGVkIHRvLiB5IGFuZCB5MiBjYW4gYmUgdXNlZC5cclxuXHQgKiAtICoqTk9URToqKiBJZiBhbGwgZGF0YSBpcyByZWxhdGVkIHRvIG9uZSBvZiB0aGUgYXhlcywgdGhlIGRvbWFpbiBvZiBheGlzIHdpdGhvdXQgcmVsYXRlZCBkYXRhIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRvbWFpbiBmcm9tIHRoZSBheGlzIHdpdGggcmVsYXRlZCBkYXRhXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkYXhlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgYXhlczoge1xyXG4gICAgICogICAgIGRhdGExOiBcInlcIixcclxuICAgICAqICAgICBkYXRhMjogXCJ5MlwiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9heGVzOiA8e1trZXk6IHN0cmluZ106IHN0cmluZ30+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxhYmVscyBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkbGFiZWxzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzLmNlbnRlcmVkPWZhbHNlXSBDZW50ZXJpemUgbGFiZWxzIG9uIGBiYXJgIHNoYXBlLiAoKipOT1RFOioqIHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZGF0YS5sYWJlbHMuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZ1bmN0aW9uIGZvciBkYXRhIGxhYmVscy48YnI+XHJcbiAgICAgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cclxuICAgICAqICAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxyXG4gICAgICogIC0gYGlkYCBpcyB0aGUgaWQgb2YgdGhlIGRhdGEgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxyXG4gICAgICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcbiAgICAgKiAgLSBgamAgaXMgdGhlIHN1YiBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uPGJyPjxicj5cclxuICAgICAqIEZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgZGVmaW5lZCBmb3IgZWFjaCBkYXRhIGJ5IHNwZWNpZnlpbmcgYXMgYW4gb2JqZWN0IGFuZCBEMyBmb3JtYXR0ZXIgZnVuY3Rpb24gY2FuIGJlIHNldCAoZXguIGQzLmZvcm1hdCgnJCcpKVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBbZGF0YS5sYWJlbHMuY29sb3JzXSBTZXQgbGFiZWwgdGV4dCBjb2xvcnMuXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW2RhdGEubGFiZWxzLnBvc2l0aW9uXSBTZXQgZWFjaCBkYXRhc2V0IHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLnk9MF0geSBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWwpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBsYWJlbCBjb2xvcnNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbENvbG9ycylcclxuICAgICAqIEBzZWUgW0RlbW86IGxhYmVsIGZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsRm9ybWF0KVxyXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgb3ZlcmxhcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsT3ZlcmxhcClcclxuICAgICAqIEBzZWUgW0RlbW86IGxhYmVsIHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxQb3NpdGlvbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIGxhYmVsczogdHJ1ZSxcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIG9yIHNldCBzcGVjaWZpYyBvcHRpb25zXHJcbiAgICAgKiAgIGxhYmVsczoge1xyXG4gICAgICogICAgIGZvcm1hdDogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIGl0J3MgcG9zc2libGUgdG8gc2V0IGZvciBlYWNoIGRhdGFcclxuICAgICAqICAgICBmb3JtYXQ6IHtcclxuICAgICAqICAgICAgICAgZGF0YTE6IGZ1bmN0aW9uKHYsIGlkLCBpLCBqKSB7IC4uLiB9LFxyXG4gICAgICogICAgICAgICAuLi5cclxuICAgICAqICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBhbGlnbiB0ZXh0IHRvIGNlbnRlciBvZiB0aGUgJ2Jhcicgc2hhcGUgKHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXHJcbiAgICAgKiAgICAgY2VudGVyZWQ6IHRydWUsXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIGFwcGx5IGZvciBhbGwgbGFiZWwgdGV4dHNcclxuICAgICAqICAgICBjb2xvcnM6IFwicmVkXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCBkaWZmZXJlbnQgY29sb3JzIHBlciBkYXRhc2V0XHJcbiAgICAgKiAgICAgLy8gZm9yIG5vdCBzcGVjaWZpZWQgZGF0YXNldCwgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IGNvbG9yIHZhbHVlXHJcbiAgICAgKiAgICAgY29sb3JzOiB7XHJcbiAgICAgKiAgICAgICAgZGF0YTE6IFwieWVsbG93XCIsXHJcbiAgICAgKiAgICAgICAgZGF0YTM6IFwiZ3JlZW5cIlxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb25cclxuICAgICAqICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgIHg6IC0xMCxcclxuICAgICAqICAgICAgICB5OiAxMFxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb24gYnkgZWFjaCBkYXRhc2V0XHJcbiAgICAgKiAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICBkYXRhMToge3g6IDUsIHk6IDV9LFxyXG4gICAgICogICAgICAgIGRhdGEyOiB7eDogMTAsIHk6IC0yMH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9sYWJlbHM6XHJcbiAgICAgICAgPGJvb2xlYW4gfCB7XHJcbiAgICAgICAgICAgIGNlbnRlcmVkPzogYm9vbGVhbjtcclxuICAgICAgICAgICAgZm9ybWF0PzogRnVuY3Rpb247XHJcbiAgICAgICAgICAgIGNvbG9ycz86IHN0cmluZ3x7W2tleTogc3RyaW5nXTogc3RyaW5nfTtcclxuICAgICAgICAgICAgcG9zaXRpb24/OiB7W2tleTogc3RyaW5nXTogbnVtYmVyfXx7W2tleTogc3RyaW5nXToge3g/OiBudW1iZXI7IHk/OiBudW1iZXI7fX1cclxuICAgICAgICB9PiB7fSxcclxuICAgIGRhdGFfbGFiZWxzX2NvbG9yczogPHN0cmluZ3xvYmplY3R8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBkYXRhX2xhYmVsc19wb3NpdGlvbjoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgcmVnaW9ucyBmb3IgZWFjaCBkYXRhLjxicj5cclxuICAgICAqIFRoZSB2YWx1ZXMgbXVzdCBiZSBhbiBhcnJheSBmb3IgZWFjaCBkYXRhIGFuZCBpdCBzaG91bGQgaW5jbHVkZSBhbiBvYmplY3QgdGhhdCBoYXMgYHN0YXJ0YCwgYGVuZGAgYW5kIGBzdHlsZWAuXHJcbiAgICAgKiAtIFRoZSBvYmplY3QgdHlwZSBzaG91bGQgYmUgYXM6XHJcbiAgICAgKiAgIC0gc3RhcnQge051bWJlcn06IFN0YXJ0IGRhdGEgcG9pbnQgbnVtYmVyLiBJZiBub3Qgc2V0LCB0aGUgc3RhcnQgd2lsbCBiZSB0aGUgZmlyc3QgZGF0YSBwb2ludC5cclxuICAgICAqICAgLSBbZW5kXSB7TnVtYmVyfTogRW5kIGRhdGEgcG9pbnQgbnVtYmVyLiBJZiBub3Qgc2V0LCB0aGUgZW5kIHdpbGwgYmUgdGhlIGxhc3QgZGF0YSBwb2ludC5cclxuICAgICAqICAgLSBbc3R5bGUuZGFzaGFycmF5PVwiMiAyXCJdIHtPYmplY3R9OiBUaGUgZmlyc3QgbnVtYmVyIHNwZWNpZmllcyBhIGRpc3RhbmNlIGZvciB0aGUgZmlsbGVkIGFyZWEsIGFuZCB0aGUgc2Vjb25kIGEgZGlzdGFuY2UgZm9yIHRoZSB1bmZpbGxlZCBhcmVhLlxyXG4gICAgICogLSAqKk5PVEU6KiogQ3VycmVudGx5IHRoaXMgb3B0aW9uIHN1cHBvcnRzIG9ubHkgbGluZSBjaGFydCBhbmQgZGFzaGVkIHN0eWxlLiBJZiB0aGlzIG9wdGlvbiBzcGVjaWZpZWQsIHRoZSBsaW5lIHdpbGwgYmUgZGFzaGVkIG9ubHkgaW4gdGhlIHJlZ2lvbnMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkcmVnaW9uc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgcmVnaW9uczoge1xyXG4gICAgICogICAgIGRhdGExOiBbe1xyXG4gICAgICogICAgICAgICBzdGFydDogMSxcclxuICAgICAqICAgICAgICAgZW5kOiAyLFxyXG4gICAgICogICAgICAgICBzdHlsZToge1xyXG4gICAgICogICAgICAgICAgICAgZGFzaGFycmF5OiBcIjUgMlwiXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICB9LCB7XHJcbiAgICAgKiAgICAgICAgIHN0YXJ0OiAzXHJcbiAgICAgKiAgICAgfV0sXHJcbiAgICAgKiAgICAgLi4uXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9yZWdpb25zOiA8e3N0YXJ0PzogbnVtYmVyOyBlbmQ/OiBudW1iZXI7IHN0eWxlPzoge2Rhc2hhcnJheTogc3RyaW5nO319W10+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzdGFja2luZyB0byBiZSBub3JtYWxpemVkXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogICAtIEZvciBzdGFja2luZywgJ1tkYXRhLmdyb3Vwc10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0Z3JvdXBzKScgb3B0aW9uIHNob3VsZCBiZSBzZXRcclxuICAgICAqICAgLSB5IEF4aXMgd2lsbCBiZSBzZXQgaW4gcGVyY2VudGFnZSB2YWx1ZSAoMCB+IDEwMCUpXHJcbiAgICAgKiAgIC0gTXVzdCBoYXZlIHBvc3RpdmUgdmFsdWVzXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc3RhY2vigKRub3JtYWxpemVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU3RhY2tOb3JtYWxpemVkKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgc3RhY2s6IHtcclxuICAgICAqICAgICAgbm9ybWFsaXplOiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zdGFja19ub3JtYWxpemU6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGRhdGEuc2VsZWN0aW9uIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBkYXRhIHNlbGVjdGlvbiBlbmFibGVkPGJyPjxicj5cclxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0cnVlLCB3ZSBjYW4gc2VsZWN0IHRoZSBkYXRhIHBvaW50cyBhbmQgZ2V0L3NldCBpdHMgc3RhdGUgb2Ygc2VsZWN0aW9uIGJ5IEFQSSAoZS5nLiBzZWxlY3QsIHVuc2VsZWN0LCBzZWxlY3RlZCkuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZW5hYmxlZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFTZWxlY3Rpb24pXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBlbmFibGVkOiB0cnVlXHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGdyb3VwZWQgc2VsZWN0aW9uIGVuYWJsZWQuPGJyPjxicj5cclxuICAgICAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBtdWx0aXBsZSBkYXRhIHBvaW50cyB0aGF0IGhhdmUgc2FtZSB4IHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWQgYnkgb25lIHNlbGVjdGlvbi5cclxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRncm91cGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgIHNlbGVjdGlvbjoge1xyXG4gICAgICogICAgICAgZ3JvdXBlZDogdHJ1ZVxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3NlbGVjdGlvbl9ncm91cGVkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBlYWNoIGRhdGEgcG9pbnQgdG8gZGV0ZXJtaW5lIGlmIGl0J3Mgc2VsZWN0YWJsZSBvciBub3QuPGJyPjxicj5cclxuICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgZCBhcyBhbiBhcmd1bWVudCBhbmQgaXQgaGFzIHNvbWUgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXguIFRoaXMgY2FsbGJhY2sgc2hvdWxkIHJldHVybiBib29sZWFuLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGlzc2VsZWN0YWJsZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgIHNlbGVjdGlvbjoge1xyXG4gICAgICogICAgICAgaXNzZWxlY3RhYmxlOiBmdW5jdGlvbihkKSB7IC4uLiB9XHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZTogKCkgPT4gdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtdWx0aXBsZSBkYXRhIHBvaW50cyBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpbGUgZGF0YSBwb2ludHMgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGF0IHRoZSBzYW1lIHRpbWUuIElmIGZhbHNlIHNldCwgb25seSBvbmUgZGF0YSBwb2ludCBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSB1bnNlbGVjdGVkIHdoZW4gdGhlIG5ldyBkYXRhIHBvaW50IGlzIHNlbGVjdGVkLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApG11bHRpcGxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBtdWx0aXBsZTogZmFsc2VcclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgdG8gc2VsZWN0IGRhdGEgcG9pbnRzIGJ5IGRyYWdnaW5nLlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIGRhdGEgcG9pbnRzIGNhbiBiZSBzZWxlY3RlZCBieSBkcmFnZ2luZy5cclxuICAgICAqIC0gKipOT1RFOioqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBzY3JvbGxpbmcgb24gdGhlIGNoYXJ0IHdpbGwgYmUgZGlzYWJsZWQgYmVjYXVzZSBkcmFnZ2luZyBldmVudCB3aWxsIGhhbmRsZSB0aGUgZXZlbnQuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZHJhZ2dhYmxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgIHNlbGVjdGlvbjoge1xyXG4gICAgICogICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zZWxlY3Rpb25fZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBvbiBkYXRhIHNlbGVjdGlvbi5cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbnNlbGVjdGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBvbnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcbiAgICAgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vbnNlbGVjdGVkOiAoKSA9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBvbiBkYXRhIHVuLXNlbGVjdGlvbi5cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbnVuc2VsZWN0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIG9udW5zZWxlY3RlZDogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcbiAgICAgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XHJcbiAgICAgKiAgICAgICAgLi4uXHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb251bnNlbGVjdGVkOiAoKSA9PiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHggYXhpcyBlbGVtZW50XHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGNsaXBQYXRoXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXSgpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxyXG4gICAgICogY2xpcFBhdGg6IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9jbGlwUGF0aDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB4IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHNob3dcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHR5cGUgb2YgeCBheGlzLjxicj48YnI+XHJcbiAgICAgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqIC0gdGltZXNlcmllc1xyXG4gICAgICogLSBjYXRlZ29yeVxyXG4gICAgICogLSBpbmRleGVkXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHR5cGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgaW5kZXhlZFxyXG4gICAgICogQHNlZSBbRGVtbzogaW5kZXhlZF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LkFyZWFDaGFydClcclxuICAgICAqIEBzZWUgW0RlbW86IHRpbWVzZXJpZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5UaW1lc2VyaWVzQ2hhcnQpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBjYXRlZ29yeV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ2F0ZWdvcnlEYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3R5cGU6IDxcImluZGV4ZWRcInxcInRpbWVzZXJpZXNcInxcImNhdGVnb3J5XCI+IFwiaW5kZXhlZFwiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGhvdyB0byB0cmVhdCB0aGUgdGltZXpvbmUgb2YgeCB2YWx1ZXMuPGJyPlxyXG4gICAgICogSWYgdHJ1ZSwgdHJlYXQgeCB2YWx1ZSBhcyBsb2NhbHRpbWUuIElmIGZhbHNlLCBjb252ZXJ0IHRvIFVUQyBpbnRlcm5hbGx5LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRsb2NhbHRpbWVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBsb2NhbHRpbWU6IGZhbHNlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X2xvY2FsdGltZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjYXRlZ29yeSBuYW1lcyBvbiBjYXRlZ29yeSBheGlzLlxyXG4gICAgICogVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGNhdGVnb3JpZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCBbXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIGNhdGVnb3JpZXM6IFtcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLl1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfY2F0ZWdvcmllczogPHN0cmluZ1tdPiBbXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNlbnRlcml6ZSB0aWNrcyBvbiBjYXRlZ29yeSBheGlzLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY2VudGVyZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY2VudGVyZWQ6IHRydWVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfY2VudGVyZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0byBmb3JtYXQgdGljayB2YWx1ZS4gRm9ybWF0IHN0cmluZyBpcyBhbHNvIGF2YWlsYWJsZSBmb3IgdGltZXNlcmllcyBkYXRhLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZm9ybWF0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRDMncyB0aW1lIHNwZWNpZmllcl0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUtZm9ybWF0I2xvY2FsZV9mb3JtYXQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzLCBhICdkYXRldGltZScgb2JqZWN0IGlzIGdpdmVuIGFzIHBhcmFtZXRlclxyXG4gICAgICogICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgKiAgICAgICAgICAgcmV0dXJuIHguZ2V0RnVsbFllYXIoKTtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgICAvLyBmb3IgY2F0ZWdvcnksIGluZGV4KE51bWJlcikgYW5kIGNhdGVnb3J5TmFtZShTdHJpbmcpIGFyZSBnaXZlbiBhcyBwYXJhbWV0ZXJcclxuICAgICAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5kZXgsIGNhdGVnb3J5TmFtZSkge1xyXG4gICAgICogICAgICAgICAgIHJldHVybiBjYXRlZ29yeU5hbWUuc3Vic3RyKDAsIDEwKTtcclxuICAgICAqICAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzIGZvcm1hdCBzcGVjaWZpZXJcclxuICAgICAqICAgICAgICBmb3JtYXQ6IFwiJVktJW0tJWQgJUg6JU06JVNcIlxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19mb3JtYXQ6IDxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cclxuICAgICAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLngudGljay5jdWxsaW5nLm1heC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmdcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0XHJcbiAgICAgKiAtIHRydWUgZm9yIGluZGV4ZWQgYXhpcyBhbmQgdGltZXNlcmllcyBheGlzXHJcbiAgICAgKiAtIGZhbHNlIGZvciBjYXRlZ29yeSBheGlzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY3VsbGluZzogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfY3VsbGluZzoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMTBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiB7XHJcbiAgICAgKiAgICAgICAgICAgbWF4OiA1XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX2N1bGxpbmdfbWF4OiAxMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgeCBheGlzIHRpY2tzIHRvIHNob3cuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIGhpZGVzIHRpY2sgbGluZXMgdG9nZXRoZXIgd2l0aCB0aWNrIHRleHQuIElmIHRoaXMgb3B0aW9uIGlzIHVzZWQgb24gdGltZXNlcmllcyBheGlzLCB0aGUgdGlja3MgcG9zaXRpb24gd2lsbCBiZSBkZXRlcm1pbmVkIHByZWNpc2VseSBhbmQgbm90IG5pY2VseSBwb3NpdGlvbmVkIChlLmcuIGl0IHdpbGwgaGF2ZSByb3VnaCBzZWNvbmQgdmFsdWUpLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY291bnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY291bnQ6IDVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfY291bnQ6IDxudW1iZXJ8dW5kZWZpbmVkPnVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayBsaW5lLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0ZXh04oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB4IEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICAgICB4OiAxMCxcclxuICAgICAqICAgICAgICAgICB5OiAxMFxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpdCB4IGF4aXMgdGlja3MuXHJcbiAgICAgKiAtICoqdHJ1ZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgbmljZWx5IHRvIGhhdmUgc2FtZSBpbnRlcnZhbHMuXHJcbiAgICAgKiAtICoqZmFsc2UqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIGFjY29yZGluZyB0byB4IHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZpdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrRml0dGluZylcclxuICAgICAqIEBzZWUgW0RlbW86IGZvciB0aW1lc2VyaWVzIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja1RpbWVzZXJpZXMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgZml0OiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19maXQ6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHggdmFsdWVzIG9mIHRpY2tzIG1hbnVhbGx5Ljxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBwcm92aWRlZCwgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGRldGVybWluZWQgYmFzZWQgb24gdGhvc2UgdmFsdWVzLjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIHdvcmtzIHdpdGggYHRpbWVzZXJpZXNgIGRhdGEgYW5kIHRoZSB4IHZhbHVlcyB3aWxsIGJlIHBhcnNlZCBhY2NvZGluZyB0byB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYW5kIGRhdGEueEZvcm1hdCBvcHRpb24uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR2YWx1ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdmFsdWVzOiBbMSwgMiwgNCwgOCwgMTYsIDMyLCAuLi5dLFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxyXG4gICAgICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3ZhbHVlczogPChzdHJpbmd8RGF0ZXxudW1iZXIpW118KCgpPT4gbnVtYmVyW10pfG51bGw+IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgeCBheGlzIHRpY2sgdGV4dC5cclxuICAgICAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG4gICAgICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYGZhbHNlYC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHJvdGF0ZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5Sb3RhdGVYQXhpc1RpY2tUZXh0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHJvdGF0ZTogNjBcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfcm90YXRlOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB4IGF4aXMgb3V0ZXIgdGljay5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG91dGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgb3V0ZXI6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX291dGVyOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRpY2sgdGV4dCB0byBiZSBtdWx0aWxpbmVcclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbmQgJ2F4aXMueC50aWNrLndpZHRoJyBvcHRpb24gaXMgaWdub3JlZC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG11bHRpbGluZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrTXVsdGlsaW5lKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIG11bHRpbGluZTogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBleGFtcGxlIG9mIGxpbmUgYnJlYWsgd2l0aCAnXFxuJ1xyXG4gICAgICogLy8gSW4gdGhpcyBjYXNlLCAnYXhpcy54LnRpY2sud2lkdGgnIGlzIGlnbm9yZWRcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgIHg6IFwieFwiLFxyXG4gICAgICogICAgY29sdW1uczogW1xyXG4gICAgICogICAgICAgIFtcInhcIiwgXCJsb25nXFxudGV4dFwiLCBcIkFub3RoZXJcXG5Mb25nXFxuVGV4dFwiXSxcclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgIF0sXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX211bHRpbGluZTogdHJ1ZSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGljayB3aWR0aFxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR3aWR0aFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgd2lkdGg6IDUwXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3dpZHRoOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gZGlzcGxheSBzeXN0ZW0gdG9vbHRpcCh2aWEgJ3RpdGxlJyBhdHRyaWJ1dGUpIGZvciB0aWNrIHRleHRcclxuICAgICAqIC0gKipOT1RFOioqIE9ubHkgYXZhaWxhYmxlIGZvciBjYXRlZ29yeSBheGlzIHR5cGUgKGBheGlzLngudHlwZT0nY2F0ZWdvcnknYClcclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRvb2x0aXBcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdG9vbHRpcDogdHJ1ZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja190b29sdGlwOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtYXggdmFsdWUgb2YgeCBheGlzIHJhbmdlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgbWF4OiAxMDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG1pbiB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApG1pblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBtaW46IC0xMDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfbWluOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHBhZGRpbmcgZm9yIHggYXhpcy48YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgcmFuZ2Ugb2YgeCBheGlzIHdpbGwgaW5jcmVhc2UvZGVjcmVhc2UgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZXMuXHJcbiAgICAgKiBJZiBubyBwYWRkaW5nIGlzIG5lZWRlZCBpbiB0aGUgcmFnZSBvZiB4IGF4aXMsIDAgc2hvdWxkIGJlIHNldC5cclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgIFRoZSBwYWRkaW5nIHZhbHVlcyBhcmVuJ3QgYmFzZWQgb24gcGl4ZWxzLiBJdCBkaWZmZXJzIGFjY29yZGluZyBheGlzIHR5cGVzPGJyPlxyXG4gICAgICogICAtICoqY2F0ZWdvcnk6KiogVGhlIHVuaXQgb2YgdGljayB2YWx1ZVxyXG4gICAgICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDFgLCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcclxuICAgICAqICAgLSAqKnRpbWVzZXJpZXM6KiogTnVtZXJpYyB0aW1lIHZhbHVlXHJcbiAgICAgKiAgICAgZXguIHRoZSBnaXZlbiB2YWx1ZSBgMTAwMCo2MCo2MCoyNGAsIHdoaWNoIGlzIG51bWVyaWMgdGltZSBlcXVpdmFsZW50IG9mIGEgZGF5LCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkcGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R8TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBwYWRkaW5nOiB7XHJcbiAgICAgKiAgICAgICAvLyB3aGVuIGF4aXMgdHlwZSBpcyAnY2F0ZWdvcnknXHJcbiAgICAgKiAgICAgICBsZWZ0OiAxLCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgdGljaydzIHdpZHRoXHJcbiAgICAgKiAgICAgICByaWdodDogMC41ICAvLyBzZXQgcmlnaHQgcGFkZGluZyB3aWR0aCBhcyBoYWxmIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgdGljaydzIHdpZHRoXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ3RpbWVzZXJpZXMnXHJcbiAgICAgKiAgICAgICBsZWZ0OiAxMDAwKjYwKjYwKjI0LCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgZGF5IHRpY2sncyB3aWR0aFxyXG4gICAgICogICAgICAgcmlnaHQ6IDEwMDAqNjAqNjAqMTIgICAvLyBzZXQgcmlnaHQgcGFkZGluZyB3aWR0aCBhcyBoYWxmIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSBkYXkgdGljaydzIHdpZHRoXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcbiAgICAgKiAgICAgcGFkZGluZzogMTBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfcGFkZGluZzogPG51bWJlcnx7bGVmdD86IG51bWJlcjsgcmlnaHQ/OiBudW1iZXI7fT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaGVpZ2h0IG9mIHggYXhpcy48YnI+PGJyPlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB4IGF4aXMgY2FuIGJlIHNldCBtYW51YWxseSBieSB0aGlzIG9wdGlvbi4gSWYgeW91IG5lZWQgbW9yZSBzcGFjZSBmb3IgeCBheGlzLCBwbGVhc2UgdXNlIHRoaXMgb3B0aW9uIGZvciB0aGF0LiBUaGUgdW5pdCBpcyBwaXhlbC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkaGVpZ2h0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIGhlaWdodDogMjBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfaGVpZ2h0OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRlZmF1bHQgZXh0ZW50IGZvciBzdWJjaGFydCBhbmQgem9vbS4gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRleHRlbnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICAvLyBleHRlbnQgcmFuZ2UgYXMgYSBwaXhlbCB2YWx1ZVxyXG4gICAgICogICAgIGV4dGVudDogWzAsIDIwMF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHdoZW4gYXhpcyBpcyAndGltZXNlcmllcycsIHBhcnNhYmxlIGRhdGV0aW1lIHN0cmluZ1xyXG4gICAgICogICAgIGV4dGVudDogW1wiMjAxOS0wMy0wMVwiLCBcIjIwMTktMDMtMDVcIl0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHJldHVybiBleHRlbnQgdmFsdWVcclxuICAgICAqICAgICBleHRlbnQ6IGZ1bmN0aW9uKGRvbWFpbiwgc2NhbGUpIHtcclxuICAgICAqICAgIFx0IHZhciBleHRlbnQgPSBkb21haW4ubWFwKGZ1bmN0aW9uKHYpIHtcclxuICAgICAqICAgICBcdCAgICByZXR1cm4gc2NhbGUodik7XHJcbiAgICAgKiAgICAgXHQgfSk7XHJcbiAgICAgKlxyXG4gICAgICogICBcdCAvLyBpdCBzaG91bGQgcmV0dXJuIGEgZm9ybWF0IG9mIGFycmF5XHJcbiAgICAgKiAgIFx0IC8vIGV4KSBbMCwgNTg0XVxyXG4gICAgICogICAgIFx0IHJldHVybiBleHRlbnQ7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9leHRlbnQ6IDwobnVtYmVyfHN0cmluZylbXXxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBsYWJlbCBvbiB4IGF4aXMuPGJyPjxicj5cclxuICAgICAqIFlvdSBjYW4gc2V0IHggYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi5cclxuICAgICAqIGBzdHJpbmdgIGFuZCBgb2JqZWN0YCBjYW4gYmUgcGFzc2VkIGFuZCB3ZSBjYW4gY2hhbmdlIHRoZSBwb2lzaXRvbiBieSBwYXNzaW5nIG9iamVjdCB0aGF0IGhhcyBwb3NpdGlvbiBrZXkuPGJyPlxyXG4gICAgICogQXZhaWxhYmxlIHBvc2l0aW9uIGRpZmZlcnMgYWNjb3JkaW5nIHRvIHRoZSBheGlzIGRpcmVjdGlvbiAodmVydGljYWwgb3IgaG9yaXpvbnRhbCkuXHJcbiAgICAgKiBJZiBzdHJpbmcgc2V0LCB0aGUgcG9zaXRpb24gd2lsbCBiZSB0aGUgZGVmYXVsdC5cclxuICAgICAqXHJcbiAgICAgKiAgLSAqKklmIGl0J3MgaG9yaXpvbnRhbCBheGlzOioqXHJcbiAgICAgKiAgICAtIGlubmVyLXJpZ2h0IFtkZWZhdWx0XVxyXG4gICAgICogICAgLSBpbm5lci1jZW50ZXJcclxuICAgICAqICAgIC0gaW5uZXItbGVmdFxyXG4gICAgICogICAgLSBvdXRlci1yaWdodFxyXG4gICAgICogICAgLSBvdXRlci1jZW50ZXJcclxuICAgICAqICAgIC0gb3V0ZXItbGVmdFxyXG4gICAgICogIC0gKipJZiBpdCdzIHZlcnRpY2FsIGF4aXM6KipcclxuICAgICAqICAgIC0gaW5uZXItdG9wIFtkZWZhdWx0XVxyXG4gICAgICogICAgLSBpbm5lci1taWRkbGVcclxuICAgICAqICAgIC0gaW5uZXItYm90dG9tXHJcbiAgICAgKiAgICAtIG91dGVyLXRvcFxyXG4gICAgICogICAgLSBvdXRlci1taWRkbGVcclxuICAgICAqICAgIC0gb3V0ZXItYm90dG9tXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGxhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ3xPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBsYWJlbDogXCJZb3VyIFggQXhpc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgIHRleHQ6IFwiWW91ciBYIEF4aXNcIixcclxuICAgICAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1jZW50ZXJcIlxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfbGFiZWw6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeCBBeGlzLlxyXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuICAgICAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuICAgICAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxyXG4gICAgICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxyXG4gICAgICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XHJcbiAgICAgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcclxuICAgICAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRheGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxyXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogeDoge1xyXG4gICAgICogICAgYXhlczogW1xyXG4gICAgICogICAgICB7XHJcbiAgICAgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geCBBeGlzIGRvbWFpbiB2YWx1ZVxyXG4gICAgICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxyXG4gICAgICogICAgICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcclxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICBjb3VudDogMixcclxuICAgICAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXHJcbiAgICAgKiAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICAuLi5cclxuICAgICAqICAgIF1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X2F4ZXM6IDxvYmplY3RbXT5bXVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB5IEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBjbGlwLXBhdGggYXR0cmlidXRlIGZvciB5IGF4aXMgZWxlbWVudFxyXG4gICAgICogLSAqKk5PVEUqKjogYGNsaXAtcGF0aGAgYXR0cmlidXRlIGZvciB5IEF4aXMgaXMgc2V0IG9ubHkgd2hlbiBgYXhpcy55LmlubmVyYCBvcHRpb24gaXMgdHJ1ZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkY2xpcFBhdGhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXHJcbiAgICAgKiBjbGlwUGF0aDogZmFsc2VcclxuICAgICAqL1xyXG4gICAgYXhpc195X2NsaXBQYXRoOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHkgYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdHlwZSBvZiB5IGF4aXMuPGJyPjxicj5cclxuICAgICAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogICAtIHRpbWVzZXJpZXNcclxuICAgICAqICAgLSBjYXRlZ29yeVxyXG4gICAgICogICAtIGluZGV4ZWRcclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdHlwZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90eXBlOiA8XCJpbmRleGVkXCJ8XCJjYXRlZ29yeVwifFwiaW5kZXhlZFwifHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG1heCB2YWx1ZSBvZiB5IGF4aXMuXHJcbiAgICAgKiAtICoqTk9URToqKiBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgbWF4OiAxMDAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtaW4gdmFsdWUgb2YgeSBheGlzLlxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkbWluXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIG1pbjogMTAwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9taW46IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5IGF4aXMuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGludmVydGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIGludmVydGVkOiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X2ludmVydGVkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeSBheGlzLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRjZW50ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgY2VudGVyOiAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X2NlbnRlcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgeSBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGlubmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIGlubmVyOiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X2lubmVyOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBsYWJlbCBvbiB5IGF4aXMuPGJyPjxicj5cclxuICAgICAqIFlvdSBjYW4gc2V0IHkgYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi4gVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGxhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ3xPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQHNlZSBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpIGZvciBwb3NpdGlvbiBzdHJpbmcgdmFsdWUuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgbGFiZWw6IFwiWW91ciBZIEF4aXNcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgICB0ZXh0OiBcIllvdXIgWSBBeGlzXCIsXHJcbiAgICAgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X2xhYmVsOiA8c3RyaW5nfG9iamVjdD4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZm9ybWF0dGVyIGZvciB5IGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGQzLmZvcm1hdCBvYmplY3QgYXMgd2VsbCBhcyBhIGZ1bmN0aW9uIHlvdSBkZWZpbmUuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRmb3JtYXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19mb3JtYXQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxyXG4gICAgICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19jdWxsaW5nOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ+KApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY3VsbGluZzoge1xyXG4gICAgICogICAgICAgICAgIG1heDogNVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19jdWxsaW5nX21heDogNSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgeSBheGlzIG91dGVyIHRpY2suXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRvdXRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIG91dGVyOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB5IGF4aXMgdGljayB2YWx1ZXMgbWFudWFsbHkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR2YWx1ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfdmFsdWVzOiA8bnVtYmVyW118KCgpPT4gbnVtYmVyW10pfG51bGw+IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgeSBheGlzIHRpY2sgdGV4dC5cclxuICAgICAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG4gICAgICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkcm90YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICByb3RhdGU6IDYwXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX3JvdGF0ZTogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcy48YnI+PGJyPlxyXG4gICAgICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY291bnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY291bnQ6IDVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfY291bnQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgbGluZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHNob3dcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBheGlzIHRpY2sgc3RlcChpbnRlcnZhbCkgc2l6ZS5cclxuICAgICAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55LnRpY2suY291bnRgIG9yIGBheGlzLnkudGljay52YWx1ZXNgIG9wdGlvbnMgYXJlIHNldC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHN0ZXBTaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlN0ZXBTaXplRm9yWUF4aXMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG4gICAgICogICAgICAgLy8gZXgpICdzdGVwU2l6ZT0xNScgPT0+IFswLCAxNSwgMzAsIDQ1LCA2MF1cclxuICAgICAqICAgICAgIHN0ZXBTaXplOiAxNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19zdGVwU2l6ZTogPG51bWJlcnxudWxsPiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgdGV4dC5cclxuICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHNob3dcclxuICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICogQGV4YW1wbGVcclxuICAgICogYXhpczoge1xyXG4gICAgKiAgIHk6IHtcclxuICAgICogICAgIHRpY2s6IHtcclxuICAgICogICAgICAgdGV4dDoge1xyXG4gICAgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICogICAgICAgfVxyXG4gICAgKiAgICAgfVxyXG4gICAgKiAgIH1cclxuICAgICogfVxyXG4gICAgKi9cclxuICAgIGF4aXNfeV90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgeSBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR0ZXh04oCkcG9zaXRpb25cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge3g6IDAsIHk6MH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICAgeDogMTAsXHJcbiAgICAgKiAgICAgICAgICAgeTogMTBcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja190ZXh0X3Bvc2l0aW9uOiB7eDogMCwgeTogMH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cclxuICAgICAqIC0gKipOT1RFOioqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBjYWxjdWxhdGVkIHByZWNpc2VseSwgc28gdGhlIHZhbHVlcyBvbiB0aGUgdGlja3Mgd2lsbCBub3QgYmUgcm91bmRlZCBuaWNlbHkuIEluIHRoZSBjYXNlLCBheGlzLnkudGljay5mb3JtYXQgb3IgYXhpcy55LnRpY2sudmFsdWVzIHdpbGwgYmUgaGVscGZ1bC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRpbWVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0aW1lLnZhbHVlXSBEMydzIHRpbWUgaW50ZXJ2YWwgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lI2ludGVydmFscylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0aW1lOiB7XHJcbiAgICAgKiAgICAgICAgICAvLyB0aWNrcyBhdCAxNS1taW51dGUgaW50ZXJ2YWxzXHJcbiAgICAgKiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3RpbWVfdGlja3NcclxuICAgICAqICAgICAgICAgIHZhbHVlOiBkMy50aW1lTWludXRlLmV2ZXJ5KDE1KVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICAvLyBAVE9ETzogbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldFxyXG4gICAgYXhpc195X3RpY2tfdGltZV92YWx1ZTogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHBhZGRpbmcgZm9yIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogWW91IGNhbiBzZXQgcGFkZGluZyBmb3IgeSBheGlzIHRvIGNyZWF0ZSBtb3JlIHNwYWNlIG9uIHRoZSBlZGdlIG9mIHRoZSBheGlzLlxyXG4gICAgICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIC0gKipOT1RFOioqIEZvciBhcmVhIGFuZCBiYXIgdHlwZSBjaGFydHMsIFthcmVhLnplcm9iYXNlZF0oIy5hcmVhKSBvciBbYmFyLnplcm9iYXNlZF0oIy5iYXIpIG9wdGlvbnMgc2hvdWxkIGJlIHNldCB0byAnZmFsc2VgIHRvIGdldCBwYWRkZWQgYm90dG9tLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRwYWRkaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdHxOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHBhZGRpbmc6IHtcclxuICAgICAqICAgICAgIHRvcDogMCxcclxuICAgICAqICAgICAgIGJvdHRvbTogMFxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCBib3RoIHZhbHVlcyBhdCBvbmNlLlxyXG4gICAgICogICAgIHBhZGRpbmc6IDEwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3BhZGRpbmc6IDxudW1iZXJ8e3RvcD86IG51bWJlcjsgYm90dG9tPzogbnVtYmVyO30+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeSBheGlzLjxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkZGVmYXVsdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIGRlZmF1bHQ6IFswLCAxMDAwXVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9kZWZhdWx0OiA8bnVtYmVyW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5IEF4aXMuXHJcbiAgICAgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB5IEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxyXG4gICAgICpcclxuICAgICAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG4gICAgICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG4gICAgICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XHJcbiAgICAgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XHJcbiAgICAgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcclxuICAgICAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxyXG4gICAgICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGF4ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB5OiB7XHJcbiAgICAgKiAgICBheGVzOiBbXHJcbiAgICAgKiAgICAgIHtcclxuICAgICAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB5IEF4aXMgZG9tYWluIHZhbHVlXHJcbiAgICAgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXHJcbiAgICAgKiAgICAgICAgdGljazoge1xyXG4gICAgICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIGNvdW50OiAyLFxyXG4gICAgICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cclxuICAgICAqICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIC4uLlxyXG4gICAgICogICAgXVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfYXhlczogPG9iamVjdFtdPiBbXVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB5MiBBeGlzICBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeTIgYXhpcy5cclxuICAgICAqIC0gKipOT1RFKio6XHJcbiAgICAgKiAgIC0gV2hlbiBzZXQgdG8gYGZhbHNlYCB3aWxsIG5vdCBnZW5lcmF0ZSB5MiBheGlzIG5vZGUuIEluIHRoaXMgY2FzZSwgYWxsICd5MicgYXhpcyByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgd29uJ3Qgd29yayBwcm9wZXJseS5cclxuICAgICAqICAgLSBJZiBuZWVkIHRvIHVzZSAneTInIHJlbGF0ZWQgb3B0aW9ucyB3aGlsZSB5MiBpc24ndCB2aXNpYmxlLCBzZXQgdGhlIHZhbHVlIGB0cnVlYCBhbmQgY29udHJvbCB2aXNpYmlsaXR5IGJ5IGNzcyBkaXNwbGF5IHByb3BlcnR5LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgc2hvdzogdHJ1ZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfc2hvdzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbWF4IHZhbHVlIG9mIHkyIGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIG1heDogMTAwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG1pbiB2YWx1ZSBvZiB5MiBheGlzLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkbWluXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBtaW46IC0xMDAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9taW46IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5MiBheGlzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkaW52ZXJ0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIGludmVydGVkOiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9pbnZlcnRlZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2VudGVyIHZhbHVlIG9mIHkyIGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRjZW50ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIGNlbnRlcjogMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfY2VudGVyOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB5MiBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRpbm5lclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgaW5uZXI6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX2lubmVyOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBsYWJlbCBvbiB5MiBheGlzLjxicj48YnI+XHJcbiAgICAgKiBZb3UgY2FuIHNldCB5MiBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGxhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ3xPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQHNlZSBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpIGZvciBwb3NpdGlvbiBzdHJpbmcgdmFsdWUuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIGxhYmVsOiBcIllvdXIgWTIgQXhpc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgICB0ZXh0OiBcIllvdXIgWTIgQXhpc1wiLFxyXG4gICAgICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLW1pZGRsZVwiXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfbGFiZWw6IDxzdHJpbmd8b2JqZWN0PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBmb3JtYXR0ZXIgZm9yIHkyIGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy55LmZvcm1hdC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRmb3JtYXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgZm9ybWF0OiBkMy5mb3JtYXQoXCIkLFwiKVxyXG4gICAgICogICAgICAgLy9vciBmb3JtYXQ6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiJFwiICsgZDsgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfZm9ybWF0OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cclxuICAgICAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLnkudGljay5jdWxsaW5nLm1heC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjdWxsaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfY3VsbGluZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjdWxsaW5n4oCkbWF4XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY3VsbGluZzoge1xyXG4gICAgICogICAgICAgICAgIG1heDogNVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfY3VsbGluZ19tYXg6IDUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyBvdXRlciB0aWNrLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApG91dGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIG91dGVyOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfb3V0ZXI6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgeTIgYXhpcyB0aWNrIHZhbHVlcyBtYW51YWxseS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR2YWx1ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHZhbHVlczogWzEwMCwgMTAwMCwgMTAwMDBdLFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxyXG4gICAgICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja192YWx1ZXM6IDxudW1iZXJbXXwoKCk9PiBudW1iZXJbXSl8bnVsbD4gbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB5MiBheGlzIHRpY2sgdGV4dC5cclxuICAgICAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG4gICAgICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHJvdGF0ZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHJvdGF0ZTogNjBcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3JvdGF0ZTogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIHkyIGF4aXMgdGlja3MuXHJcbiAgICAgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjb3VudFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY291bnQ6IDVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX2NvdW50OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayBsaW5lLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHNob3dcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja19zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGF4aXMgdGljayBzdGVwKGludGVydmFsKSBzaXplLlxyXG4gICAgICogLSAqKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBheGlzLnkyLnRpY2suY291bnRgIG9yIGBheGlzLnkyLnRpY2sudmFsdWVzYCBvcHRpb25zIGFyZSBzZXQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkc3RlcFNpemVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuU3RlcFNpemVGb3JZQXhpcylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG4gICAgICogICAgICAgLy8gZXgpICdzdGVwU2l6ZT0xNScgPT0+IFswLCAxNSwgMzAsIDQ1LCA2MF1cclxuICAgICAqICAgICAgIHN0ZXBTaXplOiAxNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfc3RlcFNpemU6IDxudW1iZXJ8bnVsbD4gbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgdGV4dC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR0ZXh04oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHkyIEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR0ZXh04oCkcG9zaXRpb25cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge3g6IDAsIHk6MH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgICAgIHg6IDEwLFxyXG4gICAgICogICAgICAgICAgIHk6IDEwXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIHkyIGF4aXMgdGlja3MuXHJcbiAgICAgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHBhZGRpbmdcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fE51bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHBhZGRpbmc6IHtcclxuICAgICAqICAgICAgIHRvcDogMTAwLFxyXG4gICAgICogICAgICAgYm90dG9tOiAxMDBcclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCBib3RoIHZhbHVlcyBhdCBvbmNlLlxyXG4gICAgICogICAgIHBhZGRpbmc6IDEwXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfcGFkZGluZzogPG51bWJlcnx7dG9wPzogbnVtYmVyOyBib3R0b20/OiBudW1iZXI7fT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5MiBheGlzLjxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkyIGF4aXMgd2hlbiB0aGVyZSBpcyBubyBkYXRhIG9uIGluaXQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRkZWZhdWx0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIGRlZmF1bHQ6IFswLCAxMDAwXVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfZGVmYXVsdDogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeTIgQXhpcy5cclxuICAgICAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHkyIEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxyXG4gICAgICpcclxuICAgICAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG4gICAgICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG4gICAgICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XHJcbiAgICAgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XHJcbiAgICAgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcclxuICAgICAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxyXG4gICAgICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRheGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxyXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogeTI6IHtcclxuICAgICAqICAgIGF4ZXM6IFtcclxuICAgICAqICAgICAge1xyXG4gICAgICogICAgICAgIC8vIGlmIHNldCwgd2lsbCBub3QgYmUgY29ycmVsYXRlZCB3aXRoIHRoZSBtYWluIHkyIEF4aXMgZG9tYWluIHZhbHVlXHJcbiAgICAgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXHJcbiAgICAgKiAgICAgICAgdGljazoge1xyXG4gICAgICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIGNvdW50OiAyLFxyXG4gICAgICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cclxuICAgICAqICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIC4uLlxyXG4gICAgICogICAgXVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX2F4ZXM6IFtdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFdpbmRvdyBvYmplY3RcclxuICogQG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuZXhwb3J0IHt3aW4gYXMgd2luZG93LCBkb2MgYXMgZG9jdW1lbnR9O1xyXG5cclxuY29uc3Qgd2luID0gKCgpID0+IHtcclxuXHRjb25zdCBkZWYgPSBvID0+IHR5cGVvZiBvICE9PSBcInVuZGVmaW5lZFwiICYmIG87XHJcblxyXG5cdHJldHVybiBkZWYoc2VsZikgfHwgZGVmKHdpbmRvdykgfHwgZGVmKGdsb2JhbCkgfHwgZGVmKGdsb2JhbFRoaXMpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcclxufSkoKTtcclxuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuXHJcbmNvbnN0IGRvYyA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge2V2ZW50IGFzIGQzRXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHticnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9ufSBmcm9tIFwiZDMtYnJ1c2hcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcInR5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQge1xyXG5cdGFzSGFsZlBpeGVsLFxyXG5cdGJydXNoRW1wdHksXHJcblx0Y2FsbEZuLFxyXG5cdGNhcGl0YWxpemUsXHJcblx0Y2VpbDEwLFxyXG5cdGNvbnZlcnRJbnB1dFR5cGUsXHJcblx0ZGlmZkRvbWFpbixcclxuXHRlbXVsYXRlRXZlbnQsXHJcblx0ZXh0ZW5kLFxyXG5cdGdldEJydXNoU2VsZWN0aW9uLFxyXG5cdGdldEJvdW5kaW5nUmVjdCxcclxuXHRnZXRDc3NSdWxlcyxcclxuXHRnZXRNaW5NYXgsXHJcblx0Z2V0T3B0aW9uLFxyXG5cdGdldFBhdGhCb3gsXHJcblx0Z2V0UmFuZG9tLFxyXG5cdGdldFJhbmdlLFxyXG5cdGdldFJlY3RTZWdMaXN0LFxyXG5cdGdldFRyYW5zbGF0aW9uLFxyXG5cdGdldFVuaXF1ZSxcclxuXHRoYXNWYWx1ZSxcclxuXHRpc0FycmF5LFxyXG5cdGlzQm9vbGVhbixcclxuXHRpc0RlZmluZWQsXHJcblx0aXNFbXB0eSxcclxuXHRpc0Z1bmN0aW9uLFxyXG5cdGlzTnVtYmVyLFxyXG5cdGlzT2JqZWN0LFxyXG5cdGlzT2JqZWN0VHlwZSxcclxuXHRpc1N0cmluZyxcclxuXHRpc1RhYlZpc2libGUsXHJcblx0aXNVbmRlZmluZWQsXHJcblx0aXNWYWx1ZSxcclxuXHRtZXJnZUFycmF5LFxyXG5cdG1lcmdlT2JqLFxyXG5cdG5vdEVtcHR5LFxyXG5cdHBhcnNlRGF0ZSxcclxuXHRzYW5pdGlzZSxcclxuXHRzZXRUZXh0VmFsdWUsXHJcblx0c29ydFZhbHVlLFxyXG5cdHRvQXJyYXksXHJcblx0dHBsUHJvY2Vzc1xyXG59O1xyXG5cclxuY29uc3QgaXNWYWx1ZSA9ICh2OiBhbnkpOiBib29sZWFuID0+IHYgfHwgdiA9PT0gMDtcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCI7XHJcbmNvbnN0IGlzU3RyaW5nID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XHJcbmNvbnN0IGlzTnVtYmVyID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XHJcbmNvbnN0IGlzVW5kZWZpbmVkID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwidW5kZWZpbmVkXCI7XHJcbmNvbnN0IGlzRGVmaW5lZCA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ICE9PSBcInVuZGVmaW5lZFwiO1xyXG5jb25zdCBpc0Jvb2xlYW4gPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCI7XHJcbmNvbnN0IGNlaWwxMCA9ICh2OiBhbnkpOiBudW1iZXIgPT4gTWF0aC5jZWlsKHYgLyAxMCkgKiAxMDtcclxuY29uc3QgYXNIYWxmUGl4ZWwgPSAobjogYW55KTogbnVtYmVyID0+IE1hdGguY2VpbChuKSArIDAuNTtcclxuY29uc3QgZGlmZkRvbWFpbiA9IChkOiBudW1iZXJbXSk6IG51bWJlciA9PiBkWzFdIC0gZFswXTtcclxuY29uc3QgaXNPYmplY3RUeXBlID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCI7XHJcbmNvbnN0IGlzRW1wdHkgPSAobzogYW55KTogYm9vbGVhbiA9PiAoXHJcblx0aXNVbmRlZmluZWQobykgfHwgbyA9PT0gbnVsbCB8fFxyXG5cdChpc1N0cmluZyhvKSAmJiBvLmxlbmd0aCA9PT0gMCkgfHxcclxuXHQoaXNPYmplY3RUeXBlKG8pICYmICEobyBpbnN0YW5jZW9mIERhdGUpICYmIE9iamVjdC5rZXlzKG8pLmxlbmd0aCA9PT0gMCkgfHxcclxuXHQoaXNOdW1iZXIobykgJiYgaXNOYU4obykpXHJcbik7XHJcbmNvbnN0IG5vdEVtcHR5ID0gKG86IGFueSk6IGJvb2xlYW4gPT4gIWlzRW1wdHkobyk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgaXMgYXJyYXlcclxuICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaXNBcnJheSA9IChhcnI6IGFueSk6IGJvb2xlYW4gPT4gQXJyYXkuaXNBcnJheShhcnIpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGlzIG9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaXNPYmplY3QgPSAob2JqOiBhbnkpOiBib29sZWFuID0+IG9iaiAmJiAhb2JqLm5vZGVUeXBlICYmIGlzT2JqZWN0VHlwZShvYmopICYmICFpc0FycmF5KG9iaik7XHJcblxyXG5mdW5jdGlvbiBnZXRPcHRpb24ob3B0aW9uczogb2JqZWN0LCBrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlKTogYW55IHtcclxuXHRyZXR1cm4gaXNEZWZpbmVkKG9wdGlvbnNba2V5XSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbHVlKGRpY3Q6IG9iamVjdCwgdmFsdWU6IGFueSk6IGJvb2xlYW4ge1xyXG5cdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRPYmplY3Qua2V5cyhkaWN0KS5mb3JFYWNoKGtleSA9PiAoZGljdFtrZXldID09PSB2YWx1ZSkgJiYgKGZvdW5kID0gdHJ1ZSkpO1xyXG5cclxuXHRyZXR1cm4gZm91bmQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxsIGZ1bmN0aW9uIHdpdGggYXJndW1lbnRzXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG4gKiBAcGFyYW0geyp9IGFyZ3MgQXJndW1lbnRzXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWU6IGZuIGlzIGZ1bmN0aW9uLCBmYWxzZTogZm4gaXMgbm90IGZ1bmN0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxsRm4oZm4sIC4uLmFyZ3MpOiBib29sZWFuIHtcclxuXHRjb25zdCBpc0ZuID0gaXNGdW5jdGlvbihmbik7XHJcblxyXG5cdGlzRm4gJiYgZm4uY2FsbCguLi5hcmdzKTtcclxuXHRyZXR1cm4gaXNGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2UgdGFnIHNpZ24gdG8gaHRtbCBlbnRpdHlcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzYW5pdGlzZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0cmV0dXJuIGlzU3RyaW5nKHN0cikgP1xyXG5cdFx0c3RyLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpIDogc3RyO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRleHQgdmFsdWUuIElmIHRoZXJlJ3MgbXVsdGlsaW5lIGFkZCBub2Rlcy5cclxuICogQHBhcmFtIHtkM1NlbGVjdGlvbn0gbm9kZSBUZXh0IG5vZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCB2YWx1ZSBzdHJpbmdcclxuICogQHBhcmFtIHtBcnJheX0gZHkgZHkgdmFsdWUgZm9yIG11bHRpbGluZWQgdGV4dFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRvTWlkZGxlIFRvIGJlIGFsaW5nbmVkIHZlcnRpY2FsbHkgbWlkZGxlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUZXh0VmFsdWUobm9kZTogZDNTZWxlY3Rpb24sIHRleHQ6IHN0cmluZywgZHk6IG51bWJlcltdID0gWy0xLCAxXSwgdG9NaWRkbGU6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG5cdGlmICghbm9kZSB8fCAhaXNTdHJpbmcodGV4dCkpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGlmICh0ZXh0LmluZGV4T2YoXCJcXG5cIikgPT09IC0xKSB7XHJcblx0XHRub2RlLnRleHQodGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNvbnN0IGRpZmYgPSBbbm9kZS50ZXh0KCksIHRleHRdLm1hcCh2ID0+IHYucmVwbGFjZSgvW1xcc1xcbl0vZywgXCJcIikpO1xyXG5cclxuXHRcdGlmIChkaWZmWzBdICE9PSBkaWZmWzFdKSB7XHJcblx0XHRcdGNvbnN0IG11bHRpbGluZSA9IHRleHQuc3BsaXQoXCJcXG5cIik7XHJcblx0XHRcdGNvbnN0IGxlbiA9IHRvTWlkZGxlID8gbXVsdGlsaW5lLmxlbmd0aCAtIDEgOiAxO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgdGV4dFxyXG5cdFx0XHRub2RlLmh0bWwoXCJcIik7XHJcblxyXG5cdFx0XHRtdWx0aWxpbmUuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdG5vZGUuYXBwZW5kKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBgJHtpID09PSAwID8gZHlbMF0gKiBsZW4gOiBkeVsxXX1lbWApXHJcblx0XHRcdFx0XHQudGV4dCh2KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBzdWJzdGl0dXRpb24gb2YgU1ZHUGF0aFNlZyBBUEkgcG9seWZpbGxcclxuZnVuY3Rpb24gZ2V0UmVjdFNlZ0xpc3QocGF0aDogU1ZHR3JhcGhpY3NFbGVtZW50KToge3g6IG51bWJlciwgeTogbnVtYmVyfVtdIHtcclxuXHQvKlxyXG5cdCAqIHNlZzEgLS0tLS0tLS0tLSBzZWcyXHJcblx0ICogICB8ICAgICAgICAgICAgICAgfFxyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcclxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XHJcblx0ICogc2VnMCAtLS0tLS0tLS0tIHNlZzNcclxuXHQgKiAqL1xyXG5cdGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IHBhdGguZ2V0QkJveCgpO1xyXG5cclxuXHRyZXR1cm4gW1xyXG5cdFx0e3gsIHk6IHkgKyBoZWlnaHR9LCAvLyBzZWcwXHJcblx0XHR7eCwgeX0sIC8vIHNlZzFcclxuXHRcdHt4OiB4ICsgd2lkdGgsIHl9LCAvLyBzZWcyXHJcblx0XHR7eDogeCArIHdpZHRoLCB5OiB5ICsgaGVpZ2h0fSAvLyBzZWczXHJcblx0XTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UGF0aEJveChwYXRoOiBTVkdHcmFwaGljc0VsZW1lbnQpOiB7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSB7XHJcblx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRjb25zdCBpdGVtcyA9IGdldFJlY3RTZWdMaXN0KHBhdGgpO1xyXG5cdGNvbnN0IHggPSBpdGVtc1swXS54O1xyXG5cdGNvbnN0IHkgPSBNYXRoLm1pbihpdGVtc1swXS55LCBpdGVtc1sxXS55KTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHgsIHksIHdpZHRoLCBoZWlnaHRcclxuXHR9O1xyXG59XHJcblxyXG4vLyByZXR1cm4gYnJ1c2ggc2VsZWN0aW9uIGFycmF5XHJcbmZ1bmN0aW9uIGdldEJydXNoU2VsZWN0aW9uKHskZWx9KSB7XHJcblx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xyXG5cdGNvbnN0IG1haW4gPSAkZWwuc3ViY2hhcnQubWFpbiB8fCAkZWwubWFpbjtcclxuXHRsZXQgc2VsZWN0aW9uO1xyXG5cclxuXHQvLyBjaGVjayBmcm9tIGV2ZW50XHJcblx0aWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiYnJ1c2hcIikge1xyXG5cdFx0c2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uO1xyXG5cdC8vIGNoZWNrIGZyb20gYnJ1c2ggYXJlYSBzZWxlY3Rpb25cclxuXHR9IGVsc2UgaWYgKG1haW4gJiYgKHNlbGVjdGlvbiA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5ub2RlKCkpKSB7XHJcblx0XHRzZWxlY3Rpb24gPSBkM0JydXNoU2VsZWN0aW9uKHNlbGVjdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc2VsZWN0aW9uO1xyXG59XHJcblxyXG4vLyBHZXQgYm91bmRpbmdDbGllbnRSZWN0LiBjYWNoZSB0aGUgZXZhbHVhdGVkIHZhbHVlIG9uY2UgaXQgd2FzIGNhbGxlZC5cclxuY29uc3QgZ2V0Qm91bmRpbmdSZWN0ID0gbm9kZSA9PiBub2RlLnJlY3QgfHwgKG5vZGUucmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG5cclxuLy8gcmV0cnVuIHJhbmRvbSBudW1iZXJcclxuZnVuY3Rpb24gZ2V0UmFuZG9tKGFzU3RyOiBib29sZWFuID0gdHJ1ZSk6IG51bWJlciB8IHN0cmluZyB7XHJcblx0Y29uc3QgcmFuZCA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG5cdHJldHVybiBhc1N0ciA/IFN0cmluZyhyYW5kKSA6IHJhbmQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJydXNoRW1wdHkoY3R4KSB7XHJcblx0Y29uc3Qgc2VsZWN0aW9uID0gZ2V0QnJ1c2hTZWxlY3Rpb24oY3R4KTtcclxuXHJcblx0aWYgKHNlbGVjdGlvbikge1xyXG5cdFx0Ly8gYnJ1c2ggc2VsZWN0ZWQgYXJlYVxyXG5cdFx0Ly8gdHdvLWRpbWVuc2lvbmFsOiBbW3gwLCB5MF0sIFt4MSwgeTFdXVxyXG5cdFx0Ly8gb25lLWRpbWVuc2lvbmFsOiBbeDAsIHgxXSBvciBbeTAsIHkxXVxyXG5cdFx0cmV0dXJuIHNlbGVjdGlvblswXSA9PT0gc2VsZWN0aW9uWzFdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQgPSB7fSwgc291cmNlKTogb2JqZWN0IHtcclxuXHRpZiAoaXNBcnJheShzb3VyY2UpKSB7XHJcblx0XHRzb3VyY2UuZm9yRWFjaCh2ID0+IGV4dGVuZCh0YXJnZXQsIHYpKTtcclxuXHR9XHJcblxyXG5cdC8vIGV4Y2x1ZGUgbmFtZSB3aXRoIG9ubHkgbnVtYmVyc1xyXG5cdGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcclxuXHRcdGlmICgvXlxcZCskLy50ZXN0KHApKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gZmlyc3QgbGV0dGVyIGNhcGl0YWxpemVkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7U3RyaW5nfSBjYXBpdGFsaXplZCBzdHJpbmdcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdG8gYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IHZcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9BcnJheSA9ICh2OiBDU1NTdHlsZURlY2xhcmF0aW9uIHwgYW55KTogYW55ID0+IFtdLnNsaWNlLmNhbGwodik7XHJcblxyXG4vKipcclxuICogR2V0IGNzcyBydWxlcyBmb3Igc3BlY2lmaWVkIHN0eWxlc2hlZXRzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlU2hlZXRzIFRoZSBzdHlsZXNoZWV0cyB0byBnZXQgdGhlIHJ1bGVzIGZyb21cclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q3NzUnVsZXMoc3R5bGVTaGVldHM6IGFueVtdKSB7XHJcblx0bGV0IHJ1bGVzID0gW107XHJcblxyXG5cdHN0eWxlU2hlZXRzLmZvckVhY2goc2hlZXQgPT4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0aWYgKHNoZWV0LmNzc1J1bGVzICYmIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJ1bGVzID0gcnVsZXMuY29uY2F0KHRvQXJyYXkoc2hlZXQuY3NzUnVsZXMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSByZWFkaW5nIHJ1bGVzIGZyb20gJHtzaGVldC5ocmVmfTogJHtlLnRvU3RyaW5nKCl9YCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBydWxlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIFNWR01hdHJpeCBvZiBhbiBTVkdFbGVtZW50XHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtTVkdNYXRyaXh9IG1hdHJpeFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obm9kZSkge1xyXG5cdGNvbnN0IHRyYW5zZm9ybSA9IG5vZGUgPyBub2RlLnRyYW5zZm9ybSA6IG51bGw7XHJcblx0Y29uc3QgYmFzZVZhbCA9IHRyYW5zZm9ybSA/IHRyYW5zZm9ybS5iYXNlVmFsIDogW107XHJcblxyXG5cdHJldHVybiBiYXNlVmFsLmxlbmd0aCA/IGJhc2VWYWwuZ2V0SXRlbSgwKS5tYXRyaXggOiB7YTogMCwgYjogMCwgYzogMCwgZDogMCwgZTogMCwgZjogMH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdW5pcXVlIHZhbHVlIGZyb20gYXJyYXlcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YVxyXG4gKiBAcmV0dXJuIHtBcnJheX0gVW5pcXVlIGFycmF5IHZhbHVlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRVbmlxdWUoZGF0YTogYW55W10pOiBhbnlbXSB7XHJcblx0Y29uc3QgaXNEYXRlID0gZGF0YVswXSBpbnN0YW5jZW9mIERhdGU7XHJcblx0Y29uc3QgZCA9IChpc0RhdGUgPyBkYXRhLm1hcChOdW1iZXIpIDogZGF0YSlcclxuXHRcdC5maWx0ZXIoKHYsIGksIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2KSA9PT0gaSk7XHJcblxyXG5cdHJldHVybiBpc0RhdGUgPyBkLm1hcCh2ID0+IG5ldyBEYXRlKHYpKSA6IGQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBhcnJheVxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUFycmF5KGFycjogYW55W10pOiBhbnlbXSB7XHJcblx0cmV0dXJuIGFyciAmJiBhcnIubGVuZ3RoID8gYXJyLnJlZHVjZSgocCwgYykgPT4gcC5jb25jYXQoYykpIDogW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBvYmplY3QgcmV0dXJuaW5nIG5ldyBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0TlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBtZXJnZWQgdGFyZ2V0IG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VPYmoodGFyZ2V0OiBvYmplY3QsIC4uLm9iamVjdE4pOiBhbnkge1xyXG5cdGlmICghb2JqZWN0Ti5sZW5ndGggfHwgKG9iamVjdE4ubGVuZ3RoID09PSAxICYmICFvYmplY3ROWzBdKSkge1xyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHNvdXJjZSA9IG9iamVjdE4uc2hpZnQoKTtcclxuXHJcblx0aWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xyXG5cdFx0T2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XHJcblxyXG5cdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHRcdFx0IXRhcmdldFtrZXldICYmICh0YXJnZXRba2V5XSA9IHt9KTtcclxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlT2JqKHRhcmdldFtrZXldLCB2YWx1ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBpc0FycmF5KHZhbHVlKSA/XHJcblx0XHRcdFx0XHR2YWx1ZS5jb25jYXQoKSA6IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBtZXJnZU9iaih0YXJnZXQsIC4uLm9iamVjdE4pO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydCB2YWx1ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHZhbHVlIHRvIGJlIHNvcnRlZFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQXNjIHRydWU6IGFzYywgZmFsc2U6IGRlc2NcclxuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ3xEYXRlfSBzb3J0ZWQgZGF0ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ydFZhbHVlKGRhdGE6IGFueVtdLCBpc0FzYyA9IHRydWUpOiBhbnlbXSB7XHJcblx0bGV0IGZuO1xyXG5cclxuXHRpZiAoZGF0YVswXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdGZuID0gaXNBc2MgPyAoYSwgYikgPT4gYSAtIGIgOiAoYSwgYikgPT4gYiAtIGE7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmIChpc0FzYyAmJiAhZGF0YS5ldmVyeShpc05hTikpIHtcclxuXHRcdFx0Zm4gPSAoYSwgYikgPT4gYSAtIGI7XHJcblx0XHR9IGVsc2UgaWYgKCFpc0FzYykge1xyXG5cdFx0XHRmbiA9IChhLCBiKSA9PiAoYSA+IGIgJiYgLTEpIHx8IChhIDwgYiAmJiAxKSB8fCAoYSA9PT0gYiAmJiAwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBkYXRhLmNvbmNhdCgpLnNvcnQoZm4pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgJ21pbicgb3IgJ21heCdcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBcnJheSBkYXRhIHZhbHVlXHJcbiAqIEByZXR1biB7TnVtYmVyfERhdGV8dW5kZWZpbmVkfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWluTWF4KHR5cGU6IFwibWluXCIgfCBcIm1heFwiLCBkYXRhOiBudW1iZXJbXSB8IERhdGVbXSB8IGFueSkge1xyXG5cdGxldCByZXMgPSBkYXRhLmZpbHRlcih2ID0+IG5vdEVtcHR5KHYpKTtcclxuXHJcblx0aWYgKHJlcy5sZW5ndGgpIHtcclxuXHRcdGlmIChpc051bWJlcihyZXNbMF0pKSB7XHJcblx0XHRcdHJlcyA9IE1hdGhbdHlwZV0oLi4ucmVzKTtcclxuXHRcdH0gZWxzZSBpZiAocmVzWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRyZXMgPSBzb3J0VmFsdWUocmVzLCB0eXBlID09PSBcIm1pblwiKVswXTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCByYW5nZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgbnVtYmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIG51bWJlclxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyW10ge1xyXG5cdGNvbnN0IHJlczogbnVtYmVyW10gPSBbXTtcclxuXHJcblx0Zm9yIChsZXQgaTogbnVtYmVyID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG5cdFx0cmVzLnB1c2goaSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vLyBlbXVsYXRlIGV2ZW50XHJcbmNvbnN0IGVtdWxhdGVFdmVudCA9IHtcclxuXHRtb3VzZTogKCgpID0+IHtcclxuXHRcdGNvbnN0IGdldFBhcmFtcyA9ICgpID0+ICh7XHJcblx0XHRcdGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgc2NyZWVuWDogMCwgc2NyZWVuWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xyXG5cdFx0XHRuZXcgTW91c2VFdmVudChcInRcIik7XHJcblxyXG5cdFx0XHRyZXR1cm4gKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xyXG5cdFx0XHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpKTtcclxuXHRcdFx0fTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Ly8gUG9seWZpbGxzIERPTTQgTW91c2VFdmVudFxyXG5cdFx0XHRyZXR1cm4gKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG1vdXNlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XHJcblxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2luaXRNb3VzZUV2ZW50XHJcblx0XHRcdFx0bW91c2VFdmVudC5pbml0TW91c2VFdmVudChcclxuXHRcdFx0XHRcdGV2ZW50VHlwZSxcclxuXHRcdFx0XHRcdHBhcmFtcy5idWJibGVzLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmNhbmNlbGFibGUsXHJcblx0XHRcdFx0XHR3aW5kb3csXHJcblx0XHRcdFx0XHQwLCAvLyB0aGUgZXZlbnQncyBtb3VzZSBjbGljayBjb3VudFxyXG5cdFx0XHRcdFx0cGFyYW1zLnNjcmVlblgsIHBhcmFtcy5zY3JlZW5ZLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmNsaWVudFgsIHBhcmFtcy5jbGllbnRZLFxyXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGxcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH0pKCksXHJcblx0dG91Y2g6IChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zOiBhbnkpID0+IHtcclxuXHRcdGNvbnN0IHRvdWNoT2JqID0gbmV3IFRvdWNoKG1lcmdlT2JqKHtcclxuXHRcdFx0aWRlbnRpZmllcjogRGF0ZS5ub3coKSxcclxuXHRcdFx0dGFyZ2V0OiBlbCxcclxuXHRcdFx0cmFkaXVzWDogMi41LFxyXG5cdFx0XHRyYWRpdXNZOiAyLjUsXHJcblx0XHRcdHJvdGF0aW9uQW5nbGU6IDEwLFxyXG5cdFx0XHRmb3JjZTogMC41XHJcblx0XHR9LCBwYXJhbXMpKTtcclxuXHJcblx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBUb3VjaEV2ZW50KGV2ZW50VHlwZSwge1xyXG5cdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxyXG5cdFx0XHRidWJibGVzOiB0cnVlLFxyXG5cdFx0XHRzaGlmdEtleTogdHJ1ZSxcclxuXHRcdFx0dG91Y2hlczogW3RvdWNoT2JqXSxcclxuXHRcdFx0dGFyZ2V0VG91Y2hlczogW10sXHJcblx0XHRcdGNoYW5nZWRUb3VjaGVzOiBbdG91Y2hPYmpdXHJcblx0XHR9KSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlICAmIHJldHVybiBib3VuZCBzdHJpbmdcclxuICogQHBhcmFtIHtTdHJpbmd9IHRwbCBUZW1wbGF0ZSBzdHJpbmdcclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSB2YWx1ZSB0byBiZSByZXBsYWNlZFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0cGxQcm9jZXNzKHRwbDogc3RyaW5nLCBkYXRhOiBvYmplY3QpOiBzdHJpbmcge1xyXG5cdGxldCByZXMgPSB0cGw7XHJcblxyXG5cdGZvciAoY29uc3QgeCBpbiBkYXRhKSB7XHJcblx0XHRyZXMgPSByZXMucmVwbGFjZShuZXcgUmVnRXhwKGB7PSR7eH19YCwgXCJnXCIpLCBkYXRhW3hdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcGFyc2VkIGRhdGUgdmFsdWVcclxuICogKEl0IG11c3QgYmUgY2FsbGVkIGluICdDaGFydEludGVybmFsJyBjb250ZXh0KVxyXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSBWYWx1ZSBvZiBkYXRlIHRvIGJlIHBhcnNlZFxyXG4gKiBAcmV0dXJuIHtEYXRlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGU6IERhdGUgfCBzdHJpbmcgfCBudW1iZXIpOiBEYXRlIHtcclxuXHRsZXQgcGFyc2VkRGF0ZTtcclxuXHJcblx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRwYXJzZWREYXRlID0gZGF0ZTtcclxuXHR9IGVsc2UgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXR9ID0gdGhpcztcclxuXHJcblx0XHRwYXJzZWREYXRlID0gZm9ybWF0LmRhdGFUaW1lKGNvbmZpZy5kYXRhX3hGb3JtYXQpKGRhdGUpO1xyXG5cdH0gZWxzZSBpZiAoaXNOdW1iZXIoZGF0ZSkgJiYgIWlzTmFOKGRhdGUpKSB7XHJcblx0XHRwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFwYXJzZWREYXRlIHx8IGlzTmFOKCtwYXJzZWREYXRlKSkge1xyXG5cdFx0Y29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSB4ICcke2RhdGV9JyB0byBEYXRlIG9iamVjdGApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBhcnNlZERhdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gaWYgdGhlIGN1cnJlbnQgZG9jIGlzIHZpc2libGUgb3Igbm90XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RhYlZpc2libGUoKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuICFkb2N1bWVudC5oaWRkZW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgaW5wdXQgdHlwZVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFwibW91c2VcIiB8IFwidG91Y2hcIiB8IG51bGxcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRJbnB1dFR5cGUobW91c2UsIHRvdWNoKTogXCJtb3VzZVwiIHwgXCJ0b3VjaFwiIHwgbnVsbCB7XHJcblx0bGV0IGlzTW9iaWxlID0gZmFsc2U7XHJcblxyXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQnJvd3Nlcl9kZXRlY3Rpb25fdXNpbmdfdGhlX3VzZXJfYWdlbnQjTW9iaWxlX1RhYmxldF9vcl9EZXNrdG9wXHJcblx0aWYgKC9Nb2JpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSAmJiB0b3VjaCkge1xyXG5cdFx0Ly8gU29tZSBFZGdlIGRlc2t0b3AgcmV0dXJuIHRydWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzIwNDE3MDc0L1xyXG5cdFx0Y29uc3QgaGFzVG91Y2hQb2ludHMgPSB3aW5kb3cubmF2aWdhdG9yICYmIFwibWF4VG91Y2hQb2ludHNcIiBpbiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xyXG5cclxuXHRcdC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL3RvdWNoZXZlbnRzLmpzXHJcblx0XHQvLyBPbiBJRTExIHdpdGggSUU5IGVtdWxhdGlvbiBtb2RlLCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSBpcyByZXR1cm5pbmcgdHJ1ZVxyXG5cdFx0Y29uc3QgaGFzVG91Y2ggPSAoXCJvbnRvdWNobW92ZVwiIGluIHdpbmRvdyB8fCAod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkpO1xyXG5cclxuXHRcdGlzTW9iaWxlID0gaGFzVG91Y2hQb2ludHMgfHwgaGFzVG91Y2g7XHJcblx0fVxyXG5cclxuXHRjb25zdCBoYXNNb3VzZSA9IG1vdXNlICYmICFpc01vYmlsZSA/IChcIm9ubW91c2VvdmVyXCIgaW4gd2luZG93KSA6IGZhbHNlO1xyXG5cclxuXHRyZXR1cm4gKGhhc01vdXNlICYmIFwibW91c2VcIikgfHwgKGlzTW9iaWxlICYmIFwidG91Y2hcIikgfHwgbnVsbDtcclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB4IGZyb20gXCIuL3hcIjtcclxuaW1wb3J0IHkgZnJvbSBcIi4veVwiO1xyXG5pbXBvcnQgeTIgZnJvbSBcIi4veTJcIjtcclxuXHJcbmltcG9ydCB7bWVyZ2VPYmp9IGZyb20gXCIuLi8uLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuIC8qKlxyXG4gKiB5IEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBtZXJnZU9iaih7XHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaCB4IGFuZCB5IGF4aXMgcG9zaXRpb24uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkcm90YXRlZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHJvdGF0ZWQ6IHRydWVcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc19yb3RhdGVkOiBmYWxzZVxyXG59LCB4LCB5LCB5Mik7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGdyaWQgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbnR5cGUgTGluZXMgPSB7dmFsdWU/OiBudW1iZXI7IHRleHQ/OiBzdHJpbmc7IGNsYXNzPzogc3RyaW5nOyBwb3NpdGlvbj86IHN0cmluZ31bXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHJlbGF0ZWQgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgZ3JpZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmcm9udD1mYWxzZV0gU2V0ICdncmlkICYgZm9jdXMgbGluZXMnIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBncmlkIGxpbmVzIGFuZCBjaGFydCBlbGVtZW50cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3guc2hvdz1mYWxzZV0gU2hvdyBncmlkcyBhbG9uZyB4IGF4aXMuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBbeC5saW5lcz1bXV0gU2hvdyBhZGRpdGlvbmFsIGdyaWQgbGluZXMgYWxvbmcgeCBheGlzLjxicj5cclxuICAgICAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy4gdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzIGFyZSBvcHRpb25hbC4gRm9yIHBvc2l0aW9uLCBzdGFydCwgbWlkZGxlIGFuZCBlbmQgKGRlZmF1bHQpIGFyZSBhdmFpbGFibGUuXHJcbiAgICAgKiAgSWYgeCBheGlzIGlzIGNhdGVnb3J5IGF4aXMsIHZhbHVlIGNhbiBiZSBjYXRlZ29yeSBuYW1lLiBJZiB4IGF4aXMgaXMgdGltZXNlcmllcyBheGlzLCB2YWx1ZSBjYW4gYmUgZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IGFuZCB1bml4dGltZSBpbnRlZ2VyLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbeS5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt5LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB5IGF4aXMuPGJyPlxyXG4gICAgICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt5LnRpY2tzPTEwXSBOdW1iZXIgb2YgeSBncmlkcyB0byBiZSBzaG93bi5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLmVkZ2U9ZmFsc2VdIFNob3cgZWRnZWQgZm9jdXMgZ3JpZCBsaW5lLjxicj4qKk5PVEU6KiogQXZhaWxhYmxlIHdoZW4gW2B0b29sdGlwLmdyb3VwZWQ9ZmFsc2VgXSgjLnRvb2x0aXApIG9wdGlvbiBpcyBzZXQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmb2N1cy5zaG93PXRydWVdIFNob3cgZ3JpZCBsaW5lIHdoZW4gZm9jdXMuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmb2N1cy55PWZhbHNlXSBTaG93IHkgY29vcmRpbmF0ZSBmb2N1cyBncmlkIGxpbmUuPGJyPioqTk9URToqKiBBdmFpbGFibGUgd2hlbiBbYHRvb2x0aXAuZ3JvdXBlZD1mYWxzZWBdKCMudG9vbHRpcCkgb3B0aW9uIGlzIHNldC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmVzLmZyb250PXRydWVdIFNldCBncmlkIGxpbmVzIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBjaGFydCBlbGVtZW50cy5cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuR3JpZExpbmVzKVxyXG4gICAgICogQHNlZSBbRGVtbzogWCBHcmlkIExpbmVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5PcHRpb25hbFhHcmlkTGluZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBZIEdyaWQgTGluZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNHcmlkLk9wdGlvbmFsWUdyaWRMaW5lcylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBncmlkOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBzaG93OiB0cnVlLFxyXG4gICAgICogICAgIGxpbmVzOiBbXHJcbiAgICAgKiAgICAgICB7dmFsdWU6IDIsIHRleHQ6IFwiTGFiZWwgb24gMlwifSxcclxuICAgICAqICAgICAgIHt2YWx1ZTogNSwgdGV4dDogXCJMYWJlbCBvbiA1XCIsIGNsYXNzOiBcImxhYmVsLTVcIn0sXHJcbiAgICAgKiAgICAgICB7dmFsdWU6IDYsIHRleHQ6IFwiTGFiZWwgb24gNlwiLCBwb3NpdGlvbjogXCJzdGFydFwifVxyXG4gICAgICogICAgIF1cclxuICAgICAqICAgfSxcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgbGluZXM6IFtcclxuICAgICAqICAgICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIG9uIDEwMFwifSxcclxuICAgICAqICAgICAgIHt2YWx1ZTogMjAwLCB0ZXh0OiBcIkxhYmVsIG9uIDIwMFwiLCBjbGFzczogXCJsYWJlbC0yMDBcIn0sXHJcbiAgICAgKiAgICAgICB7dmFsdWU6IDMwMCwgdGV4dDogXCJMYWJlbCBvbiAzMDBcIiwgcG9zaXRpb246ICdtaWRkbGUnfVxyXG4gICAgICogICAgIF0sXHJcbiAgICAgKiAgICAgdGlja3M6IDVcclxuICAgICAqICAgfSxcclxuICAgICAqICAgZnJvbnQ6IHRydWUsXHJcbiAgICAgKiAgIGZvY3VzOiB7XHJcbiAgICAgKiAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gQmVsb3cgb3B0aW9ucyBhcmUgYXZhaWxhYmxlIHdoZW4gJ3Rvb2x0aXAuZ3JvdXBlZD1mYWxzZScgb3B0aW9uIGlzIHNldFxyXG4gICAgICogICAgICBlZGdlOiB0cnVlLFxyXG4gICAgICogICAgICB5OiB0cnVlXHJcbiAgICAgKiAgIH0sXHJcbiAgICAgKiAgIGxpbmVzOiB7XHJcbiAgICAgKiAgICAgIGZyb250OiBmYWxzZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGdyaWRfeF9zaG93OiBmYWxzZSxcclxuICAgIGdyaWRfeF90eXBlOiBcInRpY2tcIixcclxuICAgIGdyaWRfeF9saW5lczogPExpbmVzPiBbXSxcclxuICAgIGdyaWRfeV9zaG93OiBmYWxzZSxcclxuICAgIGdyaWRfeV9saW5lczogPExpbmVzPiBbXSxcclxuICAgIGdyaWRfeV90aWNrczogMTAsXHJcbiAgICBncmlkX2ZvY3VzX2VkZ2U6IGZhbHNlLFxyXG4gICAgZ3JpZF9mb2N1c19zaG93OiB0cnVlLFxyXG4gICAgZ3JpZF9mb2N1c195OiBmYWxzZSxcclxuICAgIGdyaWRfZnJvbnQ6IGZhbHNlLFxyXG4gICAgZ3JpZF9saW5lc19mcm9udDogdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBwb2ludCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcG9pbnQgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgcG9pbnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9pbnQuc2hvdz10cnVlXSBXaGV0aGVyIHRvIHNob3cgZWFjaCBwb2ludCBpbiBsaW5lLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtwb2ludC5yPTIuNV0gVGhlIHJhZGl1cyBzaXplIG9mIGVhY2ggcG9pbnQuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogRGlzYWJsZWQgZm9yICdidWJibGUnIHR5cGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BvaW50LmZvY3VzLmV4cGFuZC5lbmFibGVkPXRydWVdIFdoZXRoZXIgdG8gZXhwYW5kIGVhY2ggcG9pbnQgb24gZm9jdXMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BvaW50LmZvY3VzLmV4cGFuZC5yPXBvaW50LnIqMS43NV0gVGhlIHJhZGl1cyBzaXplIG9mIGVhY2ggcG9pbnQgb24gZm9jdXMuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogRm9yICdidWJibGUnIHR5cGUsIHRoZSBkZWZhdWx0IGlzIGBidWJibGVTaXplKjEuMTVgXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BvaW50LnNlbnNpdGl2aXR5PTEwXSBUaGUgc2Vuc3Rpdml0eSB2YWx1ZSBmb3IgaW50ZXJhY3Rpb24gYm91bmRhcnkuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BvaW50LnNlbGVjdC5yPXBvaW50LnIqNF0gVGhlIHJhZGl1cyBzaXplIG9mIGVhY2ggcG9pbnQgb24gc2VsZWN0ZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3BvaW50LnR5cGU9XCJjaXJjbGVcIl0gVGhlIHR5cGUgb2YgcG9pbnQgdG8gYmUgZHJhd25cclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgIC0gSWYgY2hhcnQgaGFzICdidWJibGUnIHR5cGUsIG9ubHkgY2lyY2xlIGNhbiBiZSB1c2VkLlxyXG4gICAgICogICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxyXG4gICAgICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqICAgLSBjaXJjbGVcclxuICAgICAqICAgLSByZWN0YW5nbGVcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtwb2ludC5wYXR0ZXJuPVtdXSBUaGUgdHlwZSBvZiBwb2ludCBvciBzdmcgc2hhcGUgYXMgc3RyaW5nLCB0byBiZSBkcmF3biBmb3IgZWFjaCBsaW5lXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogICAtIFRoaXMgaXMgYW4gYGV4cGVyaW1lbnRhbGAgZmVhdHVyZSBhbmQgY2FuIGhhdmUgc29tZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cclxuICAgICAqICAgLSBJZiBjaGFydCBoYXMgJ2J1YmJsZScgdHlwZSwgb25seSBjaXJjbGUgY2FuIGJlIHVzZWQuXHJcbiAgICAgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXHJcbiAgICAgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogICAtIGNpcmNsZVxyXG4gICAgICogICAtIHJlY3RhbmdsZVxyXG4gICAgICogICAtIHN2ZyBzaGFwZSB0YWcgaW50ZXJwcmV0ZWQgYXMgc3RyaW5nPGJyPlxyXG4gICAgICogICAgIChleC4gYDxwb2x5Z29uIHBvaW50cz0nMi41IDAgMCA1IDUgNSc+PC9wb2x5Z29uPmApXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBwb2ludCB0eXBlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUG9pbnQuUmVjdGFuZ2xlUG9pbnRzKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBwb2ludDoge1xyXG4gICAgICogICAgICBzaG93OiBmYWxzZSxcclxuICAgICAqICAgICAgcjogNSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIGN1c3RvbWl6ZSB0aGUgcmFkaXVzXHJcbiAgICAgKiAgICAgIHI6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBmb2N1czoge1xyXG4gICAgICogICAgICAgICAgZXhwYW5kOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAqICAgICAgICAgICAgICByOiAxXHJcbiAgICAgKiAgICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHNlbGVjdDoge1xyXG4gICAgICogICAgICAgICAgcjogM1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gaGF2aW5nIGxvd2VyIHZhbHVlLCBtZWFucyBob3cgY2xvc2VyIHRvIGJlIGZvciBpbnRlcmFjdGlvblxyXG4gICAgICogICAgICBzZW5zaXRpdml0eTogMyxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHZhbGlkIHZhbHVlcyBhcmUgXCJjaXJjbGVcIiBvciBcInJlY3RhbmdsZVwiXHJcbiAgICAgKiAgICAgIHR5cGU6IFwicmVjdGFuZ2xlXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBvciBpbmRpY2F0ZSBhcyBwYXR0ZXJuXHJcbiAgICAgKiAgICAgIHBhdHRlcm46IFtcclxuICAgICAqICAgICAgICBcImNpcmNsZVwiLFxyXG4gICAgICogICAgICAgIFwicmVjdGFuZ2xlXCIsXHJcbiAgICAgKiAgICAgICAgXCI8cG9seWdvbiBwb2ludHM9JzAgNiA0IDAgLTQgMCc+PC9wb2x5Z29uPlwiXHJcbiAgICAgKiAgICAgXSxcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHBvaW50X3Nob3c6IHRydWUsXHJcbiAgICBwb2ludF9yOiAyLjUsXHJcbiAgICBwb2ludF9zZW5zaXRpdml0eTogMTAsXHJcbiAgICBwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBvaW50X2ZvY3VzX2V4cGFuZF9yOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgcG9pbnRfcGF0dGVybjogPHN0cmluZ1tdPiBbXSxcclxuICAgIHBvaW50X3NlbGVjdF9yOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgcG9pbnRfdHlwZTogXCJjaXJjbGVcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHN1YmNoYXJ0IG9wdGlvbnNcclxuICAgICAqIEBuYW1lIHN1YmNoYXJ0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LnNob3c9ZmFsc2VdIFNob3cgc3ViIGNoYXJ0IG9uIHRoZSBib3R0b20gb2YgdGhlIGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLngudGljay50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N1YmNoYXJ0LnNpemUuaGVpZ2h0XSBDaGFuZ2UgdGhlIGhlaWdodCBvZiB0aGUgc3ViY2hhcnQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbc3ViY2hhcnQub25icnVzaF0gU2V0IGNhbGxiYWNrIGZvciBicnVzaCBldmVudC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBjdXJyZW50IHpvb21lZCB4IGRvbWFpbi5cclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5TdWJDaGFydClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgc3ViY2hhcnQ6IHtcclxuICAgICAqICAgICAgYXhpczoge1xyXG4gICAgICogICAgICBcdHg6IHtcclxuICAgICAqICAgICAgXHQgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgIFx0ICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgXHQgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICogICAgICBcdCAgICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgXHQgICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgICAgIFx0ICAgICAgfVxyXG4gICAgICogICAgICBcdCAgICB9XHJcbiAgICAgKiAgICAgIFx0fVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBzaG93OiB0cnVlLFxyXG4gICAgICogICAgICBzaXplOiB7XHJcbiAgICAgKiAgICAgICAgICBoZWlnaHQ6IDIwXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIG9uYnJ1c2g6IGZ1bmN0aW9uKGRvbWFpbikgeyAuLi4gfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgc3ViY2hhcnRfc2hvdzogZmFsc2UsXHJcbiAgICBzdWJjaGFydF9zaXplX2hlaWdodDogNjAsXHJcbiAgICBzdWJjaGFydF9heGlzX3hfc2hvdzogdHJ1ZSxcclxuICAgIHN1YmNoYXJ0X2F4aXNfeF90aWNrX3Nob3c6IHRydWUsXHJcbiAgICBzdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcbiAgICBzdWJjaGFydF9vbmJydXNoOiAoKSA9PiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB6b29tIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB6b29tIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIHpvb21cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5lbmFibGVkPWZhbHNlXSBFbmFibGUgem9vbWluZy5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbem9vbS5lbmFibGVkLnR5cGU9J3doZWVsJ10gU2V0IHpvb20gaW50ZXJhY3Rpb24gdHlwZS5cclxuICAgICAqICAtICoqQXZhaWxhYmxlIHR5cGVzOioqXHJcbiAgICAgKiAgICAtIHdoZWVsXHJcbiAgICAgKiAgICAtIGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3pvb20ucmVzY2FsZT1mYWxzZV0gRW5hYmxlIHRvIHJlc2NhbGUgYWZ0ZXIgem9vbWluZy48YnI+XHJcbiAgICAgKiAgSWYgdHJ1ZSBzZXQsIHkgZG9tYWluIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHpvb21lZCByZWdpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBbem9vbS5leHRlbnQ9WzEsIDEwXV0gQ2hhbmdlIHpvb20gZXh0ZW50LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8RGF0ZX0gW3pvb20ueC5taW5dIFNldCB4IEF4aXMgbWluaW11bSB6b29tIHJhbmdlXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1heF0gU2V0IHggQXhpcyBtYXhpbXVtIHpvb20gcmFuZ2VcclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbXN0YXJ0PXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gem9vbWluZyBzdGFydHMuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbSBldmVudC5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbT11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjaGFydCBpcyB6b29taW5nLjxicj5cclxuICAgICAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHpvb21lZCBkb21haW4uXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb21lbmQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIGVuZHMuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxPYmplY3R9IFt6b29tLnJlc2V0QnV0dG9uPXRydWVdIFNldCB0byBkaXNwbGF5IHpvb20gcmVzZXQgYnV0dG9uIGZvciAnZHJhZycgdHlwZSB6b29tXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5yZXNldEJ1dHRvbi5vbmNsaWNrXSBTZXQgY2FsbGJhY2sgd2hlbiBjbGlja3MgdGhlIHJlc2V0IGJ1dHRvbi4gVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSByZXNldCBidXR0b24gZWxlbWVudCByZWZlcmVuY2UgYXMgYXJndW1lbnQuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3pvb20ucmVzZXRCdXR0b24udGV4dD0nUmVzZXQgWm9vbSddIFRleHQgdmFsdWUgZm9yIHpvb20gcmVzZXQgYnV0dG9uLlxyXG4gICAgICogQHNlZSBbRGVtbzp6b29tXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uWm9vbSlcclxuICAgICAqIEBzZWUgW0RlbW86ZHJhZyB6b29tXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uRHJhZ1pvb20pXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHpvb206IHtcclxuICAgICAqICAgICAgZW5hYmxlZDoge1xyXG4gICAgICogICAgICAgICAgdHlwZTogXCJkcmFnXCJcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgcmVzY2FsZTogdHJ1ZSxcclxuICAgICAqICAgICAgZXh0ZW50OiBbMSwgMTAwXSAgLy8gZW5hYmxlIG1vcmUgem9vbWluZ1xyXG4gICAgICogICAgICB4OiB7XHJcbiAgICAgKiAgICAgICAgICBtaW46IC0xLCAgLy8gc2V0IG1pbiByYW5nZVxyXG4gICAgICogICAgICAgICAgbWF4OiAxMCAgLy8gc2V0IG1heCByYW5nZVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBvbnpvb21zdGFydDogZnVuY3Rpb24oZXZlbnQpIHsgLi4uIH0sXHJcbiAgICAgKiAgICAgIG9uem9vbTogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxyXG4gICAgICogICAgICBvbnpvb21lbmQ6IGZ1bmN0aW9uKGRvbWFpbikgeyAuLi4gfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNob3cgcmVzZXQgYnV0dG9uIHdoZW4gaXMgem9vbWVkLWluXHJcbiAgICAgKiAgICAgIHJlc2V0QnV0dG9uOiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgcmVzZXRCdXR0b246IHtcclxuICAgICAqICAgICAgICAgIC8vIG9uY2xpY2sgY2FsbGJhY2sgd2hlbiByZXNldCBidXR0b24gaXMgY2xpY2tlZFxyXG4gICAgICogICAgICAgICAgb25jbGljazogZnVuY3Rpb24oYnV0dG9uKSB7XHJcbiAgICAgKiAgICAgICAgICAgIGJ1dHRvbjsgLy8gUmVzZXQgYnV0dG9uIGVsZW1lbnQgcmVmZXJlbmNlXHJcbiAgICAgKiAgICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyBjdXN0b21pemVkIHRleHQgdmFsdWUgZm9yIHJlc2V0IHpvb20gYnV0dG9uXHJcbiAgICAgKiAgICAgICAgICB0ZXh0OiBcIlVuem9vbVwiXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHpvb21fZW5hYmxlZDogPHt0eXBlOiBcIndoZWVsXCIgfCBcImRyYWdcIn18Ym9vbGVhbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIHpvb21fZXh0ZW50OiA8bnVtYmVyW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB6b29tX3ByaXZpbGVnZWQ6IGZhbHNlLFxyXG4gICAgem9vbV9yZXNjYWxlOiBmYWxzZSxcclxuICAgIHpvb21fb256b29tOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB6b29tX29uem9vbXN0YXJ0OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB6b29tX29uem9vbWVuZDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgem9vbV9yZXNldEJ1dHRvbjogPHt0ZXh0OiBzdHJpbmc7fXxib29sZWFuPiB0cnVlLFxyXG4gICAgem9vbV94X21pbjogPE51bWJlcnxEYXRlfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgem9vbV94X21heDogPE51bWJlcnxEYXRlfHVuZGVmaW5lZD4gdW5kZWZpbmVkXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGFyZWEgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFyZWEgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgYXJlYVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthcmVhLnplcm9iYXNlZD10cnVlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYXJlYSBjaGFydC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FyZWEuYWJvdmU9ZmFsc2VdIFNldCBiYWNrZ3JvdW5kIGFyZWEgYWJvdmUgdGhlIGRhdGEgY2hhcnQgbGluZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxPYmplY3R9IFthcmVhLmxpbmVhckdyYWRpZW50PWZhbHNlXSBTZXQgdGhlIGxpbmVhciBncmFkaWVudCBvbiBhcmVhLjxicj48YnI+XHJcbiAgICAgKiBPciBjdXN0b21pemUgYnkgZ2l2aW5nIGJlbG93IG9iamVjdCB2YWx1ZTpcclxuICAgICAqICAtIHgge0FycmF5fTogYHgxYCwgYHgyYCB2YWx1ZVxyXG4gICAgICogIC0geSB7QXJyYXl9OiBgeTFgLCBgeTJgIHZhbHVlXHJcbiAgICAgKiAgLSBzdG9wcyB7QXJyYXl9OiBFYWNoIGl0ZW0gc2hvdWxkIGJlIGhhdmluZyBgW29mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XWAgdmFsdWVzLlxyXG4gICAgICogQHNlZSBbTUROJ3MgJmx0O2xpbmVhckdyYWRpZW50Pl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvbGluZWFyR3JhZGllbnQpLCBbJmx0O3N0b3A+XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdG9wKVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LkFyZWFDaGFydClcclxuICAgICAqIEBzZWUgW0RlbW86IGFib3ZlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5BYm92ZSlcclxuICAgICAqIEBzZWUgW0RlbW86IGxpbmVhckdyYWRpZW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5MaW5lYXJHcmFkaWVudClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgYXJlYToge1xyXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlLFxyXG4gICAgICogICAgICBhYm92ZTogdHJ1ZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHdpbGwgZ2VuZXJhdGUgZm9sbHdpbmcgbGluZWFyR3JhZGllbnQ6XHJcbiAgICAgKiAgICAgIC8vIDxsaW5lYXJHcmFkaWVudCB4MT1cIjBcIiB4Mj1cIjBcIiB5MT1cIjBcIiB5Mj1cIjFcIj5cclxuICAgICAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjFcIj48L3N0b3A+XHJcbiAgICAgKiAgICAgIC8vICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwiJERBVEFfQ09MT1JcIiBzdG9wLW9wYWNpdHk9XCIwXCI+PC9zdG9wPlxyXG4gICAgICogICAgICAvLyA8L2xpbmVhckdyYWRpZW50PlxyXG4gICAgICogICAgICBsaW5lYXJHcmFkaWVudDogdHJ1ZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIE9yIGN1c3RvbWl6ZWQgZ3JhZGllbnRcclxuICAgICAqICAgICAgbGluZWFyR3JhZGllbnQ6IHtcclxuICAgICAqICAgICAgXHR4OiBbMCwgMF0sICAvLyB4MSwgeDIgYXR0cmlidXRlc1xyXG4gICAgICogICAgICBcdHk6IFswLCAwXSwgIC8vIHkxLCB5MiBhdHRyaWJ1dGVzXHJcbiAgICAgKiAgICAgIFx0c3RvcHM6IFtcclxuICAgICAqICAgICAgXHQgIC8vIG9mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XHJcbiAgICAgKiAgICAgIFx0ICBbMCwgXCIjN2NiNWVjXCIsIDFdLFxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQgIC8vIHNldHRpbmcgJ251bGwnIGZvciBzdG9wLWNvbG9yLCB3aWxsIHNldCBpdHMgb3JpZ2luYWwgZGF0YSBjb2xvclxyXG4gICAgICogICAgICBcdCAgWzAuNSwgbnVsbCwgMF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdCAgLy8gc2V0dGluZyAnZnVuY3Rpb24nIGZvciBzdG9wLWNvbG9yLCB3aWxsIHBhc3MgZGF0YSBpZCBhcyBhcmd1bWVudC5cclxuICAgICAqICAgICAgXHQgIC8vIEl0IHNob3VsZCByZXR1cm4gY29sb3Igc3RyaW5nIG9yIG51bGwgdmFsdWVcclxuICAgICAqICAgICAgXHQgIFsxLCBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImJsdWVcIjsgfSwgMF0sXHJcbiAgICAgKiAgICAgIFx0XVxyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBhcmVhX3plcm9iYXNlZDogdHJ1ZSxcclxuICAgIGFyZWFfYWJvdmU6IGZhbHNlLFxyXG4gICAgYXJlYV9saW5lYXJHcmFkaWVudDogPGJvb2xlYW58e3g/OiBudW1iZXJbXTsgeT86IG51bWJlcltdOyBzdG9wcz86IFtudW1iZXIsIHN0cmluZ3xGdW5jdGlvbnxudWxsLCBudW1iZXJdfT4gZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYmFyIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBiYXIgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgYmFyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnBhZGRpbmc9MF0gVGhlIHBhZGRpbmcgcGl4ZWwgdmFsdWUgYmV0d2VlbiBlYWNoIGJhci5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnJhZGl1c10gU2V0IHRoZSByYWRpdXMgb2YgYmFyIGVkZ2UgaW4gcGl4ZWwuXHJcbiAgICAgKiAtICoqTk9URToqKiBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnJhZGl1cy5yYXRpb10gU2V0IHRoZSByYWRpdXMgcmF0aW8gb2YgYmFyIGVkZ2UgaW4gcmVsYXRpdmUgdGhlIGJhcidzIHdpZHRoLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIuc2Vuc2l0aXZpdHk9Ml0gVGhlIHNlbnN0aXZpdHkgb2Zmc2V0IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoXSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydC5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lXSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBmb3IgaW5kaWNhdGVkIGRhdGFzZXQgb25seS5cclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgIC0gV29ya3Mgb25seSBmb3Igbm9uLXN0YWNrZWQgYmFyXHJcbiAgICAgKiAgIC0gQmFycyBhcmUgY2VudGVyZWQgYWNjb2RpbmcgaXRzIHRvdGFsIHdpZHRoIHZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5yYXRpbz0wLjZdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0IGJ5IHJhdGlvLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWUubWF4XSBUaGUgbWF4aW11bSB3aWR0aCB2YWx1ZSBmb3IgcmF0aW8uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtiYXIuemVyb2Jhc2VkPXRydWVdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBiYXIgY2hhcnQuXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgcGFkZGluZ10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJQYWRkaW5nKVxyXG4gICAgICogQHNlZSBbRGVtbzogYmFyIHJhZGl1c10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJSYWRpdXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgd2lkdGhdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyV2lkdGgpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgd2lkdGggdmFyaWFudF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aFZhcmlhbnQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGJhcjoge1xyXG4gICAgICogICAgICBwYWRkaW5nOiAxLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gdGhlICdyYWRpdXMnIG9wdGlvbiBjYW4gYmUgdXNlZCBvbmx5IGZvciBub24tc3RhY2tpbmcgYmFyc1xyXG4gICAgICogICAgICByYWRpdXM6IDEwLFxyXG4gICAgICogICAgICAvLyBvclxyXG4gICAgICogICAgICByYWRpdXM6IHtcclxuICAgICAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuICAgICAqICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gd2lsbCBub3QgaGF2ZSBvZmZzZXQgYmV0d2VlbiBlYWNoIGJhciBlbGVtZW50cyBmb3IgaW50ZXJhY3Rpb25cclxuICAgICAqICAgICAgc2Vuc2l0aXZpdHk6IDAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICB3aWR0aDogMTAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBvclxyXG4gICAgICogICAgICB3aWR0aDoge1xyXG4gICAgICogICAgICAgICAgcmF0aW86IDAuMixcclxuICAgICAqICAgICAgICAgIG1heDogMjBcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIHNwZWNpZnkgd2lkdGggcGVyIGRhdGFzZXRcclxuICAgICAqICAgICAgd2lkdGg6IHtcclxuICAgICAqICAgICAgICAgIGRhdGExOiAyMCxcclxuICAgICAqICAgICAgICAgIGRhdGEyOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcmF0aW86IDAuMixcclxuICAgICAqICAgICAgICAgICAgICBtYXg6IDIwXHJcbiAgICAgKiAgICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBiYXJfcGFkZGluZzogMCxcclxuICAgIGJhcl9yYWRpdXM6IDxudW1iZXJ8e3JhdGlvOiBudW1iZXJ9fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgYmFyX3JhZGl1c19yYXRpbzogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGJhcl9zZW5zaXRpdml0eTogMixcclxuICAgIGJhcl93aWR0aDogPG51bWJlcnx7cmF0aW8/OiBudW1iZXI7IG1heD86IG51bWJlcjt9fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgYmFyX3dpZHRoX3JhdGlvOiAwLjYsXHJcbiAgICBiYXJfd2lkdGhfbWF4OiB1bmRlZmluZWQsXHJcbiAgICBiYXJfemVyb2Jhc2VkOiB0cnVlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGJ1YmJsZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYnViYmxlIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIGJ1YmJsZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW2J1YmJsZS5tYXhSPTM1XSBTZXQgdGhlIG1heCBidWJibGUgcmFkaXVzIHZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtidWJibGUuemVyb2Jhc2VkPWZhbHNlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYnViYmxlIGNoYXJ0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBidWJibGU6IHtcclxuICAgICAqICAgICAgLy8gZXgpIElmIDEwMCBpcyB0aGUgaGlnaGVzdCB2YWx1ZSBhbW9uZyBkYXRhIGJvdW5kLCB0aGUgcmVwcmVzZW50YXRpb24gYnViYmxlIG9mIDEwMCB3aWxsIGhhdmUgcmFkaXVzIG9mIDUwLlxyXG4gICAgICogICAgICAvLyBBbmQgdGhlIGxlc3NlciB3aWxsIGhhdmUgcmFkaXVzIHJlbGF0aXZlbHkgZnJvbSB0aGEgbWF4IHZhbHVlLlxyXG4gICAgICogICAgICBtYXhSOiA1MCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIHNldCByYWRpdXMgY2FsbGJhY2tcclxuICAgICAqICAgICAgbWF4UjogZnVuY3Rpb24oZCkge1xyXG4gICAgICogICAgICAgICAgLy8gZXguIG9mIGQgcGFyYW0gLSB7eDogRnJpIE9jdCAwNiAyMDE3IDAwOjAwOjAwIEdNVCswOTAwLCB2YWx1ZTogODAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA1fVxyXG4gICAgICogICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUgKiAyKTtcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgYnViYmxlX21heFI6IDxudW1iZXJ8KCgpID0+IG51bWJlcik+IDM1LFxyXG4gICAgYnViYmxlX3plcm9iYXNlZDogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogbGluZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGluZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuY29ubmVjdE51bGw9ZmFsc2VdIFNldCBpZiBudWxsIGRhdGEgcG9pbnQgd2lsbCBiZSBjb25uZWN0ZWQgb3Igbm90Ljxicj5cclxuICAgICAqICBJZiB0cnVlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBiZSBjb25uZWN0ZWQgd2l0aG91dCBhbnkgZGF0YSBwb2ludC4gSWYgZmFsc2Ugc2V0LCB0aGUgcmVnaW9uIG9mIG51bGwgZGF0YSB3aWxsIG5vdCBiZSBjb25uZWN0ZWQgYW5kIGdldCBlbXB0eS5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICAgW2xpbmUuY2xhc3Nlcz11bmRlZmluZWRdIElmIHNldCwgdXNlZCB0byBzZXQgYSBjc3MgY2xhc3Mgb24gZWFjaCBsaW5lLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZS5zdGVwLnR5cGU9c3RlcF0gQ2hhbmdlIHN0ZXAgdHlwZSBmb3Igc3RlcCBjaGFydC48YnI+XHJcbiAgICAgKiAqKkF2YWlsYWJsZSB2YWx1ZXM6KipcclxuICAgICAqIC0gc3RlcFxyXG4gICAgICogLSBzdGVwLWJlZm9yZVxyXG4gICAgICogLSBzdGVwLWFmdGVyXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58QXJyYXl9IFtsaW5lLnBvaW50PXRydWVdIFNldCB0byBmYWxzZSB0byBub3QgZHJhdyBwb2ludHMgb24gbGluZWNoYXJ0cy4gT3IgcGFzcyBhbiBhcnJheSBvZiBsaW5lIGlkcyB0byBkcmF3IHBvaW50cyBmb3IuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGxpbmUgY2hhcnQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGxpbmU6IHtcclxuICAgICAqICAgICAgY29ubmVjdE51bGw6IHRydWUsXHJcbiAgICAgKiAgICAgIGNsYXNzZXM6IFtcclxuICAgICAqICAgICAgICAgIFwibGluZS1jbGFzczFcIixcclxuICAgICAqICAgICAgICAgIFwibGluZS1jbGFzczJcIlxyXG4gICAgICogICAgICBdLFxyXG4gICAgICogICAgICBzdGVwOiB7XHJcbiAgICAgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuICAgICAqICAgICAgcG9pbnQ6IGZhbHNlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuICAgICAqICAgICAgcG9pbnQ6IFtcclxuICAgICAqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXHJcbiAgICAgKiAgICAgIF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBsaW5lX2Nvbm5lY3ROdWxsOiBmYWxzZSxcclxuICAgIGxpbmVfc3RlcF90eXBlOiA8XCJzdGVwXCJ8XCJzdGVwLWJlZm9yZVwifFwic3RlcC1hZnRlclwiPiBcInN0ZXBcIixcclxuICAgIGxpbmVfemVyb2Jhc2VkOiBmYWxzZSxcclxuICAgIGxpbmVfY2xhc3NlczogPHN0cmluZ1tdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgbGluZV9wb2ludDogPHN0cmluZ1tdfGJvb2xlYW4+IHRydWVcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1NwbGluZVR5cGVzfSBmcm9tIFwiLi4vLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc3BsaW5lIG9wdGlvbnNcclxuICAgICAqIC0gKipBdmFpbGFibGUgaW50ZXJwb2xhdGlvbiB0eXBlIHZhbHVlczoqKlxyXG4gICAgICogIC0gYmFzaXMgKGQzLmN1cnZlQmFzaXMpXHJcbiAgICAgKiAgLSBiYXNpcy1jbG9zZWQgKGQzLmN1cnZlQmFzaXNDbG9zZWQpXHJcbiAgICAgKiAgLSBiYXNpcy1vcGVuIChkMy5jdXJ2ZUJhc2lzT3BlbilcclxuICAgICAqICAtIGJ1bmRsZSAoZDMuY3VydmVCdW5kbGUpXHJcbiAgICAgKiAgLSBjYXJkaW5hbCAoZDMuY3VydmVDYXJkaW5hbClcclxuICAgICAqICAtIGNhcmRpbmFsLWNsb3NlZCAoZDMuY3VydmVDYXJkaW5hbENsb3NlZClcclxuICAgICAqICAtIGNhcmRpbmFsLW9wZW4gKGQzLmN1cnZlQ2FyZGluYWxPcGVuKVxyXG4gICAgICogIC0gY2F0bXVsbC1yb20gKGQzLmN1cnZlQ2F0bXVsbFJvbSlcclxuICAgICAqICAtIGNhdG11bGwtcm9tLWNsb3NlZCAoZDMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkKVxyXG4gICAgICogIC0gY2F0bXVsbC1yb20tb3BlbiAoZDMuY3VydmVDYXRtdWxsUm9tT3BlbilcclxuICAgICAqICAtIG1vbm90b25lLXggKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICogIC0gbW9ub3RvbmUteSAoZDMuY3VydmVNb25vdG9uZVkpXHJcbiAgICAgKiAgLSBuYXR1cmFsIChkMy5jdXJ2ZU5hdHVyYWwpXHJcbiAgICAgKiAgLSBsaW5lYXItY2xvc2VkIChkMy5jdXJ2ZUxpbmVhckNsb3NlZClcclxuICAgICAqICAtIGxpbmVhciAoZDMuY3VydmVMaW5lYXIpXHJcbiAgICAgKiAgLSBzdGVwIChkMy5jdXJ2ZVN0ZXApXHJcbiAgICAgKiAgLSBzdGVwLWFmdGVyIChkMy5jdXJ2ZVN0ZXBBZnRlcilcclxuICAgICAqICAtIHN0ZXAtYmVmb3JlIChkMy5jdXJ2ZVN0ZXBCZWZvcmUpXHJcbiAgICAgKiBAbmFtZSBzcGxpbmVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzcGxpbmUuaW50ZXJwb2xhdGlvbi50eXBlPVwiY2FyZGluYWxcIl1cclxuICAgICAqIEBzZWUgW0ludGVycG9sYXRpb24gKGQzIHY0KV0oaHR0cDovL2JsLm9ja3Mub3JnL2VtbWFzYXVuZGVycy9jMjVhMTQ3OTcwZGVmMmIwMmQ4YzdjMjcxOWRjNzUwMilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgc3BsaW5lOiB7XHJcbiAgICAgKiAgICAgIGludGVycG9sYXRpb246IHtcclxuICAgICAqICAgICAgICAgIHR5cGU6IFwiY2FyZGluYWxcIlxyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlOiA8U3BsaW5lVHlwZXM+IFwiY2FyZGluYWxcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBkb251dCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZG9udXQgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgZG9udXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9udXQubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkb251dC5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtkb251dC5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkb251dC5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGRvbnV0IHBpZWNlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQuZXhwYW5kLnJhdGU9MC45OF0gU2V0IGV4cGFuZCByYXRlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC53aWR0aF0gU2V0IHdpZHRoIG9mIGRvbnV0IGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtkb251dC50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZG9udXQgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBkb251dDoge1xyXG4gICAgICogICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQpIHtcclxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KFwiJFwiKSh2YWx1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgICAgIC8vIHRvIG11bHRpbGluZSwgcmV0dXJuIHdpdGggJ1xcbicgY2hhcmFjdGVyXHJcbiAgICAgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIHRocmVzaG9sZDogMC4xLFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHNldCByYXRpbyBjYWxsYmFjay4gU2hvdWxkIHJldHVybiByYXRpbyB2YWx1ZVxyXG4gICAgICogICAgICAgICAgcmF0aW86IGZ1bmN0aW9uKGQsIHJhZGl1cywgaCkge1xyXG4gICAgICogICAgICAgICAgXHQuLi5cclxuICAgICAqICAgICAgICAgIFx0cmV0dXJuIHJhdGlvO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcclxuICAgICAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcbiAgICAgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBleHBhbmQ6IHtcclxuICAgICAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcbiAgICAgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG4gICAgICogICAgICAgICAgcmF0ZTogMVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICogICAgICBwYWRBbmdsZTogMC4yLFxyXG4gICAgICogICAgICBzdGFydGluZ0FuZ2xlOiAxLFxyXG4gICAgICogICAgICB0aXRsZTogXCJEb251dCBUaXRsZVwiXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB0aXRsZSB3aXRoIGxpbmUgYnJlYWtcclxuICAgICAqICAgICAgdGl0bGU6IFwiVGl0bGUxXFxuVGl0bGUyXCJcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGRvbnV0X2xhYmVsX3Nob3c6IHRydWUsXHJcbiAgICBkb251dF9sYWJlbF9mb3JtYXQ6IDwoKCkgPT4gbnVtYmVyfHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBkb251dF9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXHJcbiAgICBkb251dF9sYWJlbF9yYXRpbzogPG51bWJlcnwoKCkgPT4gbnVtYmVyKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGRvbnV0X3dpZHRoOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgZG9udXRfdGl0bGU6IFwiXCIsXHJcbiAgICBkb251dF9leHBhbmQ6IDxib29sZWFufHtyYXRlPzogbnVtYmVyOyBkdXJhdGlvbj86IG51bWJlcjt9PiB7fSxcclxuICAgIGRvbnV0X2V4cGFuZF9yYXRlOiAwLjk4LFxyXG4gICAgZG9udXRfZXhwYW5kX2R1cmF0aW9uOiA1MCxcclxuICAgIGRvbnV0X3BhZEFuZ2xlOiAwLFxyXG4gICAgZG9udXRfc3RhcnRpbmdBbmdsZTogMFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBnYXVnZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZ2F1Z2Ugb3B0aW9uc1xyXG4gICAgICogQG5hbWUgZ2F1Z2VcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2F1Z2UuZnVsbENpcmNsZT1mYWxzZV0gU2hvdyBmdWxsIGNpcmNsZSBhcyBkb251dC4gV2hlbiBzZXQgdG8gJ3RydWUnLCB0aGUgbWF4IGxhYmVsIHdpbGwgbm90IGJlIHNob3dlZCBkdWUgdG8gc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIHNhbWUgbG9jYXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnYXVnZS5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBnYXVnZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtnYXVnZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBnYXVnZS4gTGFiZWwgdGV4dCBjYW4gYmUgbXVsdGlsaW5lZCB3aXRoIGBcXG5gIGNoYXJhY3Rlci5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtnYXVnZS5sYWJlbC5leHRlbnRzXSBTZXQgY3VzdG9taXplZCBtaW4vbWF4IGxhYmVsIHRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnYXVnZS5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGdhdWdlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5leHBhbmQucmF0ZT0wLjk4XSBTZXQgZXhwYW5kIHJhdGUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IHRoZSBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UubWluPTBdIFNldCBtaW4gdmFsdWUgb2YgdGhlIGdhdWdlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5tYXg9MTAwXSBTZXQgbWF4IHZhbHVlIG9mIHRoZSBnYXVnZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2Uuc3RhcnRpbmdBbmdsZT0tMSAqIE1hdGguUEkgLyAyXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudGl0bGU9XCJcIl0gU2V0IHRpdGxlIG9mIGdhdWdlIGNoYXJ0LiBVc2UgYFxcbmAgY2hhcmFjdGVyIHRvIGVudGVyIGxpbmUgYnJlYWsuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLnVuaXRzXSBTZXQgdW5pdHMgb2YgdGhlIGdhdWdlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS53aWR0aF0gU2V0IHdpZHRoIG9mIGdhdWdlIGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS50eXBlPVwic2luZ2xlXCJdIFNldCB0eXBlIG9mIGdhdWdlIHRvIGJlIGRpc3BsYXllZC48YnI+PGJyPlxyXG4gICAgICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAtIHNpbmdsZVxyXG4gICAgICogLSBtdWx0aVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS5hcmNzLm1pbldpZHRoPTVdIFNldCBtaW5pbWFsIHdpZHRoIG9mIGdhdWdlIGFyY3MgdW50aWwgdGhlIGlubmVyUmFkaXVzIGRpc2FwcGVhcnMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGdhdWdlOiB7XHJcbiAgICAgKiAgICAgIGZ1bGxDaXJjbGU6IGZhbHNlLFxyXG4gICAgICogICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbykge1xyXG4gICAgICogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcclxuICAgICAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgZXh0ZW50czogZnVuY3Rpb24odmFsdWUsIGlzTWF4KSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIChpc01heCA/IFwiTWF4OlwiIDogXCJNaW46XCIpICsgdmFsdWU7XHJcbiAgICAgKiAgICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxyXG4gICAgICogICAgICBleHBhbmQ6IGZhbHNlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgZXhwYW5kOiB7XHJcbiAgICAgKiAgICAgIFx0Ly8gc2V0IGR1cmF0aW9uIG9mIGV4cGFuZCB0cmFuc2l0aW9uIHRvIDUwMG1zLlxyXG4gICAgICogICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gc2V0IGV4cGFuZCBhcmVhIHJhdGVcclxuICAgICAqICAgICAgICAgIHJhdGU6IDFcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIG1pbjogLTEwMCxcclxuICAgICAqICAgICAgbWF4OiAyMDAsXHJcbiAgICAgKiAgICAgIHR5cGU6IFwic2luZ2xlXCIgIC8vIG9yICdtdWx0aSdcclxuICAgICAqICAgICAgdGl0bGU6IFwiVGl0bGUgVGV4dFwiLFxyXG4gICAgICogICAgICB1bml0czogXCIlXCIsXHJcbiAgICAgKiAgICAgIHdpZHRoOiAxMCxcclxuICAgICAqICAgICAgYXJjczoge1xyXG4gICAgICogICAgICAgICAgbWluV2lkdGg6IDVcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgZ2F1Z2VfZnVsbENpcmNsZTogZmFsc2UsXHJcbiAgICBnYXVnZV9sYWJlbF9zaG93OiB0cnVlLFxyXG4gICAgZ2F1Z2VfbGFiZWxfZm9ybWF0OiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBnYXVnZV9sYWJlbF9leHRlbnRzOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBnYXVnZV9taW46IDAsXHJcbiAgICBnYXVnZV9tYXg6IDEwMCxcclxuICAgIGdhdWdlX3R5cGU6IFwic2luZ2xlXCIsXHJcbiAgICBnYXVnZV9zdGFydGluZ0FuZ2xlOiAtMSAqIE1hdGguUEkgLyAyLFxyXG4gICAgZ2F1Z2VfdGl0bGU6IFwiXCIsXHJcbiAgICBnYXVnZV91bml0czogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGdhdWdlX3dpZHRoOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgZ2F1Z2VfYXJjc19taW5XaWR0aDogNSxcclxuICAgIGdhdWdlX2V4cGFuZDogPGJvb2xlYW58e2R1cmF0aW9uOiBudW1iZXJ9PiB7fSxcclxuICAgIGdhdWdlX2V4cGFuZF9yYXRlOiAwLjk4LFxyXG4gICAgZ2F1Z2VfZXhwYW5kX2R1cmF0aW9uOiA1MFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHBpZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBwaWVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcGllLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggcGllIHBpZWNlLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3BpZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmxhYmVsLnRocmVzaG9sZD0wLjA1XSBTZXQgdGhyZXNob2xkIHRvIHNob3cvaGlkZSBsYWJlbHMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BpZS5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbcGllLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgcGllIHBpZWNlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbXMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxPYmplY3R9IFtwaWUuaW5uZXJSYWRpdXM9MF0gU2V0cyB0aGUgaW5uZXIgcmFkaXVzIG9mIHBpZSBhcmMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5wYWRkaW5nPTBdIFNldHMgdGhlIGdhcCBiZXR3ZWVuIHBpZSBhcmNzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBwaWU6IHtcclxuICAgICAqICAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG4gICAgICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcclxuICAgICAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcclxuICAgICAqICAgICAgICAgICAgICAuLi5cclxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gcmF0aW87XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxyXG4gICAgICogICAgICAgICAgcmF0aW86IDAuNVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cclxuICAgICAqICAgICAgZXhwYW5kOiBmYWxzZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIGV4cGFuZDoge1xyXG4gICAgICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cclxuICAgICAqICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXHJcbiAgICAgKiAgICAgICAgICByYXRlOiAxXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBpbm5lclJhZGl1czogMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgaW5uZXJSYWRpdXMgZm9yIGVhY2ggZGF0YVxyXG4gICAgICogICAgICBpbm5lclJhZGl1czoge1xyXG4gICAgICogICAgICBcdGRhdGExOiAxMCxcclxuICAgICAqICAgICAgXHRkYXRhMjogMFxyXG4gICAgICogICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICBwYWRBbmdsZTogMC4xLFxyXG4gICAgICogICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICogICAgICBzdGFydGluZ0FuZ2xlOiAxXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBwaWVfbGFiZWxfc2hvdzogdHJ1ZSxcclxuICAgIHBpZV9sYWJlbF9mb3JtYXQ6IDwoKCkgPT4gbnVtYmVyfHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBwaWVfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxyXG4gICAgcGllX2xhYmVsX3JhdGlvOiA8KCgpID0+IG51bWJlcil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBwaWVfZXhwYW5kOiA8Ym9vbGVhbnx7cmF0ZT86IG51bWJlcjsgZHVyYXRpb24/OiBudW1iZXI7fT4ge30sXHJcbiAgICBwaWVfZXhwYW5kX3JhdGU6IDAuOTgsXHJcbiAgICBwaWVfZXhwYW5kX2R1cmF0aW9uOiA1MCxcclxuICAgIHBpZV9pbm5lclJhZGl1czogPG51bWJlcnx7W2tleTogc3RyaW5nXTogbnVtYmVyfT4gMCxcclxuICAgIHBpZV9wYWRBbmdsZTogMCxcclxuICAgIHBpZV9wYWRkaW5nOiAwLFxyXG4gICAgcGllX3N0YXJ0aW5nQW5nbGU6IDBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCByYWRhciBvcHRpb25zXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsuXHJcbiAgICAgKiBAbmFtZSByYWRhclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLmF4aXMubWF4PXVuZGVmaW5lZF0gVGhlIG1heCB2YWx1ZSBvZiBheGlzLiBJZiBub3QgZ2l2ZW4sIGl0J2xsIHRha2UgdGhlIG1heCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBkYXRhLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIuYXhpcy5saW5lLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgbGluZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIuYXhpcy50ZXh0LnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAcHJvcGVydHkge05VbWJlcn0gW3JhZGFyLmF4aXMudGV4dC5wb3NpdGlvbi55PTBdIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIuYXhpcy50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgdGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmRpcmVjdGlvbi5jbG9ja3dpc2U9ZmFsc2VdIFNldCB0aGUgZGlyZWN0aW9uIHRvIGJlIGRyYXduLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5sZXZlbC5kZXB0aD0zXSBTZXQgdGhlIGxldmVsIGRlcHRoLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGV2ZWwuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbcmFkYXIubGV2ZWwudGV4dC5mb3JtYXQ9KHgpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpXSBTZXQgZm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgbGV2ZWwgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5sZXZlbC50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsIHRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLnNpemUucmF0aW89MC44N10gU2V0IHNpemUgcmF0aW8uXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuUmFkYXJDaGFydClcclxuICAgICAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiByYWRhciBsZXZlbF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyTGV2ZWwpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiByYWRhciBzaXplXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJTaXplKVxyXG4gICAgICogQHNlZSBbRGVtbzogcmFkYXIgYXhpcyBtdWx0aWxpbmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXNNdWx0aWxpbmUpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHJhZGFyOiB7XHJcbiAgICAgKiAgICAgIGF4aXM6IHtcclxuICAgICAqICAgICAgICAgIG1heDogNTAsXHJcbiAgICAgKiAgICAgICAgICBsaW5lOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICAgICAgICBcdHg6IDAsXHJcbiAgICAgKiAgICAgICAgICAgICAgXHR5OiAwXHJcbiAgICAgKiAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBkaXJlY3Rpb246IHtcclxuICAgICAqICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBsZXZlbDoge1xyXG4gICAgICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcbiAgICAgKiAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICBzaG93OiB0cnVlXHJcbiAgICAgKiAgICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHNpemU6IHtcclxuICAgICAqICAgICAgICAgIHJhdGlvOiAwLjdcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgcmFkYXJfYXhpc19tYXg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICByYWRhcl9heGlzX2xpbmVfc2hvdzogdHJ1ZSxcclxuICAgIHJhZGFyX2F4aXNfdGV4dF9zaG93OiB0cnVlLFxyXG4gICAgcmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uOiA8e3g/OiBudW1iZXI7IHk/OiBudW1iZXI7fT4ge30sXHJcbiAgICByYWRhcl9sZXZlbF9kZXB0aDogMyxcclxuICAgIHJhZGFyX2xldmVsX3Nob3c6IHRydWUsXHJcbiAgICByYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdDogKHg6IG51bWJlcikgPT4gKHggJSAxID09PSAwID8geCA6IHgudG9GaXhlZCgyKSksXHJcbiAgICByYWRhcl9sZXZlbF90ZXh0X3Nob3c6IHRydWUsXHJcbiAgICByYWRhcl9zaXplX3JhdGlvOiAwLjg3LFxyXG4gICAgcmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vLyBjb21tb25cclxuaW1wb3J0IGRhdGEgZnJvbSBcIi4vZGF0YS9kYXRhXCI7XHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9jb21tb24vY29sb3JcIjtcclxuaW1wb3J0IGludGVyYWN0aW9uIGZyb20gXCIuL2NvbW1vbi9pbnRlcmFjdGlvblwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2NvbW1vbi9sZWdlbmRcIjtcclxuaW1wb3J0IHRpdGxlIGZyb20gXCIuL2NvbW1vbi90aXRsZVwiO1xyXG5pbXBvcnQgdG9vbHRpcCBmcm9tIFwiLi9jb21tb24vdG9vbHRpcFwiO1xyXG5cclxuLy8gQXhpcyBiYXNlZFxyXG5pbXBvcnQgZGF0YUF4aXMgZnJvbSBcIi4vZGF0YS9heGlzXCI7XHJcbmltcG9ydCBkYXRhU2VsZWN0aW9uIGZyb20gXCIuL2RhdGEvc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBheGlzIGZyb20gXCIuL2F4aXMvYXhpc1wiO1xyXG5pbXBvcnQgZ3JpZCBmcm9tIFwiLi9jb21tb24vZ3JpZFwiO1xyXG5pbXBvcnQgcG9pbnQgZnJvbSBcIi4vY29tbW9uL3BvaW50XCI7XHJcbmltcG9ydCBzdWJjaGFydCBmcm9tIFwiLi9jb21tb24vc3ViY2hhcnRcIjtcclxuaW1wb3J0IHpvb20gZnJvbSBcIi4vY29tbW9uL3pvb21cIjtcclxuXHJcbmltcG9ydCBhcmVhIGZyb20gXCIuL3NoYXBlL2FyZWFcIjtcclxuaW1wb3J0IGJhciBmcm9tIFwiLi9zaGFwZS9iYXJcIjtcclxuaW1wb3J0IGJ1YmJsZSBmcm9tIFwiLi9zaGFwZS9idWJibGVcIjtcclxuaW1wb3J0IGxpbmUgZnJvbSBcIi4vc2hhcGUvbGluZVwiO1xyXG5pbXBvcnQgc3BsaW5lIGZyb20gXCIuL3NoYXBlL3NwbGluZVwiO1xyXG5cclxuLy8gTm9uLUF4aXMgYmFzZWRcclxuaW1wb3J0IGRvbnV0IGZyb20gXCIuL3NoYXBlL2RvbnV0XCI7XHJcbmltcG9ydCBnYXVnZSBmcm9tIFwiLi9zaGFwZS9nYXVnZVwiO1xyXG5pbXBvcnQgcGllIGZyb20gXCIuL3NoYXBlL3BpZVwiO1xyXG5pbXBvcnQgcmFkYXIgZnJvbSBcIi4vc2hhcGUvcmFkYXJcIjtcclxuXHJcbmltcG9ydCB7bWVyZ2VPYmp9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRvIHNldCBvcHRpb25zIG9uIGdlbmVyYXRpbmcgY2hhcnQuXHJcbiAqIC0gSXQncyBpbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cclxuICogQGNsYXNzIE9wdGlvbnNcclxuICogQHNlZSB7QGxpbmsgYmIuZ2VuZXJhdGV9IHRvIHVzZSB0aGVzZSBvcHRpb25zIG9uIGdlbmVyYXRpbmcgdGhlIGNoYXJ0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25zIHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdGNvbnN0IGFyY1NoYXBlQ29uZmlnID0gW2RvbnV0LCBnYXVnZSwgcGllLCByYWRhcl07XHJcblxyXG5cdFx0Y29uc3QgYXhpc0NvbmZpZyA9IFtkYXRhQXhpcywgZGF0YVNlbGVjdGlvbiwgYXhpcywgZ3JpZCwgcG9pbnQsIHN1YmNoYXJ0LCB6b29tXTtcclxuXHRcdGNvbnN0IGF4aXNTaGFwZUNvbmZpZyA9IFthcmVhLCBiYXIsIGJ1YmJsZSwgbGluZSwgc3BsaW5lXTtcclxuXHJcblx0XHRjb25zdCBjb25maWcgPSBbXHJcblx0XHRcdGRhdGEsXHJcblx0XHRcdGNvbG9yLFxyXG5cdFx0XHRpbnRlcmFjdGlvbixcclxuXHRcdFx0bGVnZW5kLFxyXG5cdFx0XHR0aXRsZSxcclxuXHRcdFx0dG9vbHRpcCxcclxuXHRcdFx0Li4uYXJjU2hhcGVDb25maWcsXHJcblx0XHRcdC4uLmF4aXNDb25maWcsXHJcblx0XHRcdC4uLmF4aXNTaGFwZUNvbmZpZ1xyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gbWVyZ2VPYmooe1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU3BlY2lmeSB0aGUgQ1NTIHNlbGVjdG9yIG9yIHRoZSBlbGVtZW50IHdoaWNoIHRoZSBjaGFydCB3aWxsIGJlIHNldCB0by4gRDMgc2VsZWN0aW9uIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIGFsc28uPGJyPlxyXG5cdFx0XHQgKiBJZiBvdGhlciBjaGFydCBpcyBzZXQgYWxyZWFkeSwgaXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBuZXcgb25lIChvbmx5IG9uZSBjaGFydCBjYW4gYmUgc2V0IGluIG9uZSBlbGVtZW50KS5cclxuXHRcdFx0ICogLSAqKk5PVEU6KiogSW4gY2FzZSBvZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3Qgb3Igbm90IHNwZWNpZmllZCwgd2lsbCBhZGQgYSBgPGRpdj5gIGVsZW1lbnQgdG8gdGhlIGJvZHkuXHJcblx0XHRcdCAqIEBuYW1lIGJpbmR0b1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGJpbmR0bz0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGJpbmR0by5lbGVtZW50PSNjaGFydCBTcGVjaWZ5IHRoZSBlbGVtZW50IHdoZXJlIGNoYXJ0IHdpbGwgYmUgZHJhd24uXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYmluZHRvLmNsYXNzbmFtZT1iYl0gU3BlY2lmeSB0aGUgY2xhc3MgbmFtZSBvZiBiaW5kIGVsZW1lbnQuPGJyPlxyXG5cdFx0XHQgKiAgICAgKipOT1RFOioqIFdoZW4gY2xhc3MgbmFtZSBpc24ndCBgYmJgLCB0aGVuIHlvdSBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBkZWZhdWx0IENTUyB0byBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXHJcblx0XHRcdCAqIEBkZWZhdWx0ICNjaGFydFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBiaW5kdG86IFwiI215Q29udGFpbmVyXCJcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogLy8gb3IgSFRNTEVsZW1lbnRcclxuXHRcdFx0ICogYmluZHRvOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q29udGFpbmVyXCIpXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIC8vIG9yIEQzIHNlbGVjdGlvbiBvYmplY3RcclxuXHRcdFx0ICogYmluZHRvOiBkMy5zZWxlY3QoXCIjbXlDb250YWluZXJcIilcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogLy8gb3IgdG8gY2hhbmdlIGRlZmF1bHQgY2xhc3NuYW1lXHJcblx0XHRcdCAqIGJpbmR0bzoge1xyXG5cdFx0XHQgKiAgICBlbGVtZW50OiBcIiNjaGFydFwiLFxyXG5cdFx0XHQgKiAgICBjbGFzc25hbWU6IFwiYmlsbC1ib2FyZFwiICAvLyBleCkgPGRpdiBpZD0nY2hhcnQnIGNsYXNzPSdiaWxsLWJvYXJkJz5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0YmluZHRvOiA8c3RyaW5nfHtlbGVtZW50OiBzdHJpbmc7IGNsYXNzbmFtZT86IHN0cmluZ30+IFwiI2NoYXJ0XCIsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGNoYXJ0IGJhY2tncm91bmQuXHJcblx0XHRcdCAqIEBuYW1lIGJhY2tncm91bmRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGJhY2tncm91bmQuY2xhc3MgU3BlY2lmeSB0aGUgY2xhc3MgbmFtZSBmb3IgYmFja2dyb3VuZCBlbGVtZW50LlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gYmFja2dyb3VuZC5jb2xvciBTcGVjaWZ5IHRoZSBmaWxsIGNvbG9yIGZvciBiYWNrZ3JvdW5kIGVsZW1lbnQuPGJyPioqTk9URToqKiBXaWxsIGJlIGlnbm9yZWQgaWYgYGltZ1VybGAgb3B0aW9uIGlzIHNldC5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGJhY2tncm91bmQuaW1nVXJsIFNwZWNpZnkgdGhlIGltYWdlIHVybCBzdHJpbmcgZm9yIGJhY2tncm91bmQuXHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuQmFja2dyb3VuZClcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogYmFja2dyb3VuZDoge1xyXG5cdFx0XHQgKiAgICBjbGFzczogXCJteUNsYXNzXCIsXHJcblx0XHRcdCAqICAgIGNvbG9yOiBcInJlZFwiLFxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgICAvLyBTZXQgaW1hZ2UgdXJsIGZvciBiYWNrZ3JvdW5kLlxyXG5cdFx0XHQgKiAgICAvLyBJZiBzcGVjaWZpZWQsICdjb2xvcicgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cclxuXHRcdFx0ICogICAgaW1nVXJsOiBcImh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9pbWcvbG9nby9iaWxsYm9hcmQuanMuc3ZnXCIsXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdGJhY2tncm91bmQ6IDx7Y2xhc3M/OiBzdHJpbmc7IGNvbG9yPzogc3RyaW5nOyBpbWdVcmw/OiBzdHJpbmc7fT4ge30sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSBmb3IgY2hhcnQgZWxlbWVudFxyXG5cdFx0XHQgKiAtICoqTk9URToqKlxyXG5cdFx0XHQgKiAgPiBXaGVuIGlzIGZhbHNlLCBjaGFydCBub2RlIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhZnRlciB0aGUgYXhpcyBub2RlIGluIERPTSB0cmVlIGhpZXJhcmNoeS5cclxuXHRcdFx0ICogID4gSXMgdG8gbWFrZSBjaGFydCBlbGVtZW50IHBvc2l0aW9uZWQgb3ZlciBheGlzIGVsZW1lbnQuXHJcblx0XHRcdCAqIEBuYW1lIGNsaXBQYXRoXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuY2xpcFBhdGgpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHRcdFx0ICogY2xpcFBhdGg6IGZhbHNlXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRjbGlwUGF0aDogdHJ1ZSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgc3ZnIGVsZW1lbnQncyBjbGFzcyBuYW1lXHJcblx0XHRcdCAqIEBuYW1lIHN2Z1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3N2Zy5jbGFzc25hbWVdIGNsYXNzIG5hbWUgZm9yIHN2ZyBlbGVtZW50XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHN2Zzoge1xyXG4gICAgICAgICAgICAgKiAgIGNsYXNzbmFtZTogXCJ0ZXN0X2NsYXNzXCJcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0c3ZnX2NsYXNzbmFtZTogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBjaGFydCBlbGVtZW50LlxyXG5cdFx0XHQgKiBJZiB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgd2lkdGggb2YgdGhlIGNoYXJ0IHdpbGwgYmUgY2FsY3VsYXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQgaXQncyBhcHBlbmRlZCB0by5cclxuXHRcdFx0ICogQG5hbWUgc2l6ZVxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUud2lkdGhdIHdpZHRoIG9mIHRoZSBjaGFydCBlbGVtZW50XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2l6ZS5oZWlnaHRdIGhlaWdodCBvZiB0aGUgY2hhcnQgZWxlbWVudFxyXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkNoYXJ0U2l6ZSlcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogc2l6ZToge1xyXG4gICAgICAgICAgICAgKiAgIHdpZHRoOiA2NDAsXHJcbiAgICAgICAgICAgICAqICAgaGVpZ2h0OiA0ODBcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0c2l6ZV93aWR0aDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRcdFx0c2l6ZV9oZWlnaHQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogVGhlIHBhZGRpbmcgb2YgdGhlIGNoYXJ0IGVsZW1lbnQuXHJcblx0XHRcdCAqIEBuYW1lIHBhZGRpbmdcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLnRvcF0gcGFkZGluZyBvbiB0aGUgdG9wIG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5yaWdodF0gcGFkZGluZyBvbiB0aGUgcmlnaHQgb2YgY2hhcnRcclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLmJvdHRvbV0gcGFkZGluZyBvbiB0aGUgYm90dG9tIG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5sZWZ0XSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHBhZGRpbmc6IHtcclxuICAgICAgICAgICAgICogICB0b3A6IDIwLFxyXG4gICAgICAgICAgICAgKiAgIHJpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICogICBib3R0b206IDIwLFxyXG4gICAgICAgICAgICAgKiAgIGxlZnQ6IDIwXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHBhZGRpbmdfbGVmdDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRcdFx0cGFkZGluZ19yaWdodDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRcdFx0cGFkZGluZ190b3A6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfYm90dG9tOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBjaGFydCByZXNpemUgb3B0aW9uc1xyXG5cdFx0XHQgKiBAbmFtZSByZXNpemVcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVzaXplLmF1dG89dHJ1ZV0gU2V0IGNoYXJ0IHJlc2l6ZSBhdXRvbWF0aWNhbGx5IG9uIHZpZXdwb3J0IGNoYW5nZXMuXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICByZXNpemU6IHtcclxuXHRcdFx0ICogICAgICBhdXRvOiBmYWxzZVxyXG5cdFx0XHQgKiAgfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0cmVzaXplX2F1dG86IHRydWUsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIG1vdXNlL3RvdWNoIGVudGVycyB0aGUgY2hhcnQuXHJcblx0XHRcdCAqIEBuYW1lIG9ub3ZlclxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25vdmVyOiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25vdmVyOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBtb3VzZS90b3VjaCBsZWF2ZXMgdGhlIGNoYXJ0LlxyXG5cdFx0XHQgKiBAbmFtZSBvbm91dFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25vdXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbm91dDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdXNlciByZXNpemVzIHRoZSBzY3JlZW4uXHJcblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlc2l6ZTogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ucmVzaXplOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBzY3JlZW4gcmVzaXplIGZpbmlzaGVkLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlc2l6ZWRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ucmVzaXplZDogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ucmVzaXplZDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWRcclxuXHRcdFx0ICogQG5hbWUgb25iZWZvcmVpbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmJlZm9yZWluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbmJlZm9yZWluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cclxuXHRcdFx0ICogQG5hbWUgb25pbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbmluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBhZnRlciB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWRcclxuXHRcdFx0ICogQG5hbWUgb25hZnRlcmluaXRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9uYWZ0ZXJpbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25hZnRlcmluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhcnQgaXMgcmVuZGVyZWQuIEJhc2ljYWxseSwgdGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpbiBlYWNoIHRpbWUgd2hlbiB0aGUgY2hhcnQgaXMgcmVkcmF3ZWQuXHJcblx0XHRcdCAqIEBuYW1lIG9ucmVuZGVyZWRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ucmVuZGVyZWQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbnJlbmRlcmVkOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cclxuXHRcdFx0ICogLSAqKk5PVEU6KiogSWYgYDAgYG9yIGBudWxsYCBzZXQsIHRyYW5zaXRpb24gd2lsbCBiZSBza2lwcGVkLiBTbywgdGhpcyBtYWtlcyBpbml0aWFsIHJlbmRlcmluZyBmYXN0ZXIgZXNwZWNpYWxseSBpbiBjYXNlIHlvdSBoYXZlIGEgbG90IG9mIGRhdGEuXHJcblx0XHRcdCAqIEBuYW1lIHRyYW5zaXRpb25cclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0cmFuc2l0aW9uLmR1cmF0aW9uPTM1MF0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHRyYW5zaXRpb246IHtcclxuXHRcdFx0ICogICAgZHVyYXRpb246IDUwMFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0cmFuc2l0aW9uX2R1cmF0aW9uOiAzNTAsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IHNjYXR0ZXIgb3B0aW9uc1xyXG5cdFx0XHQgKiBAbmFtZSBzY2F0dGVyXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3NjYXR0ZXIuemVyb2Jhc2VkPWZhbHNlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gc2NhdHRlciBjaGFydC5cclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHNjYXR0ZXI6IHtcclxuXHRcdFx0ICogICAgICBjb25uZWN0TnVsbDogdHJ1ZSxcclxuXHRcdFx0ICogICAgICBzdGVwOiB7XHJcblx0XHRcdCAqICAgICAgICAgIHR5cGU6IFwic3RlcC1hZnRlclwiXHJcblx0XHRcdCAqICAgICAgfSxcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogICAgICAvLyBoaWRlIGFsbCBkYXRhIHBvaW50cyAoJ3BvaW50LnNob3c9ZmFsc2UnIGFsc28gaGFzIHNpbWlsYXIgZWZmZWN0KVxyXG5cdFx0XHQgKiAgICAgIHBvaW50OiBmYWxzZSxcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogICAgICAvLyBzaG93IGRhdGEgcG9pbnRzIGZvciBvbmx5IGluZGljYXRlZCBkYXRhc1xyXG5cdFx0XHQgKiAgICAgIHBvaW50OiBbXHJcblx0XHRcdCAqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXHJcblx0XHRcdCAqICAgICAgXSxcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcblx0XHRcdCAqICB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRzY2F0dGVyX3plcm9iYXNlZDogZmFsc2UsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IHBsdWdpbnNcclxuXHRcdFx0ICogQG5hbWUgcGx1Z2luc1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICBwbHVnaW5zOiBbXHJcblx0XHRcdCAqICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXHJcblx0XHRcdCAqICAgIG5ldyBQbHVnaW5BKCksXHJcblx0XHRcdCAqICAgIC4uLlxyXG5cdFx0XHQgKiBdXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRwbHVnaW5zOiBbXSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBDb250cm9sIHRoZSByZW5kZXIgdGltaW5nXHJcblx0XHRcdCAqIEBuYW1lIHJlbmRlclxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZW5kZXIubGF6eT10cnVlXSBNYWtlIHRvIG5vdCByZW5kZXIgYXQgaW5pdGlhbGl6YXRpb24gKGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIGJpbmQgZWxlbWVudCdzIHZpc2liaWxpdHkgaXMgaGlkZGVuKS5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVuZGVyLm9ic2VydmU9dHJ1ZV0gT2JzZXJ2ZSBiaW5kIGVsZW1lbnQncyB2aXNpYmlsaXR5KGBkaXNwbGF5YCBvciBgdmlzaWJsaXR5YCBpbmxpbmUgY3NzIHByb3BlcnR5IG9yIGNsYXNzIHZhbHVlKSAmIHJlbmRlciB3aGVuIGlzIHZpc2libGUgYXV0b21hdGljYWxseSAoZm9yIElFcywgb25seSB3b3JrcyBJRTExKykuIFdoZW4gc2V0IHRvICoqZmFsc2UqKiwgY2FsbCBbYC5mbHVzaCgpYF0oLi9DaGFydC5odG1sI2ZsdXNoKSB0byByZW5kZXIuXHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuTGF6eVJlbmRlcilcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHJlbmRlcjoge1xyXG5cdFx0XHQgKiAgICBsYXp5OiB0cnVlLFxyXG5cdFx0XHQgKiAgICBvYnNlcnZlOiB0cnVlXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICpcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICpcdC8vIDwhLS0gcmVuZGVyLmxhenkgd2lsbCBkZXRlY3QgdmlzaWJpbGl0eSBkZWZpbmVkIC0tPlxyXG5cdFx0XHQgKiAgLy8gKGEpIDxkaXYgaWQ9J2NoYXJ0JyBjbGFzcz0naGlkZSc+PC9kaXY+XHJcblx0XHRcdCAqICAvLyAoYikgPGRpdiBpZD0nY2hhcnQnIHN0eWxlPSdkaXNwbGF5Om5vbmUnPjwvZGl2PlxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgLy8gcmVuZGVyLmxhenkgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gZWxlbWVudCBpcyBoaWRkZW5cclxuXHRcdFx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgLy8gY2hhcnQgd2lsbCBiZSByZW5kZXJlZCBhdXRvbWF0aWNhbGx5IHdoZW4gZWxlbWVudCdzIHZpc2liaWxpdHkgY2hhbmdlc1xyXG5cdFx0XHQgKiAgLy8gTm90ZTogd29ya3Mgb25seSBmb3IgaW5saW5lZCBjc3MgcHJvcGVydHkgb3IgY2xhc3MgYXR0cmlidXRlIGNoYW5nZXNcclxuXHRcdFx0ICogIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKSAgLy8gKGEpXHJcblx0XHRcdCAqICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgIC8vIChiKVxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKlx0Ly8gY2hhcnQgd29uJ3QgYmUgcmVuZGVyZWQgYW5kIG5vdCBvYnNlcnZpbmcgYmluZCBlbGVtZW50J3MgdmlzaWJsaXR5IGNoYW5nZXNcclxuXHRcdFx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuXHRcdFx0ICogICAgIHJlbmRlcjoge1xyXG5cdFx0XHQgKiAgICAgICAgICBsYXp5OiB0cnVlLFxyXG5cdFx0XHQgKiAgICAgICAgICBvYnNlcnZlOiBmYWxzZVxyXG5cdFx0XHQgKiAgICAgfVxyXG5cdFx0XHQgKiAgfSk7XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAvLyBjYWxsIGF0IGFueSBwb2ludCB3aGVuIHlvdSB3YW50IHRvIHJlbmRlclxyXG5cdFx0XHQgKiAgY2hhcnQuZmx1c2goKTtcclxuXHRcdFx0ICovXHJcblx0XHRcdHJlbmRlcjogPHtsYXp5PzogYm9vbGVhbjsgb2JzZXJ2ZT86IGJvb2xlYW47fT4ge30sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2hvdyByZWN0YW5nbGVzIGluc2lkZSB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHRcdFx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBhcnJheSBpbmNsdWRpbmcgb2JqZWN0IHRoYXQgaGFzIGF4aXMsIHN0YXJ0LCBlbmQgYW5kIGNsYXNzLlxyXG5cdFx0XHQgKiBUaGUga2V5cyBzdGFydCwgZW5kIGFuZCBjbGFzcyBhcmUgb3B0aW9uYWwuXHJcblx0XHRcdCAqIGF4aXMgbXVzdCBiZSB4LCB5IG9yIHkyLiBzdGFydCBhbmQgZW5kIHNob3VsZCBiZSB0aGUgdmFsdWUgd2hlcmUgcmVnaW9ucyBzdGFydCBhbmQgZW5kLlxyXG5cdFx0XHQgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZWRnZSB2YWx1ZXMgd2lsbCBiZSB1c2VkLlxyXG5cdFx0XHQgKiBJZiB0aW1lc2VyaWVzIHggYXhpcywgZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IGFuZCB1bml4dGltZSBpbnRlZ2VyIGNhbiBiZSB1c2VkLlxyXG5cdFx0XHQgKiBJZiBjbGFzcyBpcyBzZXQsIHRoZSByZWdpb24gZWxlbWVudCB3aWxsIGhhdmUgaXQgYXMgY2xhc3MuXHJcblx0XHRcdCAqIEBuYW1lIHJlZ2lvbnNcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0FycmF5fVxyXG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcmVnaW9uczogW1xyXG5cdFx0XHQgKiAgICB7XHJcblx0XHRcdCAqICAgICAgYXhpczogXCJ4XCIsXHJcblx0XHRcdCAqICAgICAgc3RhcnQ6IDEsXHJcblx0XHRcdCAqICAgICAgZW5kOiA0LFxyXG5cdFx0XHQgKiAgICAgIGNsYXNzOiBcInJlZ2lvbi0xLTRcIlxyXG5cdFx0XHQgKiAgICB9XHJcblx0XHRcdCAqICBdXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRyZWdpb25zOiA8e2F4aXM/OiBzdHJpbmc7IHN0YXJ0PzogbnVtYmVyOyBlbmQ/OiBudW1iZXI7IGNsYXNzPzogc3RyaW5nO31bXT4gW11cclxuXHRcdH0sIC4uLmNvbmZpZyk7XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt0b0FycmF5fSBmcm9tIFwiLi91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWNoZSB7XHJcblx0cHJpdmF0ZSBjYWNoZSA9IHt9O1xyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgY2FjaGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5XHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEYXRhVHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZSwgaXNEYXRhVHlwZSA9IGZhbHNlKSB7XHJcblx0XHR0aGlzLmNhY2hlW2tleV0gPSBpc0RhdGFUeXBlID8gdGhpcy5jbG9uZVRhcmdldCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgY2FjaGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0ga2V5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZW1vdmUoa2V5OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0dG9BcnJheShrZXkpLmZvckVhY2godiA9PiBkZWxldGUgdGhpcy5jYWNoZVt2XSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgY2FoY2VcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0ga2V5XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0RhdGFUeXBlXHJcblx0ICogQHJldHVybiB7Kn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldChrZXksIGlzRGF0YVR5cGUgPSBmYWxzZSkge1xyXG5cdFx0aWYgKGlzRGF0YVR5cGUpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0czogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpZDsgKGlkID0ga2V5W2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKGlkIGluIHRoaXMuY2FjaGUpIHtcclxuXHRcdFx0XHRcdHRhcmdldHMucHVzaCh0aGlzLmNsb25lVGFyZ2V0KHRoaXMuY2FjaGVbaWRdKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV0gfHwgbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIHJlc2V0IGNhY2hlZCBkYXRhXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGwgdHJ1ZTogcmVzZXQgYWxsIGRhdGEsIGZhbHNlOiByZXNldCBvbmx5ICckJyBwcmVmaXhlZCBrZXkgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcbiBcdCAqL1xyXG5cdHJlc2V0KGFsbD86IGJvb2xlYW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRmb3IgKGNvbnN0IHggaW4gJCQuY2FjaGUpIHtcclxuXHRcdFx0Ly8gcmVzZXQgdGhlIHByZWZpeGVkICckJyBrZXkod2hpY2ggaXMgaW50ZXJuYWwgdXNlIGRhdGEpIG9ubHkuXHJcblx0XHRcdGlmIChhbGwgfHwgL15cXCQvLnRlc3QoeCkpIHtcclxuXHRcdFx0XHQkJC5jYWNoZVt4XSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNsb25lVGFyZ2V0KHRhcmdldCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0aWQ6IHRhcmdldC5pZCxcclxuXHRcdFx0aWRfb3JnOiB0YXJnZXQuaWRfb3JnLFxyXG5cdFx0XHR2YWx1ZXM6IHRhcmdldC52YWx1ZXMubWFwKGQgPT4gKHt4OiBkLngsIHZhbHVlOiBkLnZhbHVlLCBpZDogZC5pZH0pKVxyXG5cdFx0fTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7c2NhbGVMaW5lYXIgYXMgZDNTY2FsZUxpbmVhcn0gZnJvbSBcImQzLXNjYWxlXCI7XHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc051bWJlciwgaXNTdHJpbmd9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1JlbmRlcmVySGVscGVyIHtcclxuXHRwcml2YXRlIG93bmVyO1xyXG5cdHByaXZhdGUgY29uZmlnO1xyXG5cdHByaXZhdGUgc2NhbGU7XHJcblxyXG5cdGNvbnN0cnVjdG9yKG93bmVyKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IGQzU2NhbGVMaW5lYXIoKTtcclxuXHRcdGNvbnN0IHtjb25maWcsIHBhcmFtc30gPSBvd25lcjtcclxuXHJcblx0XHR0aGlzLm93bmVyID0gb3duZXI7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuXHJcblx0XHRpZiAoY29uZmlnLm5vVHJhbnNpdGlvbiB8fCAhcGFyYW1zLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKSB7XHJcblx0XHRcdGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IHJhbmdlXHJcblx0XHRjb25maWcucmFuZ2UgPSB0aGlzLnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgYSBjaGFyYWN0ZXIgZGltZW5zaW9uXHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IG5vZGVcclxuXHQgKiBAcmV0dXJuIHt7dzogbnVtYmVyLCBoOiBudW1iZXJ9fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c3RhdGljIGdldFNpemVGb3IxQ2hhcihub2RlKSB7XHJcblx0XHQvLyBkZWZhdWx0IHNpemUgZm9yIG9uZSBjaGFyYWN0ZXJcclxuXHRcdGNvbnN0IHNpemUgPSB7XHJcblx0XHRcdHc6IDUuNSxcclxuXHRcdFx0aDogMTEuNVxyXG5cdFx0fTtcclxuXHJcblx0XHQhbm9kZS5lbXB0eSgpICYmIG5vZGUuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChcIjBcIilcclxuXHRcdFx0LmNhbGwoZWwgPT4ge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbC5ub2RlKCkuZ2V0QkJveCgpO1xyXG5cclxuXHRcdFx0XHRcdGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcclxuXHRcdFx0XHRcdFx0c2l6ZS53ID0gd2lkdGg7XHJcblx0XHRcdFx0XHRcdHNpemUuaCA9IGhlaWdodDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRlbC50ZXh0KFwiXCIpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZ2V0U2l6ZUZvcjFDaGFyID0gKCkgPT4gc2l6ZTtcclxuXHJcblx0XHRyZXR1cm4gc2l6ZTtcclxuXHR9XHJcblxyXG5cdGF4aXNYKHNlbGVjdGlvbiwgeCkge1xyXG5cdFx0c2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7TWF0aC5jZWlsKHgoZCkgKyB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0KX0sMClgKTtcclxuXHR9XHJcblxyXG5cdGF4aXNZKHNlbGVjdGlvbiwgeSkge1xyXG5cdFx0c2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKDAsJHtNYXRoLmNlaWwoeShkKSl9KWApO1xyXG5cdH1cclxuXHJcblx0c2NhbGVFeHRlbnQoZG9tYWluKSB7XHJcblx0XHRjb25zdCBzdGFydCA9IGRvbWFpblswXTtcclxuXHRcdGNvbnN0IHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xyXG5cclxuXHRcdHJldHVybiBzdGFydCA8IHN0b3AgPyBbc3RhcnQsIHN0b3BdIDogW3N0b3AsIHN0YXJ0XTtcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVGlja3Moc2NhbGUsIGlzWUF4ZXMpIHtcclxuXHRcdGNvbnN0IHt0aWNrU3RlcFNpemV9ID0gdGhpcy5vd25lci5wYXJhbXM7XHJcblx0XHRsZXQgdGlja3MgPSBbXTtcclxuXHJcblx0XHQvLyBXaGVuICdheGlzW3l8eTJdLnRpY2suc3RlcFNpemUnIG9wdGlvbiBpcyBzZXRcclxuXHRcdGlmIChpc1lBeGVzICYmIHRpY2tTdGVwU2l6ZSkge1xyXG5cdFx0XHRjb25zdCBbc3RhcnQsIGVuZF0gPSBzY2FsZS5kb21haW4oKTtcclxuXHRcdFx0bGV0IGludGVydmFsID0gc3RhcnQ7XHJcblxyXG5cdFx0XHR3aGlsZSAoaW50ZXJ2YWwgPD0gZW5kKSB7XHJcblx0XHRcdFx0dGlja3MucHVzaChpbnRlcnZhbCk7XHJcblx0XHRcdFx0aW50ZXJ2YWwgKz0gdGlja1N0ZXBTaXplO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHNjYWxlLnRpY2tzKSB7XHJcblx0XHRcdHRpY2tzID0gc2NhbGUudGlja3MoXHJcblx0XHRcdFx0Li4uKHRoaXMuY29uZmlnLnRpY2tBcmd1bWVudHMgfHwgW10pXHJcblx0XHRcdCkubWFwKHYgPT4gKFxyXG5cdFx0XHRcdC8vIHJvdW5kIHRoZSB0aWNrIHZhbHVlIGlmIGlzIG51bWJlclxyXG5cdFx0XHRcdChpc1N0cmluZyh2KSAmJiBpc051bWJlcih2KSAmJiAhaXNOYU4odikgJiZcclxuXHRcdFx0XHRcdE1hdGgucm91bmQodiAqIDEwKSAvIDEwXHJcblx0XHRcdFx0KSB8fCB2XHJcblx0XHRcdCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gTWF0aC5jZWlsKGRvbWFpblswXSk7IGkgPCBkb21haW5bMV07IGkrKykge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aWNrcy5sZW5ndGggPiAwICYmIHRpY2tzWzBdID4gMCkge1xyXG5cdFx0XHRcdHRpY2tzLnVuc2hpZnQodGlja3NbMF0gLSAodGlja3NbMV0gLSB0aWNrc1swXSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpY2tzO1xyXG5cdH1cclxuXHJcblx0Y29weVNjYWxlKCkge1xyXG5cdFx0Y29uc3QgbmV3U2NhbGUgPSB0aGlzLnNjYWxlLmNvcHkoKTtcclxuXHJcblx0XHRpZiAoIW5ld1NjYWxlLmRvbWFpbigpLmxlbmd0aCkge1xyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4odGhpcy5zY2FsZS5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld1NjYWxlO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvcm1hdHRlZCh2KSB7XHJcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gdGhpcy5jb25maWcudGlja0Zvcm1hdDtcclxuXHJcblx0XHQvLyB0byByb3VuZCBmbG9hdCBudW1iZXJzIGZyb20gJ2JpbmFyeSBmbG9hdGluZyBwb2ludCdcclxuXHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJsZS1wcmVjaXNpb25fZmxvYXRpbmctcG9pbnRfZm9ybWF0XHJcblx0XHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzg0OTEwMS9sYXltYW5zLWV4cGxhbmF0aW9uLWZvci13aHktamF2YXNjcmlwdC1oYXMtd2VpcmQtZmxvYXRpbmctbWF0aC1pZWVlLTc1NC1zdGFuZFxyXG5cdFx0Y29uc3QgdmFsdWUgPSAvXFxkK1xcLlxcZCswezUsfVxcZCQvLnRlc3QodikgPyArU3RyaW5nKHYpLnJlcGxhY2UoLzArXFxkJC8sIFwiXCIpIDogdjtcclxuXHRcdGNvbnN0IGZvcm1hdHRlZCA9IHRpY2tGb3JtYXQgPyB0aWNrRm9ybWF0KHZhbHVlKSA6IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiBpc0RlZmluZWQoZm9ybWF0dGVkKSA/IGZvcm1hdHRlZCA6IFwiXCI7XHJcblx0fVxyXG5cclxuXHR0cmFuc2l0aW9uaXNlKHNlbGVjdGlvbikge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcud2l0aG91dFRyYW5zaXRpb24gP1xyXG5cdFx0XHRzZWxlY3Rpb24uaW50ZXJydXB0KCkgOiBzZWxlY3Rpb24udHJhbnNpdGlvbihjb25maWcudHJhbnNpdGlvbik7XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCIuL0F4aXNSZW5kZXJlckhlbHBlclwiO1xyXG5pbXBvcnQge2lzQXJyYXksIHRvQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlcn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCJ0eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1JlbmRlcmVyIHtcclxuXHRoZWxwZXI7XHJcblx0Y29uZmlnO1xyXG5cdHBhcmFtcztcclxuXHRnO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihwYXJhbXM6IGFueSA9IHt9KSB7XHJcblx0XHRjb25zdCBjb25maWcgPSB7XHJcblx0XHRcdGlubmVyVGlja1NpemU6IDYsXHJcblx0XHRcdG91dGVyVGlja1NpemU6IHBhcmFtcy5vdXRlclRpY2sgPyA2IDogMCxcclxuXHRcdFx0b3JpZW50OiBcImJvdHRvbVwiLFxyXG5cdFx0XHRyYW5nZTogW10sXHJcblx0XHRcdHRpY2tBcmd1bWVudHM6IG51bGwsXHJcblx0XHRcdHRpY2tDZW50ZXJlZDogbnVsbCxcclxuXHRcdFx0dGlja0N1bGxpbmc6IHRydWUsXHJcblx0XHRcdHRpY2tGb3JtYXQ6IG51bGwsXHJcblx0XHRcdHRpY2tMZW5ndGg6IDksXHJcblx0XHRcdHRpY2tPZmZzZXQ6IDAsXHJcblx0XHRcdHRpY2tQYWRkaW5nOiAzLFxyXG5cdFx0XHR0aWNrVmFsdWVzOiBudWxsLFxyXG5cdFx0XHR0cmFuc2l0aW9uOiBudWxsLFxyXG5cdFx0XHRub1RyYW5zaXRpb246IHBhcmFtcy5ub1RyYW5zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tMZW5ndGggPSBNYXRoLm1heChjb25maWcuaW5uZXJUaWNrU2l6ZSwgMCkgKyBjb25maWcudGlja1BhZGRpbmc7XHJcblxyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XHJcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHRcdHRoaXMuaGVscGVyID0gbmV3IEhlbHBlcih0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBheGlzIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y3JlYXRlKGc6IGQzU2VsZWN0aW9uKSB7XHJcblx0XHRjb25zdCBjdHggPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgcGFyYW1zLCBoZWxwZXI6IGhlbHBlckluc3R9ID0gdGhpcztcclxuXHRcdGNvbnN0IHNjYWxlID0gaGVscGVySW5zdC5zY2FsZTtcclxuXHRcdGNvbnN0IG9yaWVudCA9IGNvbmZpZy5vcmllbnQ7XHJcblx0XHRjb25zdCBzcGxpdFRpY2tUZXh0ID0gdGhpcy5zcGxpdFRpY2tUZXh0LmJpbmQodGhpcyk7XHJcblx0XHRjb25zdCBpc0xlZnRSaWdodCA9IC9eKGxlZnR8cmlnaHQpJC8udGVzdChvcmllbnQpO1xyXG5cdFx0Y29uc3QgaXNUb3BCb3R0b20gPSAvXih0b3B8Ym90dG9tKSQvLnRlc3Qob3JpZW50KTtcclxuXHJcblx0XHQvLyBsaW5lL3RleHQgZW50ZXIgYW5kIHBhdGggdXBkYXRlXHJcblx0XHRjb25zdCB0aWNrVHJhbnNmb3JtID0gaGVscGVySW5zdFtpc1RvcEJvdHRvbSA/IFwiYXhpc1hcIiA6IFwiYXhpc1lcIl07XHJcblx0XHRjb25zdCBheGlzUHggPSB0aWNrVHJhbnNmb3JtID09PSBoZWxwZXJJbnN0LmF4aXNYID8gXCJ5XCIgOiBcInhcIjtcclxuXHRcdGNvbnN0IHNpZ24gPSAvXih0b3B8bGVmdCkkLy50ZXN0KG9yaWVudCkgPyAtMSA6IDE7XHJcblxyXG5cdFx0Ly8gdGljayB0ZXh0IGhlbHBlcnNcclxuXHRcdGNvbnN0IHJvdGF0ZSA9IHBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcclxuXHJcblx0XHR0aGlzLmNvbmZpZy5yYW5nZSA9IHNjYWxlLnJhbmdlRXh0ZW50ID9cclxuXHRcdFx0c2NhbGUucmFuZ2VFeHRlbnQoKSA6XHJcblx0XHRcdGhlbHBlckluc3Quc2NhbGVFeHRlbnQoKHBhcmFtcy5vcmdYU2NhbGUgfHwgc2NhbGUpLnJhbmdlKCkpO1xyXG5cclxuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCB0aWNrTGVuZ3RoLCByYW5nZX0gPSBjb25maWc7XHJcblxyXG5cdFx0Ly8gLy8gZ2V0IHRoZSBheGlzJyB0aWNrIHBvc2l0aW9uIGNvbmZpZ3VyYXRpb25cclxuXHRcdGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcclxuXHRcdGNvbnN0IHRpY2tUZXh0UG9zID0gbmFtZSAmJiAvXih4fHl8eTIpJC8udGVzdChuYW1lKSA/XHJcblx0XHRcdHBhcmFtcy5jb25maWdbYGF4aXNfJHtuYW1lfV90aWNrX3RleHRfcG9zaXRpb25gXSA6IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHQvLyB0aWNrIHZpc2libGl0eVxyXG5cdFx0Y29uc3QgcHJlZml4ID0gbmFtZSA9PT0gXCJzdWJYXCIgPyBgc3ViY2hhcnRfYXhpc194YCA6IGBheGlzXyR7bmFtZX1gO1xyXG5cdFx0Y29uc3QgYXhpc1Nob3cgPSBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fc2hvd2BdO1xyXG5cdFx0Y29uc3QgdGlja1Nob3cgPSB7XHJcblx0XHRcdHRpY2s6IGF4aXNTaG93ID8gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3RpY2tfc2hvd2BdIDogZmFsc2UsXHJcblx0XHRcdHRleHQ6IGF4aXNTaG93ID8gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3RpY2tfdGV4dF9zaG93YF0gOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRsZXQgJGc7XHJcblxyXG5cdFx0Zy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdGxldCBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBzY2FsZTtcclxuXHRcdFx0bGV0IHNjYWxlMSA9IGhlbHBlckluc3QuY29weVNjYWxlKCk7XHJcblxyXG5cdFx0XHQkZyA9IGc7XHJcblx0XHRcdHRoaXMuX19jaGFydF9fID0gc2NhbGUxO1xyXG5cclxuXHRcdFx0Y29uZmlnLnRpY2tPZmZzZXQgPSBwYXJhbXMuaXNDYXRlZ29yeSA/XHJcblx0XHRcdFx0TWF0aC5jZWlsKChzY2FsZTEoMSkgLSBzY2FsZTEoMCkpIC8gMikgOiAwO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHNlbGVjdGlvbiAtIGRhdGEgam9pblxyXG5cdFx0XHRjb25zdCBwYXRoID0gZy5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoWzBdKTtcclxuXHJcblx0XHRcdC8vIGVudGVyICsgdXBkYXRlIHNlbGVjdGlvblxyXG5cdFx0XHRwYXRoLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcclxuXHRcdFx0XHQubWVyZ2UoaGVscGVySW5zdC50cmFuc2l0aW9uaXNlKHBhdGgpKVxyXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBvdXRlclRpY2tTaXplZCA9IGNvbmZpZy5vdXRlclRpY2tTaXplICogc2lnbjtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gaXNUb3BCb3R0b20gP1xyXG5cdFx0XHRcdFx0XHRgTSR7cmFuZ2VbMF19LCR7b3V0ZXJUaWNrU2l6ZWR9VjBIJHtyYW5nZVsxXX1WJHtvdXRlclRpY2tTaXplZH1gIDpcclxuXHRcdFx0XHRcdFx0YE0ke291dGVyVGlja1NpemVkfSwke3JhbmdlWzBdfUgwViR7cmFuZ2VbMV19SCR7b3V0ZXJUaWNrU2l6ZWR9YDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmICh0aWNrU2hvdy50aWNrIHx8IHRpY2tTaG93LnRleHQpIHtcclxuXHRcdFx0XHQvLyBjb3VudCBvZiB0aWNrIGRhdGEgaW4gYXJyYXlcclxuXHRcdFx0XHRjb25zdCB0aWNrcyA9IGNvbmZpZy50aWNrVmFsdWVzIHx8IGhlbHBlckluc3QuZ2VuZXJhdGVUaWNrcyhzY2FsZTEsIGlzTGVmdFJpZ2h0KTtcclxuXHJcblx0XHRcdFx0Ly8gdXBkYXRlIHNlbGVjdGlvblxyXG5cdFx0XHRcdGxldCB0aWNrOiBkM1NlbGVjdGlvbiA9IGcuc2VsZWN0QWxsKFwiLnRpY2tcIilcclxuXHRcdFx0XHRcdC5kYXRhKHRpY2tzLCBzY2FsZTEpO1xyXG5cclxuXHRcdFx0XHQvLyBlbnRlciBzZWxlY3Rpb25cclxuXHRcdFx0XHRjb25zdCB0aWNrRW50ZXIgPSB0aWNrXHJcblx0XHRcdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHRcdFx0Lmluc2VydChcImdcIiwgXCIuZG9tYWluXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0XHRcdC8vIE1FTU86IE5vIGV4aXQgdHJhbnNpdGlvbi4gVGhlIHJlYXNvbiBpcyB0aGlzIHRyYW5zaXRpb24gYWZmZWN0cyBtYXggdGljayB3aWR0aCBjYWxjdWxhdGlvbiBiZWNhdXNlIG9sZCB0aWNrIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHRpY2tzLlxyXG5cdFx0XHRcdGNvbnN0IHRpY2tFeGl0ID0gdGljay5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdC8vIGVudGVyICsgdXBkYXRlIHNlbGVjdGlvblxyXG5cdFx0XHRcdHRpY2sgPSB0aWNrRW50ZXIubWVyZ2UodGljayk7XHJcblxyXG5cdFx0XHRcdHRpY2tTaG93LnRpY2sgJiYgdGlja0VudGVyLmFwcGVuZChcImxpbmVcIik7XHJcblx0XHRcdFx0dGlja1Nob3cudGV4dCAmJiB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2l6ZUZvcjFDaGFyID0gSGVscGVyLmdldFNpemVGb3IxQ2hhcih0aWNrKTtcclxuXHRcdFx0XHRjb25zdCBjb3VudHM6IG51bWJlcltdID0gW107XHJcblxyXG5cdFx0XHRcdGxldCB0c3BhbjogZDNTZWxlY3Rpb24gPSB0aWNrLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJ0c3BhblwiKVxyXG5cdFx0XHRcdFx0LmRhdGEoKGQsIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0ID0gcGFyYW1zLnRpY2tNdWx0aWxpbmUgP1xyXG5cdFx0XHRcdFx0XHRcdHNwbGl0VGlja1RleHQoZCwgc2NhbGUxLCB0aWNrcywgaXNMZWZ0UmlnaHQsIHNpemVGb3IxQ2hhci53KSA6IChcclxuXHRcdFx0XHRcdFx0XHRcdGlzQXJyYXkoaGVscGVySW5zdC50ZXh0Rm9ybWF0dGVkKGQpKSA/XHJcblx0XHRcdFx0XHRcdFx0XHRcdGhlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKS5jb25jYXQoKSA6IFtoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCldXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGNvdW50c1tpbmRleF0gPSBzcGxpdC5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3BsaXQubWFwKHNwbGl0dGVkID0+ICh7aW5kZXgsIHNwbGl0dGVkfSkpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRzcGFuLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdFx0dHNwYW4gPSB0c3BhblxyXG5cdFx0XHRcdFx0LmVudGVyKClcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0c3BhblwiKVxyXG5cdFx0XHRcdFx0Lm1lcmdlKHRzcGFuKVxyXG5cdFx0XHRcdFx0LnRleHQoZCA9PiBkLnNwbGl0dGVkKTtcclxuXHJcblx0XHRcdFx0Ly8gc2V0IDx0c3Bhbj4ncyBwb3NpdGlvblxyXG5cdFx0XHRcdHRzcGFuXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgaXNUb3BCb3R0b20gPyAwIDogdGlja0xlbmd0aCAqIHNpZ24pXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsICgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGxldCBkeCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoLyh0b3B8Ym90dG9tKS8udGVzdChvcmllbnQpICYmIHJvdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHRcdGR4ID0gOCAqIE1hdGguc2luKE1hdGguUEkgKiAocm90YXRlIC8gMTgwKSkgKiAob3JpZW50ID09PSBcInRvcFwiID8gLTEgOiAxKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGR4ICsgKHRpY2tUZXh0UG9zLnggfHwgMCk7XHJcblx0XHRcdFx0XHR9KSgpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCAoZCwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBkZWZWYWx1ZSA9IFwiLjcxZW1cIjtcclxuXHRcdFx0XHRcdFx0bGV0IGR5OiBudW1iZXIgfCBzdHJpbmcgPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKG9yaWVudCAhPT0gXCJ0b3BcIikge1xyXG5cdFx0XHRcdFx0XHRcdGR5ID0gc2l6ZUZvcjFDaGFyLmg7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRkeSA9IGlzTGVmdFJpZ2h0ID8gLSgoY291bnRzW2QuaW5kZXhdIC0gMSkgKiAoc2l6ZUZvcjFDaGFyLmggLyAyKSAtIDMpIDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0KHRpY2tUZXh0UG9zLnkgPT09IDAgPyBkZWZWYWx1ZSA6IDApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlzTnVtYmVyKGR5KSAmJiB0aWNrVGV4dFBvcy55ID9cclxuXHRcdFx0XHRcdFx0XHRkeSArIHRpY2tUZXh0UG9zLnkgOiBkeSB8fCBkZWZWYWx1ZTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRjb25zdCBsaW5lVXBkYXRlID0gdGljay5zZWxlY3QoXCJsaW5lXCIpO1xyXG5cdFx0XHRcdGNvbnN0IHRleHRVcGRhdGUgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XHJcblxyXG5cdFx0XHRcdHRpY2tFbnRlci5zZWxlY3QoXCJsaW5lXCIpLmF0dHIoYCR7YXhpc1B4fTJgLCBpbm5lclRpY2tTaXplICogc2lnbik7XHJcblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcInRleHRcIikuYXR0cihgJHtheGlzUHh9YCwgdGlja0xlbmd0aCAqIHNpZ24pO1xyXG5cclxuXHRcdFx0XHRjdHguc2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSk7XHJcblxyXG5cdFx0XHRcdC8vIEFwcGVuZCA8dGl0bGU+IGZvciB0b29sdGlwIGRpc3BsYXlcclxuXHRcdFx0XHRwYXJhbXMudGlja1RpdGxlICYmIHRleHRVcGRhdGUuYXBwZW5kICYmIHRleHRVcGRhdGUuYXBwZW5kKFwidGl0bGVcIilcclxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLnRleHQocGFyYW1zLnRpY2tUaXRsZVtpbmRleF0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChzY2FsZTEuYmFuZHdpZHRoKSB7XHJcblx0XHRcdFx0XHRjb25zdCB4ID0gc2NhbGUxO1xyXG5cdFx0XHRcdFx0Y29uc3QgZHggPSB4LmJhbmR3aWR0aCgpIC8gMjtcclxuXHJcblx0XHRcdFx0XHRzY2FsZTAgPSBkID0+IHgoZCkgKyBkeDtcclxuXHRcdFx0XHRcdHNjYWxlMSA9IHNjYWxlMDtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHNjYWxlMC5iYW5kd2lkdGgpIHtcclxuXHRcdFx0XHRcdHNjYWxlMCA9IHNjYWxlMTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIHRpY2tFeGl0LCBzY2FsZTEpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIHRpY2tFbnRlciwgc2NhbGUwKTtcclxuXHRcdFx0XHR0aWNrVHJhbnNmb3JtLmNhbGwoaGVscGVySW5zdCwgaGVscGVySW5zdC50cmFuc2l0aW9uaXNlKHRpY2spLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksIHNjYWxlMSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZyA9ICRnO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgeC95IGNvb3JkaW5hdGVcclxuXHQgKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGlja1hZKCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgcG9zID0ge3g6IDAsIHk6IDB9O1xyXG5cclxuXHRcdGlmICh0aGlzLnBhcmFtcy5pc0NhdGVnb3J5KSB7XHJcblx0XHRcdHBvcy54ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IDAgOiBjb25maWcudGlja09mZnNldDtcclxuXHRcdFx0cG9zLnkgPSBjb25maWcudGlja0NlbnRlcmVkID8gY29uZmlnLnRpY2tPZmZzZXQgOiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb3M7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGljayBzaXplXHJcblx0ICogQHBhcmFtIGRcclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaWNrU2l6ZShkKSB7XHJcblx0XHRjb25zdCB7c2NhbGV9ID0gdGhpcy5oZWxwZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgcmFuZ2V9ID0gY29uZmlnO1xyXG5cclxuXHRcdGNvbnN0IHRpY2tQb3NpdGlvbiA9IHNjYWxlKGQpICtcclxuXHRcdFx0KGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQpO1xyXG5cclxuXHRcdHJldHVybiByYW5nZVswXSA8IHRpY2tQb3NpdGlvbiAmJiB0aWNrUG9zaXRpb24gPCByYW5nZVsxXSA/IGlubmVyVGlja1NpemUgOiAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRpY2sncyBsaW5lICYgdGV4dCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBsaW5lVXBkYXRlXHJcblx0ICogQHBhcmFtIHRleHRVcGRhdGVcclxuXHQgKiBAcGFyYW0gc2NhbGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpIHtcclxuXHRcdGNvbnN0IHRpY2tQb3MgPSB0aGlzLmdldFRpY2tYWSgpO1xyXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIG9yaWVudCwgdGlja0xlbmd0aCwgdGlja09mZnNldH0gPSB0aGlzLmNvbmZpZztcclxuXHRcdGNvbnN0IHJvdGF0ZSA9IHRoaXMucGFyYW1zLnRpY2tUZXh0Um90YXRlO1xyXG5cclxuXHRcdGNvbnN0IHRleHRBbmNob3JGb3JUZXh0ID0gciA9PiB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gW1wic3RhcnRcIiwgXCJlbmRcIl07XHJcblxyXG5cdFx0XHRvcmllbnQgPT09IFwidG9wXCIgJiYgdmFsdWUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuICFyID8gXCJtaWRkbGVcIiA6IChyID4gMCA/IHZhbHVlWzBdIDogdmFsdWVbMV0pO1xyXG5cdFx0fTtcclxuXHRcdGNvbnN0IHRleHRUcmFuc2Zvcm0gPSByID0+IChyID8gYHJvdGF0ZSgke3J9KWAgOiBudWxsKTtcclxuXHRcdGNvbnN0IHlGb3JUZXh0ID0gciA9PiB7XHJcblx0XHRcdGNvbnN0IHIyID0gciAvIChvcmllbnQgPT09IFwiYm90dG9tXCIgPyAxNSA6IDIzKTtcclxuXHJcblx0XHRcdHJldHVybiByID8gMTEuNSAtIDIuNSAqIHIyICogKHIgPiAwID8gMSA6IC0xKSA6IHRpY2tMZW5ndGg7XHJcblx0XHR9O1xyXG5cclxuXHRcdHN3aXRjaCAob3JpZW50KSB7XHJcblx0XHRcdGNhc2UgXCJib3R0b21cIjpcclxuXHRcdFx0XHRsaW5lVXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcIngxXCIsIHRpY2tQb3MueClcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgdGlja1Bvcy54KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB0aGlzLmdldFRpY2tTaXplLmJpbmQodGhpcykpO1xyXG5cclxuXHRcdFx0XHR0ZXh0VXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yVGV4dChyb3RhdGUpKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGV4dEFuY2hvckZvclRleHQocm90YXRlKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRleHRUcmFuc2Zvcm0ocm90YXRlKSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJ0b3BcIjpcclxuXHRcdFx0XHRsaW5lVXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIC1pbm5lclRpY2tTaXplKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgLXlGb3JUZXh0KHJvdGF0ZSkgKiAyKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGV4dEFuY2hvckZvclRleHQocm90YXRlKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRleHRUcmFuc2Zvcm0ocm90YXRlKSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJsZWZ0XCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAtaW5uZXJUaWNrU2l6ZSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTFcIiwgdGlja1Bvcy55KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB0aWNrUG9zLnkpO1xyXG5cclxuXHRcdFx0XHR0ZXh0VXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgLXRpY2tMZW5ndGgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgdGlja09mZnNldClcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwicmlnaHRcIjpcclxuXHRcdFx0XHRsaW5lVXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIGlubmVyVGlja1NpemUpXHJcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIDApO1xyXG5cclxuXHRcdFx0XHR0ZXh0VXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgdGlja0xlbmd0aClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCAwKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIHRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdoZW4gY2F0ZWdvcnkgYXhpc1xyXG5cdHNwbGl0VGlja1RleHQoZCwgc2NhbGUsIHRpY2tzLCBpc0xlZnRSaWdodCwgY2hhcldpZHRoKSB7XHJcblx0XHRjb25zdCB7cGFyYW1zfSA9IHRoaXM7XHJcblx0XHRjb25zdCB0aWNrVGV4dCA9IHRoaXMuaGVscGVyLnRleHRGb3JtYXR0ZWQoZCk7XHJcblx0XHRjb25zdCBzcGxpdHRlZCA9IGlzU3RyaW5nKHRpY2tUZXh0KSAmJiB0aWNrVGV4dC5pbmRleE9mKFwiXFxuXCIpID4gLTEgP1xyXG5cdFx0XHR0aWNrVGV4dC5zcGxpdChcIlxcblwiKSA6IFtdO1xyXG5cclxuXHRcdGlmIChzcGxpdHRlZC5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHNwbGl0dGVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc0FycmF5KHRpY2tUZXh0KSkge1xyXG5cdFx0XHRyZXR1cm4gdGlja1RleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRpY2tXaWR0aCA9IHBhcmFtcy50aWNrV2lkdGg7XHJcblxyXG5cdFx0aWYgKCF0aWNrV2lkdGggfHwgdGlja1dpZHRoIDw9IDApIHtcclxuXHRcdFx0dGlja1dpZHRoID0gaXNMZWZ0UmlnaHQgPyA5NSA6IChcclxuXHRcdFx0XHRwYXJhbXMuaXNDYXRlZ29yeSA/XHJcblx0XHRcdFx0XHQoTWF0aC5jZWlsKHNjYWxlKHRpY2tzWzFdKSAtIHNjYWxlKHRpY2tzWzBdKSkgLSAxMikgOiAxMTBcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzcGxpdChzcGxpdHRlZCwgdGV4dCkge1xyXG5cdFx0XHRsZXQgc3VidGV4dDtcclxuXHRcdFx0bGV0IHNwYWNlSW5kZXg7XHJcblx0XHRcdGxldCB0ZXh0V2lkdGg7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiIFwiKSB7XHJcblx0XHRcdFx0XHRzcGFjZUluZGV4ID0gaTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN1YnRleHQgPSB0ZXh0LnN1YnN0cigwLCBpICsgMSk7XHJcblx0XHRcdFx0dGV4dFdpZHRoID0gY2hhcldpZHRoICogc3VidGV4dC5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdC8vIGlmIHRleHQgd2lkdGggZ2V0cyBvdmVyIHRpY2sgd2lkdGgsIHNwbGl0IGJ5IHNwYWNlIGluZGV4IG9yIGN1cnJlbnQgaW5kZXhcclxuXHRcdFx0XHRpZiAodGlja1dpZHRoIDwgdGV4dFdpZHRoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3BsaXQoXHJcblx0XHRcdFx0XHRcdHNwbGl0dGVkLmNvbmNhdCh0ZXh0LnN1YnN0cigwLCBzcGFjZUluZGV4IHx8IGkpKSxcclxuXHRcdFx0XHRcdFx0dGV4dC5zbGljZShzcGFjZUluZGV4ID8gc3BhY2VJbmRleCArIDEgOiBpKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzcGxpdHRlZC5jb25jYXQodGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNwbGl0KHNwbGl0dGVkLCBTdHJpbmcodGlja1RleHQpKTtcclxuXHR9XHJcblxyXG5cdHNjYWxlKHgpIHtcclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXIuc2NhbGU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5oZWxwZXIuc2NhbGUgPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0b3JpZW50KHgpIHtcclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb25maWcub3JpZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29uZmlnLm9yaWVudCA9IHggaW4ge1xyXG5cdFx0XHR0b3A6IDEsXHJcblx0XHRcdHJpZ2h0OiAxLFxyXG5cdFx0XHRib3R0b206IDEsXHJcblx0XHRcdGxlZnQ6IDFcclxuXHRcdH0gPyBTdHJpbmcoeCkgOiBcImJvdHRvbVwiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0Zvcm1hdChmb3JtYXQpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrRm9ybWF0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrRm9ybWF0ID0gZm9ybWF0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0NlbnRlcmVkKGlzQ2VudGVyZWQpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQ2VudGVyZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tDZW50ZXJlZCA9IGlzQ2VudGVyZWQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGljaydzIG9mZnNldCB2YWx1ZS5cclxuXHQgKiBUaGUgdmFsdWUgd2lsbCBiZSBzZXQgZm9yICdjYXRlZ29yeScgYXhpcyB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRpY2tPZmZzZXQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcudGlja09mZnNldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIGludGVydmFsIGNvdW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUb3RhbCBkYXRhIHNpemVcclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICovXHJcblx0dGlja0ludGVydmFsKHNpemUpIHtcclxuXHRcdGxldCBpbnRlcnZhbDtcclxuXHJcblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRpbnRlcnZhbCA9IHRoaXMuY29uZmlnLnRpY2tPZmZzZXQgKiAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5nLnNlbGVjdChcInBhdGguZG9tYWluXCIpXHJcblx0XHRcdFx0Lm5vZGUoKVxyXG5cdFx0XHRcdC5nZXRUb3RhbExlbmd0aCgpIC0gdGhpcy5jb25maWcub3V0ZXJUaWNrU2l6ZSAqIDI7XHJcblxyXG5cdFx0XHRpbnRlcnZhbCA9IGxlbmd0aCAvIChzaXplIHx8IHRoaXMuZy5zZWxlY3RBbGwoXCJsaW5lXCIpLnNpemUoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGludGVydmFsID09PSBJbmZpbml0eSA/IDAgOiBpbnRlcnZhbDtcclxuXHR9XHJcblxyXG5cdHRpY2tzKC4uLmFyZ3MpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWFyZ3MubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0FyZ3VtZW50cztcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcudGlja0FyZ3VtZW50cyA9IHRvQXJyYXkoYXJncyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrQ3VsbGluZyhjdWxsaW5nKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0N1bGxpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tDdWxsaW5nID0gY3VsbGluZztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tWYWx1ZXMoeCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKHgpKSB7XHJcblx0XHRcdGNvbmZpZy50aWNrVmFsdWVzID0gKCkgPT4geCh0aGlzLmhlbHBlci5zY2FsZS5kb21haW4oKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tWYWx1ZXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbmZpZy50aWNrVmFsdWVzID0geDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHNldFRyYW5zaXRpb24odCkge1xyXG5cdFx0dGhpcy5jb25maWcudHJhbnNpdGlvbiA9IHQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRheGlzVG9wIGFzIGQzQXhpc1RvcCxcclxuXHRheGlzQm90dG9tIGFzIGQzQXhpc0JvdHRvbSxcclxuXHRheGlzTGVmdCBhcyBkM0F4aXNMZWZ0LFxyXG5cdGF4aXNSaWdodCBhcyBkM0F4aXNSaWdodFxyXG59IGZyb20gXCJkMy1heGlzXCI7XHJcbmltcG9ydCBBeGlzUmVuZGVyZXIgZnJvbSBcIi4vQXhpc1JlbmRlcmVyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYXBpdGFsaXplLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNWYWx1ZSwgaXNFbXB0eSwgaXNOdW1iZXIsIGlzT2JqZWN0VHlwZSwgbWVyZ2VPYmosIHBhcnNlRGF0ZSwgc29ydFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL0NoYXJ0SW50ZXJuYWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXMge1xyXG5cdHB1YmxpYyBvd25lcjogQ2hhcnRJbnRlcm5hbDtcclxuXHRwcml2YXRlIGF4ZXNMaXN0ID0ge307XHJcblx0cHVibGljIHRpY2sgPSB7XHJcblx0XHR4OiBudWxsLCB5OiBudWxsLCB5MjogbnVsbFxyXG5cdH07XHJcblx0cHVibGljIHhzID0gW107XHJcblx0cHJpdmF0ZSBvcmllbnQgPSB7XHJcblx0XHR4OiBcImJvdHRvbVwiLFxyXG5cdFx0eTogXCJsZWZ0XCIsXHJcblx0XHR5MjogXCJyaWdodFwiLFxyXG5cdFx0c3ViWDogXCJib3R0b21cIlxyXG5cdH07XHJcblxyXG5cdGNvbnN0cnVjdG9yKG93bmVyKSB7XHJcblx0XHR0aGlzLm93bmVyID0gb3duZXI7XHJcblx0XHR0aGlzLnNldE9yaWVudCgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBnZXRBeGlzQ2xhc3NOYW1lKGlkKSB7XHJcblx0XHRyZXR1cm4gYCR7Q0xBU1MuYXhpc30gJHtDTEFTU1tgYXhpcyR7Y2FwaXRhbGl6ZShpZCl9YF19YFxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpIHtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkO1xyXG5cdH1cclxuXHJcblx0aW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW4sIGF4aXN9LCBzdGF0ZToge2NsaXB9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHRhcmdldCA9IFtcInhcIiwgXCJ5XCJdO1xyXG5cclxuXHRcdGNvbmZpZy5heGlzX3kyX3Nob3cgJiYgdGFyZ2V0LnB1c2goXCJ5MlwiKTtcclxuXHJcblx0XHR0YXJnZXQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgY2xhc3NBeGlzID0gdGhpcy5nZXRBeGlzQ2xhc3NOYW1lKHYpO1xyXG5cdFx0XHRjb25zdCBheGlzSWQgPSB2LnRvVXBwZXJDYXNlKCk7XHJcblx0XHRcdGNvbnN0IGNsYXNzTGFiZWwgPSBDTEFTU1tgYXhpcyR7YXhpc0lkfUxhYmVsYF07XHJcblxyXG5cdFx0XHRheGlzW3ZdID0gbWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0F4aXMpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IHJlcyA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHYgPT09IFwieFwiKSB7XHJcblx0XHRcdFx0XHRcdHJlcyA9IGNsaXAucGF0aFhBeGlzO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2ID09PSBcInlcIiAmJiBjb25maWcuYXhpc195X2lubmVyKSB7XHJcblx0XHRcdFx0XHRcdHJlcyA9IGNsaXAucGF0aFlBeGlzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUodikpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWdbYGF4aXNfJHt2fV9zaG93YF0gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdFx0YXhpc1t2XS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xhYmVsKVxyXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFtcInJvdGF0ZSgtOTApXCIsIG51bGxdW1xyXG5cdFx0XHRcdFx0diA9PT0gXCJ4XCIgPyArIWlzUm90YXRlZCA6ICtpc1JvdGF0ZWRcclxuXHRcdFx0XHRdKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRoaXNbYHRleHRBbmNob3JGb3Ike2F4aXNJZH1BeGlzTGFiZWxgXS5iaW5kKHRoaXMpKTtcclxuXHJcblx0XHRcdHRoaXMuZ2VuZXJhdGVBeGVzKHYpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYXhpcyBvcmllbnQgYWNjb3JkaW5nIG9wdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0T3JpZW50KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRheGlzX3JvdGF0ZWQ6IGlzUm90YXRlZCxcclxuXHRcdFx0YXhpc195X2lubmVyOiB5SW5uZXIsXHJcblx0XHRcdGF4aXNfeTJfaW5uZXI6IHkySW5uZXJcclxuXHRcdH0gPSAkJC5jb25maWc7XHJcblxyXG5cdFx0dGhpcy5vcmllbnQgPSB7XHJcblx0XHRcdHg6IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIixcclxuXHRcdFx0eTogaXNSb3RhdGVkID8gKHlJbm5lciA/IFwidG9wXCIgOiBcImJvdHRvbVwiKSA6ICh5SW5uZXIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiksXHJcblx0XHRcdHkyOiBpc1JvdGF0ZWQgPyAoeTJJbm5lciA/IFwiYm90dG9tXCIgOiBcInRvcFwiKSA6ICh5MklubmVyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpLFxyXG5cdFx0XHRzdWJYOiBpc1JvdGF0ZWQgPyBcImxlZnRcIiA6IFwiYm90dG9tXCJcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBheGVzXHJcblx0ICogSXQncyB1c2VkIHdoZW4gYXhpcycgYXhlcyBvcHRpb24gaXMgc2V0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIEF4aXMgaWRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlQXhlcyhpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgYXhlczogYW55W10gPSBbXTtcclxuXHRcdGNvbnN0IGF4ZXNDb25maWcgPSBjb25maWdbYGF4aXNfJHtpZH1fYXhlc2BdO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBkM0F4aXM7XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIikge1xyXG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNMZWZ0IDogZDNBeGlzQm90dG9tO1xyXG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5XCIpIHtcclxuXHRcdFx0ZDNBeGlzID0gaXNSb3RhdGVkID8gZDNBeGlzQm90dG9tIDogZDNBeGlzTGVmdDtcclxuXHRcdH0gZWxzZSBpZiAoaWQgPT09IFwieTJcIikge1xyXG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNUb3AgOiBkM0F4aXNSaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXhlc0NvbmZpZy5sZW5ndGgpIHtcclxuXHRcdFx0YXhlc0NvbmZpZy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHRpY2sgPSB2LnRpY2sgfHwge307XHJcblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpO1xyXG5cclxuXHRcdFx0XHR2LmRvbWFpbiAmJiBzY2FsZS5kb21haW4odi5kb21haW4pO1xyXG5cclxuXHRcdFx0XHRheGVzLnB1c2goXHJcblx0XHRcdFx0XHRkM0F4aXMoc2NhbGUpXHJcblx0XHRcdFx0XHRcdC50aWNrcyh0aWNrLmNvdW50KVxyXG5cdFx0XHRcdFx0XHQudGlja0Zvcm1hdChpc0Z1bmN0aW9uKHRpY2suZm9ybWF0KSA/IHRpY2suZm9ybWF0LmJpbmQoJCQuYXBpKSA6ICgoeDogYW55KSA9PiB4KSlcclxuXHRcdFx0XHRcdFx0LnRpY2tWYWx1ZXModGljay52YWx1ZXMpXHJcblx0XHRcdFx0XHRcdC50aWNrU2l6ZU91dGVyKHRpY2sub3V0ZXIgPT09IGZhbHNlID8gMCA6IDYpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5heGVzTGlzdFtpZF0gPSBheGVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGF4ZXMgbm9kZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUF4ZXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmF4ZXNMaXN0KS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGVbaWRdLmNvcHkoKTtcclxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5heGVzTGlzdFtpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGF4aXNSYW5nZSA9IHYuc2NhbGUoKS5yYW5nZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBhZGp1c3QgcmFuZ2UgdmFsdWUgd2l0aCB0aGUgY3VycmVudFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzg1OVxyXG5cdFx0XHRcdGlmICghcmFuZ2UuZXZlcnkoKHYsIGkpID0+IHYgPT09IGF4aXNSYW5nZVtpXSkpIHtcclxuXHRcdFx0XHRcdHYuc2NhbGUoKS5yYW5nZShyYW5nZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPSBgJHt0aGlzLmdldEF4aXNDbGFzc05hbWUoaWQpfS0ke2kgKyAxfWA7XHJcblx0XHRcdFx0bGV0IGcgPSBtYWluLnNlbGVjdChgLiR7Y2xhc3NOYW1lLnJlcGxhY2UoL1xccy8sIFwiLlwiKX1gKTtcclxuXHJcblx0XHRcdFx0aWYgKGcuZW1wdHkoKSkge1xyXG5cdFx0XHRcdFx0ZyA9IG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKVxyXG5cdFx0XHRcdFx0XHQuY2FsbCh2KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YXhlc0NvbmZpZ1tpXS5kb21haW4gJiYgc2NhbGUuZG9tYWluKGF4ZXNDb25maWdbaV0uZG9tYWluKTtcclxuXHJcblx0XHRcdFx0XHQkJC5heGlzLnguaGVscGVyLnRyYW5zaXRpb25pc2UoZylcclxuXHRcdFx0XHRcdFx0LmNhbGwodi5zY2FsZShzY2FsZSkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShpZCwgaSArIDEpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIGNhbGxlZCBmcm9tIDogdXBkYXRlU2NhbGVzKCkgJiBnZXRNYXhUaWNrV2lkdGgoKVxyXG5cdGdldEF4aXMobmFtZSwgc2NhbGUsIG91dGVyVGljaywgbm9UcmFuc2l0aW9uLCBub1RpY2tUZXh0Um90YXRlKTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1ggPSAvXih4fHN1YlgpJC8udGVzdChuYW1lKTtcclxuXHRcdGNvbnN0IHR5cGUgPSBpc1ggPyBcInhcIiA6IG5hbWU7XHJcblxyXG5cdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzWCAmJiAkJC5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBvcmllbnQgPSB0aGlzLm9yaWVudFtuYW1lXTtcclxuXHJcblx0XHRsZXQgdGlja0Zvcm1hdDtcclxuXHJcblx0XHRpZiAoaXNYKSB7XHJcblx0XHRcdHRpY2tGb3JtYXQgPSAkJC5mb3JtYXQueEF4aXNUaWNrO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZm4gPSBjb25maWdbYGF4aXNfJHtuYW1lfV90aWNrX2Zvcm1hdGBdO1xyXG5cclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24oZm4pKSB7XHJcblx0XHRcdFx0dGlja0Zvcm1hdCA9IGZuLmJpbmQoJCQuYXBpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrVmFsdWVzID0gJCQuYXhpcy50aWNrW3R5cGVdO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNQYXJhbXMgPSBtZXJnZU9iaih7XHJcblx0XHRcdG91dGVyVGljayxcclxuXHRcdFx0bm9UcmFuc2l0aW9uLFxyXG5cdFx0XHRjb25maWcsXHJcblx0XHRcdG5hbWUsXHJcblx0XHRcdHRpY2tUZXh0Um90YXRlOiBub1RpY2tUZXh0Um90YXRlID8gMCA6IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfcm90YXRlYF1cclxuXHRcdH0sIGlzWCAmJiB7XHJcblx0XHRcdGlzQ2F0ZWdvcnksXHJcblx0XHRcdHRpY2tNdWx0aWxpbmU6IGNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUsXHJcblx0XHRcdHRpY2tXaWR0aDogY29uZmlnLmF4aXNfeF90aWNrX3dpZHRoLFxyXG5cdFx0XHR0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcclxuXHRcdFx0b3JnWFNjYWxlOiAkJC5zY2FsZS54XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWlzWCkge1xyXG5cdFx0XHRheGlzUGFyYW1zLnRpY2tTdGVwU2l6ZSA9IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfc3RlcFNpemVgXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBheGlzID0gbmV3IEF4aXNSZW5kZXJlcihheGlzUGFyYW1zKVxyXG5cdFx0XHQuc2NhbGUoKGlzWCAmJiAkJC5zY2FsZS56b29tKSB8fCBzY2FsZSlcclxuXHRcdFx0Lm9yaWVudChvcmllbnQpO1xyXG5cclxuXHRcdGlmIChpc1ggJiYgJCQuaXNUaW1lU2VyaWVzKCkgJiYgdGlja1ZhbHVlcyAmJiAhaXNGdW5jdGlvbih0aWNrVmFsdWVzKSkge1xyXG5cdFx0XHRjb25zdCBmbiA9IHBhcnNlRGF0ZS5iaW5kKCQkKTtcclxuXHJcblx0XHRcdHRpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLm1hcCh2ID0+IGZuKHYpKTtcclxuXHRcdH0gZWxzZSBpZiAoIWlzWCAmJiAkJC5pc1RpbWVTZXJpZXNZKCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2Jsb2IvbWFzdGVyL0NIQU5HRVMubWQjdGltZS1pbnRlcnZhbHMtZDMtdGltZVxyXG5cdFx0XHRheGlzLnRpY2tzKGNvbmZpZy5heGlzX3lfdGlja190aW1lX3ZhbHVlKTtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dGlja1ZhbHVlcyAmJiBheGlzLnRpY2tWYWx1ZXModGlja1ZhbHVlcyk7XHJcblxyXG5cdFx0Ly8gU2V0IHRpY2tcclxuXHRcdGF4aXMudGlja0Zvcm1hdChcclxuXHRcdFx0dGlja0Zvcm1hdCB8fCAoXHJcblx0XHRcdFx0IWlzWCAmJiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAoeCA9PiBgJHt4fSVgKSlcclxuXHRcdFx0KVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAoaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpO1xyXG5cclxuXHRcdFx0aWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcpKSB7XHJcblx0XHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfY291bnRgXSAmJiBheGlzLnRpY2tzKGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfY291bnRgXSk7XHJcblxyXG5cdFx0cmV0dXJuIGF4aXM7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0cywgYXhpcz8pOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZml0ID0gY29uZmlnLmF4aXNfeF90aWNrX2ZpdDtcclxuXHRcdGNvbnN0IGNvdW50ID0gY29uZmlnLmF4aXNfeF90aWNrX2NvdW50O1xyXG5cdFx0bGV0IHZhbHVlcztcclxuXHJcblx0XHRpZiAoZml0IHx8IChjb3VudCAmJiBmaXQpKSB7XHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdCQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpLFxyXG5cdFx0XHRcdGNvdW50LFxyXG5cdFx0XHRcdCQkLmlzVGltZVNlcmllcygpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4aXMpIHtcclxuXHRcdFx0YXhpcy50aWNrVmFsdWVzKHZhbHVlcyk7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMueCkge1xyXG5cdFx0XHQkJC5heGlzLngudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0XHQkJC5heGlzLnN1YlggJiYgJCQuYXhpcy5zdWJYLnRpY2tWYWx1ZXModmFsdWVzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Z2V0SWQoaWQpIHtcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9IHRoaXMub3duZXI7XHJcblx0XHRsZXQgYXhpcyA9IGNvbmZpZy5kYXRhX2F4ZXNbaWRdO1xyXG5cclxuXHRcdC8vIHdoZW4gZGF0YS5heGVzIG9wdGlvbiBoYXMgJ3kyJywgYnV0ICdheGlzLnkyLnNob3c9dHJ1ZScgaXNuJ3Qgc2V0IHdpbGwgcmV0dXJuICd5J1xyXG5cdFx0aWYgKCFheGlzIHx8ICFzY2FsZVtheGlzXSkge1xyXG5cdFx0XHRheGlzID0gXCJ5XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGF4aXM7XHJcblx0fVxyXG5cclxuXHRnZXRYQXhpc1RpY2tGb3JtYXQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXR9ID0gJCQ7XHJcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gY29uZmlnLmF4aXNfeF90aWNrX2Zvcm1hdDtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xyXG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHRcdGxldCBjdXJyRm9ybWF0O1xyXG5cclxuXHRcdGlmICh0aWNrRm9ybWF0KSB7XHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKHRpY2tGb3JtYXQpKSB7XHJcblx0XHRcdFx0Y3VyckZvcm1hdCA9IHRpY2tGb3JtYXQuYmluZCgkJC5hcGkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRcdGN1cnJGb3JtYXQgPSBkYXRlID0+IChkYXRlID8gZm9ybWF0LmF4aXNUaW1lKHRpY2tGb3JtYXQpKGRhdGUpIDogXCJcIik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN1cnJGb3JtYXQgPSBpc1RpbWVTZXJpZXMgPyBmb3JtYXQuZGVmYXVsdEF4aXNUaW1lIDogKFxyXG5cdFx0XHRcdGlzQ2F0ZWdvcml6ZWQgP1xyXG5cdFx0XHRcdFx0JCQuY2F0ZWdvcnlOYW1lIDogdiA9PiAodiA8IDAgPyB2LnRvRml4ZWQoMCkgOiB2KVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGN1cnJGb3JtYXQpID8gdiA9PlxyXG5cdFx0XHRjdXJyRm9ybWF0LmFwcGx5KCQkLCBpc0NhdGVnb3JpemVkID9cclxuXHRcdFx0XHRbdiwgJCQuY2F0ZWdvcnlOYW1lKHYpXSA6IFt2XVxyXG5cdFx0XHQpIDogY3VyckZvcm1hdDtcclxuXHR9XHJcblxyXG5cdGdldFRpY2tWYWx1ZXMoaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSAkJC5jb25maWdbYGF4aXNfJHtpZH1fdGlja192YWx1ZXNgXTtcclxuXHRcdGNvbnN0IGF4aXMgPSAkJFtgJHtpZH1BeGlzYF07XHJcblxyXG5cdFx0cmV0dXJuIChpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpID8gdGlja1ZhbHVlcy5jYWxsKCQkLmFwaSkgOiB0aWNrVmFsdWVzKSB8fFxyXG5cdFx0XHQoYXhpcyA/IGF4aXMudGlja1ZhbHVlcygpIDogdW5kZWZpbmVkKTtcclxuXHR9XHJcblxyXG5cdGdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLm93bmVyLmNvbmZpZ1tgYXhpc18ke2lkfV9sYWJlbGBdO1xyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxUZXh0KGlkKSB7XHJcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xyXG5cclxuXHRcdHJldHVybiBpc1N0cmluZyhvcHRpb24pID8gb3B0aW9uIDogKFxyXG5cdFx0XHRvcHRpb24gPyBvcHRpb24udGV4dCA6IG51bGxcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRzZXRMYWJlbFRleHQoaWQsIHRleHQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xyXG5cclxuXHRcdGlmIChpc1N0cmluZyhvcHRpb24pKSB7XHJcblx0XHRcdGNvbmZpZ1tgYXhpc18ke2lkfV9sYWJlbGBdID0gdGV4dDtcclxuXHRcdH0gZWxzZSBpZiAob3B0aW9uKSB7XHJcblx0XHRcdG9wdGlvbi50ZXh0ID0gdGV4dDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldExhYmVsUG9zaXRpb24oaWQsIGRlZmF1bHRQb3NpdGlvbikge1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gdGhpcy5vd25lci5jb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gKGlzT2JqZWN0VHlwZShvcHRpb24pICYmIG9wdGlvbi5wb3NpdGlvbikgP1xyXG5cdFx0XHRvcHRpb24ucG9zaXRpb24gOiBkZWZhdWx0UG9zaXRpb25bKyFpc1JvdGF0ZWRdO1xyXG5cclxuXHRcdGNvbnN0IGhhcyA9IHYgPT4gISF+cG9zaXRpb24uaW5kZXhPZih2KTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRpc0lubmVyOiBoYXMoXCJpbm5lclwiKSxcclxuXHRcdFx0aXNPdXRlcjogaGFzKFwib3V0ZXJcIiksXHJcblx0XHRcdGlzTGVmdDogaGFzKFwibGVmdFwiKSxcclxuXHRcdFx0aXNDZW50ZXI6IGhhcyhcImNlbnRlclwiKSxcclxuXHRcdFx0aXNSaWdodDogaGFzKFwicmlnaHRcIiksXHJcblx0XHRcdGlzVG9wOiBoYXMoXCJ0b3BcIiksXHJcblx0XHRcdGlzTWlkZGxlOiBoYXMoXCJtaWRkbGVcIiksXHJcblx0XHRcdGlzQm90dG9tOiBoYXMoXCJib3R0b21cIilcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRnZXRYQXhpc0xhYmVsUG9zaXRpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKFwieFwiLCBbXCJpbm5lci10b3BcIiwgXCJpbm5lci1yaWdodFwiXSk7XHJcblx0fVxyXG5cclxuXHRnZXRZQXhpc0xhYmVsUG9zaXRpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKFwieVwiLCBbXCJpbm5lci1yaWdodFwiLCBcImlubmVyLXRvcFwiXSk7XHJcblx0fVxyXG5cclxuXHRnZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihcInkyXCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcclxuXHR9XHJcblxyXG5cdGdldExhYmVsUG9zaXRpb25CeUlkKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tgZ2V0JHtpZC50b1VwcGVyQ2FzZSgpfUF4aXNMYWJlbFBvc2l0aW9uYF0oKTtcclxuXHR9XHJcblxyXG5cdHRleHRGb3JYQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxUZXh0KFwieFwiKTtcclxuXHR9XHJcblxyXG5cdHRleHRGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxUZXh0KFwieVwiKTtcclxuXHR9XHJcblxyXG5cdHRleHRGb3JZMkF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldExhYmVsVGV4dChcInkyXCIpO1xyXG5cdH1cclxuXHJcblx0eEZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9ICQkLnN0YXRlO1xyXG5cdFx0bGV0IHggPSBwb3NpdGlvbi5pc01pZGRsZSA/IC1oZWlnaHQgLyAyIDogMDtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XHJcblx0XHRcdHggPSBwb3NpdGlvbi5pc0xlZnQgPyAwIDogKFxyXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gd2lkdGggLyAyIDogd2lkdGhcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNCb3R0b20pIHtcclxuXHRcdFx0eCA9IC0kJC5zdGF0ZS5oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cclxuXHRkeEZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGxldCBkeCA9IHBvc2l0aW9uLmlzQm90dG9tID8gXCIwLjVlbVwiIDogXCIwXCI7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCQkLCBmb3JIb3Jpem9udGFsKSkge1xyXG5cdFx0XHRkeCA9IHBvc2l0aW9uLmlzTGVmdCA/IFwiMC41ZW1cIiA6IChcclxuXHRcdFx0XHRwb3NpdGlvbi5pc1JpZ2h0ID8gXCItMC41ZW1cIiA6IFwiMFwiXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzVG9wKSB7XHJcblx0XHRcdGR4ID0gXCItMC41ZW1cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZHg7XHJcblx0fVxyXG5cclxuXHR0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0bGV0IGFuY2hvciA9IHBvc2l0aW9uLmlzTWlkZGxlID8gXCJtaWRkbGVcIiA6IFwiZW5kXCI7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCQkLCBmb3JIb3Jpem9udGFsKSkge1xyXG5cdFx0XHRhbmNob3IgPSBwb3NpdGlvbi5pc0xlZnQgPyBcInN0YXJ0XCIgOiAoXHJcblx0XHRcdFx0cG9zaXRpb24uaXNDZW50ZXIgPyBcIm1pZGRsZVwiIDogXCJlbmRcIlxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xyXG5cdFx0XHRhbmNob3IgPSBcInN0YXJ0XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFuY2hvcjtcclxuXHR9XHJcblxyXG5cdHhGb3JYQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMueEZvckF4aXNMYWJlbCh0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHR4Rm9yWUF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKSk7XHJcblx0fVxyXG5cclxuXHR4Rm9yWTJBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpKTtcclxuXHR9XHJcblxyXG5cdGR4Rm9yWEF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdGR4Rm9yWUF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0ZHhGb3JZMkF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpKTtcclxuXHR9XHJcblxyXG5cdGR5Rm9yWEF4aXNMYWJlbCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKS5pc0lubmVyO1xyXG5cdFx0Y29uc3QgeEhlaWdodCA9IGNvbmZpZy5heGlzX3hfaGVpZ2h0O1xyXG5cclxuXHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdHJldHVybiBpc0lubmVyID8gXCIxLjJlbVwiIDogLTI1IC0gdGhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ4XCIpO1xyXG5cdFx0fSBlbHNlIGlmIChpc0lubmVyKSB7XHJcblx0XHRcdHJldHVybiBcIi0wLjVlbVwiO1xyXG5cdFx0fSBlbHNlIGlmICh4SGVpZ2h0KSB7XHJcblx0XHRcdHJldHVybiB4SGVpZ2h0IC0gMTA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gXCIzZW1cIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR5Rm9yWUF4aXNMYWJlbCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IGlzSW5uZXIgPSB0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpLmlzSW5uZXI7XHJcblxyXG5cdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIi0wLjVlbVwiIDogXCIzZW1cIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBpc0lubmVyID8gXCIxLjJlbVwiIDogLTEwIC0gKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAwIDogKHRoaXMuZ2V0TWF4VGlja1dpZHRoKFwieVwiKSArIDEwKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeUZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpLmlzSW5uZXI7XHJcblxyXG5cdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiBcIi0yLjJlbVwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIi0wLjVlbVwiIDogMTUgKyAoJCQuY29uZmlnLmF4aXNfeTJfaW5uZXIgPyAwIDogKHRoaXMuZ2V0TWF4VGlja1dpZHRoKFwieTJcIikgKyAxNSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvclhBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHRleHRBbmNob3JGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcclxuXHR9XHJcblxyXG5cdHRleHRBbmNob3JGb3JZMkF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0Z2V0TWF4VGlja1dpZHRoKGlkOiBzdHJpbmcsIHdpdGhvdXRSZWNvbXB1dGU/OiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3N2ZywgY2hhcnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgY3VycmVudFRpY2tNYXggPSAkJC5zdGF0ZS5jdXJyZW50TWF4VGlja1dpZHRoc1tpZF07XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cclxuXHRcdGlmICh3aXRob3V0UmVjb21wdXRlIHx8ICFjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdKSB7XHJcblx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdmcpIHtcclxuXHRcdFx0Y29uc3QgaXNZQXhpcyA9IC9eeTI/JC8udGVzdChpZCk7XHJcblx0XHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGVbaWRdLmNvcHkoKS5kb21haW4oJCRbYGdldCR7aXNZQXhpcyA/IFwiWVwiIDogXCJYXCJ9RG9tYWluYF0odGFyZ2V0c1RvU2hvdywgaWQpKTtcclxuXHRcdFx0Y29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XHJcblxyXG5cdFx0XHQvLyBkbyBub3QgY29tcHV0ZSBpZiBkb21haW4gaXMgc2FtZVxyXG5cdFx0XHRpZiAoaXNBcnJheShjdXJyZW50VGlja01heC5kb21haW4pICYmIGN1cnJlbnRUaWNrTWF4LmRvbWFpbi5ldmVyeSgodiwgaSkgPT4gdiA9PT0gZG9tYWluW2ldKSkge1xyXG5cdFx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN1cnJlbnRUaWNrTWF4LmRvbWFpbiA9IGRvbWFpbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgYXhpcyA9IHRoaXMuZ2V0QXhpcyhpZCwgc2NhbGUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XHJcblx0XHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2NvdW50YF07XHJcblxyXG5cdFx0XHQvLyBNYWtlIHRvIGdlbmVyYXRlIHRoZSBmaW5hbCB0aWNrIHRleHQgdG8gYmUgcmVuZGVyZWRcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvOTIwXHJcblx0XHRcdGlmICh0aWNrQ291bnQpIHtcclxuXHRcdFx0XHRheGlzLnRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHR0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdFx0ZG9tYWluLFxyXG5cdFx0XHRcdFx0XHR0aWNrQ291bnQsXHJcblx0XHRcdFx0XHRcdGlzWUF4aXMgPyAkJC5pc1RpbWVTZXJpZXNZKCkgOiAkJC5pc1RpbWVTZXJpZXMoKVxyXG5cdFx0XHRcdFx0KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCFpc1lBeGlzICYmIHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3csIGF4aXMpO1xyXG5cclxuXHRcdFx0Y29uc3QgZHVtbXkgPSBjaGFydC5hcHBlbmQoXCJzdmdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBcIjBweFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgXCIwcHhcIik7XHJcblxyXG5cdFx0XHRheGlzLmNyZWF0ZShkdW1teSk7XHJcblxyXG5cdFx0XHRkdW1teS5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGR1bW15LnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXhXaWR0aCA+IDApIHtcclxuXHRcdFx0Y3VycmVudFRpY2tNYXguc2l6ZSA9IG1heFdpZHRoO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlTGFiZWxzKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkJC4kZWw7XHJcblxyXG5cdFx0Y29uc3QgbGFiZWxzID0ge1xyXG5cdFx0XHRYOiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9IC4ke0NMQVNTLmF4aXNYTGFiZWx9YCksXHJcblx0XHRcdFk6IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWX0gLiR7Q0xBU1MuYXhpc1lMYWJlbH1gKSxcclxuXHRcdFx0WTI6IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9IC4ke0NMQVNTLmF4aXNZMkxhYmVsfWApXHJcblx0XHR9O1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKGxhYmVscykuZmlsdGVyKGlkID0+ICFsYWJlbHNbaWRdLmVtcHR5KCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBsYWJlbHNbdl07XHJcblx0XHRcdFx0Y29uc3QgYXhpc0xhYmVsID0gYCR7dn1BeGlzTGFiZWxgO1xyXG5cclxuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gPyBub2RlLnRyYW5zaXRpb24oKSA6IG5vZGUpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgdGhpc1tgeEZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIHRoaXNbYGR4Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgdGhpc1tgZHlGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdFx0LnRleHQodGhpc1tgdGV4dEZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGdldFBhZGRpbmcocGFkZGluZywga2V5LCBkZWZhdWx0VmFsdWUsIGRvbWFpbkxlbmd0aCkge1xyXG5cdFx0Y29uc3QgcCA9IGlzTnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IHBhZGRpbmdba2V5XTtcclxuXHJcblx0XHRpZiAoIWlzVmFsdWUocCkpIHtcclxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwLCBkb21haW5MZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Y29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcocGl4ZWxzLCBkb21haW5MZW5ndGgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7d2lkdGgsIGhlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBsZW5ndGggPSBjb25maWcuYXhpc19yb3RhdGVkID8gd2lkdGggOiBoZWlnaHQ7XHJcblxyXG5cdFx0cmV0dXJuIGRvbWFpbkxlbmd0aCAqIChwaXhlbHMgLyBsZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUaWNrVmFsdWVzKHZhbHVlcywgdGlja0NvdW50LCBmb3JUaW1lU2VyaWVzKSB7XHJcblx0XHRsZXQgdGlja1ZhbHVlcyA9IHZhbHVlcztcclxuXHRcdGxldCBzdGFydDtcclxuXHRcdGxldCBlbmQ7XHJcblx0XHRsZXQgY291bnQ7XHJcblx0XHRsZXQgaW50ZXJ2YWw7XHJcblx0XHRsZXQgaTtcclxuXHRcdGxldCB0aWNrVmFsdWU7XHJcblxyXG5cdFx0aWYgKHRpY2tDb3VudCkge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRDb3VudCA9IGlzRnVuY3Rpb24odGlja0NvdW50KSA/IHRpY2tDb3VudCgpIDogdGlja0NvdW50O1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSB0aWNrcyBhY2NvcmRpbmcgdG8gdGlja0NvdW50XHJcblx0XHRcdGlmICh0YXJnZXRDb3VudCA9PT0gMSkge1xyXG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbdmFsdWVzWzBdXTtcclxuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXRDb3VudCA9PT0gMikge1xyXG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbdmFsdWVzWzBdLCB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdXTtcclxuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXRDb3VudCA+IDIpIHtcclxuXHRcdFx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gdGhpcy5vd25lci5pc0NhdGVnb3JpemVkKCk7XHJcblxyXG5cdFx0XHRcdGNvdW50ID0gdGFyZ2V0Q291bnQgLSAyO1xyXG5cdFx0XHRcdHN0YXJ0ID0gdmFsdWVzWzBdO1xyXG5cdFx0XHRcdGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0aW50ZXJ2YWwgPSAoZW5kIC0gc3RhcnQpIC8gKGNvdW50ICsgMSk7XHJcblxyXG5cdFx0XHRcdC8vIHJlLWNvbnN0cnVjdCB1bmlxdWUgdmFsdWVzXHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFtzdGFydF07XHJcblxyXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0aWNrVmFsdWUgPSArc3RhcnQgKyBpbnRlcnZhbCAqIChpICsgMSk7XHJcblx0XHRcdFx0XHR0aWNrVmFsdWVzLnB1c2goXHJcblx0XHRcdFx0XHRcdGZvclRpbWVTZXJpZXMgPyBuZXcgRGF0ZSh0aWNrVmFsdWUpIDogKFxyXG5cdFx0XHRcdFx0XHRcdGlzQ2F0ZWdvcml6ZWQgPyBNYXRoLnJvdW5kKHRpY2tWYWx1ZSkgOiB0aWNrVmFsdWVcclxuXHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChlbmQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmb3JUaW1lU2VyaWVzKSB7XHJcblx0XHRcdHRpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGlja1ZhbHVlcztcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IGF4aXMgPSAkJC4kZWwuYXhpcztcclxuXHJcblx0XHRjb25zdCBbYXhpc1gsIGF4aXNZLCBheGlzWTIsIGF4aXNTdWJYXSA9IFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJYXCJdXHJcblx0XHRcdC5tYXAodiA9PiB7XHJcblx0XHRcdFx0bGV0IGF4ID0gYXhpc1t2XTtcclxuXHJcblx0XHRcdFx0aWYgKGF4ICYmIGR1cmF0aW9uKSB7XHJcblx0XHRcdFx0XHRheCA9IGF4LnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYXg7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB7YXhpc1gsIGF4aXNZLCBheGlzWTIsIGF4aXNTdWJYfTtcclxuXHR9XHJcblxyXG5cdHJlZHJhdyh0cmFuc2l0aW9ucywgaXNIaWRkZW4sIGlzSW5pdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qgb3BhY2l0eSA9IGlzSGlkZGVuID8gXCIwXCIgOiBcIjFcIjtcclxuXHJcblx0XHRbXCJ4XCIsIFwieVwiLCBcInkyXCIsIFwic3ViWFwiXS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uc3QgYXhpcyA9ICQkLmF4aXNbaWRdO1xyXG5cdFx0XHRjb25zdCAkYXhpcyA9ICRlbC5heGlzW2lkXTtcclxuXHJcblx0XHRcdGlmIChheGlzICYmICRheGlzKSB7XHJcblx0XHRcdFx0aWYgKCFpc0luaXQpIHtcclxuXHRcdFx0XHRcdGF4aXMuY29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID0gIWNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0JGF4aXMuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpO1xyXG5cdFx0XHRcdGF4aXMuY3JlYXRlKHRyYW5zaXRpb25zW2BheGlzJHtjYXBpdGFsaXplKGlkKX1gXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlQXhlcygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IGF4aXNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0c1RvU2hvdyB0YXJnZXRzIGRhdGEgdG8gYmUgc2hvd25cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gd3RoXHJcblx0ICogQHBhcmFtIHtPamJlY3R9IHRyYW5zaXRpb25zXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGZsb3dcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaXNJbml0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzWm9vbSA9ICEhc2NhbGUuem9vbTtcclxuXHRcdGxldCB4RG9tYWluRm9yWm9vbTtcclxuXHJcblx0XHRpZiAoIWhhc1pvb20gJiYgJCQuaXNDYXRlZ29yaXplZCgpICYmIHRhcmdldHNUb1Nob3cubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKFswLCAkZWwuYXhpcy54LnNlbGVjdEFsbChcIi50aWNrXCIpLnNpemUoKV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzY2FsZS54ICYmIHRhcmdldHNUb1Nob3cubGVuZ3RoKSB7XHJcblx0XHRcdCFoYXNab29tICYmXHJcblx0XHRcdFx0JCQudXBkYXRlWERvbWFpbih0YXJnZXRzVG9TaG93LCB3dGguVXBkYXRlWERvbWFpbiwgd3RoLlVwZGF0ZU9yZ1hEb21haW4sIHd0aC5UcmltWERvbWFpbik7XHJcblxyXG5cdFx0XHRpZiAoIWNvbmZpZy5heGlzX3hfdGlja192YWx1ZXMpIHtcclxuXHRcdFx0XHR0aGlzLnVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzVG9TaG93KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgkJC5heGlzLngpIHtcclxuXHRcdFx0JCQuYXhpcy54LnRpY2tWYWx1ZXMoW10pO1xyXG5cdFx0XHQkJC5heGlzLnN1YlggJiYgJCQuYXhpcy5zdWJYLnRpY2tWYWx1ZXMoW10pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuem9vbV9yZXNjYWxlICYmICFmbG93KSB7XHJcblx0XHRcdHhEb21haW5Gb3Jab29tID0gc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHRbXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gc2NhbGVba2V5XTtcclxuXHJcblx0XHRcdGlmIChheGlzKSB7XHJcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja192YWx1ZXNgXTtcclxuXHRcdFx0XHRjb25zdCB0aWNrQ291bnQgPSBjb25maWdbYGF4aXNfJHtrZXl9X3RpY2tfY291bnRgXTtcclxuXHJcblx0XHRcdFx0YXhpcy5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBrZXksIHhEb21haW5Gb3Jab29tKSk7XHJcblxyXG5cdFx0XHRcdGlmICghdGlja1ZhbHVlcyAmJiB0aWNrQ291bnQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGRvbWFpbiA9IGF4aXMuZG9tYWluKCk7XHJcblxyXG5cdFx0XHRcdFx0JCRbYCR7a2V5fUF4aXNgXS50aWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHR0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdFx0XHRkb21haW4sXHJcblx0XHRcdFx0XHRcdFx0ZG9tYWluLmV2ZXJ5KHYgPT4gdiA9PT0gMCkgPyAxIDogdGlja0NvdW50LFxyXG5cdFx0XHRcdFx0XHRcdCQkLmlzVGltZVNlcmllc1koKVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gYXhlc1xyXG5cdFx0dGhpcy5yZWRyYXcodHJhbnNpdGlvbnMsICQkLmhhc0FyY1R5cGUoKSwgaXNJbml0KTtcclxuXHJcblx0XHQvLyBVcGRhdGUgYXhpcyBsYWJlbFxyXG5cdFx0dGhpcy51cGRhdGVMYWJlbHMod3RoLlRyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIHNob3cvaGlkZSBpZiBtYW51YWwgY3VsbGluZyBuZWVkZWRcclxuXHRcdGlmICgod3RoLlVwZGF0ZVhEb21haW4gfHwgd3RoLlVwZGF0ZVhBeGlzIHx8IHd0aC5ZKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLnNldEN1bGxpbmcoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgc3ViIGRvbWFpblxyXG5cdFx0aWYgKHd0aC5ZKSB7XHJcblx0XHRcdHNjYWxlLnN1YlkgJiYgc2NhbGUuc3ViWS5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInlcIikpO1xyXG5cdFx0XHRzY2FsZS5zdWJZMiAmJiBzY2FsZS5zdWJZMi5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInkyXCIpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBtYW51YWwgY3VsbGluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0Q3VsbGluZygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRbXCJzdWJYXCIsIFwieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKHR5cGUgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gJGVsLmF4aXNbdHlwZV07XHJcblxyXG5cdFx0XHQvLyBzdWJjaGFydCB4IGF4aXMgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMgY3VsbGluZ1xyXG5cdFx0XHRjb25zdCBpZCA9IHR5cGUgPT09IFwic3ViWFwiID8gXCJ4XCIgOiB0eXBlO1xyXG5cdFx0XHRjb25zdCB0b0N1bGwgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19jdWxsaW5nYF07XHJcblxyXG5cdFx0XHRpZiAoYXhpcyAmJiB0b0N1bGwpIHtcclxuXHRcdFx0XHRjb25zdCB0aWNrVGV4dCA9IGF4aXMuc2VsZWN0QWxsKFwiLnRpY2sgdGV4dFwiKTtcclxuXHRcdFx0XHRjb25zdCB0aWNrVmFsdWVzID0gc29ydFZhbHVlKHRpY2tUZXh0LmRhdGEoKSk7XHJcblx0XHRcdFx0Y29uc3QgdGlja1NpemUgPSB0aWNrVmFsdWVzLmxlbmd0aDtcclxuXHRcdFx0XHRjb25zdCBjdWxsaW5nTWF4ID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY3VsbGluZ19tYXhgXTtcclxuXHRcdFx0XHRsZXQgaW50ZXJ2YWxGb3JDdWxsaW5nO1xyXG5cclxuXHRcdFx0XHRpZiAodGlja1NpemUpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdGlja1NpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAodGlja1NpemUgLyBpIDwgY3VsbGluZ01heCkge1xyXG5cdFx0XHRcdFx0XHRcdGludGVydmFsRm9yQ3VsbGluZyA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aWNrVGV4dC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gdGlja1ZhbHVlcy5pbmRleE9mKGQpICUgaW50ZXJ2YWxGb3JDdWxsaW5nID8gXCJub25lXCIgOiBcImJsb2NrXCI7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGlja1RleHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdGNzdlBhcnNlIGFzIGQzQ3N2UGFyc2UsXHJcblx0dHN2UGFyc2UgYXMgZDNUc3ZQYXJzZSxcclxuXHRjc3ZQYXJzZVJvd3MgYXMgZDNDc3ZQYXJzZVJvd3MsXHJcblx0dHN2UGFyc2VSb3dzIGFzIGQzVHN2UGFyc2VSb3dzLFxyXG59IGZyb20gXCJkMy1kc3ZcIjtcclxuaW1wb3J0IHtpc1VuZGVmaW5lZCwgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNWYWx1ZSwgbm90RW1wdHksIGlzQXJyYXksIGNhcGl0YWxpemV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIERhdGEgY29udmVydFxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRJbnRlcm5hbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgZGF0YSBhY2NvcmRpbmcgaXRzIHR5cGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyBkYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZm9yIHVybChYSFIpIHR5cGUgbG9hZGluZ1xyXG5cdCAqIEByZXR1cm4ge09iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnREYXRhKGFyZ3MsIGNhbGxiYWNrKSB7XHJcblx0XHRsZXQgZGF0YTtcclxuXHJcblx0XHRpZiAoYXJncy5iaW5kdG8pIHtcclxuXHRcdFx0ZGF0YSA9IHt9O1xyXG5cclxuXHRcdFx0W1widXJsXCIsIFwibWltZVR5cGVcIiwgXCJoZWFkZXJzXCIsIFwia2V5c1wiLCBcImpzb25cIiwgXCJrZXlzXCIsIFwicm93c1wiLCBcImNvbHVtbnNcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGtleSA9IGBkYXRhXyR7dn1gO1xyXG5cclxuXHRcdFx0XHRcdGlmIChrZXkgaW4gYXJncykge1xyXG5cdFx0XHRcdFx0XHRkYXRhW3ZdID0gYXJnc1trZXldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGF0YSA9IGFyZ3M7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRhdGEudXJsICYmIGNhbGxiYWNrKSB7XHJcblx0XHRcdHRoaXMuY29udmVydFVybFRvRGF0YShkYXRhLnVybCwgZGF0YS5taW1lVHlwZSwgZGF0YS5oZWFkZXJzLCBkYXRhLmtleXMsIGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5qc29uKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRKc29uVG9EYXRhKGRhdGEuanNvbiwgZGF0YS5rZXlzKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5yb3dzKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRSb3dzVG9EYXRhKGRhdGEucm93cyk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Q29sdW1uc1RvRGF0YShkYXRhLmNvbHVtbnMpO1xyXG5cdFx0fSBlbHNlIGlmIChhcmdzLmJpbmR0bykge1xyXG5cdFx0XHR0aHJvdyBFcnJvcihcInVybCBvciBqc29uIG9yIHJvd3Mgb3IgY29sdW1ucyBpcyByZXF1aXJlZC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkoZGF0YSkgJiYgZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IFVSTCBkYXRhXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybCBSZW1vdGUgVVJMXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIE1JTUUgdHlwZSBzdHJpbmc6IGpzb24gfCBjc3YgfCB0c3ZcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyBIZWFkZXIgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGtleXMgS2V5IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGJhY2sgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRVcmxUb0RhdGEodXJsLCBtaW1lVHlwZSA9IFwiY3N2XCIsIGhlYWRlcnMsIGtleXMsIGRvbmUpIHtcclxuXHRcdGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHRcdHJlcS5vcGVuKFwiR0VUXCIsIHVybCk7XHJcblxyXG5cdFx0aWYgKGhlYWRlcnMpIHtcclxuXHRcdFx0T2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuXHRcdFx0aWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XHJcblx0XHRcdFx0aWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSByZXEucmVzcG9uc2VUZXh0O1xyXG5cclxuXHRcdFx0XHRcdHJlc3BvbnNlICYmIGRvbmUuY2FsbCh0aGlzLFxyXG5cdFx0XHRcdFx0XHR0aGlzW2Bjb252ZXJ0JHtjYXBpdGFsaXplKG1pbWVUeXBlKX1Ub0RhdGFgXShcclxuXHRcdFx0XHRcdFx0XHRtaW1lVHlwZSA9PT0gXCJqc29uXCIgPyBKU09OLnBhcnNlKHJlc3BvbnNlKSA6IHJlc3BvbnNlLFxyXG5cdFx0XHRcdFx0XHRcdGtleXNcclxuXHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgJHt1cmx9OiBTb21ldGhpbmcgd2VudCB3cm9uZyBsb2FkaW5nIWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXEuc2VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgQ1NWL1RTViBkYXRhXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcnNlciBQYXJzZXIgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHhzdiBEYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XHJcblx0ICovXHJcblx0Y29udmVydENzdlRzdlRvRGF0YShwYXJzZXIsIHhzdikge1xyXG5cdFx0Y29uc3Qgcm93cyA9IHBhcnNlci5yb3dzKHhzdik7XHJcblx0XHRsZXQgZDtcclxuXHJcblx0XHRpZiAocm93cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0ZCA9IFt7fV07XHJcblxyXG5cdFx0XHRyb3dzWzBdLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRcdGRbMF1baWRdID0gbnVsbDtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkID0gcGFyc2VyLnBhcnNlKHhzdik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGQ7XHJcblx0fSxcclxuXHJcblx0Y29udmVydENzdlRvRGF0YSh4c3YpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRDc3ZUc3ZUb0RhdGEoe1xyXG5cdFx0XHRyb3dzOiBkM0NzdlBhcnNlUm93cyxcclxuXHRcdFx0cGFyc2U6IGQzQ3N2UGFyc2VcclxuXHRcdH0sIHhzdik7XHJcblx0fSxcclxuXHJcblx0Y29udmVydFRzdlRvRGF0YSh0c3YpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRDc3ZUc3ZUb0RhdGEoe1xyXG5cdFx0XHRyb3dzOiBkM1RzdlBhcnNlUm93cyxcclxuXHRcdFx0cGFyc2U6IGQzVHN2UGFyc2VcclxuXHRcdH0sIHRzdik7XHJcblx0fSxcclxuXHJcblx0Y29udmVydEpzb25Ub0RhdGEoanNvbiwga2V5c1BhcmFtKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBuZXdSb3dzOiBzdHJpbmdbXVtdID0gW107XHJcblx0XHRsZXQgdGFyZ2V0S2V5czogc3RyaW5nW107XHJcblx0XHRsZXQgZGF0YTtcclxuXHJcblx0XHRpZiAoaXNBcnJheShqc29uKSkge1xyXG5cdFx0XHRjb25zdCBrZXlzID0ga2V5c1BhcmFtIHx8IGNvbmZpZy5kYXRhX2tleXM7XHJcblxyXG5cdFx0XHRpZiAoa2V5cy54KSB7XHJcblx0XHRcdFx0dGFyZ2V0S2V5cyA9IGtleXMudmFsdWUuY29uY2F0KGtleXMueCk7XHJcblx0XHRcdFx0Y29uZmlnLmRhdGFfeCA9IGtleXMueDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bmV3Um93cy5wdXNoKHRhcmdldEtleXMpO1xyXG5cclxuXHRcdFx0anNvbi5mb3JFYWNoKG8gPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG5ld1JvdyA9IHRhcmdldEtleXMubWFwKGtleSA9PiB7XHJcblx0XHRcdFx0XHQvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIGJlY2F1c2UgdW5kZWZpbmVkIGRhdGEgd2lsbCBiZSByZW1vdmVkIGluIGNvbnZlcnREYXRhVG9UYXJnZXRzKClcclxuXHRcdFx0XHRcdGxldCB2ID0gdGhpcy5maW5kVmFsdWVJbkpzb24obywga2V5KTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcclxuXHRcdFx0XHRcdFx0diA9IG51bGw7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHY7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdG5ld1Jvd3MucHVzaChuZXdSb3cpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRSb3dzVG9EYXRhKG5ld1Jvd3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0T2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHRtcCA9IGpzb25ba2V5XS5jb25jYXQoKTtcclxuXHJcblx0XHRcdFx0dG1wLnVuc2hpZnQoa2V5KTtcclxuXHRcdFx0XHRuZXdSb3dzLnB1c2godG1wKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Q29sdW1uc1RvRGF0YShuZXdSb3dzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9LFxyXG5cclxuXHRmaW5kVmFsdWVJbkpzb24ob2JqZWN0LCBwYXRoKSB7XHJcblx0XHRpZiAob2JqZWN0W3BhdGhdICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIG9iamVjdFtwYXRoXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjb252ZXJ0ZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgXCIuJDFcIik7IC8vIGNvbnZlcnQgaW5kZXhlcyB0byBwcm9wZXJ0aWVzIChyZXBsYWNlIFtdIHdpdGggLilcclxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGNvbnZlcnRlZFBhdGgucmVwbGFjZSgvXlxcLi8sIFwiXCIpLnNwbGl0KFwiLlwiKTsgLy8gc3RyaXAgYSBsZWFkaW5nIGRvdFxyXG5cdFx0bGV0IHRhcmdldCA9IG9iamVjdDtcclxuXHJcblx0XHRwYXRoQXJyYXkuc29tZShrID0+ICEoXHJcblx0XHRcdHRhcmdldCA9IHRhcmdldCAmJiBrIGluIHRhcmdldCA/XHJcblx0XHRcdFx0dGFyZ2V0W2tdIDogdW5kZWZpbmVkXHJcblx0XHQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRSb3dzVG9EYXRhKHJvd3MpIHtcclxuXHRcdGNvbnN0IGtleXMgPSByb3dzWzBdO1xyXG5cdFx0Y29uc3QgbmV3Um93czogYW55W10gPSBbXTtcclxuXHJcblx0XHRyb3dzLmZvckVhY2goKHJvdywgaSkgPT4ge1xyXG5cdFx0XHRpZiAoaSA+IDApIHtcclxuXHRcdFx0XHRjb25zdCBuZXdSb3cgPSB7fTtcclxuXHJcblx0XHRcdFx0cm93LmZvckVhY2goKHYsIGopID0+IHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2KSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKCR7aX0sICR7an0pIWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG5ld1Jvd1trZXlzW2pdXSA9IHY7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdG5ld1Jvd3MucHVzaChuZXdSb3cpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3Um93cztcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0Q29sdW1uc1RvRGF0YShjb2x1bW5zKSB7XHJcblx0XHRjb25zdCBuZXdSb3dzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdGNvbHVtbnMuZm9yRWFjaCgoY29sLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IGtleSA9IGNvbFswXTtcclxuXHJcblx0XHRcdGNvbC5mb3JFYWNoKCh2LCBqKSA9PiB7XHJcblx0XHRcdFx0aWYgKGogPiAwKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQobmV3Um93c1tqIC0gMV0pKSB7XHJcblx0XHRcdFx0XHRcdG5ld1Jvd3NbaiAtIDFdID0ge307XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU291cmNlIGRhdGEgaXMgbWlzc2luZyBhIGNvbXBvbmVudCBhdCAoJHtpfSwgJHtqfSkhYCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bmV3Um93c1tqIC0gMV1ba2V5XSA9IHY7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBuZXdSb3dzO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEsIGFwcGVuZFhzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xyXG5cclxuXHRcdGNvbnN0IGRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSB8fCB7fSk7XHJcblx0XHRjb25zdCBpZHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNOb3RYLCAkJCkgOiBbXTtcclxuXHRcdGNvbnN0IHhzID0gZGF0YUtleXMubGVuZ3RoID8gZGF0YUtleXMuZmlsdGVyKCQkLmlzWCwgJCQpIDogW107XHJcblxyXG5cdFx0bGV0IHhzRGF0YTtcclxuXHJcblx0XHQvLyBzYXZlIHggZm9yIHVwZGF0ZSBkYXRhIGJ5IGxvYWQgd2hlbiBjdXN0b20geCBhbmQgYmIueCBBUElcclxuXHRcdGlkcy5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uc3QgeEtleSA9IHRoaXMuZ2V0WEtleShpZCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5pc0N1c3RvbVgoKSB8fCBpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHQvLyBpZiBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhXHJcblx0XHRcdFx0aWYgKHhzLmluZGV4T2YoeEtleSkgPj0gMCkge1xyXG5cdFx0XHRcdFx0eHNEYXRhID0gKChhcHBlbmRYcyAmJiAkJC5kYXRhLnhzW2lkXSkgfHwgW10pXHJcblx0XHRcdFx0XHRcdC5jb25jYXQoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5tYXAoZCA9PiBkW3hLZXldKVxyXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihpc1ZhbHVlKVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgocmF3WCwgaSkgPT4gJCQuZ2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpKSlcclxuXHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbmZpZy5kYXRhX3gpIHtcclxuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGEgb2Ygb3RoZXIgaWQncyB4XHJcblx0XHRcdFx0XHR4c0RhdGEgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgbm90IGluY2x1ZGVkIGluIGlucHV0IGRhdGEsIGZpbmQgZnJvbSBwcmVsb2FkZWQgZGF0YVxyXG5cdFx0XHRcdFx0eHNEYXRhID0gJCQuZ2V0WFZhbHVlc09mWEtleSh4S2V5LCAkJC5kYXRhLnRhcmdldHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBNRU1POiBpZiBubyB4IGluY2x1ZGVkLCB1c2Ugc2FtZSB4IG9mIGN1cnJlbnQgd2lsbCBiZSB1c2VkXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0eHNEYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+IGkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4c0RhdGEgJiYgKHRoaXMuZGF0YS54c1tpZF0gPSB4c0RhdGEpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgeCBpcyBkZWZpbmVkXHJcblx0XHRpZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGlmICghdGhpcy5kYXRhLnhzW2lkXSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgeCBpcyBub3QgZGVmaW5lZCBmb3IgaWQgPSBcIiR7aWR9XCIuYCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGNvbnZlcnQgdG8gdGFyZ2V0XHJcblx0XHRjb25zdCB0YXJnZXRzID0gaWRzLm1hcCgoaWQsIGluZGV4KSA9PiB7XHJcblx0XHRcdGNvbnN0IGNvbnZlcnRlZElkID0gY29uZmlnLmRhdGFfaWRDb252ZXJ0ZXIuYmluZCgkJC5hcGkpKGlkKTtcclxuXHRcdFx0Y29uc3QgeEtleSA9ICQkLmdldFhLZXkoaWQpO1xyXG5cdFx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDdXN0b21YKCkgJiYgJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cdFx0XHRjb25zdCBoYXNDYXRlZ29yeSA9IGlzQ2F0ZWdvcml6ZWQgJiYgZGF0YS5tYXAodiA9PiB2LngpXHJcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcclxuXHRcdFx0XHRpZF9vcmc6IGlkLFxyXG5cdFx0XHRcdHZhbHVlczogZGF0YS5tYXAoKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xyXG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZFtpZF07XHJcblx0XHRcdFx0XHRsZXQgeDtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgIWlzT2JqZWN0KHZhbHVlKSA/XHJcblx0XHRcdFx0XHRcdCt2YWx1ZSA6IChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHVzZSB4IGFzIGNhdGVnb3JpZXMgaWYgY3VzdG9tIHggYW5kIGNhdGVnb3JpemVkXHJcblx0XHRcdFx0XHRpZiAoaXNDYXRlZ29yaXplZCAmJiBpbmRleCA9PT0gMCAmJiAhaXNVbmRlZmluZWQocmF3WCkpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCFoYXNDYXRlZ29yeSAmJiBpbmRleCA9PT0gMCAmJiBpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gW107XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHggPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMuaW5kZXhPZihyYXdYKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICh4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdHggPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5wdXNoKHJhd1gpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR4ID0gJCQuZ2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBtYXJrIGFzIHggPSB1bmRlZmluZWQgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZCBmaWx0ZXIgdG8gcmVtb3ZlIGFmdGVyIG1hcHBlZFxyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCAkJC5kYXRhLnhzW2lkXS5sZW5ndGggPD0gaSkge1xyXG5cdFx0XHRcdFx0XHR4ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7eCwgdmFsdWUsIGlkOiBjb252ZXJ0ZWRJZH07XHJcblx0XHRcdFx0fSkuZmlsdGVyKHYgPT4gaXNEZWZpbmVkKHYueCkpXHJcblx0XHRcdH07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBmaW5pc2ggdGFyZ2V0c1xyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHQvLyBzb3J0IHZhbHVlcyBieSBpdHMgeFxyXG5cdFx0XHRpZiAoY29uZmlnLmRhdGFfeFNvcnQpIHtcclxuXHRcdFx0XHR0LnZhbHVlcyA9IHQudmFsdWVzLnNvcnQoKHYxLCB2MikgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeDEgPSB2MS54IHx8IHYxLnggPT09IDAgPyB2MS54IDogSW5maW5pdHk7XHJcblx0XHRcdFx0XHRjb25zdCB4MiA9IHYyLnggfHwgdjIueCA9PT0gMCA/IHYyLnggOiBJbmZpbml0eTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4geDEgLSB4MjtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaW5kZXhpbmcgZWFjaCB2YWx1ZVxyXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiAodi5pbmRleCA9IGkpKTtcclxuXHJcblx0XHRcdC8vIHRoaXMgbmVlZHMgdG8gYmUgc29ydGVkIGJlY2F1c2UgaXRzIGluZGV4IGFuZCB2YWx1ZS5pbmRleCBpcyBpZGVudGljYWxcclxuXHRcdFx0JCQuZGF0YS54c1t0LmlkXS5zb3J0KCh2MSwgdjIpID0+IHYxIC0gdjIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgdmFsdWVzXHJcblx0XHRzdGF0ZS5oYXNOZWdhdGl2ZVZhbHVlID0gJCQuaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcclxuXHRcdHN0YXRlLmhhc1Bvc2l0aXZlVmFsdWUgPSAkJC5oYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xyXG5cclxuXHRcdC8vIHNldCB0YXJnZXQgdHlwZXNcclxuXHRcdGlmIChjb25maWcuZGF0YV90eXBlKSB7XHJcblx0XHRcdCQkLnNldFRhcmdldFR5cGUoJCQubWFwVG9JZHModGFyZ2V0cylcclxuXHRcdFx0XHQuZmlsdGVyKGlkID0+ICEoaWQgaW4gY29uZmlnLmRhdGFfdHlwZXMpKSwgY29uZmlnLmRhdGFfdHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FjaGUgYXMgb3JpZ2luYWwgaWQga2V5ZWRcclxuXHRcdHRhcmdldHMuZm9yRWFjaChkID0+ICQkLmNhY2hlLmFkZChkLmlkX29yZywgZCwgdHJ1ZSkpO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7XHJcblx0Z2V0VW5pcXVlLFxyXG5cdGhhc1ZhbHVlLFxyXG5cdGlzQXJyYXksXHJcblx0aXNCb29sZWFuLFxyXG5cdGlzRGVmaW5lZCxcclxuXHRpc0Z1bmN0aW9uLFxyXG5cdGlzTnVtYmVyLFxyXG5cdGlzT2JqZWN0LFxyXG5cdGlzT2JqZWN0VHlwZSxcclxuXHRpc1N0cmluZyxcclxuXHRpc1VuZGVmaW5lZCxcclxuXHRpc1ZhbHVlLFxyXG5cdG1lcmdlQXJyYXksXHJcblx0bm90RW1wdHksXHJcblx0cGFyc2VEYXRlLFxyXG5cdHNvcnRWYWx1ZVxyXG59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGlzWChrZXkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhS2V5ID0gY29uZmlnLmRhdGFfeCAmJiBrZXkgPT09IGNvbmZpZy5kYXRhX3g7XHJcblx0XHRjb25zdCBleGlzdFZhbHVlID0gbm90RW1wdHkoY29uZmlnLmRhdGFfeHMpICYmIGhhc1ZhbHVlKGNvbmZpZy5kYXRhX3hzLCBrZXkpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhS2V5IHx8IGV4aXN0VmFsdWU7XHJcblx0fSxcclxuXHJcblx0aXNOb3RYKGtleSkge1xyXG5cdFx0cmV0dXJuICF0aGlzLmlzWChrZXkpO1xyXG5cdH0sXHJcblxyXG5cdGlzU3RhY2tOb3JtYWxpemVkKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAhIShjb25maWcuZGF0YV9zdGFja19ub3JtYWxpemUgJiYgY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aCk7XHJcblx0fSxcclxuXHJcblx0aXNHcm91cGVkKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZGF0YV9ncm91cHNcclxuXHRcdFx0Lm1hcCh2ID0+IHYuaW5kZXhPZihpZCkgPj0gMClbMF07XHJcblx0fSxcclxuXHJcblx0Z2V0WEtleShpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmRhdGFfeCA/XHJcblx0XHRcdGNvbmZpZy5kYXRhX3ggOiAobm90RW1wdHkoY29uZmlnLmRhdGFfeHMpID8gY29uZmlnLmRhdGFfeHNbaWRdIDogbnVsbCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WFZhbHVlc09mWEtleShrZXksIHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlkcyA9IHRhcmdldHMgJiYgbm90RW1wdHkodGFyZ2V0cykgPyAkJC5tYXBUb0lkcyh0YXJnZXRzKSA6IFtdO1xyXG5cdFx0bGV0IHhWYWx1ZXM7XHJcblxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRpZiAoJCQuZ2V0WEtleShpZCkgPT09IGtleSkge1xyXG5cdFx0XHRcdHhWYWx1ZXMgPSAkJC5kYXRhLnhzW2lkXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHhWYWx1ZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGluZGV4IG51bWJlciBiYXNlZCBvbiBnaXZlbiB4IEF4aXMgdmFsdWVcclxuXHQgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ30geCB4IEF4aXMgdG8gYmUgY29tcGFyZWRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlZFggeCBBeGlzIGxpc3QgdG8gYmUgYmFzZWQgb25cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kZXhCeVgoeCwgYmFzZWRYKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGJhc2VkWCA/XHJcblx0XHRcdGJhc2VkWC5pbmRleE9mKGlzU3RyaW5nKHgpID8geCA6ICt4KSA6XHJcblx0XHRcdCgkJC5maWx0ZXJCeVgoJCQuZGF0YS50YXJnZXRzLCB4KVswXSB8fCB7aW5kZXg6IG51bGx9KS5pbmRleDtcclxuXHR9LFxyXG5cclxuXHRnZXRYVmFsdWUoaWQsIGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gaWQgaW4gJCQuZGF0YS54cyAmJlxyXG5cdFx0XHQkJC5kYXRhLnhzW2lkXSAmJlxyXG5cdFx0XHRpc1ZhbHVlKCQkLmRhdGEueHNbaWRdW2ldKSA/ICQkLmRhdGEueHNbaWRdW2ldIDogaTtcclxuXHR9LFxyXG5cclxuXHRnZXRPdGhlclRhcmdldFhzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzRm9yWCA9IE9iamVjdC5rZXlzKCQkLmRhdGEueHMpO1xyXG5cclxuXHRcdHJldHVybiBpZHNGb3JYLmxlbmd0aCA/ICQkLmRhdGEueHNbaWRzRm9yWFswXV0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldE90aGVyVGFyZ2V0WChpbmRleCkge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcclxuXHJcblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGFkZFhzKHhzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNNdWx0aXBsZVgoKSB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcclxuXHRcdFx0IXRoaXMuY29uZmlnLmRhdGFfeFNvcnQgfHxcclxuXHRcdFx0dGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8XHJcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0YWRkTmFtZShkYXRhKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IG5hbWU7XHJcblxyXG5cdFx0aWYgKGRhdGEpIHtcclxuXHRcdFx0bmFtZSA9IGNvbmZpZy5kYXRhX25hbWVzW2RhdGEuaWRdO1xyXG5cdFx0XHRkYXRhLm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogZGF0YS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9LFxyXG5cclxuXHRnZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKVxyXG5cdFx0XHQubWFwKHQgPT4gJCQuYWRkTmFtZSgkJC5nZXRWYWx1ZU9uSW5kZXgodC52YWx1ZXMsIGluZGV4KSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlT25JbmRleCh2YWx1ZXMsIGluZGV4KSB7XHJcblx0XHRjb25zdCB2YWx1ZU9uSW5kZXggPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdi5pbmRleCA9PT0gaW5kZXgpO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZU9uSW5kZXgubGVuZ3RoID8gdmFsdWVPbkluZGV4WzBdIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRYKHRhcmdldHMsIHgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHR2LnggPSAkJC5nZW5lcmF0ZVRhcmdldFgoeFtpXSwgdC5pZCwgaSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuZGF0YS54c1t0LmlkXSA9IHg7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRYcyh0YXJnZXRzLCB4cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0eHNbdC5pZF0gJiYgJCQudXBkYXRlVGFyZ2V0WChbdF0sIHhzW3QuaWRdKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaW5kZXgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB4ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gaW5kZXggOiAocmF3WCB8fCBpbmRleCk7XHJcblxyXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0eCA9IHJhd1ggPyBmbihyYXdYKSA6IGZuKCQkLmdldFhWYWx1ZShpZCwgaW5kZXgpKTtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNDdXN0b21YKCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWHModmFsdWVzKSB7XHJcblx0XHRpZiAodmFsdWVzLmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLmF4aXMueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQcmV2WChpKSB7XHJcblx0XHRjb25zdCB4ID0gdGhpcy5heGlzLnhzW2kgLSAxXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0TmV4dFgoaSkge1xyXG5cdFx0Y29uc3QgeCA9IHRoaXMuYXhpcy54c1tpICsgMV07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBiYXNlIHZhbHVlIGlzQXJlYVJhbmdlVHlwZVxyXG5cdCAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZVZhbHVlKGRhdGEpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB2YWx1ZSA9IGRhdGEudmFsdWU7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSBvZiBhcmVhLXJhbmdlLCBkYXRhIGlzIGdpdmVuIGFzOiBbbG93LCBtaWQsIGhpZ2hdIG9yIHtsb3csIG1pZCwgaGlnaH1cclxuXHRcdC8vIHdpbGwgdGFrZSB0aGUgJ21pZCcgYXMgdGhlIGJhc2UgdmFsdWVcclxuXHRcdGlmICh2YWx1ZSAmJiAkJC5oYXNBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5pc0FyZWFSYW5nZVR5cGUoZGF0YSkpIHtcclxuXHRcdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVaVHlwZShkYXRhKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBtaW4vbWF4IHZhbHVlIGZyb20gdGhlIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgZGF0YSB0byBiZSBldmFsdWF0ZWRcclxuXHQgKiBAcmV0dXJuIHt7bWluOiB7TnVtYmVyfSwgbWF4OiB7TnVtYmVyfX19XHJcblx0ICovXHJcblx0Z2V0TWluTWF4VmFsdWUoZGF0YSkge1xyXG5cdFx0Y29uc3QgZ2V0QmFzZVZhbHVlID0gdGhpcy5nZXRCYXNlVmFsdWUuYmluZCh0aGlzKTtcclxuXHRcdGxldCBtaW47XHJcblx0XHRsZXQgbWF4O1xyXG5cclxuXHRcdChkYXRhIHx8IHRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSlcclxuXHRcdFx0LmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYubWFwKGdldEJhc2VWYWx1ZSkuZmlsdGVyKGlzTnVtYmVyKTtcclxuXHJcblx0XHRcdFx0bWluID0gTWF0aC5taW4oaSA/IG1pbiA6IEluZmluaXR5LCAuLi52YWx1ZSk7XHJcblx0XHRcdFx0bWF4ID0gTWF0aC5tYXgoaSA/IG1heCA6IC1JbmZpbml0eSwgLi4udmFsdWUpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4ge21pbiwgbWF4fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1pbi9tYXggZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7e21pbjogQXJyYXksIG1heDogQXJyYXl9fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heERhdGEoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJG1pbk1heERhdGFcIjtcclxuXHRcdGxldCBtaW5NYXhEYXRhID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIW1pbk1heERhdGEpIHtcclxuXHRcdFx0Y29uc3QgZGF0YSA9ICQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcyk7XHJcblx0XHRcdGNvbnN0IG1pbk1heCA9ICQkLmdldE1pbk1heFZhbHVlKGRhdGEpO1xyXG5cclxuXHRcdFx0bGV0IG1pbiA9IFtdO1xyXG5cdFx0XHRsZXQgbWF4ID0gW107XHJcblxyXG5cdFx0XHRkYXRhLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbWluRGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1pbik7XHJcblx0XHRcdFx0Y29uc3QgbWF4RGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1heCk7XHJcblxyXG5cdFx0XHRcdGlmIChtaW5EYXRhLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0bWluID0gbWluLmNvbmNhdChtaW5EYXRhKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChtYXhEYXRhLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0bWF4ID0gbWF4LmNvbmNhdChtYXhEYXRhKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBjYWNoZWQgZGF0YVxyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIG1pbk1heERhdGEgPSB7bWluLCBtYXh9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWluTWF4RGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgc3VtIG9mIGRhdGEgcGVyIGluZGV4XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJuIHtBcnJheX1cclxuXHQgKi9cclxuXHRnZXRUb3RhbFBlckluZGV4KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiR0b3RhbFBlckluZGV4XCI7XHJcblx0XHRsZXQgc3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAhc3VtKSB7XHJcblx0XHRcdHN1bSA9IFtdO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2gocm93ID0+IHtcclxuXHRcdFx0XHRyb3cudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdGlmICghc3VtW2ldKSB7XHJcblx0XHRcdFx0XHRcdHN1bVtpXSA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRvdGFsIGRhdGEgc3VtXHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG4gXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvdGFsRGF0YVN1bSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkdG90YWxEYXRhU3VtXCI7XHJcblx0XHRsZXQgdG90YWxEYXRhU3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIXRvdGFsRGF0YVN1bSkge1xyXG5cdFx0XHRjb25zdCB0b3RhbCA9IG1lcmdlQXJyYXkoJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSlcclxuXHRcdFx0XHQubWFwKHYgPT4gdi52YWx1ZSlcclxuXHRcdFx0XHQucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIHRvdGFsRGF0YVN1bSA9IHRvdGFsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdG90YWxEYXRhU3VtO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmaWx0ZXJlZCBkYXRhIGJ5IHZhbHVlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gZmlsdGVyZWQgYXJyYXkgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RmlsdGVyZWREYXRhQnlWYWx1ZShkYXRhLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKHQgPT4gdGhpcy5nZXRCYXNlVmFsdWUodCkgPT09IHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgdGhlIGRhdGFcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IG1heCBkYXRhIGxlbmd0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TWF4RGF0YUNvdW50KCkge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLmxlbmd0aCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heERhdGFDb3VudFRhcmdldCgpIHtcclxuXHRcdGxldCB0YXJnZXQgPSB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKSB8fCBbXTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcCh0ID0+IHQudmFsdWVzKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2LngpO1xyXG5cclxuXHRcdFx0dGFyZ2V0ID0gc29ydFZhbHVlKGdldFVuaXF1ZSh0YXJnZXQpKVxyXG5cdFx0XHRcdC5tYXAoKHgsIGluZGV4KSA9PiAoe3gsIGluZGV4fSkpO1xyXG5cdFx0fSBlbHNlIGlmIChsZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0WzBdLnZhbHVlcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvSWRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0YXJnZXRzLm1hcChkID0+IGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvVGFyZ2V0SWRzKGlkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgPyAoaXNBcnJheShpZHMpID8gaWRzLmNvbmNhdCgpIDogW2lkc10pIDogJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHR9LFxyXG5cclxuXHRoYXNUYXJnZXQodGFyZ2V0cywgaWQpIHtcclxuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHZhbDsgKHZhbCA9IGlkc1tpXSk7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclRhcmdldHNUb1Nob3codGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAodGFyZ2V0cyB8fCAkJC5kYXRhLnRhcmdldHMpLmZpbHRlcih0ID0+ICQkLmlzVGFyZ2V0VG9TaG93KHQuaWQpKTtcclxuXHR9LFxyXG5cclxuXHRtYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgeHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0aWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0eHMgPSBnZXRVbmlxdWUoXHJcblx0XHRcdFx0bWVyZ2VBcnJheSh0YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLm1hcCh2ID0+ICt2LngpKSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHhzID0gJCQuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpIHtcclxuXHRcdHRoaXMuc3RhdGUuaGlkZGVuVGFyZ2V0SWRzID0gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuY29uY2F0KHRhcmdldElkcyk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSGlkZGVuVGFyZ2V0SWRzKHRhcmdldElkcykge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0YWRkSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcykge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeXMgPSB7fTtcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcclxuXHRcdGNvbnN0IHhzID0gaXNNdWx0aXBsZVggPyAkJC5tYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKVxyXG5cdFx0XHQubWFwKHYgPT4gKGlzU3RyaW5nKHYpID8gdiA6ICt2KSkgOiBudWxsO1xyXG5cclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0Y29uc3QgZGF0YTogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2LnZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaCguLi52YWx1ZSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgXCJoaWdoXCIgaW4gdmFsdWUpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaCguLi5PYmplY3QudmFsdWVzKHZhbHVlKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVpUeXBlKHYpKSB7XHJcblx0XHRcdFx0XHRkYXRhLnB1c2goJCQuaGFzQXhpcyAmJiAkJC5nZXRCdWJibGVaRGF0YSh2YWx1ZSwgXCJ5XCIpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGlzTXVsdGlwbGVYKSB7XHJcblx0XHRcdFx0XHRcdGRhdGFbJCQuZ2V0SW5kZXhCeVgodi54LCB4cyldID0gdmFsdWU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRkYXRhLnB1c2godmFsdWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR5c1t0LmlkXSA9IGRhdGE7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4geXM7XHJcblx0fSxcclxuXHJcblx0Y2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCBjaGVja2VyKSB7XHJcblx0XHRjb25zdCBpZHMgPSBPYmplY3Qua2V5cyh0YXJnZXRzKTtcclxuXHRcdGxldCB2YWx1ZXM7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFsdWVzID0gdGFyZ2V0c1tpZHNbaV1dLnZhbHVlcztcclxuXHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGNoZWNrZXIodmFsdWVzW2pdLnZhbHVlKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGhhc011bHRpVGFyZ2V0cygpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPiAxO1xyXG5cdH0sXHJcblxyXG5cdGhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCB2ID0+IHYgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2ID4gMCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrT3JkZXIodHlwZSkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qgb3JkZXIgPSBjb25maWcuZGF0YV9vcmRlcjtcclxuXHJcblx0XHRyZXR1cm4gaXNTdHJpbmcob3JkZXIpICYmIG9yZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR5cGU7XHJcblx0fSxcclxuXHJcblx0aXNPcmRlckRlc2MoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tPcmRlcihcImRlc2NcIik7XHJcblx0fSxcclxuXHJcblx0aXNPcmRlckFzYygpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiYXNjXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNvcnQgdGFyZ2V0cyBkYXRhXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0c1ZhbHVlXHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvcmRlclRhcmdldHModGFyZ2V0c1ZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFsuLi50YXJnZXRzVmFsdWVdO1xyXG5cdFx0Y29uc3Qgb3JkZXJBc2MgPSAkJC5pc09yZGVyQXNjKCk7XHJcblx0XHRjb25zdCBvcmRlckRlc2MgPSAkJC5pc09yZGVyRGVzYygpO1xyXG5cclxuXHRcdGlmIChvcmRlckFzYyB8fCBvcmRlckRlc2MpIHtcclxuXHRcdFx0dGFyZ2V0cy5zb3J0KCh0MSwgdDIpID0+IHtcclxuXHRcdFx0XHRjb25zdCByZWR1Y2VyID0gKHAsIGMpID0+IHAgKyBNYXRoLmFicyhjLnZhbHVlKTtcclxuXHRcdFx0XHRjb25zdCB0MVN1bSA9IHQxLnZhbHVlcy5yZWR1Y2UocmVkdWNlciwgMCk7XHJcblx0XHRcdFx0Y29uc3QgdDJTdW0gPSB0Mi52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gb3JkZXJBc2MgPyB0MlN1bSAtIHQxU3VtIDogdDFTdW0gLSB0MlN1bTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY29uZmlnLmRhdGFfb3JkZXIpKSB7XHJcblx0XHRcdHRhcmdldHMuc29ydChjb25maWcuZGF0YV9vcmRlci5iaW5kKCQkLmFwaSkpO1xyXG5cdFx0fSAvLyBUT0RPOiBhY2NlcHQgbmFtZSBhcnJheSBmb3Igb3JkZXJcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJCeVgodGFyZ2V0cywgeCkge1xyXG5cdFx0cmV0dXJuIG1lcmdlQXJyYXkodGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpLmZpbHRlcih2ID0+IHYueCAtIHggPT09IDApO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclJlbW92ZU51bGwoZGF0YSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKGQgPT4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlckJ5WERvbWFpbih0YXJnZXRzLCB4RG9tYWluKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0cy5tYXAodCA9PiAoe1xyXG5cdFx0XHRpZDogdC5pZCxcclxuXHRcdFx0aWRfb3JnOiB0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0LnZhbHVlcy5maWx0ZXIodiA9PiB4RG9tYWluWzBdIDw9IHYueCAmJiB2LnggPD0geERvbWFpblsxXSlcclxuXHRcdH0pKTtcclxuXHR9LFxyXG5cclxuXHRoYXNEYXRhTGFiZWwoKSB7XHJcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHM7XHJcblxyXG5cdFx0cmV0dXJuIChpc0Jvb2xlYW4oZGF0YUxhYmVscykgJiYgZGF0YUxhYmVscykgfHxcclxuXHRcdFx0KGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzKSAmJiBub3RFbXB0eShkYXRhTGFiZWxzKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RGF0YUxhYmVsTGVuZ3RoKG1pbiwgbWF4LCBrZXkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGxlbmd0aHMgPSBbMCwgMF07XHJcblx0XHRjb25zdCBwYWRkaW5nQ29lZiA9IDEuMztcclxuXHJcblx0XHQkJC4kZWwuY2hhcnQuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdEFsbChcIi5kdW1teVwiKVxyXG5cdFx0XHQuZGF0YShbbWluLCBtYXhdKVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChkID0+ICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKShkKSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGxlbmd0aHNbaV0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV0gKiBwYWRkaW5nQ29lZjtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsZW5ndGhzO1xyXG5cdH0sXHJcblxyXG5cdGlzTm9uZUFyYyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNUYXJnZXQodGhpcy5kYXRhLnRhcmdldHMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJjKGQpIHtcclxuXHRcdHJldHVybiBcImRhdGFcIiBpbiBkICYmIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRTYW1lWE9mVmFsdWVzKHZhbHVlcywgaW5kZXgpIHtcclxuXHRcdGNvbnN0IHRhcmdldFggPSB2YWx1ZXNbaW5kZXhdLng7XHJcblx0XHRjb25zdCBzYW1lczogYW55W10gPSBbXTtcclxuXHRcdGxldCBpO1xyXG5cclxuXHRcdGZvciAoaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSBpbmRleDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGFyZ2V0WCAhPT0gdmFsdWVzW2ldLngpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzYW1lcztcclxuXHR9LFxyXG5cclxuXHRmaW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHMsIHBvcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiAkJC5maW5kQ2xvc2VzdCh0YXJnZXQudmFsdWVzLCBwb3MpKTsgLy8gbWFwIHRvIGFycmF5IG9mIGNsb3Nlc3QgcG9pbnRzIG9mIGVhY2ggdGFyZ2V0XHJcblxyXG5cdFx0Ly8gZGVjaWRlIGNsb3Nlc3QgcG9pbnQgYW5kIHJldHVyblxyXG5cdFx0cmV0dXJuICQkLmZpbmRDbG9zZXN0KGNhbmRpZGF0ZXMsIHBvcyk7XHJcblx0fSxcclxuXHJcblx0ZmluZENsb3Nlc3QodmFsdWVzLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YSA9IHZhbHVlcy5maWx0ZXIodiA9PiB2ICYmIGlzVmFsdWUodi52YWx1ZSkpO1xyXG5cdFx0bGV0IG1pbkRpc3QgPSBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHk7XHJcblx0XHRsZXQgY2xvc2VzdDtcclxuXHJcblx0XHQvLyBmaW5kIG1vdXNlb3ZlcmluZyBiYXJcclxuXHRcdGRhdGFcclxuXHRcdFx0LmZpbHRlcih2ID0+ICQkLmlzQmFyVHlwZSh2LmlkKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYmFyc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHYuaWQpfSAuJHtDTEFTUy5iYXJ9LSR7di5pbmRleH1gKS5ub2RlKCk7XHJcblxyXG5cdFx0XHRcdGlmICghY2xvc2VzdCAmJiAkJC5pc1dpdGhpbkJhcihzaGFwZSkpIHtcclxuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gZmluZCBjbG9zZXN0IHBvaW50IGZyb20gbm9uLWJhclxyXG5cdFx0ZGF0YVxyXG5cdFx0XHQuZmlsdGVyKHYgPT4gISQkLmlzQmFyVHlwZSh2LmlkKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgZCA9ICQkLmRpc3QodiwgcG9zKTtcclxuXHJcblx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0KSB7XHJcblx0XHRcdFx0XHRtaW5EaXN0ID0gZDtcclxuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XHJcblx0fSxcclxuXHJcblx0ZGlzdChkYXRhLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWc6IHtheGlzX3JvdGF0ZWQ6IGlzUm90YXRlZH0sIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgeEluZGV4ID0gaXNSb3RhdGVkID8gMSA6IDA7XHJcblx0XHRjb25zdCB5SW5kZXggPSBpc1JvdGF0ZWQgPyAwIDogMTtcclxuXHRcdGNvbnN0IHkgPSAkJC5jaXJjbGVZKGRhdGEsIGRhdGEuaW5kZXgpO1xyXG5cdFx0Y29uc3QgeCA9IChzY2FsZS56b29tIHx8IHNjYWxlLngpKGRhdGEueCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zW3hJbmRleF0sIDIpICsgTWF0aC5wb3coeSAtIHBvc1t5SW5kZXhdLCAyKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGZvciBzdGVwIHR5cGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgT2JqZWN0IGRhdGEgdmFsdWVzXHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgc3RlcFR5cGUgPSBjb25maWcubGluZV9zdGVwX3R5cGU7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xyXG5cclxuXHRcdGlmICghaXNSb3RhdGVkICYmICFpc0NhdGVnb3JpemVkKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5zZXJ0ICYgYXBwZW5kIGNsb25pbmcgZmlyc3QvbGFzdCB2YWx1ZSB0byBiZSBmdWxseSByZW5kZXJlZCBjb3ZlcmluZyBvbiBlYWNoIGdhcCBzaWRlc1xyXG5cdFx0Y29uc3QgaWQgPSBjb252ZXJ0ZWRbMF0uaWQ7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0XHJcblx0XHRsZXQgeCA9IGNvbnZlcnRlZFswXS54IC0gMTtcclxuXHRcdGxldCB2YWx1ZSA9IGNvbnZlcnRlZFswXS52YWx1ZTtcclxuXHJcblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC51bnNoaWZ0KHt4LCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcclxuXHRcdFx0Y29udmVydGVkLnVuc2hpZnQoe3g6IHggLSAxLCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHQvLyBhcHBlbmRcclxuXHRcdHggPSBjb252ZXJ0ZWQubGVuZ3RoO1xyXG5cdFx0dmFsdWUgPSBjb252ZXJ0ZWRbeCAtIDFdLnZhbHVlO1xyXG5cclxuXHRcdGlzQ2F0ZWdvcml6ZWQgJiYgY29udmVydGVkLnB1c2goe3gsIHZhbHVlLCBpZH0pO1xyXG5cclxuXHRcdHN0ZXBUeXBlID09PSBcInN0ZXAtYmVmb3JlXCIgJiZcclxuXHRcdFx0Y29udmVydGVkLnB1c2goe3g6IHggKyAxLCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRyZXR1cm4gY29udmVydGVkO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRWYWx1ZXNUb1JhbmdlKHZhbHVlcykge1xyXG5cdFx0Y29uc3QgY29udmVydGVkID0gaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzLmNvbmNhdCgpIDogW3ZhbHVlc107XHJcblx0XHRjb25zdCByYW5nZXM6IHt4OiBzdHJpbmcgfCBudW1iZXIsIGlkOiBzdHJpbmcsIHZhbHVlOiBudW1iZXJ9W10gPSBbXTtcclxuXHJcblx0XHRjb252ZXJ0ZWQuZm9yRWFjaChyYW5nZSA9PiB7XHJcblx0XHRcdGNvbnN0IHt4LCBpZH0gPSByYW5nZTtcclxuXHJcblx0XHRcdHJhbmdlcy5wdXNoKHtcclxuXHRcdFx0XHR4LFxyXG5cdFx0XHRcdGlkLFxyXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVswXVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJhbmdlcy5wdXNoKHtcclxuXHRcdFx0XHR4LFxyXG5cdFx0XHRcdGlkLFxyXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVsyXVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiByYW5nZXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRGF0YUF0dHJpYnV0ZXMobmFtZSwgYXR0cnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50ID0gY29uZmlnW2BkYXRhXyR7bmFtZX1gXTtcclxuXHJcblx0XHRpZiAoaXNVbmRlZmluZWQoYXR0cnMpKSB7XHJcblx0XHRcdHJldHVybiBjdXJyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y3VycmVudFtpZF0gPSBhdHRyc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5yZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHJcblx0XHRyZXR1cm4gY3VycmVudDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhUmFuZ2VEYXRhKGQsIHR5cGUpIHtcclxuXHRcdGNvbnN0IHZhbHVlID0gZC52YWx1ZTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0Y29uc3QgaW5kZXggPSBbXCJoaWdoXCIsIFwibWlkXCIsIFwibG93XCJdLmluZGV4T2YodHlwZSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHZhbHVlW2luZGV4XTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVbdHlwZV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHJhdGlvIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgUmF0aW8gZm9yIGdpdmVuIHR5cGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIHZhbHVlIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNQZXJjZW50IENvbnZlcnQgdGhlIHJldHVybiBhcyBwZXJjZW50IG9yIG5vdFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gUmF0aW8gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFJhdGlvKHR5cGUsIGQsIGFzUGVyY2VudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBhcGkgPSAkJC5hcGk7XHJcblx0XHRsZXQgcmF0aW8gPSAwO1xyXG5cclxuXHRcdGlmIChkICYmIGFwaS5kYXRhLnNob3duKCkubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IGRhdGFWYWx1ZXMgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpO1xyXG5cclxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXHJcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcclxuXHRcdFx0XHRcdGxldCB0b3RhbCA9ICQkLmdldFRvdGFsRGF0YVN1bSgpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5oaWRkZW5UYXJnZXRJZHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRvdGFsIC09IGRhdGFWYWx1ZXMoc3RhdGUuaGlkZGVuVGFyZ2V0SWRzKS5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyYXRpbyA9IGQudmFsdWUgLyB0b3RhbDtcclxuXHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcclxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcclxuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKHN0YXRlLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XHJcblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xyXG5cclxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdFx0cmF0aW8gPSAocGFyc2VGbG9hdChTdHJpbmcoTWF0aC5tYXgoZC52YWx1ZSwgMCkpKSAvICQkLm1heFZhbHVlKSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YUluZGV4QnlYKHRpY2tWYWx1ZXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB0aWNrVmFsdWVNYXAgPSB0aWNrVmFsdWVzLnJlZHVjZSgob3V0LCB0aWNrLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbTnVtYmVyKHRpY2sueCldID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gdGlja1ZhbHVlTWFwW051bWJlcih2YWx1ZS54KV07XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpbmRleCA9IHZhbHVlSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhbHVlLmluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRsb2FkKHJhd1RhcmdldHMsIGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB0YXJnZXRzID0gcmF3VGFyZ2V0cztcclxuXHJcblx0XHRpZiAodGFyZ2V0cykge1xyXG5cdFx0XHQvLyBmaWx0ZXIgbG9hZGluZyB0YXJnZXRzIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAoYXJncy5maWx0ZXIpIHtcclxuXHRcdFx0XHR0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoYXJncy5maWx0ZXIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgdHlwZSBpZiBhcmdzLnR5cGVzIHx8IGFyZ3MudHlwZSBzcGVjaWZpZWRcclxuXHRcdFx0aWYgKGFyZ3MudHlwZSB8fCBhcmdzLnR5cGVzKSB7XHJcblx0XHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IChhcmdzLnR5cGVzICYmIGFyZ3MudHlwZXNbdC5pZF0pIHx8IGFyZ3MudHlwZTtcclxuXHJcblx0XHRcdFx0XHQkJC5zZXRUYXJnZXRUeXBlKHQuaWQsIHR5cGUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoZC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0XHRkLnZhbHVlcyA9IHRhcmdldHNbaV0udmFsdWVzO1xyXG5cdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5jb25jYXQodGFyZ2V0cyk7IC8vIGFkZCByZW1haW5lZFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZS5jYWxsKCQkLmFwaSk7XHJcblx0fSxcclxuXHJcblx0bG9hZEZyb21BcmdzKGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQvLyBwcmV2ZW50IGxvYWQgd2hlbiBjaGFydCBpcyBhbHJlYWR5IGRlc3Ryb3llZFxyXG5cdFx0aWYgKCEkJC5jb25maWcpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlc2V0KCk7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IGFyZ3MuZGF0YSB8fCAkJC5jb252ZXJ0RGF0YShhcmdzLCBkID0+ICQkLmxvYWQoJCQuY29udmVydERhdGFUb1RhcmdldHMoZCksIGFyZ3MpKTtcclxuXHJcblx0XHRkYXRhICYmICQkLmxvYWQoJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSksIGFyZ3MpO1xyXG5cdH0sXHJcblxyXG5cdHVubG9hZChyYXdUYXJnZXRJZHMsIGN1c3RvbURvbmVDYikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRsZXQgZG9uZSA9IGN1c3RvbURvbmVDYjtcclxuXHRcdGxldCB0YXJnZXRJZHMgPSByYXdUYXJnZXRJZHM7XHJcblxyXG5cdFx0Ly8gcmVzZXQgaW50ZXJuYWxseSBjYWNoZWQgZGF0YVxyXG5cdFx0JCQuY2FjaGUucmVzZXQoKTtcclxuXHJcblx0XHRpZiAoIWRvbmUpIHtcclxuXHRcdFx0ZG9uZSA9ICgpID0+IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZpbHRlciBleGlzdGluZyB0YXJnZXRcclxuXHRcdHRhcmdldElkcyA9IHRhcmdldElkcy5maWx0ZXIoaWQgPT4gJCQuaGFzVGFyZ2V0KCQkLmRhdGEudGFyZ2V0cywgaWQpKTtcclxuXHJcblx0XHQvLyBJZiBubyB0YXJnZXQsIGNhbGwgZG9uZSBhbmQgcmV0dXJuXHJcblx0XHRpZiAoIXRhcmdldElkcyB8fCB0YXJnZXRJZHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdGRvbmUoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5zdmcuc2VsZWN0QWxsKHRhcmdldElkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JUYXJnZXQoaWQpKSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKClcclxuXHRcdFx0LmNhbGwoJCQuZW5kYWxsLCBkb25lKTtcclxuXHJcblx0XHR0YXJnZXRJZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdC8vIFJlc2V0IGZhZGVpbiBmb3IgZnV0dXJlIGxvYWRcclxuXHRcdFx0c3RhdGUud2l0aG91dEZhZGVJbltpZF0gPSBmYWxzZTtcclxuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldCdzIGVsZW1lbnRzXHJcblx0XHRcdGlmICgkZWwubGVnZW5kKSB7XHJcblx0XHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkucmVtb3ZlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldFxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHQgPT4gdC5pZCAhPT0gaWQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZHJhZyBhcyBkM0RyYWd9IGZyb20gXCJkMy1kcmFnXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtlbXVsYXRlRXZlbnQsIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSGFuZGxlIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBvcHRpb25zXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJcclxuXHQgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldE92ZXJPdXQoaXNPdmVyLCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzQXJjID0gaXNPYmplY3QoZCk7XHJcblxyXG5cdFx0Ly8gQ2FsbCBldmVudCBoYW5kbGVyXHJcblx0XHRpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcclxuXHRcdFx0bGV0IGNhbGxiYWNrID0gY29uZmlnW2lzT3ZlciA/IFwiZGF0YV9vbm92ZXJcIiA6IFwiZGF0YV9vbm91dFwiXS5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0XHRjb25maWcuY29sb3Jfb25vdmVyICYmICQkLnNldE92ZXJDb2xvcihpc092ZXIsIGQsIGlzQXJjKTtcclxuXHJcblx0XHRcdGlmIChpc0FyYykge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGQsIG1haW4uc2VsZWN0KGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKS5ub2RlKCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgY2FsbGVlID0gJCQuc2V0T3Zlck91dDtcclxuXHRcdFx0XHRsZXQgbGFzdCA9IGNhbGxlZS5sYXN0IHx8IFtdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0c2hhcGVcclxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGxhc3QubGVuZ3RoID09PSAwIHx8IGxhc3QuZXZlcnkodiA9PiB2ICE9PSB0aGlzKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0XHRcdGxhc3QucHVzaCh0aGlzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChsYXN0Lmxlbmd0aCA+IDAgJiYgc2hhcGUuZW1wdHkoKSkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBjb25maWcuZGF0YV9vbm91dC5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0XHRcdFx0bGFzdC5mb3JFYWNoKHYgPT4gY2FsbGJhY2soZDNTZWxlY3QodikuZGF0dW0oKSwgdikpO1xyXG5cdFx0XHRcdFx0bGFzdCA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FsbGVlLmxhc3QgPSBsYXN0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlzT3ZlciAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0ISQkLmlzTXVsdGlwbGVYKCkgJiYgbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YClcclxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZCwgdGhpcyk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGwgZGF0YS5vbm92ZXIvb3V0IGNhbGxiYWNrIGZvciB0b3VjaCBldmVudFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZCB0YXJnZXQgaW5kZXggb3IgZGF0YSBvYmplY3QgZm9yIEFyYyB0eXBlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjYWxsT3Zlck91dEZvclRvdWNoKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhbGxlZSA9ICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2g7XHJcblx0XHRjb25zdCB7bGFzdH0gPSBjYWxsZWU7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KGQpICYmIGxhc3QgPyBkLmlkICE9PSBsYXN0LmlkIDogKGQgIT09IGxhc3QpKSB7XHJcblx0XHRcdChsYXN0IHx8IGlzTnVtYmVyKGxhc3QpKSAmJiAkJC5zZXRPdmVyT3V0KGZhbHNlLCBsYXN0KTtcclxuXHRcdFx0KGQgfHwgaXNOdW1iZXIoZCkpICYmICQkLnNldE92ZXJPdXQodHJ1ZSwgZCk7XHJcblxyXG5cdFx0XHRjYWxsZWUubGFzdCA9IGQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGRyYWdnYWJsZSBzZWxlY3Rpb24gZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldERyYWdnYWJsZVNlbGVjdGlvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUgJiYgJCQuZHJhZyA/XHJcblx0XHRcdGQzRHJhZygpXHJcblx0XHRcdFx0Lm9uKFwiZHJhZ1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdCQkLmRyYWcoZDNNb3VzZSh0aGlzKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdCQkLmRyYWdzdGFydChkM01vdXNlKHRoaXMpKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7ICQkLmRyYWdlbmQoKTsgfSkgOiAoKSA9PiB7fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaCBhIG1vdXNlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZXZlbnQgdHlwZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiBldmVudFJlY3RcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWVcclxuXHQgKi9cclxuXHRkaXNwYXRjaEV2ZW50KHR5cGUsIGluZGV4LCBtb3VzZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBgLiR7aXNNdWx0aXBsZVggPyBDTEFTUy5ldmVudFJlY3QgOiBgJHtDTEFTUy5ldmVudFJlY3R9LSR7aW5kZXh9YH1gO1xyXG5cdFx0Y29uc3QgZXZlbnRSZWN0ID0gJCQuJGVsLm1haW4uc2VsZWN0KHNlbGVjdG9yKS5ub2RlKCk7XHJcblx0XHRjb25zdCB7d2lkdGgsIGxlZnQsIHRvcH0gPSBldmVudFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHRjb25zdCB4ID0gbGVmdCArIChtb3VzZSA/IG1vdXNlWzBdIDogMCkgKyAoXHJcblx0XHRcdGlzTXVsdGlwbGVYIHx8ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogKHdpZHRoIC8gMilcclxuXHRcdCk7XHJcblx0XHRjb25zdCB5ID0gdG9wICsgKG1vdXNlID8gbW91c2VbMV0gOiAwKTtcclxuXHRcdGNvbnN0IHBhcmFtcyA9IHtcclxuXHRcdFx0c2NyZWVuWDogeCxcclxuXHRcdFx0c2NyZWVuWTogeSxcclxuXHRcdFx0Y2xpZW50WDogeCxcclxuXHRcdFx0Y2xpZW50WTogeVxyXG5cdFx0fTtcclxuXHJcblx0XHRlbXVsYXRlRXZlbnRbL14obW91c2V8Y2xpY2spLy50ZXN0KHR5cGUpID8gXCJtb3VzZVwiIDogXCJ0b3VjaFwiXShldmVudFJlY3QsIHR5cGUsIHBhcmFtcyk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZW5lcmF0ZUNsYXNzKHByZWZpeCwgdGFyZ2V0SWQpIHtcclxuXHRcdHJldHVybiBgICR7cHJlZml4fSAke3ByZWZpeCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0KGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0cyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHRzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1NoYXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzU2hhcGVzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGVzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9ICQkLmNvbmZpZy5saW5lX2NsYXNzZXMgfHwgW107XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblxyXG5cdFx0XHRpZiAoaWRzLmluZGV4T2YoaWQpIDwgMCkge1xyXG5cdFx0XHRcdGlkcy5wdXNoKGlkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNsYXNzZXNbaWRzLmluZGV4T2YoaWQpICUgY2xhc3Nlcy5sZW5ndGhdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmVzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmxpbmVzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NpcmNsZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZSwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGVzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQmFyKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFyLCBkLmluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0JhcnMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFycywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NBcmMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyYywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyY3MoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZC5kYXRhKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmNzLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJlYShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWEsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJlYXMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzUmVnaW9uKGQsIGkpIHtcclxuXHRcdHJldHVybiBgJHt0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MucmVnaW9uLCBpKX0gJHtcImNsYXNzXCIgaW4gZCA/IGQuY2xhc3MgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NFdmVudChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmV2ZW50UmVjdCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUYXJnZXQoaWQpIHtcclxuXHRcdGNvbnN0IGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCA9IHRoaXMuY29uZmlnLmRhdGFfY2xhc3Nlc1tpZF07XHJcblx0XHRsZXQgYWRkaXRpb25hbENsYXNzID0gXCJcIjtcclxuXHJcblx0XHRpZiAoYWRkaXRpb25hbENsYXNzU3VmZml4KSB7XHJcblx0XHRcdGFkZGl0aW9uYWxDbGFzcyA9IGAgJHtDTEFTUy50YXJnZXR9LSR7YWRkaXRpb25hbENsYXNzU3VmZml4fWA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50YXJnZXQsIGlkKSArIGFkZGl0aW9uYWxDbGFzcztcclxuXHR9LFxyXG5cclxuXHRjbGFzc0ZvY3VzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzRm9jdXNlZChkKSArIHRoaXMuY2xhc3NEZWZvY3VzZWQoZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1c2VkKGQpIHtcclxuXHRcdHJldHVybiBgICR7dGhpcy5zdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmZvY3VzZWQgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NEZWZvY3VzZWQoZCkge1xyXG5cdFx0cmV0dXJuIGAgJHt0aGlzLnN0YXRlLmRlZm9jdXNlZFRhcmdldElkcy5pbmRleE9mKGQuaWQpID49IDAgPyBDTEFTUy5kZWZvY3VzZWQgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydFRleHQoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0VGV4dCArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydExpbmUoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydEJhcihkKSB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRCYXIgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRBcmMoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QXJjICsgdGhpcy5jbGFzc1RhcmdldChkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRSYWRhcihkKSB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRSYWRhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpIHtcclxuXHRcdHJldHVybiB0YXJnZXRJZCB8fCB0YXJnZXRJZCA9PT0gMCA/XHJcblx0XHRcdGAtJHt0YXJnZXRJZH1gLnJlcGxhY2UoL1tcXHM/IUAjJCVeJiooKV89KywuPD4nXCI6O1xcW1xcXVxcL3x+YHt9XFxcXF0vZywgXCItXCIpIDogXCJcIjtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvclRhcmdldChpZCwgcHJlZml4KSB7XHJcblx0XHRjb25zdCBwZnggPSBwcmVmaXggfHwgXCJcIjtcclxuXHRcdGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpO1xyXG5cclxuXHRcdC8vIHNlbGVjdCB0YXJnZXQgJiBjaXJjbGVcclxuXHRcdHJldHVybiBgJHtwZnh9LiR7Q0xBU1MudGFyZ2V0ICsgdGFyZ2V0fSwgJHtwZnh9LiR7Q0xBU1MuY2lyY2xlcyArIHRhcmdldH1gO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yVGFyZ2V0cyhpZHNWYWx1ZSwgcHJlZml4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpZHMgPSBpZHNWYWx1ZSB8fCBbXTtcclxuXHJcblx0XHRyZXR1cm4gaWRzLmxlbmd0aCA/XHJcblx0XHRcdGlkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JUYXJnZXQoaWQsIHByZWZpeCkpIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvckxlZ2VuZChpZCkge1xyXG5cdFx0cmV0dXJuIGAuJHtDTEFTUy5sZWdlbmRJdGVtICsgdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YDtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvckxlZ2VuZHMoaWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGlkcyAmJiBpZHMubGVuZ3RoID9cclxuXHRcdFx0aWRzLm1hcChpZCA9PiAkJC5zZWxlY3RvckxlZ2VuZChpZCkpIDogbnVsbDtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7c2NhbGVPcmRpbmFsIGFzIGQzU2NhbGVPcmRpbmFsfSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge25vdEVtcHR5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmd9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFNldCBwYXR0ZXJuJ3MgYmFja2dyb3VuZCBjb2xvclxyXG4gKiAoaXQgYWRkcyBhIDxyZWN0PiBlbGVtZW50IHRvIHNpbXVsYXRlIGJnLWNvbG9yKVxyXG4gKiBAcGFyYW0ge1NWR1BhdHRlcm5FbGVtZW50fSBwYXR0ZXJuIFNWRyBwYXR0ZXJuIGVsZW1lbnRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgSUQgdG8gYmUgc2V0XHJcbiAqIEByZXR1cm4ge3tpZDogc3RyaW5nLCBub2RlOiBTVkdQYXR0ZXJuRWxlbWVudH19XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjb2xvcml6ZVBhdHRlcm4gPSAocGF0dGVybiwgY29sb3IsIGlkOiBzdHJpbmcpID0+IHtcclxuXHRjb25zdCBub2RlID0gZDNTZWxlY3QocGF0dGVybi5jbG9uZU5vZGUodHJ1ZSkpO1xyXG5cclxuXHRub2RlXHJcblx0XHQuYXR0cihcImlkXCIsIGlkKVxyXG5cdFx0Lmluc2VydChcInJlY3RcIiwgXCI6Zmlyc3QtY2hpbGRcIilcclxuXHRcdC5hdHRyKFwid2lkdGhcIiwgbm9kZS5hdHRyKFwid2lkdGhcIikpXHJcblx0XHQuYXR0cihcImhlaWdodFwiLCBub2RlLmF0dHIoXCJoZWlnaHRcIikpXHJcblx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGlkLFxyXG5cdFx0bm9kZTogbm9kZS5ub2RlKClcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gUmVwbGFjZW1lbnQgb2YgZDMuc2NoZW1lQ2F0ZWdvcnkxMC5cclxuLy8gQ29udGFpbmVkIGRpZmZlcmVudGx5IGRlcGVuZCBvbiBkMyB2ZXJzaW9uOiB2NChkMy1zY2FsZSksIHY1KGQzLXNjYWxlLWNocm9tYXRpYylcclxuY29uc3Qgc2NoZW1lQ2F0ZWdvcnkxMCA9IFtcIiMxZjc3YjRcIiwgXCIjZmY3ZjBlXCIsIFwiIzJjYTAyY1wiLCBcIiNkNjI3MjhcIiwgXCIjOTQ2N2JkXCIsIFwiIzhjNTY0YlwiLCBcIiNlMzc3YzJcIiwgXCIjN2Y3ZjdmXCIsIFwiI2JjYmQyMlwiLCBcIiMxN2JlY2ZcIl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGNvbG9yIHBhdHRlcm4gZnJvbSBDU1MgZmlsZVxyXG5cdCAqIENTUyBzaG91bGQgYmUgZGVmaW5lZCBhczogYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiIzAwYzczYzsjZmE3MTcxOyAuLi5cIik7XHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRDb2xvckZyb21Dc3MoKSB7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiX19jb2xvclBhdHRlcm5fX1wiO1xyXG5cdFx0Y29uc3Qge2JvZHl9ID0gZG9jdW1lbnQ7XHJcblx0XHRsZXQgcGF0dGVybiA9IGJvZHlbY2FjaGVLZXldO1xyXG5cclxuXHRcdGlmICghcGF0dGVybikge1xyXG5cdFx0XHRjb25zdCBkZWxpbWl0ZXIgPSBcIjtcIjtcclxuXHRcdFx0Y29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG5cclxuXHRcdFx0c3Bhbi5jbGFzc05hbWUgPSBDTEFTUy5jb2xvclBhdHRlcm47XHJcblx0XHRcdHNwYW4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cdFx0XHRib2R5LmFwcGVuZENoaWxkKHNwYW4pO1xyXG5cclxuXHRcdFx0Y29uc3QgY29udGVudCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNwYW4pLmJhY2tncm91bmRJbWFnZTtcclxuXHJcblx0XHRcdHNwYW4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzcGFuKTtcclxuXHJcblx0XHRcdGlmIChjb250ZW50LmluZGV4T2YoZGVsaW1pdGVyKSA+IC0xKSB7XHJcblx0XHRcdFx0cGF0dGVybiA9IGNvbnRlbnRcclxuXHRcdFx0XHRcdC5yZXBsYWNlKC91cmxbXiNdKnxbXCInKCldfChcXHN8JTIwKS9nLCBcIlwiKVxyXG5cdFx0XHRcdFx0LnNwbGl0KGRlbGltaXRlcilcclxuXHRcdFx0XHRcdC5tYXAodiA9PiB2LnRyaW0oKS5yZXBsYWNlKC9bXFxcIidcXHNdL2csIFwiXCIpKVxyXG5cdFx0XHRcdFx0LmZpbHRlcihCb29sZWFuKTtcclxuXHJcblx0XHRcdFx0Ym9keVtjYWNoZUtleV0gPSBwYXR0ZXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhdHRlcm47XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVDb2xvcigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjb2xvcnMgPSBjb25maWcuZGF0YV9jb2xvcnM7XHJcblx0XHRjb25zdCBjYWxsYmFjayA9IGNvbmZpZy5kYXRhX2NvbG9yO1xyXG5cdFx0Y29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdGxldCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLmNvbG9yX3BhdHRlcm4pID8gY29uZmlnLmNvbG9yX3BhdHRlcm4gOlxyXG5cdFx0XHRkM1NjYWxlT3JkaW5hbCgkJC5nZXRDb2xvckZyb21Dc3MoKSB8fCBzY2hlbWVDYXRlZ29yeTEwKS5yYW5nZSgpO1xyXG5cclxuXHRcdGNvbnN0IG9yaWdpbmFsQ29sb3JQYXR0ZXJuID0gcGF0dGVybjtcclxuXHJcblx0XHRpZiAoaXNGdW5jdGlvbihjb25maWcuY29sb3JfdGlsZXMpKSB7XHJcblx0XHRcdGNvbnN0IHRpbGVzID0gY29uZmlnLmNvbG9yX3RpbGVzLmJpbmQoJCQuYXBpKSgpO1xyXG5cclxuXHRcdFx0Ly8gQWRkIGJhY2tncm91bmQgY29sb3IgdG8gcGF0dGVybnNcclxuXHRcdFx0Y29uc3QgY29sb3JpemVkUGF0dGVybnMgPSBwYXR0ZXJuLm1hcCgocCwgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9IHAucmVwbGFjZSgvWyNcXChcXClcXHMsXS9nLCBcIlwiKTtcclxuXHRcdFx0XHRjb25zdCBpZCA9IGAkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LXBhdHRlcm4tJHtjb2xvcn0tJHtpbmRleH1gO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29sb3JpemVQYXR0ZXJuKHRpbGVzW2luZGV4ICUgdGlsZXMubGVuZ3RoXSwgcCwgaWQpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBhdHRlcm4gPSBjb2xvcml6ZWRQYXR0ZXJucy5tYXAocCA9PiBgdXJsKCMke3AuaWR9KWApO1xyXG5cdFx0XHQkJC5wYXR0ZXJucyA9IGNvbG9yaXplZFBhdHRlcm5zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdGNvbnN0IGlkOiBzdHJpbmcgPSBkLmlkIHx8IChkLmRhdGEgJiYgZC5kYXRhLmlkKSB8fCBkO1xyXG5cdFx0XHRjb25zdCBpc0xpbmUgPSAkJC5pc1R5cGVPZihpZCwgW1wibGluZVwiLCBcInNwbGluZVwiLCBcInN0ZXBcIl0pIHx8ICFjb25maWcuZGF0YV90eXBlc1tpZF07XHJcblx0XHRcdGxldCBjb2xvcjtcclxuXHJcblx0XHRcdC8vIGlmIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkXHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGNvbG9yc1tpZF0pKSB7XHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaWRdLmJpbmQoJCQuYXBpKShkKTtcclxuXHJcblx0XHRcdC8vIGlmIHNwZWNpZmllZCwgY2hvb3NlIHRoYXQgY29sb3JcclxuXHRcdFx0fSBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaWRdO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChpZHMuaW5kZXhPZihpZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvciA9IGlzTGluZSA/IG9yaWdpbmFsQ29sb3JQYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIG9yaWdpbmFsQ29sb3JQYXR0ZXJuLmxlbmd0aF0gOlxyXG5cdFx0XHRcdFx0cGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XHJcblxyXG5cdFx0XHRcdGNvbG9yc1tpZF0gPSBjb2xvcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oY2FsbGJhY2spID9cclxuXHRcdFx0XHRjYWxsYmFjay5iaW5kKCQkLmFwaSkoY29sb3IsIGQpIDogY29sb3I7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlTGV2ZWxDb2xvcigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjb2xvcnMgPSBjb25maWcuY29sb3JfcGF0dGVybjtcclxuXHRcdGNvbnN0IHRocmVzaG9sZCA9IGNvbmZpZy5jb2xvcl90aHJlc2hvbGQ7XHJcblx0XHRjb25zdCBhc1ZhbHVlID0gdGhyZXNob2xkLnVuaXQgPT09IFwidmFsdWVcIjtcclxuXHRcdGNvbnN0IG1heCA9IHRocmVzaG9sZC5tYXggfHwgMTAwO1xyXG5cdFx0Y29uc3QgdmFsdWVzID0gdGhyZXNob2xkLnZhbHVlcyAmJlxyXG5cdFx0XHR0aHJlc2hvbGQudmFsdWVzLmxlbmd0aCA/IHRocmVzaG9sZC52YWx1ZXMgOiBbXTtcclxuXHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhyZXNob2xkKSA/IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdGNvbnN0IHYgPSBhc1ZhbHVlID8gdmFsdWUgOiAodmFsdWUgKiAxMDAgLyBtYXgpO1xyXG5cdFx0XHRsZXQgY29sb3IgPSBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHYgPD0gdmFsdWVzW2ldKSB7XHJcblx0XHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpXTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNvbG9yO1xyXG5cdFx0fSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBkYXRhIG92ZXIgY29sb3IuXHJcblx0ICogV2hlbiBpcyBvdXQsIHdpbGwgcmVzdGF0ZSBpbiBpdHMgcHJldmlvdXMgY29sb3IgdmFsdWVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlciB0cnVlOiBzZXQgb3ZlcmVkIGNvbG9yLCBmYWxzZTogcmVzdG9yZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZCB0YXJnZXQgaW5kZXggb3IgZGF0YSBvYmplY3QgZm9yIEFyYyB0eXBlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRPdmVyQ29sb3IoaXNPdmVyLCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IG9ub3ZlciA9IGNvbmZpZy5jb2xvcl9vbm92ZXI7XHJcblx0XHRsZXQgY29sb3IgPSBpc092ZXIgPyBvbm92ZXIgOiAkJC5jb2xvcjtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoY29sb3IpKSB7XHJcblx0XHRcdGNvbG9yID0gKHtpZH0pID0+IChpZCBpbiBvbm92ZXIgPyBvbm92ZXJbaWRdIDogJCQuY29sb3IoaWQpKTtcclxuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoY29sb3IpKSB7XHJcblx0XHRcdGNvbG9yID0gKCkgPT4gb25vdmVyO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9ub3ZlcikpIHtcclxuXHRcdFx0Y29sb3IgPSBjb2xvci5iaW5kKCQkLmFwaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBBcmMgdHlwZVxyXG5cdFx0aWYgKGlzT2JqZWN0KGQpKSB7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IoZCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHticnVzaEVtcHR5LCBnZXRCcnVzaFNlbGVjdGlvbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIG5vdEVtcHR5LCBpc1ZhbHVlLCBpc09iamVjdCwgaXNOdW1iZXIsIGRpZmZEb21haW4sIHBhcnNlRGF0ZSwgc29ydFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIHR5cGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc01pbiA9IHR5cGUgPT09IFwibWluXCI7XHJcblxyXG5cdFx0Y29uc3QgZGF0YUdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHRcdGNvbnN0IGlkcyA9ICQkLm1hcFRvSWRzKHRhcmdldHMpO1xyXG5cdFx0Y29uc3QgeXMgPSAkJC5nZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cyk7XHJcblxyXG5cdFx0aWYgKGRhdGFHcm91cHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRjb25zdCBoYXNWYWx1ZSA9ICQkW2BoYXMke2lzTWluID8gXCJOZWdhdGl2ZVwiIDogXCJQb3NpdGl2ZVwifVZhbHVlSW5UYXJnZXRzYF0odGFyZ2V0cyk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqID0gMCwgaWRzSW5Hcm91cDsgKGlkc0luR3JvdXAgPSBkYXRhR3JvdXBzW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGJhc2VJZFxyXG5cdFx0XHRcdGlkc0luR3JvdXAgPSBpZHNJbkdyb3VwLmZpbHRlcih2ID0+IGlkcy5pbmRleE9mKHYpID49IDApO1xyXG5cclxuXHRcdFx0XHRpZiAoaWRzSW5Hcm91cC5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgYmFzZUlkID0gaWRzSW5Hcm91cFswXTtcclxuXHRcdFx0XHRjb25zdCBiYXNlQXhpc0lkID0gJCQuYXhpcy5nZXRJZChiYXNlSWQpO1xyXG5cclxuXHRcdFx0XHQvLyBJbml0aWFsaXplIGJhc2UgdmFsdWUuIFNldCB0byAwIGlmIG5vdCBtYXRjaCB3aXRoIHRoZSBjb25kaXRpb25cclxuXHRcdFx0XHRpZiAoaGFzVmFsdWUgJiYgeXNbYmFzZUlkXSkge1xyXG5cdFx0XHRcdFx0eXNbYmFzZUlkXSA9IHlzW2Jhc2VJZF0ubWFwKHYgPT4gKFxyXG5cdFx0XHRcdFx0XHQoaXNNaW4gPyB2IDwgMCA6IHYgPiAwKSA/IHYgOiAwXHJcblx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGsgPSAxLCBpZDsgKGlkID0gaWRzSW5Hcm91cFtrXSk7IGsrKykge1xyXG5cdFx0XHRcdFx0aWYgKCF5c1tpZF0pIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYXhpc0lkID0gJCQuYXhpcy5nZXRJZChpZCk7XHJcblxyXG5cdFx0XHRcdFx0eXNbaWRdLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgdmFsID0gK3Y7XHJcblx0XHRcdFx0XHRcdGNvbnN0IG1lZXRDb25kaXRpb24gPSBpc01pbiA/IHZhbCA+IDAgOiB2YWwgPCAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGF4aXNJZCA9PT0gYmFzZUF4aXNJZCAmJiAhKGhhc1ZhbHVlICYmIG1lZXRDb25kaXRpb24pKSB7XHJcblx0XHRcdFx0XHRcdFx0eXNbYmFzZUlkXVtpXSArPSB2YWw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRNaW5NYXgodHlwZSwgT2JqZWN0LmtleXMoeXMpLm1hcChrZXkgPT4gZ2V0TWluTWF4KHR5cGUsIHlzW2tleV0pKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0WURvbWFpbk1pbih0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlEb21haW5NYXgodGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluKHRhcmdldHMsIGF4aXNJZCwgeERvbWFpbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIFswLCAxMDBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRhcmdldHNCeUF4aXNJZCA9IHRhcmdldHMuZmlsdGVyKHQgPT4gJCQuYXhpcy5nZXRJZCh0LmlkKSA9PT0gYXhpc0lkKTtcclxuXHRcdGNvbnN0IHlUYXJnZXRzID0geERvbWFpbiA/ICQkLmZpbHRlckJ5WERvbWFpbih0YXJnZXRzQnlBeGlzSWQsIHhEb21haW4pIDogdGFyZ2V0c0J5QXhpc0lkO1xyXG5cclxuXHRcdGlmICh5VGFyZ2V0cy5sZW5ndGggPT09IDApIHsgLy8gdXNlIGRvbWFpbiBvZiB0aGUgb3RoZXIgYXhpcyBpZiB0YXJnZXQgb2YgYXhpc0lkIGlzIG5vbmVcclxuXHRcdFx0cmV0dXJuIGF4aXNJZCA9PT0gXCJ5MlwiID9cclxuXHRcdFx0XHRzY2FsZS55LmRvbWFpbigpIDpcclxuXHRcdFx0XHQvLyBXaGVuIGFsbCBkYXRhIGJvdW5kcyB0byB5MiwgeSBBeGlzIGRvbWFpbiBpcyBjYWxsZWQgcHJpb3IgeTIuXHJcblx0XHRcdFx0Ly8gU28sIGl0IG5lZWRzIHRvIGNhbGwgdG8gZ2V0IHkyIGRvbWFpbiBoZXJlXHJcblx0XHRcdFx0JCQuZ2V0WURvbWFpbih0YXJnZXRzLCBcInkyXCIsIHhEb21haW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHlNaW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X21pbmBdO1xyXG5cdFx0Y29uc3QgeU1heCA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fbWF4YF07XHJcblx0XHRsZXQgeURvbWFpbk1pbiA9ICQkLmdldFlEb21haW5NaW4oeVRhcmdldHMpO1xyXG5cdFx0bGV0IHlEb21haW5NYXggPSAkJC5nZXRZRG9tYWluTWF4KHlUYXJnZXRzKTtcclxuXHJcblx0XHRjb25zdCBjZW50ZXIgPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2NlbnRlcmBdO1xyXG5cdFx0bGV0IGlzWmVyb0Jhc2VkID0gW1wiYXJlYVwiLCBcImJhclwiLCBcImJ1YmJsZVwiLCBcImxpbmVcIiwgXCJzY2F0dGVyXCJdXHJcblx0XHRcdC5zb21lKHYgPT4gJCQuaGFzVHlwZSh2LCB5VGFyZ2V0cykgJiYgY29uZmlnW2Ake3Z9X3plcm9iYXNlZGBdKTtcclxuXHRcdGNvbnN0IGlzSW52ZXJ0ZWQgPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2ludmVydGVkYF07XHJcblx0XHRjb25zdCBzaG93SG9yaXpvbnRhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBzaG93VmVydGljYWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiAhY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBNRU1POiBhdm9pZCBpbnZlcnRpbmcgZG9tYWluIHVuZXhwZWN0ZWRseVxyXG5cdFx0eURvbWFpbk1pbiA9IGlzVmFsdWUoeU1pbikgPyB5TWluIDpcclxuXHRcdFx0KGlzVmFsdWUoeU1heCkgPyAoeURvbWFpbk1pbiA8IHlNYXggPyB5RG9tYWluTWluIDogeU1heCAtIDEwKSA6IHlEb21haW5NaW4pO1xyXG5cdFx0eURvbWFpbk1heCA9IGlzVmFsdWUoeU1heCkgPyB5TWF4IDpcclxuXHRcdFx0KGlzVmFsdWUoeU1pbikgPyAoeU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwKSA6IHlEb21haW5NYXgpO1xyXG5cclxuXHRcdGlmIChpc05hTih5RG9tYWluTWluKSkgeyAvLyBzZXQgbWluaW11bSB0byB6ZXJvIHdoZW4gbm90IG51bWJlclxyXG5cdFx0XHR5RG9tYWluTWluID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4oeURvbWFpbk1heCkpIHsgLy8gc2V0IG1heGltdW0gdG8gaGF2ZSBzYW1lIHZhbHVlIGFzIHlEb21haW5NaW5cclxuXHRcdFx0eURvbWFpbk1heCA9IHlEb21haW5NaW47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHlEb21haW5NaW4gPT09IHlEb21haW5NYXgpIHtcclxuXHRcdFx0eURvbWFpbk1pbiA8IDAgPyB5RG9tYWluTWF4ID0gMCA6IHlEb21haW5NaW4gPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzQWxsUG9zaXRpdmUgPSB5RG9tYWluTWluID49IDAgJiYgeURvbWFpbk1heCA+PSAwO1xyXG5cdFx0Y29uc3QgaXNBbGxOZWdhdGl2ZSA9IHlEb21haW5NaW4gPD0gMCAmJiB5RG9tYWluTWF4IDw9IDA7XHJcblxyXG5cdFx0Ly8gQ2FuY2VsIHplcm9iYXNlZCBpZiBheGlzXypfbWluIC8gYXhpc18qX21heCBzcGVjaWZpZWRcclxuXHRcdGlmICgoaXNWYWx1ZSh5TWluKSAmJiBpc0FsbFBvc2l0aXZlKSB8fCAoaXNWYWx1ZSh5TWF4KSAmJiBpc0FsbE5lZ2F0aXZlKSkge1xyXG5cdFx0XHRpc1plcm9CYXNlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxyXG5cdFx0aWYgKGlzWmVyb0Jhc2VkKSB7XHJcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHlEb21haW5NaW4gPSAwKTtcclxuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAoeURvbWFpbk1heCA9IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRvbWFpbkxlbmd0aCA9IE1hdGguYWJzKHlEb21haW5NYXggLSB5RG9tYWluTWluKTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSB7dG9wOiBkb21haW5MZW5ndGggKiAwLjEsIGJvdHRvbTogZG9tYWluTGVuZ3RoICogMC4xfTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNlbnRlcikpIHtcclxuXHRcdFx0Y29uc3QgeURvbWFpbkFicyA9IE1hdGgubWF4KE1hdGguYWJzKHlEb21haW5NaW4pLCBNYXRoLmFicyh5RG9tYWluTWF4KSk7XHJcblxyXG5cdFx0XHR5RG9tYWluTWF4ID0gY2VudGVyICsgeURvbWFpbkFicztcclxuXHRcdFx0eURvbWFpbk1pbiA9IGNlbnRlciAtIHlEb21haW5BYnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWRkIHBhZGRpbmcgZm9yIGRhdGEgbGFiZWxcclxuXHRcdGlmIChzaG93SG9yaXpvbnRhbERhdGFMYWJlbCkge1xyXG5cdFx0XHRjb25zdCBkaWZmID0gZGlmZkRvbWFpbihzY2FsZS55LnJhbmdlKCkpO1xyXG5cdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcIndpZHRoXCIpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYgLyBkaWZmKTtcclxuXHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSArPSBkb21haW5MZW5ndGggKiAocmF0aW9baV0gLyAoMSAtIHJhdGlvWzBdIC0gcmF0aW9bMV0pKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKHNob3dWZXJ0aWNhbERhdGFMYWJlbCkge1xyXG5cdFx0XHRjb25zdCBsZW5ndGhzID0gJCQuZ2V0RGF0YUxhYmVsTGVuZ3RoKHlEb21haW5NaW4sIHlEb21haW5NYXgsIFwiaGVpZ2h0XCIpO1xyXG5cclxuXHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRwYWRkaW5nW3ZdICs9ICQkLmF4aXMuY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcobGVuZ3Roc1tpXSwgZG9tYWluTGVuZ3RoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKC9eeTI/JC8udGVzdChheGlzSWQpKSB7XHJcblx0XHRcdGNvbnN0IHAgPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X3BhZGRpbmdgXTtcclxuXHJcblx0XHRcdGlmIChub3RFbXB0eShwKSkge1xyXG5cdFx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0cGFkZGluZ1t2XSA9ICQkLmF4aXMuZ2V0UGFkZGluZyhwLCB2LCBwYWRkaW5nW3ZdLCBkb21haW5MZW5ndGgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmFyL0FyZWEgY2hhcnQgc2hvdWxkIGJlIDAtYmFzZWQgaWYgYWxsIHBvc2l0aXZlfG5lZ2F0aXZlXHJcblx0XHRpZiAoaXNaZXJvQmFzZWQpIHtcclxuXHRcdFx0aXNBbGxQb3NpdGl2ZSAmJiAocGFkZGluZy5ib3R0b20gPSB5RG9tYWluTWluKTtcclxuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAocGFkZGluZy50b3AgPSAteURvbWFpbk1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZG9tYWluID0gW3lEb21haW5NaW4gLSBwYWRkaW5nLmJvdHRvbSwgeURvbWFpbk1heCArIHBhZGRpbmcudG9wXTtcclxuXHJcblx0XHRyZXR1cm4gaXNJbnZlcnRlZCA/IGRvbWFpbi5yZXZlcnNlKCkgOiBkb21haW47XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB2YWx1ZSA9ICQkLmNvbmZpZ1tgYXhpc194XyR7dHlwZX1gXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHZhbHVlKSA/XHJcblx0XHRcdCgkJC5pc1RpbWVTZXJpZXMoKSA/IHBhcnNlRGF0ZS5jYWxsKCQkLCB2YWx1ZSkgOiB2YWx1ZSkgOlxyXG5cdFx0XHRnZXRNaW5NYXgodHlwZSwgdGFyZ2V0cy5tYXAodCA9PiBnZXRNaW5NYXgodHlwZSwgdC52YWx1ZXMubWFwKHYgPT4gdi54KSkpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluTWluKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtaW5cIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbk1heCh0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWF4XCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5QYWRkaW5nKGRvbWFpbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRpZmYgPSBkb21haW5bMV0gLSBkb21haW5bMF07XHJcblx0XHRjb25zdCB4UGFkZGluZyA9IGNvbmZpZy5heGlzX3hfcGFkZGluZztcclxuXHRcdGxldCBtYXhEYXRhQ291bnQ7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAwO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNUeXBlKFwiYmFyXCIpKSB7XHJcblx0XHRcdG1heERhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xyXG5cdFx0XHRwYWRkaW5nID0gbWF4RGF0YUNvdW50ID4gMSA/IChkaWZmIC8gKG1heERhdGFDb3VudCAtIDEpKSAvIDIgOiAwLjU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYWRkaW5nID0gZGlmZiAqIDAuMDE7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxlZnQgPSBwYWRkaW5nO1xyXG5cdFx0bGV0IHJpZ2h0ID0gcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoeFBhZGRpbmcpICYmIG5vdEVtcHR5KHhQYWRkaW5nKSkge1xyXG5cdFx0XHRsZWZ0ID0gaXNWYWx1ZSh4UGFkZGluZy5sZWZ0KSA/IHhQYWRkaW5nLmxlZnQgOiBwYWRkaW5nO1xyXG5cdFx0XHRyaWdodCA9IGlzVmFsdWUoeFBhZGRpbmcucmlnaHQpID8geFBhZGRpbmcucmlnaHQgOiBwYWRkaW5nO1xyXG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihjb25maWcuYXhpc194X3BhZGRpbmcpKSB7XHJcblx0XHRcdGxlZnQgPSB4UGFkZGluZztcclxuXHRcdFx0cmlnaHQgPSB4UGFkZGluZztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge2xlZnQsIHJpZ2h0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHhEb21haW4gPSBbJCQuZ2V0WERvbWFpbk1pbih0YXJnZXRzKSwgJCQuZ2V0WERvbWFpbk1heCh0YXJnZXRzKV07XHJcblx0XHRsZXQgW2ZpcnN0WCwgbGFzdFhdID0geERvbWFpbjtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSAkJC5nZXRYRG9tYWluUGFkZGluZyh4RG9tYWluKTtcclxuXHRcdGxldCBtaW46IERhdGUgfCBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IG1heDogRGF0ZSB8IG51bWJlciA9IDA7XHJcblxyXG5cdFx0Ly8gc2hvdyBjZW50ZXIgb2YgeCBkb21haW4gaWYgbWluIGFuZCBtYXggYXJlIHRoZSBzYW1lXHJcblx0XHRpZiAoKGZpcnN0WCAtIGxhc3RYKSA9PT0gMCAmJiAhJCQuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHRcdGZpcnN0WCA9IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgKiAwLjUpO1xyXG5cdFx0XHRcdGxhc3RYID0gbmV3IERhdGUobGFzdFguZ2V0VGltZSgpICogMS41KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmaXJzdFggPSBmaXJzdFggPT09IDAgPyAxIDogKGZpcnN0WCAqIDAuNSk7XHJcblx0XHRcdFx0bGFzdFggPSBsYXN0WCA9PT0gMCA/IC0xIDogKGxhc3RYICogMS41KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChmaXJzdFggfHwgZmlyc3RYID09PSAwKSB7XHJcblx0XHRcdG1pbiA9ICQkLmlzVGltZVNlcmllcygpID8gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAtIHBhZGRpbmcubGVmdCkgOiBmaXJzdFggLSBwYWRkaW5nLmxlZnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RYIHx8IGxhc3RYID09PSAwKSB7XHJcblx0XHRcdG1heCA9ICQkLmlzVGltZVNlcmllcygpID8gbmV3IERhdGUobGFzdFguZ2V0VGltZSgpICsgcGFkZGluZy5yaWdodCkgOiBsYXN0WCArIHBhZGRpbmcucmlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWERvbWFpbih0YXJnZXRzLCB3aXRoVXBkYXRlWERvbWFpbiwgd2l0aFVwZGF0ZU9yZ1hEb21haW4sIHdpdGhUcmltLCBkb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZywgc2NhbGU6IHt4LCBzdWJYfX0gPSAkJDtcclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4pIHtcclxuXHRcdFx0eC5kb21haW4oZG9tYWluIHx8IHNvcnRWYWx1ZSgkJC5nZXRYRG9tYWluKHRhcmdldHMpKSk7XHJcblx0XHRcdG9yZy54RG9tYWluID0geC5kb21haW4oKTtcclxuXHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHN1YlguZG9tYWluKHguZG9tYWluKCkpO1xyXG5cdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC5zY2FsZShzdWJYKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZVhEb21haW4pIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluVmFsdWUgPSBkb21haW4gfHwgKCEkJC5icnVzaCB8fCBicnVzaEVtcHR5KCQkKSkgP1xyXG5cdFx0XHRcdG9yZy54RG9tYWluIDogZ2V0QnJ1c2hTZWxlY3Rpb24oJCQpLm1hcChzdWJYLmludmVydCk7XHJcblxyXG5cdFx0XHR4LmRvbWFpbihkb21haW5WYWx1ZSk7XHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmltIGRvbWFpbiB3aGVuIHRvbyBiaWcgYnkgem9vbSBtb3VzZW1vdmUgZXZlbnRcclxuXHRcdHdpdGhUcmltICYmIHguZG9tYWluKCQkLnRyaW1YRG9tYWluKHgub3JnRG9tYWluKCkpKTtcclxuXHJcblx0XHRyZXR1cm4geC5kb21haW4oKTtcclxuXHR9LFxyXG5cclxuXHR0cmltWERvbWFpbihkb21haW4pIHtcclxuXHRcdGNvbnN0IHpvb21Eb21haW4gPSB0aGlzLmdldFpvb21Eb21haW4oKTtcclxuXHRcdGNvbnN0IFttaW4sIG1heF0gPSB6b29tRG9tYWluO1xyXG5cclxuXHRcdGlmIChkb21haW5bMF0gPD0gbWluKSB7XHJcblx0XHRcdGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcclxuXHRcdFx0ZG9tYWluWzBdID0gbWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXggPD0gZG9tYWluWzFdKSB7XHJcblx0XHRcdGRvbWFpblswXSA9ICtkb21haW5bMF0gLSAoZG9tYWluWzFdIC0gbWF4KTtcclxuXHRcdFx0ZG9tYWluWzFdID0gbWF4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkb21haW47XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5mdW5jdGlvbiBnZXRGb3JtYXQoJCQsIHR5cGVWYWx1ZSwgdikge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0Y29uc3QgdHlwZSA9IGBheGlzXyR7dHlwZVZhbHVlfV90aWNrX2Zvcm1hdGA7XHJcblx0Y29uc3QgZm9ybWF0ID0gY29uZmlnW3R5cGVdID9cclxuXHRcdGNvbmZpZ1t0eXBlXSA6ICQkLmRlZmF1bHRWYWx1ZUZvcm1hdDtcclxuXHJcblx0cmV0dXJuIGZvcm1hdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFlGb3JtYXQoZm9yQXJjKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQge3lGb3JtYXQsIHkyRm9ybWF0fSA9ICQkO1xyXG5cclxuXHRcdGlmIChmb3JBcmMgJiYgISQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHR5Rm9ybWF0ID0gJCQuZGVmYXVsdEFyY1ZhbHVlRm9ybWF0O1xyXG5cdFx0XHR5MkZvcm1hdCA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24odiwgcmF0aW8sIGlkKSB7XHJcblx0XHRcdGNvbnN0IGZvcm1hdCA9ICQkLmF4aXMgJiYgJCQuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0eTJGb3JtYXQgOiB5Rm9ybWF0O1xyXG5cclxuXHRcdFx0cmV0dXJuIGZvcm1hdC5jYWxsKCQkLCB2LCByYXRpbyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHlGb3JtYXQodikge1xyXG5cdFx0cmV0dXJuIGdldEZvcm1hdCh0aGlzLCBcInlcIiwgdik7XHJcblx0fSxcclxuXHJcblx0eTJGb3JtYXQodikge1xyXG5cdFx0cmV0dXJuIGdldEZvcm1hdCh0aGlzLCBcInkyXCIsIHYpO1xyXG5cdH0sXHJcblxyXG5cdGRlZmF1bHRWYWx1ZUZvcm1hdCh2KSB7XHJcblx0XHRyZXR1cm4gaXNWYWx1ZSh2KSA/ICt2IDogXCJcIjtcclxuXHR9LFxyXG5cclxuXHRkZWZhdWx0QXJjVmFsdWVGb3JtYXQodiwgcmF0aW8pIHtcclxuXHRcdHJldHVybiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMSl9JWA7XHJcblx0fSxcclxuXHJcblx0ZGF0YUxhYmVsRm9ybWF0KHRhcmdldElkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzO1xyXG5cdFx0Y29uc3QgZGVmYXVsdEZvcm1hdCA9IHYgPT4gKGlzVmFsdWUodikgPyArdiA6IFwiXCIpO1xyXG5cdFx0bGV0IGZvcm1hdCA9IGRlZmF1bHRGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gZmluZCBmb3JtYXQgYWNjb3JkaW5nIHRvIGF4aXMgaWRcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xyXG5cdFx0XHRmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdDtcclxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3RUeXBlKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xyXG5cdFx0XHRpZiAoZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdKSB7XHJcblx0XHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdID09PSB0cnVlID9cclxuXHRcdFx0XHRcdGRlZmF1bHRGb3JtYXQgOiBkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9ybWF0ID0gKCkgPT4gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3JtYXQuYmluZCgkJC5hcGkpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50LFxyXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgaXNEZWZpbmVkLCBnZXRPcHRpb24sIGlzRW1wdHksIGlzRnVuY3Rpb24sIG5vdEVtcHR5LCB0cGxQcm9jZXNzfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0TGVnZW5kKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLnN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkID0gZmFsc2U7XHJcblx0XHQkZWwubGVnZW5kID0gJCQuJGVsLnN2Zy5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0JGVsLmxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYWxsIGhlcmUgdG8gdXBkYXRlIGxlZ2VuZCBib3ggYW5kIHRyYW5zbGF0ZSBmb3IgYWxsXHJcblx0XHRcdC8vIE1FTU86IHRyYW5zbGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYnkgdGhpcywgc28gdHJhbnNmb3JtIG5vdCBuZWVkZWQgaW4gdXBkYXRlTGVnZW5kKClcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC4kZWwubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHRcdFx0JCQuc3RhdGUuaGlkZGVuTGVnZW5kSWRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoVHJhbnNmb3JtIDogV2hldGhlciB0byB1c2UgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBXaGV0aGVyIHRyYW5zaXRpb24gaXMgdXNlZCB3aGVuIHVzaW5nIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbiA6IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25zIFJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9uc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kKHRhcmdldElkcywgb3B0aW9ucywgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCBzY2FsZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qgb3B0aW9ueiA9IG9wdGlvbnMgfHwge1xyXG5cdFx0XHR3aXRoVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0b3B0aW9uei53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xyXG5cdFx0b3B0aW9uei53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIHRydWUpO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0byAmJiBjb25maWcubGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlKSB7XHJcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRFbGVtZW50KFxyXG5cdFx0XHRcdHRhcmdldElkcyB8fCAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLFxyXG5cdFx0XHRcdG9wdGlvbnosXHJcblx0XHRcdFx0dHJhbnNpdGlvbnNcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0b2dnbGUgbGVnZW5kIHN0YXRlXHJcblx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuLCBpZCA9PiAhJCQuaXNUYXJnZXRUb1Nob3coaWQpKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgc2l6ZSBhbmQgc2NhbGVcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyhmYWxzZSwgIXNjYWxlLnpvb20pO1xyXG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBnIHBvc2l0aW9uc1xyXG5cdFx0JCQudHJhbnNmb3JtQWxsKG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHRzdGF0ZS5sZWdlbmRIYXNSZW5kZXJlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCB1c2luZyB0ZW1wbGF0ZSBvcHRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qgd3JhcHBlciA9IGQzU2VsZWN0KGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvKTtcclxuXHRcdGNvbnN0IHRlbXBsYXRlID0gY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTtcclxuXHJcblx0XHRpZiAoIXdyYXBwZXIuZW1wdHkoKSkge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3QgaWRzOiBhbnlbXSA9IFtdO1xyXG5cdFx0XHRsZXQgaHRtbCA9IFwiXCI7XHJcblxyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGlzRnVuY3Rpb24odGVtcGxhdGUpID9cclxuXHRcdFx0XHRcdHRlbXBsYXRlLmJpbmQoJCQuYXBpKSh2LCAkJC5jb2xvcih2KSwgJCQuYXBpLmRhdGEodilbMF0udmFsdWVzKSA6XHJcblx0XHRcdFx0XHR0cGxQcm9jZXNzKHRlbXBsYXRlLCB7XHJcblx0XHRcdFx0XHRcdENPTE9SOiAkJC5jb2xvcih2KSxcclxuXHRcdFx0XHRcdFx0VElUTEU6IHZcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAoY29udGVudCkge1xyXG5cdFx0XHRcdFx0aWRzLnB1c2godik7XHJcblx0XHRcdFx0XHRodG1sICs9IGNvbnRlbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGxlZ2VuZEl0ZW0gPSB3cmFwcGVyLmh0bWwoaHRtbClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzOyB9KVxyXG5cdFx0XHRcdC5kYXRhKGlkcyk7XHJcblxyXG5cdFx0XHQkJC5zZXRMZWdlbmRJdGVtKGxlZ2VuZEl0ZW0pO1xyXG5cclxuXHRcdFx0JGVsLmxlZ2VuZCA9IHdyYXBwZXI7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBsZWdlbmQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iZWpjdH0gc2l6ZSBTXHJcblx0ICovXHJcblx0dXBkYXRlU2l6ZUZvckxlZ2VuZChzaXplKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge1xyXG5cdFx0XHRpc0xlZ2VuZFRvcCwgaXNMZWdlbmRMZWZ0LCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0LCBjdXJyZW50V2lkdGgsIGN1cnJlbnRIZWlnaHRcclxuXHRcdH19ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xyXG5cclxuXHRcdGNvbnN0IGluc2V0TGVnZW5kUG9zaXRpb24gPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRUb3AgP1xyXG5cdFx0XHRcdCQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCkgKyBjb25maWcubGVnZW5kX2luc2V0X3kgKyA1LjUgOlxyXG5cdFx0XHRcdGN1cnJlbnRIZWlnaHQgLSBoZWlnaHQgLSAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF95LFxyXG5cdFx0XHRsZWZ0OiBpc0xlZ2VuZExlZnQgP1xyXG5cdFx0XHRcdCQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpICsgY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41IDpcclxuXHRcdFx0XHRjdXJyZW50V2lkdGggLSB3aWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSAtIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNVxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC5zdGF0ZS5tYXJnaW4zID0ge1xyXG5cdFx0XHR0b3A6IGlzTGVnZW5kUmlnaHQgP1xyXG5cdFx0XHRcdDAgOiBpc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi50b3AgOiBjdXJyZW50SGVpZ2h0IC0gaGVpZ2h0LFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IGlzTGVnZW5kUmlnaHQgP1xyXG5cdFx0XHRcdGN1cnJlbnRXaWR0aCAtIHdpZHRoIDogaXNMZWdlbmRJbnNldCA/IGluc2V0TGVnZW5kUG9zaXRpb24ubGVmdCA6IDBcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVHJhbnNmb3JtIExlZ2VuZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxyXG5cdCAqL1xyXG5cdHRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2xlZ2VuZH0gPSAkJC4kZWw7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gbGVnZW5kLnRyYW5zaXRpb24oKSA6IGxlZ2VuZClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibGVnZW5kXCIpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZCBzdGVwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCkge1xyXG5cdFx0dGhpcy5zdGF0ZS5sZWdlbmRTdGVwID0gc3RlcDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gd2lkdGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCh3KSB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZEl0ZW1XaWR0aCA9IHc7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCBpdGVtIGhlaWdodFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQoaCkge1xyXG5cdFx0dGhpcy5zdGF0ZS5sZWdlbmRJdGVtSGVpZ2h0ID0gaDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gY29sb3JcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBDb3JyZXNwb25kaW5nIGRhdGEgSUQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRJdGVtQ29sb3IoaWQsIGNvbG9yKSB7XHJcblx0XHR0aGlzLiRlbC5sZWdlbmQuc2VsZWN0KGAuJHtDTEFTUy5sZWdlbmRJdGVtfS0ke2lkfSBsaW5lYClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIGNvbG9yKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gd2lkdGhcclxuXHQgKi9cclxuXHRnZXRMZWdlbmRXaWR0aCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjdXJyZW50V2lkdGgsIGlzTGVnZW5kUmlnaHQsIGlzTGVnZW5kSW5zZXQsIGxlZ2VuZEl0ZW1XaWR0aCwgbGVnZW5kU3RlcH0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLmxlZ2VuZF9zaG93ID8gKFxyXG5cdFx0XHRpc0xlZ2VuZFJpZ2h0IHx8IGlzTGVnZW5kSW5zZXQgP1xyXG5cdFx0XHRcdGxlZ2VuZEl0ZW1XaWR0aCAqIChsZWdlbmRTdGVwICsgMSkgOiBjdXJyZW50V2lkdGhcclxuXHRcdCkgOiAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TGVnZW5kSGVpZ2h0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnRIZWlnaHQsIGlzTGVnZW5kUmlnaHQsIGxlZ2VuZEl0ZW1IZWlnaHQsIGxlZ2VuZFN0ZXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcclxuXHRcdFx0aXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0Y3VycmVudEhlaWdodCA6IE1hdGgubWF4KDIwLCBsZWdlbmRJdGVtSGVpZ2h0KSAqIChsZWdlbmRTdGVwICsgMSlcclxuXHRcdCkgOiAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuU2VsZWN0XHJcblx0ICogQHJldHVybnMge051bWJlcn0gb3BhY2l0eVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JMZWdlbmQobGVnZW5kSXRlbSkge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjFcIjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZCB0aGF0IGlzIHVuZm9jdXNlZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGxlZ2VuZEl0ZW0sIGQzLlNlbGVjdFxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IG9wYWNpdHlcclxuXHQgKi9cclxuXHRvcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kKGxlZ2VuZEl0ZW0pIHtcclxuXHRcdHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIwLjNcIjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBmb2N1cyBvZiB0aGUgbGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gZm9jdXMuXHJcblx0ICovXHJcblx0dG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCBmb2N1cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWR6ID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHQkJC4kZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxyXG5cdFx0XHQuZmlsdGVyKGlkID0+IHRhcmdldElkei5pbmRleE9mKGlkKSA+PSAwKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZm9jdXMpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gKGZvY3VzID8gJCQub3BhY2l0eUZvckxlZ2VuZCA6ICQkLm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQpXHJcblx0XHRcdFx0XHQuY2FsbCgkJCwgZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXZlcnQgdGhlIGxlZ2VuZCB0byBpdHMgZGVmYXVsdCBzdGF0ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmV2ZXJ0TGVnZW5kKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLiRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAkJC5vcGFjaXR5Rm9yTGVnZW5kKGQzU2VsZWN0KHRoaXMpKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvd3MgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gSUQncyBvZiB0YXJnZXRcclxuXHQgKi9cclxuXHRzaG93TGVnZW5kKHRhcmdldElkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bGVnZW5kfX0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHRjb25maWcubGVnZW5kX3Nob3cgPSB0cnVlO1xyXG5cdFx0XHRsZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuXHJcblx0XHRcdCEkJC5zdGF0ZS5sZWdlbmRIYXNSZW5kZXJlZCAmJiAkJC51cGRhdGVMZWdlbmQoKTtcclxuXHRcdH1cclxuXHRcdCQkLnJlbW92ZUhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdGxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkM1NlbGVjdCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gSUQncyBvZiB0YXJnZXRcclxuXHQgKi9cclxuXHRoaWRlTGVnZW5kKHRhcmdldElkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bGVnZW5kfX0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93ICYmIGlzRW1wdHkodGFyZ2V0SWRzKSkge1xyXG5cdFx0XHRjb25maWcubGVnZW5kX3Nob3cgPSBmYWxzZTtcclxuXHRcdFx0bGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5hZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcclxuXHRcdGxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGxlZ2VuZCBpdGVtIHRleHRib3ggZGltZW5zaW9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IHRleHRFbGVtZW50XHJcblx0ICovXHJcblx0Z2V0TGVnZW5kSXRlbVRleHRCb3goaWQ/OiBzdHJpbmcsIHRleHRFbGVtZW50Pykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NhY2hlfSA9ICQkO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiRsZWdlbmRJdGVtVGV4dEJveFwiO1xyXG5cclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRsZXQgZGF0YSA9IGNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0XHRpZiAoIWRhdGEpIHtcclxuXHRcdFx0XHRkYXRhID0ge307XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghZGF0YVtpZF0pIHtcclxuXHRcdFx0XHRkYXRhW2lkXSA9ICQkLmdldFRleHRSZWN0KHRleHRFbGVtZW50LCBDTEFTUy5sZWdlbmRJdGVtKTtcclxuXHRcdFx0XHRjYWNoZS5hZGQoY2FjaGVLZXksIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YVtpZF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjYWNoZS5yZW1vdmUoY2FjaGVLZXkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsZWdlbmQgaXRlbSBzdHlsZSAmIGJpbmQgZXZlbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gaXRlbVxyXG5cdCAqL1xyXG5cdHNldExlZ2VuZEl0ZW0oaXRlbSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGl0ZW1cclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGl0ZW1DbGFzcyArICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGVnZW5kSXRlbSwgaWQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGlkID0+ICgkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcclxuXHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25jbGljaywgYXBpLCBpZCkpIHtcclxuXHRcdFx0XHRcdGlmIChkM0V2ZW50LmFsdEtleSkge1xyXG5cdFx0XHRcdFx0XHRhcGkuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHRhcGkuc2hvdyhpZCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhcGkudG9nZ2xlKGlkKTtcclxuXHRcdFx0XHRcdFx0IWlzVG91Y2ggJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gYXBpLmZvY3VzKGlkKSA6IGFwaS5yZXZlcnQoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlzVG91Y2ggJiYgJCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFpc1RvdWNoKSB7XHJcblx0XHRcdGl0ZW1cclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29ub3V0LCBhcGksIGlkKSkge1xyXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0XHRcdFx0XHQkJC51bmRvTWFya092ZXJsYXBwZWQoJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQkJC5hcGkucmV2ZXJ0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdGlmICghY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm92ZXIsIGFwaSwgaWQpKSB7XHJcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQubWFya092ZXJsYXBwZWQoaWQsICQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFzdGF0ZS50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdFx0XHRcdGFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuIFx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcywgb3B0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nVG9wID0gNDtcclxuXHRcdGNvbnN0IHBhZGRpbmdSaWdodCA9IDEwO1xyXG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XHJcblx0XHRjb25zdCB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XHJcblx0XHRsZXQgeEZvckxlZ2VuZDtcclxuXHRcdGxldCB5Rm9yTGVnZW5kO1xyXG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdGNvbnN0IG9mZnNldHMgPSB7fTtcclxuXHRcdGNvbnN0IHdpZHRocyA9IHt9O1xyXG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xyXG5cdFx0Y29uc3QgbWFyZ2lucyA9IFswXTtcclxuXHRcdGNvbnN0IHN0ZXBzID0ge307XHJcblx0XHRsZXQgc3RlcCA9IDA7XHJcblx0XHRsZXQgYmFja2dyb3VuZDtcclxuXHRcdGNvbnN0IGlzTGVnZW5kUmlnaHRPckluc2V0ID0gc3RhdGUuaXNMZWdlbmRSaWdodCB8fCBzdGF0ZS5pc0xlZ2VuZEluc2V0O1xyXG5cclxuXHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSB0YXJnZXRJZHNcclxuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcclxuXHJcblx0XHRjb25zdCB3aXRoVHJhbnNpdGlvbiA9IG9wdGlvbnMud2l0aFRyYW5zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24odGV4dEVsZW1lbnQsIGlkLCBpbmRleCkge1xyXG5cdFx0XHRjb25zdCByZXNldCA9IGluZGV4ID09PSAwO1xyXG5cdFx0XHRjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gdGFyZ2V0SWR6Lmxlbmd0aCAtIDE7XHJcblx0XHRcdGNvbnN0IGJveCA9ICQkLmdldExlZ2VuZEl0ZW1UZXh0Qm94KGlkLCB0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGl0ZW1XaWR0aCA9IGJveC53aWR0aCArIHRpbGVXaWR0aCArXHJcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcclxuXHRcdFx0Y29uc3QgaXRlbUhlaWdodCA9IGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wO1xyXG5cdFx0XHRjb25zdCBpdGVtTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBpdGVtSGVpZ2h0IDogaXRlbVdpZHRoO1xyXG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XHJcblx0XHRcdGxldCBtYXJnaW47XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxyXG5cdFx0XHRjb25zdCB1cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbihpZDIsIHdpdGhvdXRTdGVwPzogYm9vbGVhbikge1xyXG5cdFx0XHRcdGlmICghd2l0aG91dFN0ZXApIHtcclxuXHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gdG90YWxMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcclxuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0XHRzdGVwKys7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGVwc1tpZDJdID0gc3RlcDtcclxuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gc3RhdGUuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xyXG5cdFx0XHRcdG9mZnNldHNbaWQyXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGl0ZW1MZW5ndGg7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAocmVzZXQpIHtcclxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XHJcblx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0bWF4V2lkdGggPSAwO1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdHdpZHRoc1tpZF0gPSAwO1xyXG5cdFx0XHRcdGhlaWdodHNbaWRdID0gMDtcclxuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xyXG5cdFx0XHRcdG9mZnNldHNbaWRdID0gMDtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xyXG5cdFx0XHRoZWlnaHRzW2lkXSA9IGl0ZW1IZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xyXG5cdFx0XHRcdG1heFdpZHRoID0gaXRlbVdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW1heEhlaWdodCB8fCBpdGVtSGVpZ2h0ID49IG1heEhlaWdodCkge1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1heExlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gbWF4SGVpZ2h0IDogbWF4V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9lcXVhbGx5KSB7XHJcblx0XHRcdFx0T2JqZWN0LmtleXMod2lkdGhzKS5mb3JFYWNoKGlkMiA9PiAod2lkdGhzW2lkMl0gPSBtYXhXaWR0aCkpO1xyXG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcclxuXHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkei5sZW5ndGgpIC8gMjtcclxuXHJcblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHN0ZXAgPSBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgPyBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgOiB0YXJnZXRJZHoubGVuZ3RoO1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcclxuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0fSBlbHNlIGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xyXG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXhIZWlnaHQgKiBzdGVwc1tpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFRleHQgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFJlY3QgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpO1xyXG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XHJcblx0XHRjb25zdCB4MkZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMiArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cclxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XHJcblx0XHRjb25zdCB5Rm9yTGVnZW5kUmVjdCA9IChpZCwgaT86IG51bWJlcikgPT4geUZvckxlZ2VuZChpZCwgaSkgLSA1O1xyXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHlGb3JMZWdlbmQoaWQsIGkpICsgNDtcclxuXHJcblx0XHRjb25zdCBwb3MgPSAtMjAwO1xyXG5cclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxyXG5cdFx0Y29uc3QgbCA9IGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xyXG5cclxuXHRcdGwuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRUZXh0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XHJcblxyXG5cdFx0bC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XHJcblxyXG5cdFx0Y29uc3QgdXNlUG9pbnQgPSBjb25maWcubGVnZW5kX3VzZVBvaW50O1xyXG5cclxuXHRcdGlmICh1c2VQb2ludCkge1xyXG5cdFx0XHRjb25zdCBpZHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcclxuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID9cclxuXHRcdFx0XHRcdGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRcdFx0aWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xyXG5cclxuXHRcdFx0XHRpZiAocG9pbnQgPT09IFwicmVjdGFuZ2xlXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XHJcblx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRJdGVtUG9pbnQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaHJlZlwiLCAoZGF0YSwgaWR4LCBzZWxlY3Rpb24pID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHtzdGF0ZS5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVRpbGUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX2hlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmQgZm9yIGluc2V0IGxlZ2VuZFxyXG5cdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCAmJiBtYXhXaWR0aCA+IDAgJiYgYmFja2dyb3VuZC5zaXplKCkgPT09IDApIHtcclxuXHRcdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHRzID0gbGVnZW5kLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpIC8vIE1FTU86IG5lZWRlZCBmb3IgdXBkYXRlXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRUZXh0KTtcclxuXHJcblx0XHRjb25zdCByZWN0cyA9IGxlZ2VuZC5zZWxlY3RBbGwoYHJlY3QuJHtDTEFTUy5sZWdlbmRJdGVtRXZlbnR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cylcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpZCA9PiB3aWR0aHNbaWRdKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRSZWN0KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFJlY3QpO1xyXG5cclxuXHJcblx0XHRpZiAodXNlUG9pbnQpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xyXG5cclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0bGV0IHggPSBcInhcIjtcclxuXHRcdFx0XHRcdGxldCB5ID0gXCJ5XCI7XHJcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XHJcblx0XHRcdFx0XHRsZXQgeU9mZnNldCA9IDIuNTtcclxuXHRcdFx0XHRcdGxldCByYWRpdXM7XHJcblx0XHRcdFx0XHRsZXQgd2lkdGg7XHJcblx0XHRcdFx0XHRsZXQgaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMC4yO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcclxuXHRcdFx0XHRcdFx0eSA9IFwiY3lcIjtcclxuXHRcdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRSICsgc2l6ZTtcclxuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAtc2l6ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwicmVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XHJcblxyXG5cdFx0XHRcdFx0XHR3aWR0aCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKHgsIGQgPT4geDFGb3JMZWdlbmRUaWxlKGQpICsgeE9mZnNldClcclxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiclwiLCByYWRpdXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCB0aWxlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldElkeik7XHJcblxyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQubGV2ZWxDb2xvciA/IGlkID0+ICQkLmxldmVsQ29sb3IoJCQuY2FjaGUuZ2V0KGlkKS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4MUZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIHgyRm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIHlGb3JMZWdlbmRUaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYmFja2dyb3VuZCkge1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFdpZHRoICogKHN0ZXAgKyAxKSArIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgYWxsIHRvIHJlZmxlY3QgY2hhbmdlIG9mIGxlZ2VuZFxyXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobWF4SGVpZ2h0KTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2NhbGVUaW1lIGFzIGQzU2NhbGVUaW1lLFxyXG5cdHNjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJcclxufSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRTY2FsZShtaW4sIG1heCwgZm9yVGltZXNlcmllcykge1xyXG5cdFx0cmV0dXJuIChmb3JUaW1lc2VyaWVzID9cclxuXHRcdFx0ZDNTY2FsZVRpbWUoKSA6IGQzU2NhbGVMaW5lYXIoKVxyXG5cdFx0KS5yYW5nZShbbWluLCBtYXhdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeCBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb2Zmc2V0IFRoZSBvZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WChtaW4sIG1heCwgZG9tYWluLCBvZmZzZXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGUuem9vbSB8fCAkJC5nZXRTY2FsZShtaW4sIG1heCwgJCQuaXNUaW1lU2VyaWVzKCkpO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRDdXN0b21pemVkU2NhbGUoXHJcblx0XHRcdGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsXHJcblx0XHRcdG9mZnNldFxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeSBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRZKG1pbiwgbWF4LCBkb21haW4pIHtcclxuXHRcdGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZShtaW4sIG1heCwgdGhpcy5pc1RpbWVTZXJpZXNZKCkpO1xyXG5cclxuXHRcdGRvbWFpbiAmJiBzY2FsZS5kb21haW4oZG9tYWluKTtcclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGN1c3RvbWl6ZWQgc2NhbGVcclxuXHQgKiBAcGFyYW0ge2QzLnNjYWxlTGluZWFyfGQzLnNjYWxlVGltZX0gc2NhbGVWYWx1ZVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldFZhbHVlIE9mZnNldCBnZXR0ZXIgdG8gYmUgc3VtXHJcblx0ICogQHJldHVybiB7fSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q3VzdG9taXplZFNjYWxlKHNjYWxlVmFsdWUsIG9mZnNldFZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSB8fCAoKCkgPT4gJCQuYXhpcy54LnRpY2tPZmZzZXQoKSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IGZ1bmN0aW9uKGQsIHJhdykge1xyXG5cdFx0XHRjb25zdCB2ID0gc2NhbGVWYWx1ZShkKSArIG9mZnNldCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xyXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc2NhbGVWYWx1ZSkge1xyXG5cdFx0XHRzY2FsZVtrZXldID0gc2NhbGVWYWx1ZVtrZXldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlLm9yZ0RvbWFpbiA9ICgpID0+IHNjYWxlVmFsdWUuZG9tYWluKCk7XHJcblx0XHRzY2FsZS5vcmdTY2FsZSA9ICgpID0+IHNjYWxlVmFsdWU7XHJcblxyXG5cdFx0Ly8gZGVmaW5lIGN1c3RvbSBkb21haW4oKSBmb3IgY2F0ZWdvcml6ZWQgYXhpc1xyXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRzY2FsZS5kb21haW4gPSBmdW5jdGlvbihkb21haW5WYWx1ZSkge1xyXG5cdFx0XHRcdGxldCBkb21haW4gPSBkb21haW5WYWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRkb21haW4gPSB0aGlzLm9yZ0RvbWFpbigpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBbZG9tYWluWzBdLCBkb21haW5bMV0gKyAxXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNjYWxlVmFsdWUuZG9tYWluKGRvbWFpbik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBzY2FsZTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0Z2V0WVNjYWxlKGlkKSB7XHJcblx0XHRjb25zdCB7eSwgeTJ9ID0gdGhpcy5zY2FsZTtcclxuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB5MiA6IHk7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ViWVNjYWxlKGlkKSB7XHJcblx0XHRjb25zdCB7c3ViWSwgc3ViWTJ9ID0gdGhpcy5zY2FsZTtcclxuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyBzdWJZMiA6IHN1Ylk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCAtIHBhcmFtIGlzIGdpdmVuIGF0IHRoZSBpbml0IHJlbmRlcmluZ1xyXG5cdCAqL1xyXG5cdHVwZGF0ZVNjYWxlcyhpc0luaXQsIHVwZGF0ZVhEb21haW4gPSB0cnVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBmb3JtYXQsIG9yZywgc2NhbGUsXHJcblx0XHRcdHN0YXRlOiB7d2lkdGgsIGhlaWdodCwgd2lkdGgyLCBoZWlnaHQyfVxyXG5cdFx0fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBeGlzKSB7XHJcblx0XHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZWRnZXNcclxuXHRcdFx0Y29uc3QgbWluID0ge1xyXG5cdFx0XHRcdHg6IGlzUm90YXRlZCA/IDEgOiAwLFxyXG5cdFx0XHRcdHk6IGlzUm90YXRlZCA/IDAgOiBoZWlnaHQsXHJcblx0XHRcdFx0c3ViWDogaXNSb3RhdGVkID8gMSA6IDAsXHJcblx0XHRcdFx0c3ViWTogaXNSb3RhdGVkID8gMCA6IGhlaWdodDJcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IG1heCA9IHtcclxuXHRcdFx0XHR4OiBpc1JvdGF0ZWQgPyBoZWlnaHQgOiB3aWR0aCxcclxuXHRcdFx0XHR5OiBpc1JvdGF0ZWQgPyB3aWR0aCA6IDEsXHJcblx0XHRcdFx0c3ViWDogaXNSb3RhdGVkID8gaGVpZ2h0IDogd2lkdGgsXHJcblx0XHRcdFx0c3ViWTogaXNSb3RhdGVkID8gd2lkdGgyIDogMVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgc2NhbGVzXHJcblx0XHRcdC8vIHggQXhpc1xyXG5cdFx0XHRjb25zdCB4RG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiBzY2FsZS54ICYmIHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IHhTdWJEb21haW4gPSB1cGRhdGVYRG9tYWluICYmIG9yZy54RG9tYWluO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9ICQkLmdldFgobWluLngsIG1heC54LCB4RG9tYWluLCAoKSA9PiBheGlzLngudGlja09mZnNldCgpKTtcclxuXHRcdFx0c2NhbGUuc3ViWCA9ICQkLmdldFgobWluLngsIG1heC54LCB4U3ViRG9tYWluLCBkID0+IChkICUgMSA/IDAgOiBheGlzLnN1YlgudGlja09mZnNldCgpKSk7XHJcblxyXG5cdFx0XHRmb3JtYXQueEF4aXNUaWNrID0gYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKTtcclxuXHRcdFx0YXhpcy50aWNrLnggPSBheGlzLmdldFRpY2tWYWx1ZXMoXCJ4XCIpO1xyXG5cclxuXHRcdFx0YXhpcy54ID0gYXhpcy5nZXRBeGlzKFwieFwiLCBzY2FsZS54LCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0XHRheGlzLnN1YlggPSBheGlzLmdldEF4aXMoXCJzdWJYXCIsIHNjYWxlLnN1YlgsIGNvbmZpZy5heGlzX3hfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8geSBBeGlzXHJcblx0XHRcdHNjYWxlLnkgPSAkJC5nZXRZKG1pbi55LCBtYXgueSwgc2NhbGUueSA/IHNjYWxlLnkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xyXG5cdFx0XHRzY2FsZS5zdWJZID0gJCQuZ2V0WShtaW4uc3ViWSwgbWF4LnN1YlksIHNjYWxlLnN1YlkgPyBzY2FsZS5zdWJZLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KTtcclxuXHJcblx0XHRcdGF4aXMudGljay55ID0gYXhpcy5nZXRUaWNrVmFsdWVzKFwieVwiKTtcclxuXHRcdFx0YXhpcy55ID0gYXhpcy5nZXRBeGlzKFwieVwiLCBzY2FsZS55LCBjb25maWcuYXhpc195X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblxyXG5cdFx0XHQvLyB5MiBBeGlzXHJcblx0XHRcdGlmIChjb25maWcuYXhpc195Ml9zaG93KSB7XHJcblx0XHRcdFx0c2NhbGUueTIgPSAkJC5nZXRZKG1pbi55LCBtYXgueSwgc2NhbGUueTIgPyBzY2FsZS55Mi5kb21haW4oKSA6IGNvbmZpZy5heGlzX3kyX2RlZmF1bHQpO1xyXG5cdFx0XHRcdHNjYWxlLnN1YlkyID0gJCQuZ2V0WShtaW4uc3ViWSwgbWF4LnN1YlksXHJcblx0XHRcdFx0XHRzY2FsZS5zdWJZMiA/IHNjYWxlLnN1YlkyLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeTJfZGVmYXVsdCk7XHJcblxyXG5cdFx0XHRcdGF4aXMudGljay55MiA9IGF4aXMuZ2V0VGlja1ZhbHVlcyhcInkyXCIpO1xyXG5cdFx0XHRcdGF4aXMueTIgPSBheGlzLmdldEF4aXMoXCJ5MlwiLCBzY2FsZS55MiwgY29uZmlnLmF4aXNfeTJfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdXBkYXRlIGZvciBhcmNcclxuXHRcdFx0JCQudXBkYXRlQXJjICYmICQkLnVwZGF0ZUFyYygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc1ZhbHVlLCBjZWlsMTAsIGNhcGl0YWxpemV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjb250YWluZXIgc2l6ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0Q29udGFpbmVyU2l6ZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRzdGF0ZS5jdXJyZW50V2lkdGggPSAkJC5nZXRDdXJyZW50V2lkdGgoKTtcclxuXHRcdHN0YXRlLmN1cnJlbnRIZWlnaHQgPSAkJC5nZXRDdXJyZW50SGVpZ2h0KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFdpZHRoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuc2l6ZV93aWR0aCB8fCAkJC5nZXRQYXJlbnRXaWR0aCgpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRIZWlnaHQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaCA9IGNvbmZpZy5zaXplX2hlaWdodCB8fCAkJC5nZXRQYXJlbnRIZWlnaHQoKTtcclxuXHJcblx0XHRyZXR1cm4gaCA+IDAgPyBoIDogMzIwIC8gKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IEF4aXMgc2l6ZSBhY2NvcmRpbmcgaXRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIEF4aXMgaWQgdmFsdWUgLSB4LCB5IG9yIHkyXHJcblx0ICogQHJldHVybiB7bnVtYmVyfSBzaXplIEF4aXMgc2l6ZSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QXhpc1NpemUoaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0cmV0dXJuIChpc1JvdGF0ZWQgJiYgaWQgPT09IFwieFwiKSB8fCAoIWlzUm90YXRlZCAmJiAveTI/Ly50ZXN0KGlkKSkgP1xyXG5cdFx0XHQkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChpZCwgdHJ1ZSkgOlxyXG5cdFx0XHQkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChpZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFBhZGRpbmdUb3AoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnLmF4aXNfeTJfYXhlcy5sZW5ndGg7XHJcblxyXG5cdFx0bGV0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3RvcCkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ190b3AgOiAwO1xyXG5cclxuXHRcdGlmICgkZWwudGl0bGUgJiYgJGVsLnRpdGxlLm5vZGUoKSkge1xyXG5cdFx0XHRwYWRkaW5nICs9ICQkLmdldFRpdGxlUGFkZGluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzTGVuICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICogYXhlc0xlbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZztcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGlzSWQgPSBjb25maWcuYXhpc19yb3RhdGVkID8gXCJ5XCIgOiBcInhcIjtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2F4ZXNgXS5sZW5ndGg7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gaXNWYWx1ZShjb25maWcucGFkZGluZ19ib3R0b20pID9cclxuXHRcdFx0Y29uZmlnLnBhZGRpbmdfYm90dG9tIDogMDtcclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChcclxuXHRcdFx0YXhlc0xlbiA/ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGF4aXNJZCkgKiBheGVzTGVuIDogMFxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ0xlZnQod2l0aG91dFJlY29tcHV0ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBheGlzSWQgPSBpc1JvdGF0ZWQgPyBcInhcIiA6IFwieVwiO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcclxuXHRcdGNvbnN0IGF4aXNXaWR0aCA9ICQkLmhhc0F4aXMgPyAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChheGlzSWQsIHdpdGhvdXRSZWNvbXB1dGUpIDogMDtcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2xlZnQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19sZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyA9ICFjb25maWcuYXhpc194X3Nob3cgP1xyXG5cdFx0XHRcdDEgOiBNYXRoLm1heChjZWlsMTAoYXhpc1dpZHRoKSwgNDApO1xyXG5cdFx0fSBlbHNlIGlmICghY29uZmlnLmF4aXNfeV9zaG93IHx8IGNvbmZpZy5heGlzX3lfaW5uZXIpIHsgLy8gJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWRcclxuXHRcdFx0cGFkZGluZyA9ICQkLmF4aXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNPdXRlciA/IDMwIDogMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjZWlsMTAoYXhpc1dpZHRoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChheGlzV2lkdGggKiBheGVzTGVuKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRlZmF1bHRQYWRkaW5nID0gMTA7XHJcblx0XHRjb25zdCBsZWdlbmRXaWR0aE9uUmlnaHQgPSAkJC5zdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSArIDIwIDogMDtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGF4aXNXaWR0aCA9ICQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKFwieTJcIik7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNWYWx1ZShjb25maWcucGFkZGluZ19yaWdodCkpIHtcclxuXHRcdFx0cGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nX3JpZ2h0ICsgMTsgLy8gMSBpcyBuZWVkZWQgbm90IHRvIGhpZGUgdGljayBsaW5lXHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMgJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nID0gZGVmYXVsdFBhZGRpbmcgKyBsZWdlbmRXaWR0aE9uUmlnaHQ7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMgJiYgKCFjb25maWcuYXhpc195Ml9zaG93IHx8IGNvbmZpZy5heGlzX3kyX2lubmVyKSkgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxyXG5cdFx0XHRwYWRkaW5nID0gMiArIGxlZ2VuZFdpZHRoT25SaWdodCArXHJcblx0XHRcdFx0KCQkLmF4aXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpLmlzT3V0ZXIgPyAyMCA6IDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IGNlaWwxMChheGlzV2lkdGgpICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcGFyZW50IHJlY3QgZWxlbWVudCdzIHNpemVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHByb3BlcnR5L2F0dHJpYnV0ZSBuYW1lXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRQYXJlbnRSZWN0VmFsdWUoa2V5KSB7XHJcblx0XHRjb25zdCBvZmZzZXROYW1lID0gYG9mZnNldCR7Y2FwaXRhbGl6ZShrZXkpfWA7XHJcblx0XHRsZXQgcGFyZW50ID0gdGhpcy4kZWwuY2hhcnQubm9kZSgpO1xyXG5cdFx0bGV0IHY7XHJcblxyXG5cdFx0d2hpbGUgKCF2ICYmIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHR2ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV07XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRpZiAob2Zmc2V0TmFtZSBpbiBwYXJlbnQpIHtcclxuXHRcdFx0XHRcdC8vIEluIElFIGluIGNlcnRhaW4gY2FzZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XHJcblx0XHRcdFx0XHQvLyB3aWxsIGNhdXNlIGFuIFwidW5zcGVjaWZpZWQgZXJyb3JcIlxyXG5cdFx0XHRcdFx0diA9IHBhcmVudFtvZmZzZXROYW1lXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChrZXkgPT09IFwid2lkdGhcIikge1xyXG5cdFx0XHQvLyBTb21ldGltZXMgZWxlbWVudCdzIHdpZHRoIHZhbHVlIGlzIGluY29ycmVjdChleC4gZmxleCBjb250YWluZXIpXHJcblx0XHRcdC8vIEluIHRoaXMgY2FzZSwgdXNlIGJvZHkncyBvZmZzZXRXaWR0aCBpbnN0ZWFkLlxyXG5cdFx0XHRjb25zdCBib2R5V2lkdGggPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xyXG5cclxuXHRcdFx0diA+IGJvZHlXaWR0aCAmJiAodiA9IGJvZHlXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHY7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyZW50V2lkdGgoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQYXJlbnRSZWN0VmFsdWUoXCJ3aWR0aFwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQYXJlbnRIZWlnaHQoKSB7XHJcblx0XHRjb25zdCBoID0gdGhpcy4kZWwuY2hhcnQuc3R5bGUoXCJoZWlnaHRcIik7XHJcblxyXG5cdFx0cmV0dXJuIGguaW5kZXhPZihcInB4XCIpID4gMCA/IHBhcnNlSW50KGgsIDEwKSA6IDA7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ZnTGVmdCh3aXRob3V0UmVjb21wdXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNMZWZ0QXhpc1JlY3QgPSBjb25maWcuYXhpc19yb3RhdGVkIHx8ICghY29uZmlnLmF4aXNfcm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeV9pbm5lcik7XHJcblx0XHRjb25zdCBsZWZ0QXhpc0NsYXNzID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IENMQVNTLmF4aXNYIDogQ0xBU1MuYXhpc1k7XHJcblx0XHRjb25zdCBsZWZ0QXhpcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7bGVmdEF4aXNDbGFzc31gKS5ub2RlKCk7XHJcblx0XHRjb25zdCBzdmdSZWN0ID0gbGVmdEF4aXMgJiYgaGFzTGVmdEF4aXNSZWN0ID8gbGVmdEF4aXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7cmlnaHQ6IDB9O1xyXG5cdFx0Y29uc3QgY2hhcnRSZWN0ID0gJGVsLmNoYXJ0Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdGNvbnN0IHN2Z0xlZnQgPSBzdmdSZWN0LnJpZ2h0IC0gY2hhcnRSZWN0LmxlZnQgLVxyXG5cdFx0XHQoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSk7XHJcblxyXG5cdFx0cmV0dXJuIHN2Z0xlZnQgPiAwID8gc3ZnTGVmdCA6IDA7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc1dpZHRoQnlBeGlzSWQoaWQsIHdpdGhvdXRSZWNvbXB1dGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRpZiAoJCQuYXhpcykge1xyXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9ICQkLmF4aXMgJiYgJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoaWQsIHdpdGhvdXRSZWNvbXB1dGUpICtcclxuXHRcdFx0XHQocG9zaXRpb24uaXNJbm5lciA/IDIwIDogNDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIDQwO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3Qge3JvdGF0ZWRQYWRkaW5nLCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0fSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBoID0gMzA7XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIiAmJiAhY29uZmlnLmF4aXNfeF9zaG93KSB7XHJcblx0XHRcdHJldHVybiA4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgY29uZmlnLmF4aXNfeF9oZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ5XCIgJiYgIWNvbmZpZy5heGlzX3lfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmxlZ2VuZF9zaG93ICYmXHJcblx0XHRcdFx0IWlzTGVnZW5kUmlnaHQgJiZcclxuXHRcdFx0XHQhaXNMZWdlbmRJbnNldCA/IDEwIDogMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieTJcIiAmJiAhY29uZmlnLmF4aXNfeTJfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gcm90YXRlZFBhZGRpbmcudG9wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJvdGF0ZSA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3JvdGF0ZWBdO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSB4L3kgYXhpcyBoZWlnaHQgd2hlbiB0aWNrIHJvdGF0ZWRcclxuXHRcdGlmIChcclxuXHRcdFx0KChpZCA9PT0gXCJ4XCIgJiYgIWlzUm90YXRlZCkgfHwgKC95Mj8vLnRlc3QoaWQpICYmIGlzUm90YXRlZCkpICYmIHJvdGF0ZVxyXG5cdFx0KSB7XHJcblx0XHRcdGggPSAzMCArXHJcblx0XHRcdFx0JCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoaWQpICpcclxuXHRcdFx0XHRNYXRoLmNvcyhNYXRoLlBJICogKDkwIC0gcm90YXRlKSAvIDE4MCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGggK1xyXG5cdFx0XHQoJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCkuaXNJbm5lciA/IDAgOiAxMCkgK1xyXG5cdFx0XHQoaWQgPT09IFwieTJcIiAmJiAhaXNSb3RhdGVkID8gLTEwIDogMCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRSZWN0V2lkdGgoKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5heGlzLngudGlja0ludGVydmFsKCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZURpbWVuc2lvbih3aXRob3V0QXhpcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7YXhpc319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0F4aXMgJiYgIXdpdGhvdXRBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5heGlzLnggJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5jcmVhdGUoYXhpcy54KTtcclxuXHRcdFx0XHQkJC5heGlzLnN1YlggJiYgJCQuYXhpcy5zdWJYLmNyZWF0ZShheGlzLnN1YlgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLmF4aXMueSAmJiAkJC5heGlzLnkuY3JlYXRlKGF4aXMueSk7XHJcblx0XHRcdFx0JCQuYXhpcy55MiAmJiAkJC5heGlzLnkyLmNyZWF0ZShheGlzLnkyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHBhc3MgJ3dpdGhvdXRBeGlzJyBwYXJhbSB0byBub3QgYW5pbWF0ZSBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyh3aXRob3V0QXhpcyk7XHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblx0XHQkJC50cmFuc2Zvcm1BbGwoZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVN2Z1NpemUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0c3ZnXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUuY3VycmVudFdpZHRoKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBzdGF0ZS5jdXJyZW50SGVpZ2h0KTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCBicnVzaCA9IHN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN2Zy5zZWxlY3RBbGwoW2AjJHtzdGF0ZS5jbGlwLmlkfWAsIGAjJHtzdGF0ZS5jbGlwLmlkR3JpZH1gXSlcclxuXHRcdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuaGVpZ2h0KTtcclxuXHJcblx0XHRcdHN2Zy5zZWxlY3QoYCMke3N0YXRlLmNsaXAuaWRYQXhpc31gKVxyXG5cdFx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFhBeGlzQ2xpcFguYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsICQkLmdldFhBeGlzQ2xpcFkuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRYQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFlBeGlzfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WUF4aXNDbGlwWC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WUF4aXNDbGlwWS5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFlBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHRzdGF0ZS5jbGlwLmlkU3ViY2hhcnQgJiYgc3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFN1YmNoYXJ0fWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGJydXNoU2l6ZS5oZWlnaHQpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1Muem9vbVJlY3R9YClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmhlaWdodCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNpemUgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0luaXQgSWYgaXMgY2FsbGVkIGF0IGluaXRpYWxpemF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplcyhpc0luaXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcclxuXHJcblx0XHRjb25zdCBjdXJyTGVnZW5kID0ge1xyXG5cdFx0XHR3aWR0aDogbGVnZW5kID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDAsXHJcblx0XHRcdGhlaWdodDogbGVnZW5kID8gJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgOiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGxlZ2VuZEhlaWdodEZvckJvdHRvbSA9IHN0YXRlLmlzTGVnZW5kUmlnaHQgfHwgc3RhdGUuaXNMZWdlbmRJbnNldCA/IDAgOiBjdXJyTGVnZW5kLmhlaWdodDtcclxuXHRcdGNvbnN0IHhBeGlzSGVpZ2h0ID0gaXNSb3RhdGVkIHx8IGhhc0FyYyA/IDAgOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XHJcblxyXG5cdFx0Y29uc3Qgc3ViY2hhcnRYQXhpc0hlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyAmJiBjb25maWcuc3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93ID9cclxuXHRcdFx0eEF4aXNIZWlnaHQgOiAzMDtcclxuXHRcdGNvbnN0IHN1YmNoYXJ0SGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgIWhhc0FyYyA/XHJcblx0XHRcdChjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgKyBzdWJjaGFydFhBeGlzSGVpZ2h0KSA6IDA7XHJcblxyXG5cdFx0IWlzSW5pdCAmJiAkJC5zZXRDb250YWluZXJTaXplKCk7XHJcblxyXG5cdFx0Ly8gZm9yIG1haW5cclxuXHRcdHN0YXRlLm1hcmdpbiA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0dG9wOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSxcclxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXHJcblx0XHRcdGJvdHRvbTogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ5XCIpICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSxcclxuXHRcdFx0bGVmdDogc3ViY2hhcnRIZWlnaHQgKyAoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpKVxyXG5cdFx0fSA6IHtcclxuXHRcdFx0dG9wOiA0ICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSwgLy8gZm9yIHRvcCB0aWNrIHRleHRcclxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXHJcblx0XHRcdGJvdHRvbTogeEF4aXNIZWlnaHQgKyBzdWJjaGFydEhlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXHJcblx0XHRcdGxlZnQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmb3Igc3ViY2hhcnRcclxuXHRcdHN0YXRlLm1hcmdpbjIgPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdHRvcDogc3RhdGUubWFyZ2luLnRvcCxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiAyMCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0bGVmdDogJCQuc3RhdGUucm90YXRlZFBhZGRpbmcubGVmdFxyXG5cdFx0fSA6IHtcclxuXHRcdFx0dG9wOiBzdGF0ZS5jdXJyZW50SGVpZ2h0IC0gc3ViY2hhcnRIZWlnaHQgLSBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogc3ViY2hhcnRYQXhpc0hlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0bGVmdDogc3RhdGUubWFyZ2luLmxlZnRcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZm9yIGxlZ2VuZFxyXG5cdFx0c3RhdGUubWFyZ2luMyA9IHtcclxuXHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0JCQudXBkYXRlU2l6ZUZvckxlZ2VuZCAmJiAkJC51cGRhdGVTaXplRm9yTGVnZW5kKGN1cnJMZWdlbmQpO1xyXG5cclxuXHRcdHN0YXRlLndpZHRoID0gc3RhdGUuY3VycmVudFdpZHRoIC0gc3RhdGUubWFyZ2luLmxlZnQgLSBzdGF0ZS5tYXJnaW4ucmlnaHQ7XHJcblx0XHRzdGF0ZS5oZWlnaHQgPSBzdGF0ZS5jdXJyZW50SGVpZ2h0IC0gc3RhdGUubWFyZ2luLnRvcCAtIHN0YXRlLm1hcmdpbi5ib3R0b207XHJcblxyXG5cdFx0aWYgKHN0YXRlLndpZHRoIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS53aWR0aCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmhlaWdodCA8IDApIHtcclxuXHRcdFx0c3RhdGUuaGVpZ2h0ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS53aWR0aDIgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRzdGF0ZS5tYXJnaW4ubGVmdCAtIHN0YXRlLnJvdGF0ZWRQYWRkaW5nLmxlZnQgLSBzdGF0ZS5yb3RhdGVkUGFkZGluZy5yaWdodCA6IHN0YXRlLndpZHRoO1xyXG5cclxuXHRcdHN0YXRlLmhlaWdodDIgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRzdGF0ZS5oZWlnaHQgOiBzdGF0ZS5jdXJyZW50SGVpZ2h0IC0gc3RhdGUubWFyZ2luMi50b3AgLSBzdGF0ZS5tYXJnaW4yLmJvdHRvbTtcclxuXHJcblx0XHRpZiAoc3RhdGUud2lkdGgyIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS53aWR0aDIgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5oZWlnaHQyIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS5oZWlnaHQyID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgYXJjXHJcblx0XHRzdGF0ZS5hcmNXaWR0aCA9IHN0YXRlLndpZHRoIC0gKHN0YXRlLmlzTGVnZW5kUmlnaHQgPyBjdXJyTGVnZW5kLndpZHRoICsgMTAgOiAwKTtcclxuXHRcdHN0YXRlLmFyY0hlaWdodCA9IHN0YXRlLmhlaWdodCAtIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gMCA6IDEwKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSkge1xyXG5cdFx0XHRzdGF0ZS5hcmNIZWlnaHQgKz0gc3RhdGUuaGVpZ2h0IC0gJCQuZ2V0R2F1Z2VMYWJlbEhlaWdodCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnVwZGF0ZVJhZGl1cyAmJiAkJC51cGRhdGVSYWRpdXMoKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRSaWdodCAmJiBoYXNBcmMpIHtcclxuXHRcdFx0c3RhdGUubWFyZ2luMy5sZWZ0ID0gc3RhdGUuYXJjV2lkdGggLyAyICsgc3RhdGUucmFkaXVzRXhwYW5kZWQgKiAxLjE7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhcGl0YWxpemUsIGdldEJvdW5kaW5nUmVjdCwgZ2V0UmFuZG9tLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBnZXRUcmFuc2xhdGlvbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0b3BhY2l0eUZvclRleHQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNEYXRhTGFiZWwoKSA/IFwiMVwiIDogXCIwXCI7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUZXh0KCkge1xyXG5cdFx0Y29uc3QgeyRlbH0gPSB0aGlzO1xyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0VGV4dHMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjaGFydFRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAkJC5kYXRhLnRhcmdldHNcclxuXHQgKi9cclxuXHR1cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0VGV4dCA9ICQkLmNsYXNzQ2hhcnRUZXh0LmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NUZXh0cyA9ICQkLmNsYXNzVGV4dHMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IG1haW5UZXh0VXBkYXRlID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydFRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRUZXh0fWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0VGV4dChkKSArIGNsYXNzRm9jdXMoZCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5UZXh0RW50ZXIgPSBtYWluVGV4dFVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0VGV4dClcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdG1haW5UZXh0RW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dHMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhRm4gPSAkJC5sYWJlbGlzaERhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc1RleHQgPSAkJC5jbGFzc1RleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0JGVsLnRleHQgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dH1gKVxyXG5cdFx0XHQuZGF0YShkID0+ICh0aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBkYXRhRm4oZCkpKTtcclxuXHJcblx0XHQkZWwudGV4dC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwudGV4dCA9ICRlbC50ZXh0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0Lm1lcmdlKCQkLiRlbC50ZXh0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBkID0+IChjb25maWcuYXhpc19yb3RhdGVkID8gKGQudmFsdWUgPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIikgOiBcIm1pZGRsZVwiKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnRleHQoKGQsIGksIGopID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9ICQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInpcIikgOiBkLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKHZhbHVlLCBkLmlkLCBpLCBqKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGV4dENvbG9yKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGxhYmVsQ29sb3JzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzX2NvbG9ycztcclxuXHRcdGxldCBjb2xvcjtcclxuXHJcblx0XHRpZiAoaXNTdHJpbmcobGFiZWxDb2xvcnMpKSB7XHJcblx0XHRcdGNvbG9yID0gbGFiZWxDb2xvcnM7XHJcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KGxhYmVsQ29sb3JzKSkge1xyXG5cdFx0XHRjb2xvciA9IGxhYmVsQ29sb3JzW2QuaWRdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb2xvciB8fCAkJC5jb2xvcihkKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgY2hhcnRUZXh0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0geCBQb3NpdGlvbmluZyBmdW5jdGlvbiBmb3IgeFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHkgUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHlcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvckZsb3dcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3VGV4dCh4LCB5LCBmb3JGbG93LCB3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdCA9IGdldFJhbmRvbSgpO1xyXG5cdFx0Y29uc3Qgb3BhY2l0eUZvclRleHQgPSBmb3JGbG93ID8gMCA6ICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCQkLiRlbC50ZXh0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGNvbnN0IHRleHQgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0Ly8gZG8gbm90IGFwcGx5IHRyYW5zaXRpb24gZm9yIG5ld2x5IGFkZGVkIHRleHQgZWxlbWVudHNcclxuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gJiYgdGV4dC5hdHRyKFwieFwiKSA/IHRleHQudHJhbnNpdGlvbih0KSA6IHRleHQpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeC5iaW5kKHRoaXMpKGQsIGkpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHkuYmluZCh0aGlzKShkLCBpKSlcclxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHlGb3JUZXh0KTtcclxuXHRcdFx0fSlcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHZhbHVlIG9mIHRoZSBlbGVtZW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcblx0ICovXHJcblx0Z2V0VGV4dFJlY3QoZWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCBiYXNlID0gKGVsZW1lbnQubm9kZSA/IGVsZW1lbnQubm9kZSgpIDogZWxlbWVudCk7XHJcblxyXG5cdFx0aWYgKCEvdGV4dC9pLnRlc3QoYmFzZS50YWdOYW1lKSkge1xyXG5cdFx0XHRiYXNlID0gYmFzZS5xdWVyeVNlbGVjdG9yKFwidGV4dFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0ZXh0ID0gYmFzZS50ZXh0Q29udGVudDtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gYCQke3RleHQucmVwbGFjZSgvXFxXL2csIFwiX1wiKX1gO1xyXG5cdFx0bGV0IHJlY3QgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghcmVjdCkge1xyXG5cdFx0XHQkJC4kZWwuc3ZnLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZm9udFwiLCBkM1NlbGVjdChiYXNlKS5zdHlsZShcImZvbnRcIikpXHJcblx0XHRcdFx0LmNsYXNzZWQoY2xhc3NOYW1lLCB0cnVlKVxyXG5cdFx0XHRcdC50ZXh0KHRleHQpXHJcblx0XHRcdFx0LmNhbGwodiA9PiB7XHJcblx0XHRcdFx0XHRyZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHYubm9kZSgpKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRcdCQkLmNhY2hlLmFkZChjYWNoZUtleSwgcmVjdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlY3Q7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgeCBvciB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5kaWNlcyBJbmRpY2VzIHZhbHVlc1xyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yWCB3aGV0aGVyIG9yIG5vdCB0byB4XHJcblx0ICogQHJldHVybnMge051bWJlcn0gY29vcmRpbmF0ZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlWFlGb3JUZXh0KGluZGljZXMsIGZvclgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHR5cGVzID0gT2JqZWN0LmtleXMoaW5kaWNlcyk7XHJcblx0XHRjb25zdCBwb2ludHMgPSB7fTtcclxuXHRcdGNvbnN0IGdldHRlciA9IGZvclggPyAkJC5nZXRYRm9yVGV4dCA6ICQkLmdldFlGb3JUZXh0O1xyXG5cclxuXHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiB0eXBlcy5wdXNoKFwicmFkYXJcIik7XHJcblxyXG5cdFx0dHlwZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0cG9pbnRzW3ZdID0gJCRbYGdlbmVyYXRlR2V0JHtjYXBpdGFsaXplKHYpfVBvaW50c2BdKGluZGljZXNbdl0sIGZhbHNlKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdGNvbnN0IHR5cGUgPSAoJCQuaXNBcmVhVHlwZShkKSAmJiBcImFyZWFcIikgfHxcclxuXHRcdFx0XHQoJCQuaXNCYXJUeXBlKGQpICYmIFwiYmFyXCIpIHx8XHJcblx0XHRcdFx0KCQkLmlzUmFkYXJUeXBlKGQpICYmIFwicmFkYXJcIikgfHwgXCJsaW5lXCI7XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2V0dGVyLmNhbGwoJCQsIHBvaW50c1t0eXBlXShkLCBpKSwgZCwgdGhpcyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBjZW50ZXJpemVkIHRleHQgcG9zaXRpb24gZm9yIGJhciB0eXBlIGRhdGEubGFiZWwudGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgRGF0YSBwb2ludHMgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZXh0RWxlbWVudCBEYXRhIGxhYmVsIHRleHQgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFBvc2l0aW9uIHZhbHVlXHJcblx0ICovXHJcblx0Z2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGlmIChjb25maWcuZGF0YV9sYWJlbHMuY2VudGVyZWQgJiYgJCQuaXNCYXJUeXBlKGQpKSB7XHJcblx0XHRcdGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xyXG5cdFx0XHRjb25zdCBpc1Bvc2l0aXZlID0gZC52YWx1ZSA+PSAwO1xyXG5cclxuXHRcdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRcdGNvbnN0IHcgPSAoXHJcblx0XHRcdFx0XHRpc1Bvc2l0aXZlID9cclxuXHRcdFx0XHRcdFx0cG9pbnRzWzFdWzFdIC0gcG9pbnRzWzBdWzFdIDpcclxuXHRcdFx0XHRcdFx0cG9pbnRzWzBdWzFdIC0gcG9pbnRzWzFdWzFdXHJcblx0XHRcdFx0KSAvIDIgKyAocmVjdC53aWR0aCAvIDIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaXNQb3NpdGl2ZSA/IC13IC0gMyA6IHcgKyAyO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGggPSAoXHJcblx0XHRcdFx0XHRpc1Bvc2l0aXZlID9cclxuXHRcdFx0XHRcdFx0cG9pbnRzWzBdWzFdIC0gcG9pbnRzWzFdWzFdIDpcclxuXHRcdFx0XHRcdFx0cG9pbnRzWzFdWzFdIC0gcG9pbnRzWzBdWzFdXHJcblx0XHRcdFx0KSAvIDIgKyAocmVjdC5oZWlnaHQgLyAyKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGlzUG9zaXRpdmUgPyBoIDogLWggLSAyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEubGFiZWxzLnBvc2l0aW9uIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIERhdGEgaWQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB4IHwgeVxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gUG9zaXRpb24gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRleHRQb3MoaWQsIHR5cGUpIHtcclxuXHRcdGNvbnN0IHBvcyA9IHRoaXMuY29uZmlnLmRhdGFfbGFiZWxzX3Bvc2l0aW9uO1xyXG5cclxuXHRcdHJldHVybiAoaWQgaW4gcG9zID8gcG9zW2lkXSA6IHBvcylbdHlwZV0gfHwgMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB4IGNvb3JkaW5hdGVcclxuXHQgKi9cclxuXHRnZXRYRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgeFBvcztcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyA9ICQkLmlzQmFyVHlwZShkKSA/IDQgOiA2O1xyXG5cdFx0XHR4UG9zID0gcG9pbnRzWzJdWzFdICsgcGFkZGluZyAqIChkLnZhbHVlIDwgMCA/IC0xIDogMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4UG9zID0gJCQuaGFzVHlwZShcImJhclwiKSA/IChwb2ludHNbMl1bMF0gKyBwb2ludHNbMF1bMF0pIC8gMiA6IHBvaW50c1swXVswXTtcclxuXHRcdH1cclxuXHRcdC8vIHNob3cgbGFiZWxzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRvbWFpbiBpZiB2YWx1ZSBpcyBudWxsXHJcblx0XHRpZiAoZC52YWx1ZSA9PT0gbnVsbCkge1xyXG5cdFx0XHRpZiAoeFBvcyA+IHN0YXRlLndpZHRoKSB7XHJcblx0XHRcdFx0Y29uc3Qge3dpZHRofSA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCk7XHJcblxyXG5cdFx0XHRcdHhQb3MgPSBzdGF0ZS53aWR0aCAtIHdpZHRoO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHhQb3MgPCAwKSB7XHJcblx0XHRcdFx0eFBvcyA9IDQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHhQb3MgKz0gJCQuZ2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4UG9zICsgJCQuZ2V0VGV4dFBvcyhkLmlkLCBcInhcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRzXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcblx0ICogQHJldHVybnMge051bWJlcn0geSBjb29yZGluYXRlXHJcblx0ICovXHJcblx0Z2V0WUZvclRleHQocG9pbnRzLCBkLCB0ZXh0RWxlbWVudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgciA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0Y29uc3QgcmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCk7XHJcblx0XHRsZXQgYmFzZVkgPSAzO1xyXG5cdFx0bGV0IHlQb3M7XHJcblxyXG5cdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHR5UG9zID0gKHBvaW50c1swXVswXSArIHBvaW50c1syXVswXSArIHJlY3QuaGVpZ2h0ICogMC42KSAvIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR5UG9zID0gcG9pbnRzWzJdWzFdO1xyXG5cclxuXHRcdFx0aWYgKGlzTnVtYmVyKHIpICYmIHIgPiA1ICYmICgkJC5pc0xpbmVUeXBlKGQpIHx8ICQkLmlzU2NhdHRlclR5cGUoZCkpKSB7XHJcblx0XHRcdFx0YmFzZVkgKz0gY29uZmlnLnBvaW50X3IgLyAyLjM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkLnZhbHVlIDwgMCB8fCAoZC52YWx1ZSA9PT0gMCAmJiAhc3RhdGUuaGFzUG9zaXRpdmVWYWx1ZSAmJiBzdGF0ZS5oYXNOZWdhdGl2ZVZhbHVlKSkge1xyXG5cdFx0XHRcdHlQb3MgKz0gcmVjdC5oZWlnaHQgKyAoJCQuaXNCYXJUeXBlKGQpID8gLWJhc2VZIDogYmFzZVkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBkaWZmID0gLWJhc2VZICogMjtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmlzQmFyVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0ZGlmZiA9IC1iYXNlWTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0ZGlmZiA9IGJhc2VZO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0eVBvcyArPSBkaWZmO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcclxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsICYmICFpc1JvdGF0ZWQpIHtcclxuXHRcdFx0Y29uc3QgYm94SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoeVBvcyA8IGJveEhlaWdodCkge1xyXG5cdFx0XHRcdHlQb3MgPSBib3hIZWlnaHQ7XHJcblx0XHRcdH0gZWxzZSBpZiAoeVBvcyA+IHRoaXMuaGVpZ2h0KSB7XHJcblx0XHRcdFx0eVBvcyA9IHRoaXMuaGVpZ2h0IC0gNDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNSb3RhdGVkKSB7XHJcblx0XHRcdHlQb3MgKz0gJCQuZ2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB5UG9zICsgJCQuZ2V0VGV4dFBvcyhkLmlkLCBcInlcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlIGlmIHR3byBvciBtb3JlIHRleHQgbm9kZXMgYXJlIG92ZXJsYXBwaW5nXHJcblx0ICogTWFyayBvdmVybGFwcGluZyB0ZXh0IG5vZGVzIHdpdGggXCJ0ZXh0LW92ZXJsYXBwaW5nXCIgY2xhc3NcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZFxyXG5cdCAqIEBwYXJhbSB7Q2hhcnRJbnRlcm5hbH0gJCRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcclxuXHQgKi9cclxuXHRtYXJrT3ZlcmxhcHBlZChpZCwgJCQsIHNlbGVjdG9yKSB7XHJcblx0XHRjb25zdCB0ZXh0Tm9kZXMgPSAkJC4kZWwuYXJjcy5zZWxlY3RBbGwoc2VsZWN0b3IpO1xyXG5cdFx0Y29uc3QgZmlsdGVyZWRUZXh0Tm9kZXMgPSB0ZXh0Tm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5kYXRhLmlkICE9PSBpZCk7XHJcblx0XHRjb25zdCB0ZXh0Tm9kZSA9IHRleHROb2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmRhdGEuaWQgPT09IGlkKTtcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZSA9IGdldFRyYW5zbGF0aW9uKHRleHROb2RlLm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoZSBoeXBvdGVudXNlXHJcblx0XHRjb25zdCBjYWxjSHlwbyA9ICh4LCB5KSA9PiBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSk7XHJcblxyXG5cdFx0dGV4dE5vZGUubm9kZSgpICYmIGZpbHRlcmVkVGV4dE5vZGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGNvb3JkaW5hdGUgPSBnZXRUcmFuc2xhdGlvbih0aGlzKTtcclxuXHRcdFx0Y29uc3QgZmlsdGVyZWRUZXh0Tm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRjb25zdCBub2RlRm9yV2lkdGggPSBjYWxjSHlwbyh0cmFuc2xhdGUuZSwgdHJhbnNsYXRlLmYpID4gY2FsY0h5cG8oY29vcmRpbmF0ZS5lLCBjb29yZGluYXRlLmYpID9cclxuXHRcdFx0XHR0ZXh0Tm9kZSA6IGZpbHRlcmVkVGV4dE5vZGU7XHJcblxyXG5cdFx0XHRjb25zdCBvdmVybGFwc1ggPSBNYXRoLmNlaWwoTWF0aC5hYnModHJhbnNsYXRlLmUgLSBjb29yZGluYXRlLmUpKSA8XHJcblx0XHRcdFx0TWF0aC5jZWlsKG5vZGVGb3JXaWR0aC5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkpO1xyXG5cdFx0XHRjb25zdCBvdmVybGFwc1kgPSBNYXRoLmNlaWwoTWF0aC5hYnModHJhbnNsYXRlLmYgLSBjb29yZGluYXRlLmYpKSA8XHJcblx0XHRcdFx0cGFyc2VJbnQodGV4dE5vZGUuc3R5bGUoXCJmb250LXNpemVcIiksIDApO1xyXG5cclxuXHRcdFx0ZmlsdGVyZWRUZXh0Tm9kZS5jbGFzc2VkKENMQVNTLlRleHRPdmVybGFwcGluZywgb3ZlcmxhcHNYICYmIG92ZXJsYXBzWSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgaWYgdHdvIG9yIG1vcmUgdGV4dCBub2RlcyBhcmUgb3ZlcmxhcHBpbmdcclxuXHQgKiBSZW1vdmUgXCJ0ZXh0LW92ZXJsYXBwaW5nXCIgY2xhc3Mgb24gc2VsZWN0ZWQgdGV4dCBub2Rlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtDaGFydEludGVybmFsfSAkJFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxyXG5cdCAqL1xyXG5cdHVuZG9NYXJrT3ZlcmxhcHBlZCgkJCwgc2VsZWN0b3IpIHtcclxuXHRcdCQkLiRlbC5hcmNzLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0ZDNTZWxlY3RBbGwoW3RoaXMsIHRoaXMucHJldmlvdXNTaWJsaW5nXSlcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLlRleHRPdmVybGFwcGluZywgZmFsc2UpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc051bWJlciwgc2V0VGV4dFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdGV4dCBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zIHJpZ2h0LCBsZWZ0IG9yIGNlbnRlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggY2hhcnQgd2lkdGhcclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn0gdGV4dC1hbmNob3IgdmFsdWUgb3IgcG9zaXRpb24gaW4gcGl4ZWxcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFRleHRQb3MocG9zID0gXCJsZWZ0XCIsIHdpZHRoPzogbnVtYmVyKSB7XHJcblx0Y29uc3QgaXNOdW0gPSBpc051bWJlcih3aWR0aCk7XHJcblx0bGV0IHBvc2l0aW9uO1xyXG5cclxuXHRpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikgPiAtMSkge1xyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IHdpZHRoIC8gMiA6IFwibWlkZGxlXCI7XHJcblx0fSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpID4gLTEpIHtcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyB3aWR0aCA6IFwiZW5kXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyAwIDogXCJzdGFydFwiO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvc2l0aW9uO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy50aXRsZV90ZXh0KSB7XHJcblx0XHRcdCRlbC50aXRsZSA9ICRlbC5zdmcuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHRcdGNvbnN0IHRleHQgPSAkZWwudGl0bGVcclxuXHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIGdldFRleHRQb3MoY29uZmlnLnRpdGxlX3Bvc2l0aW9uKSlcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRpdGxlKTtcclxuXHJcblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCBjb25maWcudGl0bGVfdGV4dCwgWzAuMywgMS41XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdUaXRsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y3VycmVudFdpZHRofSwgJGVsOiB7dGl0bGV9fSA9ICQkO1xyXG5cclxuXHRcdGlmICh0aXRsZSkge1xyXG5cdFx0XHRjb25zdCB5ID0gJCQueUZvclRpdGxlLmNhbGwoJCQpO1xyXG5cclxuXHRcdFx0aWYgKC9nL2kudGVzdCh0aXRsZS5ub2RlKCkudGFnTmFtZSkpIHtcclxuXHRcdFx0XHR0aXRsZS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtnZXRUZXh0UG9zKGNvbmZpZy50aXRsZV9wb3NpdGlvbiwgY3VycmVudFdpZHRoKX0sICR7eX0pYCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGl0bGUuYXR0cihcInhcIiwgJCQueEZvclRpdGxlLmNhbGwoJCQpKS5hdHRyKFwieVwiLCB5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHggYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge051bWJlcn0geCBhdHRyaWJ1dGUgdmFsdWVcclxuXHQgKi9cclxuXHR4Rm9yVGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnRXaWR0aH19ID0gJCQ7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IGNvbmZpZy50aXRsZV9wb3NpdGlvbiB8fCBcImxlZnRcIjtcclxuXHRcdGNvbnN0IHRleHRSZWN0V2lkdGggPSAkJC5nZXRUZXh0UmVjdCgkJC4kZWwudGl0bGUsIENMQVNTLnRpdGxlKS53aWR0aDtcclxuXHRcdGxldCB4O1xyXG5cclxuXHRcdGlmICgvKHJpZ2h0fGNlbnRlcikvLnRlc3QocG9zaXRpb24pKSB7XHJcblx0XHRcdHggPSBjdXJyZW50V2lkdGggLSB0ZXh0UmVjdFdpZHRoO1xyXG5cclxuXHRcdFx0aWYgKHBvc2l0aW9uLmluZGV4T2YoXCJyaWdodFwiKSA+PSAwKSB7XHJcblx0XHRcdFx0eCA9IGN1cnJlbnRXaWR0aCAtIHRleHRSZWN0V2lkdGggLSBjb25maWcudGl0bGVfcGFkZGluZy5yaWdodDtcclxuXHRcdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pbmRleE9mKFwiY2VudGVyXCIpID49IDApIHtcclxuXHRcdFx0XHR4ID0gKGN1cnJlbnRXaWR0aCAtIHRleHRSZWN0V2lkdGgpIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHsgLy8gbGVmdFxyXG5cdFx0XHR4ID0gKGNvbmZpZy50aXRsZV9wYWRkaW5nLmxlZnQgfHwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgeSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB5IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdCAqL1xyXG5cdHlGb3JUaXRsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLnRvcCB8fCAwKSArXHJcblx0XHRcdCQkLmdldFRleHRSZWN0KCQkLiRlbC50aXRsZSwgQ0xBU1MudGl0bGUpLmhlaWdodDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGl0bGUgcGFkZGluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge051bWJlcn0gcGFkZGluZyB2YWx1ZVxyXG5cdCAqL1xyXG5cdGdldFRpdGxlUGFkZGluZygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQueUZvclRpdGxlKCkgKyAoJCQuY29uZmlnLnRpdGxlX3BhZGRpbmcuYm90dG9tIHx8IDApO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0bW91c2UgYXMgZDNNb3VzZVxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVmFsdWUsIGNhbGxGbiwgc2FuaXRpc2UsIHRwbFByb2Nlc3MsIGlzVW5kZWZpbmVkLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VG9vbHRpcCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHtiaW5kdG99ID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblxyXG5cdFx0JGVsLnRvb2x0aXAgPSBkM1NlbGVjdChiaW5kdG8pO1xyXG5cclxuXHRcdGlmICgkZWwudG9vbHRpcC5lbXB0eSgpKSB7XHJcblx0XHRcdCRlbC50b29sdGlwID0gJGVsLmNoYXJ0XHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJkaXZcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRvb2x0aXBDb250YWluZXIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNob3cgdG9vbHRpcCBpZiBuZWVkZWRcclxuXHRcdGlmIChjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcclxuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpICYmIGlzU3RyaW5nKGNvbmZpZy50b29sdGlwX2luaXRfeCkpIHtcclxuXHRcdFx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzWzBdO1xyXG5cdFx0XHRcdGxldCBpO1xyXG5cdFx0XHRcdGxldCB2YWw7XHJcblxyXG5cdFx0XHRcdGNvbmZpZy50b29sdGlwX2luaXRfeCA9IHBhcnNlRGF0ZS5jYWxsKCQkLCBjb25maWcudG9vbHRpcF9pbml0X3gpO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgPSAwOyAodmFsID0gdGFyZ2V0cy52YWx1ZXNbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICgodmFsLnggLSBjb25maWcudG9vbHRpcF9pbml0X3gpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uZmlnLnRvb2x0aXBfaW5pdF94ID0gaTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JGVsLnRvb2x0aXAuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcclxuXHRcdFx0XHQkJC5kYXRhLnRhcmdldHMubWFwKGQgPT4gJCQuYWRkTmFtZShkLnZhbHVlc1tjb25maWcudG9vbHRpcF9pbml0X3hdKSksXHJcblx0XHRcdFx0JCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSxcclxuXHRcdFx0XHQkJC5nZXRZRm9ybWF0KCQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pKSxcclxuXHRcdFx0XHQkJC5jb2xvclxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRcdGlmICghYmluZHRvKSB7XHJcblx0XHRcdFx0JGVsLnRvb2x0aXAuc3R5bGUoXCJ0b3BcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi50b3ApXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGNvbmZpZy50b29sdGlwX2luaXRfcG9zaXRpb24ubGVmdClcclxuXHRcdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdG9vbHRpcCBIVE1MIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBGb3JtYXR0ZWQgSFRNTCBzdHJpbmdcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwSFRNTCguLi5hcmdzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKSA/XHJcblx0XHRcdGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmQoJCQuYXBpKSguLi5hcmdzKSA6ICQkLmdldFRvb2x0aXBDb250ZW50KC4uLmFyZ3MpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRvb2x0aXAgY29udGVudChIVE1MIHN0cmluZylcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBkYXRhXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFZhbHVlRm9ybWF0IERlZmF1bHQgZm9ybWF0IGZvciBlYWNoIGRhdGEgdmFsdWUgaW4gdGhlIHRvb2x0aXAuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3IgQ29sb3IgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBodG1sXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHthcGksIGNvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRsZXQgW3RpdGxlRm9ybWF0LCBuYW1lRm9ybWF0LCB2YWx1ZUZvcm1hdF0gPSBbXCJ0aXRsZVwiLCBcIm5hbWVcIiwgXCJ2YWx1ZVwiXS5tYXAodiA9PiB7XHJcblx0XHRcdGNvbnN0IGZuID0gY29uZmlnW2B0b29sdGlwX2Zvcm1hdF8ke3Z9YF07XHJcblxyXG5cdFx0XHRyZXR1cm4gaXNGdW5jdGlvbihmbikgPyBmbi5iaW5kKGFwaSkgOiBmbjtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRpdGxlRm9ybWF0ID0gdGl0bGVGb3JtYXQgfHwgZGVmYXVsdFRpdGxlRm9ybWF0O1xyXG5cdFx0bmFtZUZvcm1hdCA9IG5hbWVGb3JtYXQgfHwgKG5hbWUgPT4gbmFtZSk7XHJcblx0XHR2YWx1ZUZvcm1hdCA9IHZhbHVlRm9ybWF0IHx8IChcclxuXHRcdFx0XHQkJC5pc1N0YWNrTm9ybWFsaXplZCgpID8gKHYsIHJhdGlvKSA9PiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JWAgOiBkZWZhdWx0VmFsdWVGb3JtYXRcclxuXHRcdFx0KTtcclxuXHJcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy50b29sdGlwX29yZGVyO1xyXG5cdFx0Y29uc3QgZ2V0Um93VmFsdWUgPSByb3cgPT4gKCQkLmF4aXMgJiYgJCQuaXNCdWJibGVaVHlwZShyb3cpID8gJCQuZ2V0QnViYmxlWkRhdGEocm93LnZhbHVlLCBcInpcIikgOiAkJC5nZXRCYXNlVmFsdWUocm93KSk7XHJcblx0XHRjb25zdCBnZXRCZ0NvbG9yID0gJCQubGV2ZWxDb2xvciA/IHJvdyA9PiAkJC5sZXZlbENvbG9yKHJvdy52YWx1ZSkgOiByb3cgPT4gY29sb3Iocm93KTtcclxuXHRcdGNvbnN0IGNvbnRlbnRzID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblx0XHRjb25zdCB0cGxTdHIgPSBjb250ZW50cy50ZW1wbGF0ZTtcclxuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKCk7XHJcblxyXG5cdFx0aWYgKG9yZGVyID09PSBudWxsICYmIGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gZm9yIHN0YWNrZWQgZGF0YSwgb3JkZXIgc2hvdWxkIGFsaWduZWQgd2l0aCB0aGUgdmlzdWFsbHkgZGlzcGxheWVkIGRhdGFcclxuXHRcdFx0Y29uc3QgaWRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cylcclxuXHRcdFx0XHQubWFwKGkyID0+IGkyLmlkKVxyXG5cdFx0XHRcdC5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRkLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdFx0XHRsZXQgdjEgPSBhID8gYS52YWx1ZSA6IG51bGw7XHJcblx0XHRcdFx0bGV0IHYyID0gYiA/IGIudmFsdWUgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAodjEgPiAwICYmIHYyID4gMCkge1xyXG5cdFx0XHRcdFx0djEgPSBhLmlkID8gaWRzLmluZGV4T2YoYS5pZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0djIgPSBiLmlkID8gaWRzLmluZGV4T2YoYi5pZCkgOiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHYxIC0gdjI7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmICgvXihhc2N8ZGVzYykkLy50ZXN0KG9yZGVyKSkge1xyXG5cdFx0XHRjb25zdCBpc0FzY2VuZGluZyA9IG9yZGVyID09PSBcImFzY1wiO1xyXG5cclxuXHRcdFx0ZC5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdjEgPSBhID8gZ2V0Um93VmFsdWUoYSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IHYyID0gYiA/IGdldFJvd1ZhbHVlKGIpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGlzQXNjZW5kaW5nID8gdjEgLSB2MiA6IHYyIC0gdjE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9yZGVyKSkge1xyXG5cdFx0XHRkLnNvcnQob3JkZXIuYmluZChhcGkpKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0cGwgPSAkJC5nZXRUb29sdGlwQ29udGVudFRlbXBsYXRlKHRwbFN0cik7XHJcblx0XHRjb25zdCBsZW4gPSBkLmxlbmd0aDtcclxuXHRcdGxldCB0ZXh0O1xyXG5cdFx0bGV0IHJvdztcclxuXHRcdGxldCBwYXJhbTtcclxuXHRcdGxldCB2YWx1ZTtcclxuXHRcdGxldCBpO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRyb3cgPSBkW2ldO1xyXG5cclxuXHRcdFx0aWYgKCFyb3cgfHwgIShnZXRSb3dWYWx1ZShyb3cpIHx8IGdldFJvd1ZhbHVlKHJvdykgPT09IDApKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpc1VuZGVmaW5lZCh0ZXh0KSkge1xyXG5cdFx0XHRcdGNvbnN0IHRpdGxlID0gc2FuaXRpc2UodGl0bGVGb3JtYXQgPyB0aXRsZUZvcm1hdChyb3cueCkgOiByb3cueCk7XHJcblxyXG5cdFx0XHRcdHRleHQgPSB0cGxQcm9jZXNzKHRwbFswXSwge1xyXG5cdFx0XHRcdFx0Q0xBU1NfVE9PTFRJUDogQ0xBU1MudG9vbHRpcCxcclxuXHRcdFx0XHRcdFRJVExFOiBpc1ZhbHVlKHRpdGxlKSA/IChcclxuXHRcdFx0XHRcdFx0dHBsU3RyID8gdGl0bGUgOiBgPHRyPjx0aCBjb2xzcGFuPVwiMlwiPiR7dGl0bGV9PC90aD48L3RyPmBcclxuXHRcdFx0XHRcdCkgOiBcIlwiXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcmFtID0gW3Jvdy5yYXRpbywgcm93LmlkLCByb3cuaW5kZXgsIGRdO1xyXG5cdFx0XHR2YWx1ZSA9IHNhbml0aXNlKHZhbHVlRm9ybWF0KGdldFJvd1ZhbHVlKHJvdyksIC4uLnBhcmFtKSk7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNBcmVhUmFuZ2VUeXBlKHJvdykpIHtcclxuXHRcdFx0XHRjb25zdCBbaGlnaCwgbG93XSA9IFtcImhpZ2hcIiwgXCJsb3dcIl0ubWFwKHYgPT4gc2FuaXRpc2UoXHJcblx0XHRcdFx0XHR2YWx1ZUZvcm1hdCgkJC5nZXRBcmVhUmFuZ2VEYXRhKHJvdywgdiksIC4uLnBhcmFtKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0XHR2YWx1ZSA9IGA8Yj5NaWQ6PC9iPiAke3ZhbHVlfSA8Yj5IaWdoOjwvYj4gJHtoaWdofSA8Yj5Mb3c6PC9iPiAke2xvd31gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRcdFx0aWYgKHJvdy5uYW1lID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBzYW5pdGlzZShuYW1lRm9ybWF0KHJvdy5uYW1lLCAuLi5wYXJhbSkpO1xyXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gZ2V0QmdDb2xvcihyb3cpO1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRWYWx1ZSA9IHtcclxuXHRcdFx0XHRcdENMQVNTX1RPT0xUSVBfTkFNRTogQ0xBU1MudG9vbHRpcE5hbWUgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChyb3cuaWQpLFxyXG5cdFx0XHRcdFx0Q09MT1I6ICh0cGxTdHIgfHwgISQkLnBhdHRlcm5zKSA/IGNvbG9yIDogYDxzdmc+PHJlY3Qgc3R5bGU9XCJmaWxsOiR7Y29sb3J9XCIgd2lkdGg9XCIxMFwiIGhlaWdodD1cIjEwXCI+PC9yZWN0Pjwvc3ZnPmAsXHJcblx0XHRcdFx0XHROQU1FOiBuYW1lLFxyXG5cdFx0XHRcdFx0VkFMVUU6IHZhbHVlXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0aWYgKHRwbFN0ciAmJiBpc09iamVjdChjb250ZW50cy50ZXh0KSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSB0YXJnZXRJZHMuaW5kZXhPZihyb3cuaWQpO1xyXG5cclxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKGNvbnRlbnRzLnRleHQpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRcdFx0Y29udGVudFZhbHVlW2tleV0gPSBjb250ZW50cy50ZXh0W2tleV1baW5kZXhdO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0ICs9IHRwbFByb2Nlc3ModHBsWzFdLCBjb250ZW50VmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGAke3RleHR9PC90YWJsZT5gO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY29udGVudCB0ZW1wbGF0ZSBzdHJpbmdcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHBsU3RyXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUZW1wbGF0ZSBzdHJpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUodHBsU3RyKSB7XHJcblx0XHRyZXR1cm4gKHRwbFN0ciB8fCBgPHRhYmxlIGNsYXNzPVwiez1DTEFTU19UT09MVElQfVwiPjx0Ym9keT5cclxuXHRcdFx0XHR7PVRJVExFfVxyXG5cdFx0XHRcdHt7PHRyIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+XHJcblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJuYW1lXCI+JHt0aGlzLnBhdHRlcm5zID8gYHs9Q09MT1J9YCA6IGA8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ez1DT0xPUn1cIj48L3NwYW4+YH17PU5BTUV9PC90ZD5cclxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cInZhbHVlXCI+ez1WQUxVRX08L3RkPlxyXG5cdFx0XHRcdDwvdHI+fX1cclxuXHRcdFx0PC90Ym9keT48L3RhYmxlPmApXHJcblx0XHRcdC5yZXBsYWNlKC8oXFxyP1xcbnxcXHQpL2csIFwiXCIpXHJcblx0XHRcdC5zcGxpdCgve3soLiopfX0vKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVG9TaG93IGRhdGFcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdFdpZHRoIFdpZHRoIHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0SGVpZ2h0IEhlaWdodCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcblx0ICogQHJldHVybnMge09iamVjdH0gdG9wLCBsZWZ0IHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0b29sdGlwUG9zaXRpb24oZGF0YVRvU2hvdywgdFdpZHRoLCB0SGVpZ2h0LCBlbGVtZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBjdXJyZW50V2lkdGgsIGN1cnJlbnRIZWlnaHQsIGlzTGVnZW5kUmlnaHQsIGlucHV0VHlwZX0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcclxuXHRcdGNvbnN0IHN2Z0xlZnQgPSAkJC5nZXRTdmdMZWZ0KHRydWUpO1xyXG5cdFx0bGV0IFtsZWZ0LCB0b3BdID0gZDNNb3VzZShlbGVtZW50KTtcclxuXHRcdGxldCBjaGFydFJpZ2h0ID0gc3ZnTGVmdCArIGN1cnJlbnRXaWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKTtcclxuXHJcblx0XHR0b3AgKz0gMjA7XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIHRvb2x0aXAgcG9zaXRpb25cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0Y29uc3QgcmF3ID0gaW5wdXRUeXBlID09PSBcInRvdWNoXCIgfHwgJCQuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdFx0aWYgKCFyYXcpIHtcclxuXHRcdFx0XHR0b3AgKz0gaGFzR2F1Z2UgPyBoZWlnaHQgOiBoZWlnaHQgLyAyO1xyXG5cdFx0XHRcdGxlZnQgKz0gKHdpZHRoIC0gKGlzTGVnZW5kUmlnaHQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCkpIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZGF0YVNjYWxlID0gc2NhbGUueChkYXRhVG9TaG93WzBdLngpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0XHR0b3AgPSBkYXRhU2NhbGUgKyAyMDtcclxuXHRcdFx0XHRsZWZ0ICs9IHN2Z0xlZnQgKyAxMDA7XHJcblx0XHRcdFx0Y2hhcnRSaWdodCAtPSBzdmdMZWZ0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRvcCAtPSA1O1xyXG5cdFx0XHRcdGxlZnQgPSBzdmdMZWZ0ICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHRydWUpICsgMjAgKyAoc2NhbGUuem9vbSA/IGxlZnQgOiBkYXRhU2NhbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcmlnaHQgPSBsZWZ0ICsgdFdpZHRoO1xyXG5cclxuXHRcdGlmIChyaWdodCA+IGNoYXJ0UmlnaHQpIHtcclxuXHRcdFx0Ly8gMjAgaXMgbmVlZGVkIGZvciBGaXJlZm94IHRvIGtlZXAgdG9vbHRpcCB3aWR0aFxyXG5cdFx0XHRsZWZ0IC09IHJpZ2h0IC0gY2hhcnRSaWdodCArIDIwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0b3AgKyB0SGVpZ2h0ID4gY3VycmVudEhlaWdodCkge1xyXG5cdFx0XHR0b3AgLT0gaGFzR2F1Z2UgPyB0SGVpZ2h0ICogMyA6IHRIZWlnaHQgKyAzMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodG9wIDwgMCkge1xyXG5cdFx0XHR0b3AgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7dG9wLCBsZWZ0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IHRoZSB0b29sdGlwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWREYXRhXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG5cdCAqL1xyXG5cdHNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgZWxlbWVudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3Rvb2x0aXB9fSA9ICQkO1xyXG5cdFx0Y29uc3Qge2JpbmR0b30gPSBjb25maWcudG9vbHRpcF9jb250ZW50cztcclxuXHRcdGNvbnN0IGZvckFyYyA9ICQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pO1xyXG5cdFx0Y29uc3QgZGF0YVRvU2hvdyA9IHNlbGVjdGVkRGF0YS5maWx0ZXIoZCA9PiBkICYmIGlzVmFsdWUoJCQuZ2V0QmFzZVZhbHVlKGQpKSk7XHJcblxyXG5cdFx0aWYgKGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICFjb25maWcudG9vbHRpcF9zaG93KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXR1bSA9IHRvb2x0aXAuZGF0dW0oKTtcclxuXHRcdGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShzZWxlY3RlZERhdGEpO1xyXG5cdFx0bGV0IHt3aWR0aCA9IDAsIGhlaWdodCA9IDB9ID0gZGF0dW0gfHwge307XHJcblxyXG5cdFx0aWYgKCFkYXR1bSB8fCBkYXR1bS5jdXJyZW50ICE9PSBkYXRhU3RyKSB7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gc2VsZWN0ZWREYXRhLmNvbmNhdCgpLnNvcnQoKVswXS5pbmRleDtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3csICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdC8vIHNldCB0b29sdGlwIGNvbnRlbnRcclxuXHRcdFx0dG9vbHRpcFxyXG5cdFx0XHRcdC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxyXG5cdFx0XHRcdFx0c2VsZWN0ZWREYXRhLFxyXG5cdFx0XHRcdFx0JCQuYXhpcyAmJiAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLFxyXG5cdFx0XHRcdFx0JCQuZ2V0WUZvcm1hdChmb3JBcmMpLFxyXG5cdFx0XHRcdFx0JCQuY29sb3JcclxuXHRcdFx0XHQpKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIG51bGwpIC8vIGZvciBJRTlcclxuXHRcdFx0XHQuZGF0dW0oe1xyXG5cdFx0XHRcdFx0aW5kZXgsXHJcblx0XHRcdFx0XHRjdXJyZW50OiBkYXRhU3RyLFxyXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoID0gdG9vbHRpcC5wcm9wZXJ0eShcIm9mZnNldFdpZHRoXCIpLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQgPSB0b29sdGlwLnByb3BlcnR5KFwib2Zmc2V0SGVpZ2h0XCIpXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25zaG93biwgJCQuYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKHRydWUsIGluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWJpbmR0bykge1xyXG5cdFx0XHRsZXQgZm4gPSBjb25maWcudG9vbHRpcF9wb3NpdGlvbjtcclxuXHRcdFx0bGV0IHVuaXQ7XHJcblxyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuXHRcdFx0XHRmbiA9IGZuLmJpbmQoJCQuYXBpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1bml0ID0gZm4gJiYgZm4udW5pdDtcclxuXHRcdFx0XHRmbiA9ICQkLnRvb2x0aXBQb3NpdGlvbi5iaW5kKCQkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gR2V0IHRvb2x0aXAgZGltZW5zaW9uc1xyXG5cdFx0XHRjb25zdCBwb3MgPSBmbihkYXRhVG9TaG93LCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KTtcclxuXHJcblx0XHRcdFtcInRvcFwiLCBcImxlZnRcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRsZXQgdmFsdWUgPSBwb3Nbdl07XHJcblxyXG5cdFx0XHRcdC8vIHdoZW4gdmFsdWUgaXMgbnVtYmVyXHJcblx0XHRcdFx0aWYgKC9eXFxkKyhcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSkge1xyXG5cdFx0XHRcdFx0aWYgKHVuaXQgPT09IFwiJVwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBzdGF0ZVt2ID09PSBcInRvcFwiID8gXCJjdXJyZW50SGVpZ2h0XCIgOiBcImN1cnJlbnRXaWR0aFwiXTtcclxuXHJcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUgLyBzaXplICogMTAwO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dW5pdCA9IFwicHhcIjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR2YWx1ZSArPSB1bml0O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZSh2LCB2YWx1ZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdGhlIHRvb2x0aXBcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHRvIGhpZGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhpZGVUb29sdGlwKGZvcmNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHt0b29sdGlwfX0gPSAkJDtcclxuXHJcblx0XHRpZiAodG9vbHRpcC5zdHlsZShcImRpc3BsYXlcIikgIT09IFwibm9uZVwiICYmICghY29uZmlnLnRvb2x0aXBfZG9Ob3RIaWRlIHx8IGZvcmNlKSkge1xyXG5cdFx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSBKU09OLnBhcnNlKHRvb2x0aXAuZGF0dW0oKS5jdXJyZW50KTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbmhpZGUsICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdC8vIGhpZGUgdG9vbHRpcFxyXG5cdFx0XHR0b29sdGlwXHJcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpIC8vIGZvciBJRTlcclxuXHRcdFx0XHQuZGF0dW0obnVsbCk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRkZW4sICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGUgZGlzcGxheSBmb3IgbGlua2VkIGNoYXJ0IGluc3RhbmNlc1xyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdyB0cnVlOiBzaG93LCBmYWxzZTogaGlkZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCB4IEF4aXMgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9oYW5kbGVMaW5rZWRDaGFydHMoc2hvdywgaW5kZXgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjaGFydHMsIGNvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLnRvb2x0aXBfbGlua2VkICYmIGNoYXJ0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGNvbnN0IGxpbmtlZE5hbWUgPSBjb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcclxuXHJcblx0XHRcdGNoYXJ0cy5mb3JFYWNoKGMgPT4ge1xyXG5cdFx0XHRcdGlmIChjICE9PSAkJC5hcGkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHtjb25maWd9ID0gYy5pbnRlcm5hbDtcclxuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNJbkRvbSA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMoYy5lbGVtZW50KTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNMaW5rZWQgJiYgbGlua2VkTmFtZSA9PT0gbmFtZSAmJiBpc0luRG9tKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjLmludGVybmFsLiRlbC50b29sdGlwLmRhdGEoKVswXTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgaXNOb3RTYW1lSW5kZXggPSBpbmRleCAhPT0gKGRhdGEgJiYgZGF0YS5pbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IHRocm93aW5nIGVycm9yIGZvciBub24tcGFpcmVkIGxpbmtlZCBpbmRleGVzXHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHNob3cgJiYgaXNOb3RTYW1lSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5zaG93KHtpbmRleH0pO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHthc0hhbGZQaXhlbH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0VHJhbnNsYXRlKHRhcmdldCwgaW5kZXggPSAwKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHRcdGxldCBwYWRkaW5nID0gMDtcclxuXHRcdGxldCB4O1xyXG5cdFx0bGV0IHk7XHJcblxyXG5cdFx0aWYgKGluZGV4ICYmIC9eKHh8eTI/KSQvLnRlc3QodGFyZ2V0KSkge1xyXG5cdFx0XHRwYWRkaW5nID0gJCQuZ2V0QXhpc1NpemUodGFyZ2V0KSAqIGluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0YXJnZXQgPT09IFwibWFpblwiKSB7XHJcblx0XHRcdHggPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4ubGVmdCk7XHJcblx0XHRcdHkgPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4udG9wKTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcImNvbnRleHRcIikge1xyXG5cdFx0XHR4ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luMi5sZWZ0KTtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbjIudG9wKTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcImxlZ2VuZFwiKSB7XHJcblx0XHRcdHggPSBzdGF0ZS5tYXJnaW4zLmxlZnQ7XHJcblx0XHRcdHkgPSBzdGF0ZS5tYXJnaW4zLnRvcCArIChoYXNHYXVnZSA/IDEwIDogMCk7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IC1wYWRkaW5nIDogMDtcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiBzdGF0ZS5oZWlnaHQgKyBwYWRkaW5nO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieVwiKSB7XHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogLXBhZGRpbmc7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyBzdGF0ZS5oZWlnaHQgKyBwYWRkaW5nIDogMDtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInkyXCIpIHtcclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiBzdGF0ZS53aWR0aCArIHBhZGRpbmc7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAxIC0gcGFkZGluZyA6IDA7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJzdWJYXCIpIHtcclxuXHRcdFx0eCA9IDA7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAwIDogc3RhdGUuaGVpZ2h0MjtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcImFyY1wiKSB7XHJcblx0XHRcdHggPSBzdGF0ZS5hcmNXaWR0aCAvIDI7XHJcblx0XHRcdHkgPSBzdGF0ZS5hcmNIZWlnaHQgLyAyO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwicmFkYXJcIikge1xyXG5cdFx0XHRjb25zdCBbd2lkdGhdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblxyXG5cdFx0XHR4ID0gc3RhdGUud2lkdGggLyAyIC0gd2lkdGg7XHJcblx0XHRcdHkgPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4udG9wKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KWA7XHJcblx0fSxcclxuXHJcblx0dHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGxldCB4QXhpcztcclxuXHRcdGxldCB5QXhpcztcclxuXHRcdGxldCB5MkF4aXM7XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNYKSB7XHJcblx0XHRcdHhBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1g7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4QXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKTtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdHhBeGlzID0geEF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZKSB7XHJcblx0XHRcdHlBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1k7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR5QXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWX1gKTtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdHlBeGlzID0geUF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZMikge1xyXG5cdFx0XHR5MkF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR5MkF4aXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1kyfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eTJBeGlzID0geTJBeGlzLnRyYW5zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IG1haW4udHJhbnNpdGlvbigpIDogbWFpbilcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibWFpblwiKSk7XHJcblxyXG5cdFx0eEF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ4XCIpKTtcclxuXHRcdHlBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieVwiKSk7XHJcblx0XHR5MkF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5MlwiKSk7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc31gKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJhcmNcIikpO1xyXG5cdH0sXHJcblxyXG5cdHRyYW5zZm9ybUFsbCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHQkJC50cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyk7XHJcblxyXG5cdFx0JCQuaGFzQXhpcyAmJiBjb25maWcuc3ViY2hhcnRfc2hvdyAmJlxyXG5cdFx0XHQkJC50cmFuc2Zvcm1Db250ZXh0KHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyk7XHJcblxyXG5cdFx0JGVsLmxlZ2VuZCAmJiAkJC50cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5cclxuLy8gZGVmaW5lZCBjaGFydCB0eXBlcyBhcyBjYXRlZ29yeVxyXG5leHBvcnQgY29uc3QgVFlQRVMgPSB7XHJcblx0QXJlYTogW1wiYXJlYVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIiwgXCJhcmVhLWxpbmUtcmFuZ2VcIiwgXCJhcmVhLXN0ZXBcIl0sXHJcblx0QXJlYVJhbmdlOiBbXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiXSxcclxuXHRBcmM6IFtcInBpZVwiLCBcImRvbnV0XCIsIFwiZ2F1Z2VcIiwgXCJyYWRhclwiXSxcclxuXHRMaW5lOiBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwiYXJlYVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIiwgXCJhcmVhLWxpbmUtcmFuZ2VcIiwgXCJzdGVwXCIsIFwiYXJlYS1zdGVwXCJdLFxyXG5cdFN0ZXA6IFtcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXHJcblx0U3BsaW5lOiBbXCJzcGxpbmVcIiwgXCJhcmVhLXNwbGluZVwiLCBcImFyZWEtc3BsaW5lLXJhbmdlXCJdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1N0cmluZywgaXNBcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7VFlQRVN9IGZyb20gXCIuLi8uLi9jb25maWcvY29uc3RcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRzZXRUYXJnZXRUeXBlKHRhcmdldElkcywgdHlwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aXRob3V0RmFkZUlufX0gPSAkJDtcclxuXHJcblx0XHQkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHR3aXRob3V0RmFkZUluW2lkXSA9ICh0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0pO1xyXG5cdFx0XHRjb25maWcuZGF0YV90eXBlc1tpZF0gPSB0eXBlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZSA9IHR5cGU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aGFzVHlwZSh0eXBlLCB0YXJnZXRzVmFsdWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0eXBlcyA9IGNvbmZpZy5kYXRhX3R5cGVzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHRhcmdldHNWYWx1ZSB8fCAkJC5kYXRhLnRhcmdldHM7XHJcblx0XHRsZXQgaGFzID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdCA9IHR5cGVzW3RhcmdldC5pZF07XHJcblxyXG5cdFx0XHRcdGlmICgodCAmJiB0LmluZGV4T2YodHlwZSkgPj0gMCkgfHwgKCF0ICYmIHR5cGUgPT09IFwibGluZVwiKSkge1xyXG5cdFx0XHRcdFx0aGFzID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChPYmplY3Qua2V5cyh0eXBlcykubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0XHRpZiAodHlwZXNbaWRdID09PSB0eXBlKSB7XHJcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoYXMgPSBjb25maWcuZGF0YV90eXBlID09PSB0eXBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoYXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgZ2l2ZW4gY2hhcnQgdHlwZXNcclxuXHQgKiBAcGFybWEge1N0cmluZ30gdHlwZSBUeXBlIGtleVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNUeXBlT2YodHlwZSwgdGFyZ2V0cywgZXhjbHVkZSA9IFtdKSB7XHJcblx0XHRyZXR1cm4gIVRZUEVTW3R5cGVdXHJcblx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0LmZpbHRlcih2ID0+IGV4Y2x1ZGUuaW5kZXhPZih2KSA9PT0gLTEpXHJcblx0XHRcdC5ldmVyeSh2ID0+ICF0aGlzLmhhc1R5cGUodiwgdGFyZ2V0cykpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGdpdmVuIGRhdGEgaXMgY2VydGFpbiBjaGFydCB0eXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdHlwZSBjaGFydCB0eXBlXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGlzVHlwZU9mKGQsIHR5cGUpIHtcclxuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcclxuXHRcdGNvbnN0IGRhdGFUeXBlID0gdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkodHlwZSkgP1xyXG5cdFx0XHR0eXBlLmluZGV4T2YoZGF0YVR5cGUpID49IDAgOiBkYXRhVHlwZSA9PT0gdHlwZTtcclxuXHR9LFxyXG5cclxuXHRoYXNQb2ludFR5cGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmhhc1R5cGVPZihcIkxpbmVcIikgfHwgJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNUeXBlKFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBjb250YWlucyBhcmMgdHlwZXMgY2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0c1xyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGV4Y2x1ZGUgRXhjbHVkZWQgdHlwZXNcclxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGFzQXJjVHlwZSh0YXJnZXRzLCBleGNsdWRlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNUeXBlT2YoXCJBcmNcIiwgdGFyZ2V0cywgZXhjbHVkZSk7XHJcblx0fSxcclxuXHJcblx0aGFzTXVsdGlBcmNHYXVnZSgpIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiB0aGlzLmNvbmZpZy5nYXVnZV90eXBlID09PSBcIm11bHRpXCI7XHJcblx0fSxcclxuXHJcblx0aXNMaW5lVHlwZShkKSB7XHJcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XHJcblxyXG5cdFx0cmV0dXJuICF0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXSB8fFxyXG5cdFx0XHR0aGlzLmlzVHlwZU9mKGlkLCBUWVBFUy5MaW5lKTtcclxuXHR9LFxyXG5cclxuXHRpc1N0ZXBUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlN0ZXApO1xyXG5cdH0sXHJcblxyXG5cdGlzU3BsaW5lVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5TcGxpbmUpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJlYVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuQXJlYSk7XHJcblx0fSxcclxuXHJcblx0aXNBcmVhUmFuZ2VUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLkFyZWFSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0aXNCYXJUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYmFyXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzQnViYmxlVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJ1YmJsZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1NjYXR0ZXJUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1BpZVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJwaWVcIik7XHJcblx0fSxcclxuXHJcblx0aXNHYXVnZVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJnYXVnZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0RvbnV0VHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImRvbnV0XCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmFkYXJUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicmFkYXJcIik7XHJcblx0fSxcclxuXHJcblx0aXNBcmNUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzUGllVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzRG9udXRUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNHYXVnZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXRlcm1pbmUgaWYgaXMgJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGlzQ2lyY2xlUG9pbnQoKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBwYXR0ZXJuID0gY29uZmlnLnBvaW50X3BhdHRlcm47XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF90eXBlID09PSBcImNpcmNsZVwiICYmXHJcblx0XHRcdCghcGF0dGVybiB8fCAoaXNBcnJheShwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMCkpO1xyXG5cdH0sXHJcblxyXG5cdGxpbmVEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzTGluZVR5cGUoZCkgPyBbZF0gOiBbXTtcclxuXHR9LFxyXG5cclxuXHRhcmNEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gW2RdIDogW107XHJcblx0fSxcclxuXHJcblx0YmFyRGF0YShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc0JhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIGFkYXB0IGZvciBkYXRhIGxhYmVsIHNob3dpbmdcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0bGFiZWxpc2hEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzTGluZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1NjYXR0ZXJUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGJhckxpbmVCdWJibGVEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fCB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc0J1YmJsZVR5cGUoZCkgP1xyXG5cdFx0XHRkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZSNjdXJ2ZXNcclxuXHRpc0ludGVycG9sYXRpb25UeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0XCJiYXNpc1wiLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiLFxyXG5cdFx0XHRcImJhc2lzLW9wZW5cIixcclxuXHRcdFx0XCJidW5kbGVcIixcclxuXHRcdFx0XCJjYXJkaW5hbFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIixcclxuXHRcdFx0XCJsaW5lYXJcIixcclxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCIsXHJcblx0XHRcdFwibW9ub3RvbmUteFwiLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIixcclxuXHRcdFx0XCJuYXR1cmFsXCJcclxuXHRcdF0uaW5kZXhPZih0eXBlKSA+PSAwO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3RUeXBlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtDaGFydH0gJCRcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXHJcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldE1pbk1heCgkJCwgdHlwZTogXCJtaW5cIiB8IFwibWF4XCIsIHZhbHVlKSB7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRjb25zdCBheGlzWCA9IGBheGlzX3hfJHt0eXBlfWA7XHJcblx0Y29uc3QgYXhpc1kgPSBgYXhpc195XyR7dHlwZX1gO1xyXG5cdGNvbnN0IGF4aXNZMiA9IGBheGlzX3kyXyR7dHlwZX1gO1xyXG5cclxuXHRpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG5cdFx0aWYgKGlzT2JqZWN0VHlwZSh2YWx1ZSkpIHtcclxuXHRcdFx0aXNWYWx1ZSh2YWx1ZS54KSAmJiAoY29uZmlnW2F4aXNYXSA9IHZhbHVlLngpO1xyXG5cdFx0XHRpc1ZhbHVlKHZhbHVlLnkpICYmIChjb25maWdbYXhpc1ldID0gdmFsdWUueSk7XHJcblx0XHRcdGlzVmFsdWUodmFsdWUueTIpICYmIChjb25maWdbYXhpc1kyXSA9IHZhbHVlLnkyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbmZpZ1theGlzWV0gPSB2YWx1ZTtcclxuXHRcdFx0Y29uZmlnW2F4aXNZMl0gPSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWVcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWluL21heCB2YWx1ZVxyXG4gKiBAcGFyYW0ge0NoYXJ0fSAkJFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gKiBAcmV0dXJuIHt7eCwgeSwgeTJ9fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIik6IHt4OiBudW1iZXIsIHk6IG51bWJlciwgeTI6IG51bWJlcn0ge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiBjb25maWdbYGF4aXNfeF8ke3R5cGV9YF0sXHJcblx0XHR5OiBjb25maWdbYGF4aXNfeV8ke3R5cGV9YF0sXHJcblx0XHR5MjogY29uZmlnW2BheGlzX3kyXyR7dHlwZX1gXVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYXhpc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCBheGlzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApGxhYmVsc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYWJlbHMgc3BlY2lmaWVkIGF4aXMnIGxhYmVsIHRvIGJlIHVwZGF0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcclxuXHQgKiBjaGFydC5heGlzLmxhYmVscyh7XHJcblx0ICogICB4OiBcIk5ldyBYIEF4aXMgTGFiZWxcIixcclxuXHQgKiAgIHk6IFwiTmV3IFkgQXhpcyBMYWJlbFwiXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bGFiZWxzOiBmdW5jdGlvbihsYWJlbHM6IHt4Pzogc3RyaW5nLCB5Pzogc3RyaW5nLCB5Mj86IHN0cmluZ30pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhsYWJlbHMpLmZvckVhY2goYXhpc0lkID0+IHtcclxuXHRcdFx0XHQkJC5heGlzLnNldExhYmVsVGV4dChheGlzSWQsIGxhYmVsc1theGlzSWRdKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5heGlzLnVwZGF0ZUxhYmVscygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIHZhbHVlLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtaW4gSWYgbWluIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIHZhbHVlIHdpbGwgYmUgdXBkYXRlZC48YnI+XHJcblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWluIHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICAgICBJZiBub3Qgc2V0IGFueSBtaW4gdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gVXBkYXRlIGF4aXMnIG1pblxyXG5cdCAqIGNoYXJ0LmF4aXMubWluKHtcclxuXHQgKiAgIHg6IC0xMCxcclxuXHQgKiAgIHk6IDEwMDAsXHJcblx0ICogICB5MjogMTAwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbihtaW4/OiBudW1iZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRyZXR1cm4gaXNWYWx1ZShtaW4pID9cclxuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1pblwiLCBtaW4pIDpcclxuXHRcdFx0Z2V0TWluTWF4KCQkLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1heCB2YWx1ZS5cclxuXHQgKiBAbWV0aG9kIGF4aXPigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF4IElmIG1heCBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxyXG5cdCAqICAgICBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG1heCB2YWx1ZXMgc2V0IG9uIGdlbmVyYXRpbmcgb3B0aW9uIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWF4IHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMubWF4KHtcclxuXHQgKiAgICB4OiAxMDAsXHJcblx0ICogICAgeTogMTAwMCxcclxuXHQgKiAgICB5MjogMTAwMDBcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKG1heD86IG51bWJlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID9cclxuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1heFwiLCBtYXgpIDpcclxuXHRcdFx0Z2V0TWluTWF4KCQkLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1pbiBhbmQgbWF4IHZhbHVlLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHJhbmdlIElmIHJhbmdlIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIGFuZCBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMucmFuZ2Uoe1xyXG5cdCAqICAgbWluOiB7XHJcblx0ICogICAgIHg6IC0xMCxcclxuXHQgKiAgICAgeTogLTEwMDAsXHJcblx0ICogICAgIHkyOiAtMTAwMDBcclxuXHQgKiAgIH0sXHJcblx0ICogICBtYXg6IHtcclxuXHQgKiAgICAgeDogMTAwLFxyXG5cdCAqICAgICB5OiAxMDAwLFxyXG5cdCAqICAgICB5MjogMTAwMDBcclxuXHQgKiAgIH0sXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0cmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XHJcblx0XHRjb25zdCB7YXhpc30gPSB0aGlzO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5tYXgpICYmIGF4aXMubWF4KHJhbmdlLm1heCk7XHJcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5taW4pICYmIGF4aXMubWluKHJhbmdlLm1pbik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdG1heDogYXhpcy5tYXgoKSxcclxuXHRcdFx0XHRtaW46IGF4aXMubWluKClcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtheGlzfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHNwZWNpZmllZCBjYXRlZ29yeSBuYW1lIG9uIGNhdGVnb3J5IGF4aXMuXHJcblx0ICogQG1ldGhvZCBjYXRlZ29yeVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpIGluZGV4IG9mIGNhdGVnb3J5IHRvIGJlIGNoYW5nZWRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnkgdmFsdWUgdG8gYmUgY2hhbmdlZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcnkoMiwgXCJDYXRlZ29yeSAzXCIpO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3J5KGk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzW2ldID0gY2F0ZWdvcnk7XHJcblx0XHRcdCQkLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXHJcblx0ICogQG1ldGhvZCBjYXRlZ29yaWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gY2F0ZWdvcmllcyBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmNhdGVnb3JpZXMoW1xyXG5cdCAqICAgICAgXCJDYXRlZ29yeSAxXCIsIFwiQ2F0ZWdvcnkgMlwiLCAuLi5cclxuXHQgKiBdKTtcclxuXHQgKi9cclxuXHRjYXRlZ29yaWVzKGNhdGVnb3JpZXM6IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XHJcblx0XHQkJC5yZWRyYXcoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNUYWJWaXNpYmxlLCBpc1ZhbHVlLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEZsb3cgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBhcHBlbmQgbmV3IGRhdGEgcG9pbnRzIHRvIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIGZsb3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IGpzb24gfCBPYmplY3QgfCBEYXRhIGFzIEpTT04gZm9ybWF0IChAc2VlIFtkYXRh4oCkanNvbl0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0anNvbikpIHxcclxuXHQgKiAgICB8IHJvd3MgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgcm93IGZvcm1hdCAoQHNlZSBbZGF0YeKApHJvd3NdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGpzb24pKSB8XHJcblx0ICogICAgfCBjb2x1bW5zIHwgQXJyYXkgfCBEYXRhIGluIGFycmF5IGFzIGNvbHVtbiBmb3JtYXQgKEBzZWUgW2RhdGHigKRjb2x1bW5zXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRjb2x1bW5zKSkgfFxyXG5cdCAqICAgIHwgdG8gfCBTdHJpbmcgfCBUaGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSB0byB0aGF0IHBvaW50LiBJZiBub3QgZ2l2ZW4sIHRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgZ2l2ZW4gZGF0YSBwb2ludHMgfFxyXG5cdCAqICAgIHwgbGVuZ3RoIHwgTnVtYmVyIHwgVGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiB0aGlzIGFyZ3VtZW50IHxcclxuXHQgKiAgICB8IGR1cmF0aW9uIHwgTnVtYmVyIHwgVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgc3BlY2lmaWVkIHZhbHVlLiBJZiBub3QgZ2l2ZW4sIHRyYW5zaXRpb24uZHVyYXRpb24gd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgfFxyXG5cdCAqICAgIHwgZG9uZSB8IEZ1bmN0aW9uIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIGZsb3cgZW5kcyB8XHJcblx0ICpcclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBJZiBqc29uLCByb3dzIGFuZCBjb2x1bW5zIGdpdmVuLCB0aGUgZGF0YSB3aWxsIGJlIGxvYWRlZC5cclxuXHQgKiAgIC0gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIGFwcGVuZGVkLlxyXG5cdCAqICAgLSBPdGhlcndpc2UsIG5ldyB0YXJnZXQgd2lsbCBiZSBhZGRlZC4gT25lIG9mIHRoZXNlIGlzIHJlcXVpcmVkIHdoZW4gY2FsbGluZy5cclxuXHQgKiAgIC0gSWYganNvbiBzcGVjaWZpZWQsIGtleXMgaXMgcmVxdWlyZWQgYXMgd2VsbCBhcyBkYXRhLmpzb24uXHJcblx0ICogXHQgLSBJZiB0YWIgaXNuJ3QgdmlzaWJsZShieSBldmFsdWF0aW5nIGBkb2N1bWVudC5oaWRkZW5gKSwgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSB3b3JrLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gMiBkYXRhIHBvaW50cyB3aWxsIGJlIGFwcHJlbmRlZCB0byB0aGUgdGFpbCBhbmQgcG9wcGVkIGZyb20gdGhlIGhlYWQuXHJcblx0ICogLy8gQWZ0ZXIgdGhhdCwgNCBkYXRhIHBvaW50cyB3aWxsIGJlIGFwcGVuZGVkIGFuZCBubyBkYXRhIHBvaW50cyB3aWxsIGJlIHBvcHBvZWQuXHJcblx0ICogY2hhcnQuZmxvdyh7XHJcblx0ICogIGNvbHVtbnM6IFtcclxuXHQgKiAgICBbXCJ4XCIsIFwiMjAxOC0wMS0xMVwiLCBcIjIwMTgtMDEtMjFcIl0sXHJcblx0ICogICAgW1wiZGF0YTFcIiwgNTAwLCAyMDBdLFxyXG5cdCAqICAgIFtcImRhdGEyXCIsIDEwMCwgMzAwXSxcclxuXHQgKiAgICBbXCJkYXRhM1wiLCAyMDAsIDEyMF1cclxuXHQgKiAgXSxcclxuXHQgKiAgdG86IFwiMjAxMy0wMS0xMVwiLFxyXG5cdCAqICBkb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0ICogICAgY2hhcnQuZmxvdyh7XHJcblx0ICogICAgICBjb2x1bW5zOiBbXHJcblx0ICogICAgICAgIFtcInhcIiwgXCIyMDE4LTAyLTExXCIsIFwiMjAxOC0wMi0xMlwiLCBcIjIwMTgtMDItMTNcIiwgXCIyMDE4LTAyLTE0XCJdLFxyXG5cdCAqICAgICAgICBbXCJkYXRhMVwiLCAyMDAsIDMwMCwgMTAwLCAyNTBdLFxyXG5cdCAqICAgICAgICBbXCJkYXRhMlwiLCAxMDAsIDkwLCA0MCwgMTIwXSxcclxuXHQgKiAgICAgICAgW1wiZGF0YTNcIiwgMTAwLCAxMDAsIDMwMCwgNTAwXVxyXG5cdCAqICAgICAgXSxcclxuXHQgKiAgICAgIGxlbmd0aDogMixcclxuICAgICAqICAgICAgZHVyYXRpb246IDE1MDBcclxuXHQgKiAgICB9KTtcclxuXHQgKiAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGZsb3coYXJncykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0bGV0IGRhdGE7XHJcblx0XHRsZXQgZG9tYWluO1xyXG5cdFx0bGV0IGxlbmd0aDogbnVtYmVyID0gMDtcclxuXHRcdGxldCB0YWlsID0gMDtcclxuXHRcdGxldCBkaWZmO1xyXG5cdFx0bGV0IHRvO1xyXG5cclxuXHRcdGlmIChhcmdzLmpzb24gfHwgYXJncy5yb3dzIHx8IGFyZ3MuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gJCQuY29udmVydERhdGEoYXJncyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFkYXRhIHx8ICFpc1RhYlZpc2libGUoKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgbm90Zm91bmRJZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBvcmdEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCB0cnVlKTtcclxuXHJcblx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcclxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0LmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdKSB7XHJcblx0XHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGVuZ3RoID0gdGFyZ2V0c1tpXS52YWx1ZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0uaW5kZXggPSB0YWlsICsgajtcclxuXHJcblx0XHRcdFx0XHRcdGlmICghJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRzW2ldLnZhbHVlc1tqXS54ID0gdGFpbCArIGo7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0LnZhbHVlcyA9IHQudmFsdWVzLmNvbmNhdCh0YXJnZXRzW2ldLnZhbHVlcyk7XHJcblx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0IWZvdW5kICYmIG5vdGZvdW5kSWRzLnB1c2godC5pZCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBBcHBlbmQgbnVsbCBmb3Igbm90IGZvdW5kIHRhcmdldHNcclxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5vdGZvdW5kSWRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHQuaWQgPT09IG5vdGZvdW5kSWRzW2ldKSB7XHJcblx0XHRcdFx0XHR0YWlsID0gdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0uaW5kZXggKyAxO1xyXG5cclxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0dC52YWx1ZXMucHVzaCh7XHJcblx0XHRcdFx0XHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdFx0XHRcdFx0aW5kZXg6IHRhaWwgKyBqLFxyXG5cdFx0XHRcdFx0XHRcdHg6ICQkLmlzVGltZVNlcmllcygpID8gJCQuZ2V0T3RoZXJUYXJnZXRYKHRhaWwgKyBqKSA6IHRhaWwgKyBqLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgbnVsbCB2YWx1ZXMgZm9yIG5ldyB0YXJnZXRcclxuXHRcdGlmICgkJC5kYXRhLnRhcmdldHMubGVuZ3RoKSB7XHJcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaXNzaW5nOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlc1swXS5pbmRleDsgaSA8IHRhaWw7IGkrKykge1xyXG5cdFx0XHRcdFx0bWlzc2luZy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdFx0XHRcdGluZGV4OiBpLFxyXG5cdFx0XHRcdFx0XHR4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WChpKSA6IGksXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHR2LmluZGV4ICs9IHRhaWw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCEkJC5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHRcdFx0XHR2LnggKz0gdGFpbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dC52YWx1ZXMgPSBtaXNzaW5nLmNvbmNhdCh0LnZhbHVlcyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5jb25jYXQodGFyZ2V0cyk7IC8vIGFkZCByZW1haW5lZFxyXG5cclxuXHRcdC8vIGNoZWNrIGRhdGEgY291bnQgYmVjYXVzZSBiZWhhdmlvciBuZWVkcyB0byBjaGFuZ2Ugd2hlbiBpdFwicyBvbmx5IG9uZVxyXG5cdFx0Ly8gY29uc3QgZGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XHJcblx0XHRjb25zdCBiYXNlVGFyZ2V0ID0gJCQuZGF0YS50YXJnZXRzWzBdO1xyXG5cdFx0Y29uc3QgYmFzZVZhbHVlID0gYmFzZVRhcmdldC52YWx1ZXNbMF07XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGxlbmd0aCB0byBmbG93IGlmIG5lZWRlZFxyXG5cdFx0aWYgKGlzRGVmaW5lZChhcmdzLnRvKSkge1xyXG5cdFx0XHRsZW5ndGggPSAwO1xyXG5cdFx0XHR0byA9ICQkLmlzVGltZVNlcmllcygpID8gcGFyc2VEYXRlLmNhbGwoJCQsIGFyZ3MudG8pIDogYXJncy50bztcclxuXHJcblx0XHRcdGJhc2VUYXJnZXQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0di54IDwgdG8gJiYgbGVuZ3RoKys7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5sZW5ndGgpKSB7XHJcblx0XHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIG9ubHkgb25lIGRhdGEsIHVwZGF0ZSB0aGUgZG9tYWluIHRvIGZsb3cgZnJvbSBsZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0XHJcblx0XHRpZiAoIW9yZ0RhdGFDb3VudCkge1xyXG5cdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRkaWZmID0gYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoID4gMSA/XHJcblx0XHRcdFx0XHRiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLnggOlxyXG5cdFx0XHRcdFx0YmFzZVZhbHVlLnggLSAkJC5nZXRYRG9tYWluKCQkLmRhdGEudGFyZ2V0cylbMF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGlmZiA9IDE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRvbWFpbiA9IFtiYXNlVmFsdWUueCAtIGRpZmYsIGJhc2VWYWx1ZS54XTtcclxuXHRcdH0gZWxzZSBpZiAob3JnRGF0YUNvdW50ID09PSAxICYmICQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGRpZmYgPSAoYmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54KSAvIDI7XHJcblx0XHRcdGRvbWFpbiA9IFtuZXcgRGF0ZSgrYmFzZVZhbHVlLnggLSBkaWZmKSwgbmV3IERhdGUoK2Jhc2VWYWx1ZS54ICsgZGlmZildO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRvbWFpbiAmJiAkJC51cGRhdGVYRG9tYWluKG51bGwsIHRydWUsIHRydWUsIGZhbHNlLCBkb21haW4pO1xyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdGZsb3c6IHtcclxuXHRcdFx0XHRpbmRleDogYmFzZVZhbHVlLmluZGV4LFxyXG5cdFx0XHRcdGxlbmd0aDogbGVuZ3RoLFxyXG5cdFx0XHRcdGR1cmF0aW9uOiBpc1ZhbHVlKGFyZ3MuZHVyYXRpb24pID8gYXJncy5kdXJhdGlvbiA6ICQkLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uLFxyXG5cdFx0XHRcdGRvbmU6IGFyZ3MuZG9uZSxcclxuXHRcdFx0XHRvcmdEYXRhQ291bnQ6IG9yZ0RhdGFDb3VudCxcclxuXHRcdFx0fSxcclxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IG9yZ0RhdGFDb3VudCA+IDEsXHJcblx0XHRcdHdpdGhUcmltWERvbWFpbjogZmFsc2UsXHJcblx0XHRcdHdpdGhVcGRhdGVYQXhpczogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgeCBncmlkIGxpbmVzLlxyXG4gKiBAbWV0aG9kIHhncmlkc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueC5saW5lcy5cclxuICogQGV4YW1wbGVcclxuICogIC8vIFNob3cgMiB4IGdyaWQgbGluZXNcclxuICogY2hhcnQueGdyaWRzKFtcclxuICogICAge3ZhbHVlOiAxLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXHJcbiAqICAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcbiAqIF0pO1xyXG4gKi9cclxuZnVuY3Rpb24geGdyaWRzKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0aWYgKCFncmlkcykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XHJcblx0fVxyXG5cclxuXHRjb25maWcuZ3JpZF94X2xpbmVzID0gZ3JpZHM7XHJcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XHJcbn1cclxuXHJcbmV4dGVuZCh4Z3JpZHMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgeCBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyB4IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB4Z3JpZHMuXHJcblx0ICogQG1ldGhvZCB4Z3JpZHPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZ3JpZHMgTmV3IHggZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBBZGQgYSBuZXcgeCBncmlkIGxpbmVcclxuXHQgKiBjaGFydC54Z3JpZHMuYWRkKFxyXG5cdCAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcclxuXHQgKiBjaGFydC54Z3JpZHMuYWRkKFtcclxuXHQgKiAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCAyXCJ9LFxyXG5cdCAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiBdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pIHtcclxuXHRcdHJldHVybiB0aGlzLnhncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF94X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHggZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQG1ldGhvZCB4Z3JpZHPigKRyZW1vdmVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgdmFsdWUgb3IgY2xhc3MuIElmIHZhbHVlIGlzIGdpdmVuLCB0aGUgeCBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgeCB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQuIElmIGNsYXNzIGlzIGdpdmVuLCB0aGUgeCBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgY2xhc3Mgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyB4IGdyaWQgbGluZSBvbiB4ID0gMiB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKHt2YWx1ZTogMn0pO1xyXG5cdCAqXHJcblx0ICogLy8geCBncmlkIGxpbmVzIHRoYXQgaGF2ZSAnZ3JpZC1BJyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzOiBcImdyaWQtQVwiXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKHBhcmFtcz86IHt2YWx1ZT86IG51bWJlciwgY2xhc3M/OiBzdHJpbmd9KSB7IC8vIFRPRE86IG11bHRpcGxlXHJcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIHRydWUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7eGdyaWRzfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogVXBkYXRlIHkgZ3JpZCBsaW5lcy5cclxuICogQG1ldGhvZCB5Z3JpZHNcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBncmlkcyBZIGdyaWQgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMuXHJcbiAqIEBleGFtcGxlXHJcbiAqICAvLyBTaG93IDIgeSBncmlkIGxpbmVzXHJcbiAqIGNoYXJ0LnlncmlkcyhbXHJcbiAqICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXHJcbiAqICAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuICogXSk7XHJcbiAqL1xyXG5mdW5jdGlvbiB5Z3JpZHMoZ3JpZHM6IHt2YWx1ZT86IG51bWJlciwgdGV4dD86IHN0cmluZ31bXSkge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRpZiAoIWdyaWRzKSB7XHJcblx0XHRyZXR1cm4gY29uZmlnLmdyaWRfeV9saW5lcztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5ncmlkX3lfbGluZXMgPSBncmlkcztodHRwOi8vamluZG8uY29tL2dpdC9iaWxsYm9hcmQuanMvZGVtby93b3JrL2NoYXJ0Lmh0bWxcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gY29uZmlnLmdyaWRfeV9saW5lcztcclxufVxyXG5cclxuZXh0ZW5kKHlncmlkcywge1xyXG5cdC8qKlxyXG5cdCAqIEFkZCB5IGdyaWQgbGluZXMuPGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHkgZ3JpZCBsaW5lcyBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHlncmlkcy5cclxuXHQgKiBAbWV0aG9kIHlncmlkc+KApGFkZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeSBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEFkZCBhIG5ldyB4IGdyaWQgbGluZVxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5hZGQoXHJcblx0ICogICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogKTtcclxuXHQgKlxyXG5cdCAqIC8vIEFkZCBuZXcgeCBncmlkIGxpbmVzXHJcblx0ICogY2hhcnQueWdyaWRzLmFkZChbXHJcblx0ICogICB7dmFsdWU6IDIwMCwgdGV4dDogXCJMYWJlbCAyXCJ9LFxyXG5cdCAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGFkZDogZnVuY3Rpb24oZ3JpZHM6IHt2YWx1ZT86IG51bWJlciwgdGV4dD86IHN0cmluZ31bXSkge1xyXG5cdFx0cmV0dXJuIHRoaXMueWdyaWRzKFxyXG5cdFx0XHR0aGlzLmludGVybmFsLmNvbmZpZy5ncmlkX3lfbGluZXNcclxuXHRcdFx0XHQuY29uY2F0KGdyaWRzIHx8IFtdKVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgeSBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cclxuXHQgKiBAbWV0aG9kIHlncmlkc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB5IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHkgZ3JpZCBsaW5lIG9uIHkgPSAyMDAgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7dmFsdWU6IDIwMH0pO1xyXG5cdCAqXHJcblx0ICogLy8geSBncmlkIGxpbmVzIHRoYXQgaGF2ZSAnZ3JpZC1BJyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzOiBcImdyaWQtQVwiXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKHBhcmFtcz86IHt2YWx1ZT86IG51bWJlciwgY2xhc3M/OiBzdHJpbmd9KSB7IC8vIFRPRE86IG11bHRpcGxlXHJcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZhbHNlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3lncmlkc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1VuZGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGdyb3VwcyBmb3IgdGhlIHRhcmdldHMuXHJcblx0ICogQG1ldGhvZCBncm91cHNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBncm91cHMgVGhpcyBhcmd1bWVudCBuZWVkcyB0byBiZSBhbiBBcnJheSB0aGF0IGluY2x1ZGVzIG9uZSBvciBtb3JlIEFycmF5IHRoYXQgaW5jbHVkZXMgdGFyZ2V0IGlkcyB0byBiZSBncm91cGVkLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBHcm91cGVkIGRhdGEgbmFtZXMgYXJyYXlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBhIG5ldyBncm91cC5cclxuXHQgKiAgY2hhcnQuZ3JvdXBzKFtcclxuXHQgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxyXG5cdCAqICBdKTtcclxuXHQgKi9cclxuXHRncm91cHMoZ3JvdXBzOiBzdHJpbmdbXVtdKTogc3RyaW5nW11bXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChpc1VuZGVmaW5lZChncm91cHMpKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xyXG5cdFx0JCQucmVkcmF3KCk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldE9wdGlvbiwgZXh0ZW5kfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgcmVnaW9ucy5cclxuICogQG1ldGhvZCByZWdpb25zXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gcmVnaW9ucyBSZWdpb25zIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucy5cclxuICogQHJldHVybiB7QXJyYXl9IHJlZ2lvbnNcclxuICogQGV4YW1wbGVcclxuICogLy8gU2hvdyAyIHJlZ2lvbnNcclxuICogY2hhcnQucmVnaW9ucyhbXHJcbiAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXHJcbiAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxyXG4gKiBdKTtcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lvbnMocmVnaW9uczoge2F4aXM/OiBzdHJpbmcsIHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIsIGNsYXNzPzogc3RyaW5nfVtdKToge31bXSB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdGlmICghcmVnaW9ucykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xyXG5cdH1cclxuXHJcblx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xyXG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdHJldHVybiByZWdpb25zO1xyXG59XHJcblxyXG5leHRlbmQocmVnaW9ucywge1xyXG5cdC8qKlxyXG5cdCAqIEFkZCBuZXcgcmVnaW9uLjxicj48YnI+XHJcblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgcmVnaW9uIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgcmVnaW9ucy5cclxuXHQgKiBAbWV0aG9kIHJlZ2lvbnPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcmVnaW9ucyBOZXcgcmVnaW9uIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIHJlZ2lvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBBZGQgYSBuZXcgcmVnaW9uXHJcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoXHJcblx0ICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHJlZ2lvbnNcclxuXHQgKiBjaGFydC5yZWdpb25zLmFkZChbXHJcblx0ICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcclxuXHQgKiAgICB7YXhpczogXCJ5XCIsIGVuZDogNTAsIGNsYXNzOiBcInJlZ2lvbllcIn1cclxuXHQgKl0pO1xyXG5cdCAqL1xyXG5cdGFkZDogZnVuY3Rpb24ocmVnaW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoIXJlZ2lvbnMpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5yZWdpb25zID0gY29uZmlnLnJlZ2lvbnMuY29uY2F0KHJlZ2lvbnMpO1xyXG5cdFx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHJlZ2lvbnMuPGJyPjxicj5cclxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHJlZ2lvbnMuXHJcblx0ICogQG1ldGhvZCByZWdpb25z4oCkcmVtb3ZlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlZ2lvbnMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQHJldHVybiB7QXJyYXl9IHJlZ2lvbnMgUmVtb3ZlZCByZWdpb25zXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyByZWdpb25zIHRoYXQgaGF2ZSAncmVnaW9uLUEnIG9yICdyZWdpb24tQicgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzZXM6IFtcclxuXHQgKiAgICAgXCJyZWdpb24tQVwiLCBcInJlZ2lvbi1CXCJcclxuXHQgKiAgIF1cclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiByZWdpb25zIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ob3B0aW9uc1ZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zVmFsdWUgfHwge307XHJcblx0XHRjb25zdCBkdXJhdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcImR1cmF0aW9uXCIsIGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKTtcclxuXHRcdGNvbnN0IGNsYXNzZXMgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJjbGFzc2VzXCIsIFtDTEFTUy5yZWdpb25dKTtcclxuXHRcdGxldCByZWdpb25zID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5yZWdpb25zfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoY2xhc3Nlcy5tYXAoYyA9PiBgLiR7Y31gKSk7XHJcblxyXG5cdFx0KGR1cmF0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pIDogcmVnaW9ucylcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHJlZ2lvbnMgPSBjb25maWcucmVnaW9ucztcclxuXHJcblx0XHRpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XHJcblx0XHRcdHJlZ2lvbnMgPSByZWdpb25zLmZpbHRlcihyZWdpb24gPT4ge1xyXG5cdFx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIXJlZ2lvbi5jbGFzcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZWdpb24uY2xhc3Muc3BsaXQoXCIgXCIpLmZvckVhY2goYyA9PiB7XHJcblx0XHRcdFx0XHRpZiAoY2xhc3Nlcy5pbmRleE9mKGMpID49IDApIHtcclxuXHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gIWZvdW5kO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbmZpZy5yZWdpb25zID0gW107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlZ2lvbnM7XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtyZWdpb25zfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtEYXRhSXRlbX0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IHNlbGVjdGVkIGRhdGEgcG9pbnRzLjxicj48YnI+XHJcblx0ICogQnkgdGhpcyBBUEksIHlvdSBjYW4gZ2V0IHNlbGVjdGVkIGRhdGEgcG9pbnRzIGluZm9ybWF0aW9uLiBUbyB1c2UgdGhpcyBBUEksIGRhdGEuc2VsZWN0aW9uLmVuYWJsZWQgbmVlZHMgdG8gYmUgc2V0IHRydWUuXHJcblx0ICogQG1ldGhvZCBzZWxlY3RlZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGFyZ2V0SWRdIFlvdSBjYW4gZmlsdGVyIHRoZSByZXN1bHQgYnkgZ2l2aW5nIHRhcmdldCBpZCB0aGF0IHlvdSB3YW50IHRvIGdldC4gSWYgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSBwb2ludHMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gZGF0YVBvaW50IEFycmF5IG9mIHRoZSBkYXRhIHBvaW50cy48YnI+ZXguKSBgW3t4OiAxLCB2YWx1ZTogMjAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMSwgbmFtZTogXCJkYXRhMVwifSwgLi4uXWBcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBhbGwgc2VsZWN0ZWQgZGF0YSBwb2ludHMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgY2hhcnQuc2VsZWN0ZWQoKTtcclxuXHQgKiAgLy8gLS0+IGV4LikgW3t4OiAxLCB2YWx1ZTogMjAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMSwgbmFtZTogXCJkYXRhMVwifSwgLi4uIF1cclxuXHQgKlxyXG5cdCAqICAvLyBhbGwgc2VsZWN0ZWQgZGF0YSBwb2ludHMgb2YgZGF0YTEgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgY2hhcnQuc2VsZWN0ZWQoXCJkYXRhMVwiKTtcclxuXHQgKi9cclxuXHRzZWxlY3RlZCh0YXJnZXRJZD86IHN0cmluZyk6IERhdGFJdGVtW10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3QgZGF0YVBvaW50OiBEYXRhSXRlbVtdID0gW107XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZCl9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5lYWNoKGQgPT4gZGF0YVBvaW50LnB1c2goZCkpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhUG9pbnQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRhdGEgcG9pbnRzIHRvIGJlIHNlbGVjdGVkLiAoYFtkYXRhLnNlbGVjdGlvbi5lbmFibGVkXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRzZWxlY3Rpb24lMjVFMiUyNTgwJTI1QTRlbmFibGVkKSBvcHRpb24gc2hvdWxkIGJlIHNldCB0cnVlIHRvIHVzZSB0aGlzIG1ldGhvZClgXHJcblx0ICogQG1ldGhvZCBzZWxlY3RcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gZ2V0IHNlbGVjdGVkLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtpbmRpY2VzXSBUaGUgaW5kZXggYXJyYXkgb2YgZGF0YSBwb2ludHMuIElmIGZhbHN5IHZhbHVlIGdpdmVuLCB3aWxsIHNlbGVjdCBhbGwgZGF0YSBwb2ludHMuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVzZXRPdGhlcl0gVW5zZWxlY3QgYWxyZWFkeSBzZWxlY3RlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzXHJcblx0ICogIGNoYXJ0LnNlbGVjdCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBhbGwgZnJvbSAnZGF0YTInXHJcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGEyXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBhbGwgZnJvbSAnZGF0YTEnIGFuZCAnZGF0YTInXHJcblx0ICogIGNoYXJ0LnNlbGVjdChbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDIgYW5kIHVuc2VsZWN0IG90aGVycyBzZWxlY3RlZFxyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMVwiLCBbMl0sIHRydWUpO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMCwgMyBhbmQgNVxyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMVwiLCBbMCwgMywgNV0pO1xyXG5cdCAqL1xyXG5cdHNlbGVjdChpZHM/OiBzdHJpbmdbXSB8IHN0cmluZywgaW5kaWNlcz86IG51bWJlcltdLCByZXNldE90aGVyPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcclxuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHJcblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXgpIHtcclxuXHRcdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSAmJiAhaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0XHR0b2dnbGUodHJ1ZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgdHJ1ZSksIGQsIGkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKHJlc2V0T3RoZXIpICYmIHJlc2V0T3RoZXIgJiYgaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRhdGEgcG9pbnRzIHRvIGJlIHVuLXNlbGVjdGVkLlxyXG5cdCAqIEBtZXRob2QgdW5zZWxlY3RcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gYmUgdW5zZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC51bnNlbGVjdCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBmcm9tICdkYXRhMSdcclxuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyB1bnNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMlxyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIsIFsyXSk7XHJcblx0ICovXHJcblx0dW5zZWxlY3QoaWRzPzogc3RyaW5nIHwgc3RyaW5nW10sIGluZGljZXM/OiBudW1iZXJbXSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcclxuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHJcblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXggJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgJiYgaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXHJcblx0ICogQG1ldGhvZCB4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0geCBJZiB4IGlzIGdpdmVuLCB4IHZhbHVlcyBvZiBldmVyeSB0YXJnZXQgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHhzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcclxuXHQgKiAgY2hhcnQueCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcclxuXHQgKiAgY2hhcnQueChbMTAwLCAyMDAsIDMwMCwgNDAwLCAuLi5dKTtcclxuXHQgKi9cclxuXHR4KHgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSAkJC5pc0N1c3RvbVgoKSAmJiAkJC5pc0NhdGVnb3JpemVkKCk7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkoeCkpIHtcclxuXHRcdFx0aWYgKGlzQ2F0ZWdvcml6ZWQpIHtcclxuXHRcdFx0XHR0aGlzLmNhdGVnb3JpZXMoeCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQudXBkYXRlVGFyZ2V0WCgkJC5kYXRhLnRhcmdldHMsIHgpO1xyXG5cclxuXHRcdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzQ2F0ZWdvcml6ZWQgPyB0aGlzLmNhdGVnb3JpZXMoKSA6ICQkLmRhdGEueHM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIHhzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0geHMgSWYgeHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyB4IHZhbHVlcyB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0geHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBHZXQgY3VycmVudCB4IHZhbHVlc1xyXG5cdCAqICBjaGFydC54cygpO1xyXG5cdCAqXHJcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcclxuXHQgKiAgY2hhcnQueHMoe1xyXG5cdCAqICAgIGRhdGExOiBbMTAsIDIwLCAzMCwgNDAsIC4uLl0sXHJcblx0ICogICAgZGF0YTI6IFsxMDAsIDIwMCwgMzAwLCA0MDAsIC4uLl1cclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0eHMoeHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoeHMpKSB7XHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldFhzKCQkLmRhdGEudGFyZ2V0cywgeHMpO1xyXG5cclxuXHRcdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJCQuZGF0YS54cztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt6b29tSWRlbnRpdHkgYXMgZDNab29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gYXMgZDNab29tVHJhbnNmb3JtfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBleHRlbmQsIGdldE1pbk1heCwgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNTdHJpbmcsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRvbWFpbiBpcyB3aXRoaW4gem9vbSByYW5nZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhpblJhbmdlKGRvbWFpbjogbnVtYmVyW10sIHJhbmdlOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IFttaW4sIG1heF0gPSByYW5nZTtcclxuXHJcblx0cmV0dXJuIGRvbWFpbi5ldmVyeSgodiwgaSkgPT4gKFxyXG5cdFx0aSA9PT0gMCA/ICh2ID49IG1pbikgOiAodiA8PSBtYXgpXHJcblx0KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogWm9vbSBieSBnaXZpbmcgeCBkb21haW4uXHJcbiAqIC0gKipOT1RFOioqXHJcbiAqICAtIEZvciBgd2hlZWxgIHR5cGUgem9vbSwgdGhlIG1pbmltdW0gem9vbSByYW5nZSB3aWxsIGJlIHNldCBhcyB0aGUgZ2l2ZW4gZG9tYWluLiBUbyBnZXQgdGhlIGluaXRpYWwgc3RhdGUsIFsudW56b29tKCldKCN1bnpvb20pIHNob3VsZCBiZSBjYWxsZWQuXHJcbiAqICAtIFRvIGJlIHVzZWQgW3pvb20uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy56b29tKSBvcHRpb24gc2hvdWxkIGJlIHNldCBhcyBgdHJ1dGh5YC5cclxuICogQG1ldGhvZCB6b29tXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluVmFsdWUgSWYgZG9tYWluIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB6b29tZWQgdG8gdGhlIGdpdmVuIGRvbWFpbi4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IHpvb21lZCBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHJldHVybiB7QXJyYXl9IGRvbWFpbiB2YWx1ZSBpbiBhcnJheVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKFsxMCwgMjBdKTtcclxuICpcclxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKCk7XHJcbiAqL1xyXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWU/OiBudW1iZXJbXSkge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XHJcblx0bGV0IHJlc3VsdERvbWFpbjtcclxuXHJcblx0aWYgKGNvbmZpZy56b29tX2VuYWJsZWQgJiYgZG9tYWluICYmIHdpdGhpblJhbmdlKGRvbWFpbiwgJCQuZ2V0Wm9vbURvbWFpbigpKSkge1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRjb25zdCBmbiA9IHBhcnNlRGF0ZS5iaW5kKCQkKTtcclxuXHJcblx0XHRcdGRvbWFpbiA9IGRvbWFpbi5tYXAoeCA9PiBmbih4KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHJcblx0XHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgW3hTY2FsZShkb21haW5bMF0pLCB4U2NhbGUoZG9tYWluWzFdKV0pO1xyXG5cdFx0XHRyZXN1bHREb21haW4gPSBkb21haW47XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihkb21haW4pO1xyXG5cdFx0XHRzY2FsZS56b29tID0gc2NhbGUueDtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbS5vcmdEb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5zZXRab29tUmVzZXRCdXR0b24oKTtcclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb20sICQkLmFwaSwgcmVzdWx0RG9tYWluKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbSA/XHJcblx0XHRcdHNjYWxlLnpvb20uZG9tYWluKCkgOiBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdERvbWFpbjtcclxufTtcclxuXHJcbmV4dGVuZCh6b29tLCB7XHJcblx0LyoqXHJcblx0ICogRW5hYmxlIGFuZCBkaXNhYmxlIHpvb21pbmcuXHJcblx0ICogQG1ldGhvZCB6b29t4oCkZW5hYmxlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gZW5hYmxlZCBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzIGFyZSBcIndoZWVsXCIgb3IgXCJkcmFnXCIuIElmIGVuYWJsZWQgaXMgdHJ1ZSwgXCJ3aGVlbFwiIHdpbGwgYmUgdXNlZC4gSWYgZmFsc2UgaXMgZ2l2ZW4sIHpvb21pbmcgd2lsbCBiZSBkaXNhYmxlZC48YnI+V2hlbiBzZXQgdG8gZmFsc2UsIHRoZSBjdXJyZW50IHpvb21pbmcgc3RhdHVzIHdpbGwgYmUgcmVzZXQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlIHdoZWVsXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKHRydWUpO1xyXG5cdCAqICAvLyBPclxyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShcIndoZWVsXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIGJ5IGRyYWdnaW5nXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKFwiZHJhZ1wiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBEaXNhYmxlIHpvb21pbmdcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoZmFsc2UpO1xyXG5cdCAqL1xyXG5cdGVuYWJsZTogZnVuY3Rpb24oZW5hYmxlZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBlbmFibGVUeXBlOiBhbnkgPSBlbmFibGVkO1xyXG5cclxuXHRcdGlmIChlbmFibGVkKSB7XHJcblx0XHRcdGVuYWJsZVR5cGUgPSBpc1N0cmluZyhlbmFibGVkKSAmJiAvXihkcmFnfHdoZWVsKSQvLnRlc3QoZW5hYmxlZCkgP1xyXG5cdFx0XHRcdHt0eXBlOiBlbmFibGVkfSA6IGVuYWJsZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnpvb21fZW5hYmxlZCA9IGVuYWJsZVR5cGU7XHJcblxyXG5cdFx0aWYgKCEkJC56b29tKSB7XHJcblx0XHRcdCQkLmluaXRab29tKCk7XHJcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdH0gZWxzZSBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYmluZFpvb21FdmVudChmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlIHZhbHVlXHJcblx0ICogQG1ldGhvZCB6b29t4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXhdIG1heGltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSB6b29tIG1heCB2YWx1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFNldCBtYXhpbXVtIHJhbmdlIHZhbHVlXHJcblx0ICogIGNoYXJ0Lnpvb20ubWF4KDIwKTtcclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKG1heD86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmc6IHt4RG9tYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAobWF4ID09PSAwIHx8IG1heCkge1xyXG5cdFx0XHRjb25maWcuem9vbV94X21heCA9IGdldE1pbk1heChcIm1heFwiLCBbeERvbWFpblsxXSwgbWF4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy56b29tX3hfbWF4O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgeCBBeGlzIG1pbmltdW0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIEBtZXRob2Qgem9vbeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gem9vbSBtaW4gdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTZXQgbWluaW11bSByYW5nZSB2YWx1ZVxyXG5cdCAqICBjaGFydC56b29tLm1pbigtMSk7XHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbihtaW4/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnOiB7eERvbWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG1pbiA9PT0gMCB8fCBtaW4pIHtcclxuXHRcdFx0Y29uZmlnLnpvb21feF9taW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW3hEb21haW5bMF0sIG1pbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21pbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgem9vbSByYW5nZVxyXG5cdCAqIEBtZXRob2Qgem9vbeKApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtyYW5nZV1cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiB7XHJcblx0ICogICBtaW46IDAsXHJcblx0ICogICBtYXg6IDEwMFxyXG5cdCAqIH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC56b29tLnJhbmdlKHtcclxuXHQgKiAgICAgIG1pbjogMTAsXHJcblx0ICogICAgICBtYXg6IDEwMFxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcclxuXHRcdGNvbnN0IHpvb20gPSB0aGlzLnpvb207XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KHJhbmdlKSkge1xyXG5cdFx0XHRjb25zdCB7bWluLCBtYXh9ID0gcmFuZ2U7XHJcblxyXG5cdFx0XHRpc0RlZmluZWQobWluKSAmJiB6b29tLm1pbihtaW4pO1xyXG5cdFx0XHRpc0RlZmluZWQobWF4KSAmJiB6b29tLm1heChtYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG1pbjogem9vbS5taW4oKSxcclxuXHRcdFx0bWF4OiB6b29tLm1heCgpXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0em9vbSxcclxuXHJcblx0LyoqXHJcblx0ICogVW56b29tIHpvb21lZCBhcmVhXHJcblx0ICogQG1ldGhvZCB1bnpvb21cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC51bnpvb20oKTtcclxuXHQgKi9cclxuXHR1bnpvb20oKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5zY2FsZS56b29tKSB7XHJcblx0XHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ID9cclxuXHRcdFx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24oKS5jYWxsKCQkLmJydXNoLm1vdmUsIG51bGwpIDpcclxuXHRcdFx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKGQzWm9vbUlkZW50aXR5KTtcclxuXHJcblx0XHRcdCQkLnVwZGF0ZVpvb20odHJ1ZSk7XHJcblx0XHRcdCQkLnpvb20ucmVzZXRCdG4gJiYgJCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgdHJhbnNmb3JtXHJcblx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XHJcblxyXG5cdFx0XHRpZiAoZDNab29tVHJhbnNmb3JtKGV2ZW50UmVjdHMubm9kZSgpKSAhPT0gZDNab29tSWRlbnRpdHkpIHtcclxuXHRcdFx0XHQkJC56b29tLnRyYW5zZm9ybShldmVudFJlY3RzLCBkM1pvb21JZGVudGl0eSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGVcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRQYXRoQm94fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcInR5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcuXHJcblx0ICogRGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIE9iamVjdFxyXG5cdCAqL1xyXG5cdGRyYWcobW91c2UpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8XHJcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCB8fCAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXHJcblx0XHRcdChjb25maWcuem9vbV9lbmFibGVkICYmICEkJC56b29tLmFsdERvbWFpbikgfHwgLy8gc2tpcCBpZiB6b29tYWJsZSBiZWNhdXNlIG9mIGNvbmZsaWN0IGRyYWcgYmVoYXZpb3JcclxuXHRcdFx0IWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSAvLyBza2lwIHdoZW4gc2luZ2xlIHNlbGVjdGlvbiBiZWNhdXNlIGRyYWcgaXMgdXNlZCBmb3IgbXVsdGlwbGUgc2VsZWN0aW9uXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IFtzeCwgc3ldID0gc3RhdGUuZHJhZ1N0YXJ0O1xyXG5cdFx0Y29uc3QgW214LCBteV0gPSBtb3VzZTtcclxuXHJcblx0XHRjb25zdCBtaW5YID0gTWF0aC5taW4oc3gsIG14KTtcclxuXHRcdGNvbnN0IG1heFggPSBNYXRoLm1heChzeCwgbXgpO1xyXG5cdFx0Y29uc3QgbWluWSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gc3RhdGUubWFyZ2luLnRvcCA6IE1hdGgubWluKHN5LCBteSk7XHJcblx0XHRjb25zdCBtYXhZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyBzdGF0ZS5oZWlnaHQgOiBNYXRoLm1heChzeSwgbXkpO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgbWluWClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIG1pblkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4WCAtIG1pblgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG1heFkgLSBtaW5ZKTtcclxuXHJcblx0XHQvLyBUT0RPOiBiaW5hcnkgc2VhcmNoIHdoZW4gbXVsdGlwbGUgeHNcclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmZpbHRlcihkID0+IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGU6IGQzU2VsZWN0aW9uID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzSW5jbHVkZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLklOQ0xVREVEKTtcclxuXHRcdFx0XHRsZXQgaXNXaXRoaW46IGFueSA9IGZhbHNlO1xyXG5cdFx0XHRcdGxldCB0b2dnbGU7XHJcblxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmNpcmNsZSkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHg6IG51bWJlciA9ICtzaGFwZS5hdHRyKFwiY3hcIikgKiAxO1xyXG5cdFx0XHRcdFx0Y29uc3QgeTogbnVtYmVyID0gK3NoYXBlLmF0dHIoXCJjeVwiKSAqIDE7XHJcblxyXG5cdFx0XHRcdFx0dG9nZ2xlID0gJCQudG9nZ2xlUG9pbnQ7XHJcblx0XHRcdFx0XHRpc1dpdGhpbiA9IG1pblggPCB4ICYmIHggPCBtYXhYICYmIG1pblkgPCB5ICYmIHkgPCBtYXhZO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBnZXRQYXRoQm94KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBhdGg7XHJcblx0XHRcdFx0XHRpc1dpdGhpbiA9ICEobWF4WCA8IHggfHwgeCArIHdpZHRoIDwgbWluWCkgJiYgIShtYXhZIDwgeSB8fCB5ICsgaGVpZ2h0IDwgbWluWSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRpZiAoaXNXaXRoaW4gXiBpc0luY2x1ZGVkKSB7XHJcblx0XHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLklOQ0xVREVELCAhaXNJbmNsdWRlZCk7XHJcblx0XHRcdFx0XHQvLyBUT0RPOiBpbmNsdWRlZC91bmluY2x1ZGVkIGNhbGxiYWNrIGhlcmVcclxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcclxuXHRcdFx0XHRcdHRvZ2dsZS5jYWxsKCQkLCAhaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgc3RhcnRzLlxyXG5cdCAqIEFkZHMgYW5kIFNob3dzIHRoZSBkcmFnIGFyZWEuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgT2JqZWN0XHJcblx0ICovXHJcblx0ZHJhZ3N0YXJ0KG1vdXNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRyYWdTdGFydCA9IG1vdXNlO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmRyYWdhcmVhKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMC4xXCIpO1xyXG5cclxuXHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgZmluaXNoZXMuXHJcblx0ICogUmVtb3ZlcyB0aGUgZHJhZyBhcmVhLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZHJhZ2VuZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7IC8vIGRvIG5vdGhpbmcgaWYgbm90IHNlbGVjdGFibGVcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsIGZhbHNlKTtcclxuXHJcblx0XHQkJC5zZXREcmFnU3RhdHVzKGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHRzZXREcmFnU3RhdHVzKGlzRHJhZ2dpbmcpIHtcclxuXHRcdHRoaXMuZHJhZ2dpbmcgPSBpc0RyYWdnaW5nO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2Vhc2VMaW5lYXIgYXMgZDNFYXNlTGluZWFyfSBmcm9tIFwiZDMtZWFzZVwiO1xyXG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQge2RpZmZEb21haW59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgZmxvd1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRmxvdyhhcmdzKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2RhdGEsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBmbG93TGVuZ3RoID0gYXJncy5mbG93Lmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIHNldCBmbGFnXHJcblx0XHRcdHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIGhlYWQgZGF0YSBhZnRlciByZW5kZXJlZFxyXG5cdFx0XHRkYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRkLnZhbHVlcy5zcGxpY2UoMCwgZmxvd0xlbmd0aCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxyXG5cdFx0XHRpZiAoJCQudXBkYXRlWEdyaWQpIHtcclxuXHRcdFx0XHQkJC51cGRhdGVYR3JpZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdGFyZ2V0IGVsZW1lbnRzXHJcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0ge307XHJcblxyXG5cdFx0XHRbXCJheGlzLnhcIiwgXCJncmlkLnhcIiwgXCJncmlkTGluZXMueFwiLCBcInJlZ2lvbi5saXN0XCIsIFwidGV4dFwiLCBcImJhclwiLCBcImxpbmVcIiwgXCJhcmVhXCIsIFwiY2lyY2xlXCJdXHJcblx0XHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdi5zcGxpdChcIi5cIik7XHJcblx0XHRcdFx0XHRsZXQgbm9kZSA9ICRlbFtuYW1lWzBdXTtcclxuXHJcblx0XHRcdFx0XHRpZiAobm9kZSAmJiBuYW1lLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVbbmFtZVsxXV07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG5vZGUgJiYgbm9kZS5zaXplKCkpIHtcclxuXHRcdFx0XHRcdFx0ZWxlbWVudHNbdl0gPSBub2RlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0XHQkJC5zZXRGbG93TGlzdChlbGVtZW50cywgYXJncyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBmbG93IGxpc3RcclxuXHQgKiBAcGFyYW0gZWxlbWVudHMge09iamVjdH0gVGFyZ2V0IGVsZW1lbnRzXHJcblx0ICogQHBhcmFtIGFyZ3Mge09iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEZsb3dMaXN0KGVsZW1lbnRzLCBhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7ZmxvdywgdGFyZ2V0c30gPSBhcmdzO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRkdXJhdGlvbiA9IGFyZ3MuZHVyYXRpb24sXHJcblx0XHRcdGluZGV4OiBmbG93SW5kZXgsXHJcblx0XHRcdGxlbmd0aDogZmxvd0xlbmd0aCxcclxuXHRcdFx0b3JnRGF0YUNvdW50LFxyXG5cdFx0fSA9IGZsb3c7XHJcblxyXG5cdFx0Y29uc3QgdHJhbnNmb3JtID0gJCQuZ2V0Rmxvd1RyYW5zZm9ybSh0YXJnZXRzLCBvcmdEYXRhQ291bnQsIGZsb3dJbmRleCwgZmxvd0xlbmd0aCk7XHJcblx0XHRjb25zdCB3YWl0ID0gJCQuZ2VuZXJhdGVXYWl0KCk7XHJcblx0XHRjb25zdCBndCA9IGQzVHJhbnNpdGlvbigpLmVhc2UoZDNFYXNlTGluZWFyKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pO1xyXG5cclxuXHRcdHdhaXQuYWRkKE9iamVjdC5rZXlzKGVsZW1lbnRzKS5tYXAodiA9PiB7XHJcblx0XHRcdGxldCBuID0gZWxlbWVudHNbdl07XHJcblxyXG5cdFx0XHRpZiAodiA9PT0gXCJheGlzLnhcIikge1xyXG5cdFx0XHRcdG4gPSBuLnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuY2FsbChnID0+ICQkLmF4aXMueC5zZXRUcmFuc2l0aW9uKGd0KS5jcmVhdGUoZykpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwicmVnaW9uLmxpc3RcIikge1xyXG5cdFx0XHRcdG4gPSBuLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuID0gbi50cmFuc2l0aW9uKGd0KS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuO1xyXG5cdFx0fSkpO1xyXG5cclxuXHRcdGd0LmNhbGwod2FpdCwgKCkgPT4ge1xyXG5cdFx0XHQkJC5jbGVhblVwRmxvdyhlbGVtZW50cywgYXJncyk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhbiB1cCBmbG93XHJcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtPYmplY3R9IFRhcmdldCBlbGVtZW50c1xyXG5cdCAqIEBwYXJhbSBhcmdzIHtPYmplY3R9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjbGVhblVwRmxvdyhlbGVtZW50cywgYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbnN0IHtmbG93LCBzaGFwZSwgeHZ9ID0gYXJncztcclxuXHRcdGNvbnN0IHtjeCwgY3ksIHhGb3JUZXh0LCB5Rm9yVGV4dH0gPSBzaGFwZS5wb3M7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fSxcclxuXHRcdFx0bGVuZ3RoOiBmbG93TGVuZ3RoXHJcblx0XHR9ID0gZmxvdztcclxuXHJcblx0XHQvLyBSZW1vdmUgZmxvd2VkIGVsZW1lbnRzXHJcblx0XHRpZiAoZmxvd0xlbmd0aCkge1xyXG5cdFx0XHRbXCJjaXJjbGVcIiwgXCJ0ZXh0XCIsIFwic2hhcGVcIiwgXCJldmVudFJlY3RcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0YXJnZXQgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbG93TGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRhcmdldC5wdXNoKGAuJHtDTEFTU1t2XX0tJHtpfWApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLnNlbGVjdEFsbChgLiR7Q0xBU1NbYCR7dn1zYF19YCkgLy8gY2lyY2xlcywgc2hhcGVzLCB0ZXh0cywgZXZlbnRSZWN0c1xyXG5cdFx0XHRcdFx0LnNlbGVjdEFsbCh0YXJnZXQpXHJcblx0XHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1MueGdyaWR9YClcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZHJhdyBhZ2FpbiBmb3IgcmVtb3ZpbmcgZmxvd2VkIGVsZW1lbnRzIGFuZCByZXZlcnRpbmcgYXR0clxyXG5cdFx0T2JqZWN0LmtleXMoZWxlbWVudHMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdGNvbnN0IG4gPSBlbGVtZW50c1t2XTtcclxuXHJcblx0XHRcdGlmICh2ICE9PSBcImF4aXMueFwiKSB7XHJcblx0XHRcdFx0bi5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodiA9PT0gXCJncmlkLnhcIikge1xyXG5cdFx0XHRcdG4uYXR0cihzdGF0ZS54Z3JpZEF0dHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwiZ3JpZExpbmVzLnhcIikge1xyXG5cdFx0XHRcdG4uYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiB4dik7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJncmlkTGluZXMueFwiKSB7XHJcblx0XHRcdFx0bi5zZWxlY3QoXCJsaW5lXCIpLmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogeHYpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogeHYpO1xyXG5cclxuXHRcdFx0XHRuLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeHYpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKC9eKGFyZWF8YmFyfGxpbmUpJC8udGVzdCh2KSkge1xyXG5cdFx0XHRcdG4uYXR0cihcImRcIiwgc2hhcGUudHlwZVt2XSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJ0ZXh0XCIpIHtcclxuXHRcdFx0XHRuLmF0dHIoXCJ4XCIsIHhGb3JUZXh0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JUZXh0KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpKTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcImNpcmNsZVwiKSB7XHJcblx0XHRcdFx0aWYgKCQkLmlzQ2lyY2xlUG9pbnQoKSkge1xyXG5cdFx0XHRcdFx0bi5hdHRyKFwiY3hcIiwgY3gpLmF0dHIoXCJjeVwiLCBjeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHhGdW5jID0gZCA9PiBjeChkKSAtIGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0Y29uc3QgeUZ1bmMgPSBkID0+IGN5KGQpIC0gY29uZmlnLnBvaW50X3I7XHJcblxyXG5cdFx0XHRcdFx0bi5hdHRyKFwieFwiLCB4RnVuYylcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGdW5jKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN4XCIsIGN4KSAvLyB3aGVuIHBhdHRlcm4gaXMgdXNlZCwgaXQgcG9zc2libHkgY29udGFpbiAnY2lyY2xlJyBhbHNvLlxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIGN5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJyZWdpb24ubGlzdFwiKSB7XHJcblx0XHRcdFx0bi5zZWxlY3QoXCJyZWN0XCIpLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAkJC5yZWdpb25YLmJpbmQoJCQpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5yZWdpb25XaWR0aC5iaW5kKCQkKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdC8vIGNhbGxiYWNrIGZvciBlbmQgb2YgZmxvd1xyXG5cdFx0ZG9uZS5jYWxsKCQkLmFwaSk7XHJcblxyXG5cdFx0c3RhdGUuZmxvd2luZyA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmbG93IHRyYW5zZm9ybSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB0YXJnZXRzXHJcblx0ICogQHBhcmFtIG9yZ0RhdGFDb3VudFxyXG5cdCAqIEBwYXJhbSBmbG93SW5kZXhcclxuXHQgKiBAcGFyYW0gZmxvd0xlbmd0aFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEZsb3dUcmFuc2Zvcm0odGFyZ2V0cywgb3JnRGF0YUNvdW50LCBmbG93SW5kZXgsIGZsb3dMZW5ndGgpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2RhdGEsIHNjYWxlOiB7eH19ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhVmFsdWVzID0gZGF0YS50YXJnZXRzWzBdLnZhbHVlcztcclxuXHJcblx0XHRsZXQgZmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KGRhdGFWYWx1ZXMsIGZsb3dJbmRleCk7XHJcblx0XHRsZXQgZmxvd0VuZCA9ICQkLmdldFZhbHVlT25JbmRleChkYXRhVmFsdWVzLCBmbG93SW5kZXggKyBmbG93TGVuZ3RoKTtcclxuXHRcdGxldCB0cmFuc2xhdGVYO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB4IGRvbWFpbiB0byBnZW5lcmF0ZSBheGlzIGVsZW1lbnRzIGZvciBmbG93XHJcblx0XHRjb25zdCBvcmdEb21haW4gPSB4LmRvbWFpbigpO1xyXG5cdFx0Y29uc3QgZG9tYWluID0gJCQudXBkYXRlWERvbWFpbih0YXJnZXRzLCB0cnVlLCB0cnVlKTtcclxuXHJcblx0XHQvLyBnZW5lcmF0ZSB0cmFuc2Zvcm0gdG8gZmxvd1xyXG5cdFx0aWYgKCFvcmdEYXRhQ291bnQpIHsgLy8gaWYgZW1wdHlcclxuXHRcdFx0aWYgKGRhdGFWYWx1ZXMubGVuZ3RoICE9PSAxKSB7XHJcblx0XHRcdFx0dHJhbnNsYXRlWCA9IHgob3JnRG9tYWluWzBdKSAtIHgoZG9tYWluWzBdKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRcdGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleChkYXRhVmFsdWVzLCAwKTtcclxuXHRcdFx0XHRcdGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoZGF0YVZhbHVlcywgZGF0YVZhbHVlcy5sZW5ndGggLSAxKTtcclxuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSB4KGZsb3dTdGFydC54KSAtIHgoZmxvd0VuZC54KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9IGRpZmZEb21haW4oZG9tYWluKSAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSB8fCAoZmxvd1N0YXJ0ICYmIGZsb3dTdGFydC54KSA9PT0gKGZsb3dFbmQgJiYgZmxvd0VuZC54KSkge1xyXG5cdFx0XHR0cmFuc2xhdGVYID0geChvcmdEb21haW5bMF0pIC0geChkb21haW5bMF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHJhbnNsYXRlWCA9ICQkLmlzVGltZVNlcmllcygpID9cclxuXHRcdFx0XHR4KG9yZ0RvbWFpblswXSkgLSB4KGRvbWFpblswXSkgOlxyXG5cdFx0XHRcdHgoZmxvd1N0YXJ0LngpIC0geChmbG93RW5kLngpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNjYWxlWCA9IChkaWZmRG9tYWluKG9yZ0RvbWFpbikgLyBkaWZmRG9tYWluKGRvbWFpbikpO1xyXG5cclxuXHRcdHJldHVybiBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH0sMCkgc2NhbGUoJHtzY2FsZVh9LDEpYDtcclxuXHR9XHJcbn07XHJcbiIsIlx0LyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNCb29sZWFufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBhcmVhIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXHJcblx0ICogQWRkIGEgY29udGFpbmVyIGZvciB0aGUgem9uZSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdEV2ZW50UmVjdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0cylcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXdzIHRoZSBhcmVhIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdFdmVudFJlY3QoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XHJcblx0XHRsZXQgZXZlbnRSZWN0VXBkYXRlO1xyXG5cclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YClcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIHpvb21FbmFibGVkICYmIHpvb21FbmFibGVkLnR5cGUgIT09IFwiZHJhZ1wiID8gKFxyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIm5zLXJlc2l6ZVwiIDogXCJldy1yZXNpemVcIlxyXG5cdFx0XHQpIDogbnVsbClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0c011bHRpcGxlLCBpc011bHRpcGxlWClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0c1NpbmdsZSwgIWlzTXVsdGlwbGVYKTtcclxuXHJcblx0XHQvLyBjbGVhciBvbGQgcmVjdHNcclxuXHRcdGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Ly8gb3BlbiBhcyBwdWJsaWMgY29uc3RpYWJsZVxyXG5cdFx0JGVsLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XHJcblxyXG5cdFx0aWYgKGlzTXVsdGlwbGVYKSB7XHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICRlbC5ldmVudFJlY3QuZGF0YShbMF0pO1xyXG5cdFx0XHQvLyB1cGRhdGVcclxuXHRcdFx0Ly8gZW50ZXI6IG9ubHkgb25lIHJlY3Qgd2lsbCBiZSBhZGRlZFxyXG5cdFx0XHQvLyBleGl0OiBub3QgbmVlZGVkIGJlY2F1c2UgYWx3YXlzIG9ubHkgb25lIHJlY3QgZXhpc3RzXHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXHJcblx0XHRcdFx0Lm1lcmdlKGV2ZW50UmVjdFVwZGF0ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBTZXQgZGF0YSBhbmQgdXBkYXRlICRlbC5ldmVudFJlY3RcclxuXHRcdFx0Y29uc3QgeEF4aXNUaWNrVmFsdWVzID0gJCQuZ2V0TWF4RGF0YUNvdW50VGFyZ2V0KCk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZGF0YSdzIGluZGV4IHZhbHVlIHRvIGJlIGFsaW5nZWQgd2l0aCB0aGUgeCBBeGlzXHJcblx0XHRcdCQkLnVwZGF0ZURhdGFJbmRleEJ5WCh4QXhpc1RpY2tWYWx1ZXMpO1xyXG5cdFx0XHQkJC51cGRhdGVYcyh4QXhpc1RpY2tWYWx1ZXMpO1xyXG5cdFx0XHQkJC51cGRhdGVQb2ludENsYXNzKHRydWUpO1xyXG5cclxuXHRcdFx0ZXZlbnRSZWN0cy5kYXR1bSh4QXhpc1RpY2tWYWx1ZXMpO1xyXG5cclxuXHRcdFx0JGVsLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICRlbC5ldmVudFJlY3QuZGF0YShkID0+IGQpO1xyXG5cclxuXHRcdFx0Ly8gZXhpdFxyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlXHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXHJcblx0XHRcdFx0Lm1lcmdlKGV2ZW50UmVjdFVwZGF0ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JGVsLmV2ZW50UmVjdCA9IGV2ZW50UmVjdFVwZGF0ZTtcclxuXHRcdCQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xyXG5cclxuXHRcdGlmICgkJC5zdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAhJGVsLnN2Zy5vbihcInRvdWNoc3RhcnQuZXZlbnRSZWN0XCIpICYmICEkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0JCQuYmluZFRvdWNoT25FdmVudFJlY3QoaXNNdWx0aXBsZVgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCBnZXRFdmVudFJlY3QgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHJcblx0XHRcdHJldHVybiBkM1NlbGVjdChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgZ2V0SW5kZXggPSBldmVudFJlY3QgPT4ge1xyXG5cdFx0XHRsZXQgaW5kZXggPSBldmVudFJlY3QgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKSAmJiBldmVudFJlY3QuYXR0cihcImNsYXNzXCIpXHJcblx0XHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cChgKCR7Q0xBU1MuZXZlbnRSZWN0fS0/fHMpYCwgXCJnXCIpLCBcIlwiKSAqIDE7XHJcblxyXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpIHx8IGluZGV4ID09PSBudWxsKSB7XHJcblx0XHRcdFx0aW5kZXggPSAtMTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGluZGV4O1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBzZWxlY3RSZWN0ID0gY29udGV4dCA9PiB7XHJcblx0XHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xyXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoZXZlbnRSZWN0KTtcclxuXHJcblx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XHJcblxyXG5cdFx0XHRcdGluZGV4ID09PSAtMSA/XHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKSA6XHJcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQoKVxyXG5cdFx0Ly8gYWNjb3JkaW5nICdpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQnIG9wdGlvblxyXG5cdFx0Y29uc3QgcHJldmVudERlZmF1bHQgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoLnByZXZlbnREZWZhdWx0O1xyXG5cdFx0Y29uc3QgaXNQcmV2ZW50ZWQgPSAoaXNCb29sZWFuKHByZXZlbnREZWZhdWx0KSAmJiBwcmV2ZW50RGVmYXVsdCkgfHwgZmFsc2U7XHJcblx0XHRjb25zdCBwcmV2ZW50VGhyZXNob2xkID0gKCFpc05hTihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IG51bGw7XHJcblx0XHRsZXQgc3RhcnRQeDtcclxuXHJcblx0XHRjb25zdCBwcmV2ZW50RXZlbnQgPSBldmVudCA9PiB7XHJcblx0XHRcdGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XHJcblx0XHRcdGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHRcdGNvbnN0IGN1cnJlbnRYWSA9IHRvdWNoW2BjbGllbnQke2NvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIllcIiA6IFwiWFwifWBdO1xyXG5cclxuXHRcdFx0Ly8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmdcclxuXHRcdFx0aWYgKGV2ZW50VHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcclxuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQpIHtcclxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChwcmV2ZW50VGhyZXNob2xkICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRzdGFydFB4ID0gY3VycmVudFhZO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChldmVudFR5cGUgPT09IFwidG91Y2htb3ZlXCIpIHtcclxuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQgfHwgc3RhcnRQeCA9PT0gdHJ1ZSB8fCAoXHJcblx0XHRcdFx0XHRwcmV2ZW50VGhyZXNob2xkICE9PSBudWxsICYmIE1hdGguYWJzKHN0YXJ0UHggLSBjdXJyZW50WFkpID49IHByZXZlbnRUaHJlc2hvbGRcclxuXHRcdFx0XHQpKSB7XHJcblx0XHRcdFx0XHQvLyBvbmNlIHByZXZlbnRlZCwga2VlcCBwcmV2ZW50ZWQgZHVyaW5nIHdob2xlICd0b3VjaG1vdmUnIGNvbnRleHRcclxuXHRcdFx0XHRcdHN0YXJ0UHggPSB0cnVlO1xyXG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gYmluZCB0b3VjaCBldmVudHNcclxuXHRcdHN2Z1xyXG5cdFx0XHQub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdCB0b3VjaG1vdmUuZXZlbnRSZWN0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHJcblx0XHRcdFx0aWYgKCFldmVudFJlY3QuZW1wdHkoKSAmJiBldmVudFJlY3QuY2xhc3NlZChDTEFTUy5ldmVudFJlY3QpKSB7XHJcblx0XHRcdFx0XHQvLyBpZiB0b3VjaCBwb2ludHMgYXJlID4gMSwgbWVhbnMgZG9pbmcgem9vbWluZyBpbnRlcmFjdGlvbi4gSW4gdGhpcyBjYXNlIGRvIG5vdCBleGVjdXRlIHRvb2x0aXAgY29kZXMuXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkgfHwgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwcmV2ZW50RXZlbnQoZXZlbnQpO1xyXG5cdFx0XHRcdFx0c2VsZWN0UmVjdCh0aGlzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0cnVlKVxyXG5cdFx0XHQub24oXCJ0b3VjaGVuZC5ldmVudFJlY3RcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcclxuXHRcdFx0XHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgISQkLnRvZ2dsZVNoYXBlIHx8IHN0YXRlLmNhbmNlbENsaWNrKSB7XHJcblx0XHRcdFx0XHRcdHN0YXRlLmNhbmNlbENsaWNrICYmIChzdGF0ZS5jYW5jZWxDbGljayA9IGZhbHNlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGxvY2F0aW9uIGFuZCBzaXplIG9mIHRoZSBldmVudFJlY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKi9cclxuXHR1cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB4U2NhbGUgPSBzY2FsZS56b29tIHx8IHNjYWxlLng7XHJcblx0XHRjb25zdCBldmVudFJlY3REYXRhID0gZXZlbnRSZWN0VXBkYXRlIHx8ICQkLiRlbC5ldmVudFJlY3QuZGF0YSgpOyAvLyBzZXQgdXBkYXRlIHNlbGVjdGlvbiBpZiBudWxsXHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IHg7XHJcblx0XHRsZXQgeTtcclxuXHRcdGxldCB3O1xyXG5cdFx0bGV0IGg7XHJcblxyXG5cdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcclxuXHRcdFx0Ly8gVE9ETzogcm90YXRlZCBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHR4ID0gMDtcclxuXHRcdFx0eSA9IDA7XHJcblx0XHRcdHcgPSBzdGF0ZS53aWR0aDtcclxuXHRcdFx0aCA9IHN0YXRlLmhlaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCByZWN0VztcclxuXHRcdFx0bGV0IHJlY3RYO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRcdHJlY3RXID0gJCQuZ2V0RXZlbnRSZWN0V2lkdGgoKTtcclxuXHRcdFx0XHRyZWN0WCA9IGQgPT4geFNjYWxlKGQueCkgLSAocmVjdFcgLyAyKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBnZXRQcmV2TmV4dFggPSBkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZC5pbmRleDtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRwcmV2OiAkJC5nZXRQcmV2WChpbmRleCksXHJcblx0XHRcdFx0XHRcdG5leHQ6ICQkLmdldE5leHRYKGluZGV4KVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZWN0VyA9IGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGdldFByZXZOZXh0WChkKTtcclxuXHJcblx0XHRcdFx0XHQvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgbWFrZSB0aGUgZXZlbnRSZWN0IGZ1bGwgd2lkdGggKG9yIGhlaWdodClcclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBpc1JvdGF0ZWQgPyBzdGF0ZS5oZWlnaHQgOiBzdGF0ZS53aWR0aDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHgucHJldiA9IHhTY2FsZS5kb21haW4oKVswXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeC5uZXh0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHgubmV4dCA9IHhTY2FsZS5kb21haW4oKVsxXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgKHhTY2FsZSh4Lm5leHQpIC0geFNjYWxlKHgucHJldikpIC8gMik7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmVjdFggPSBkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XHJcblx0XHRcdFx0XHRjb25zdCB0aGlzWCA9IGQueDtcclxuXHJcblx0XHRcdFx0XHQvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgcG9zaXRpb24gdGhlIGV2ZW50UmVjdCBhdCAwXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsICYmIHgubmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHgucHJldiA9IHhTY2FsZS5kb21haW4oKVswXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gKHhTY2FsZSh0aGlzWCkgKyB4U2NhbGUoeC5wcmV2KSkgLyAyO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogcmVjdFg7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyByZWN0WCA6IDA7XHJcblx0XHRcdHcgPSBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IHJlY3RXO1xyXG5cdFx0XHRoID0gaXNSb3RhdGVkID8gcmVjdFcgOiBzdGF0ZS5oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZXZlbnRSZWN0RGF0YS5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHgpXHJcblx0XHRcdC5hdHRyKFwieVwiLCB5KVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIHcpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGgpO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdFJlY3RGb3JTaW5nbGUoY29udGV4dCwgZXZlbnRSZWN0LCBpbmRleCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1NlbGVjdGlvbkVuYWJsZWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDtcclxuXHRcdGNvbnN0IGlzU2VsZWN0aW9uR3JvdXBlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkO1xyXG5cdFx0Y29uc3QgaXNUb29sdGlwR3JvdXBlZCA9IGNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XHJcblx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSAkJC5nZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KTtcclxuXHJcblx0XHRpZiAoaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xyXG5cdFx0XHQkJC5zaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHRpZiAoIWlzU2VsZWN0aW9uRW5hYmxlZCB8fCBpc1NlbGVjdGlvbkdyb3VwZWQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7aW5kZXh9YClcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQpIHtcclxuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBpc1NlbGVjdGlvbkdyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdFx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHRcdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xyXG5cclxuXHRcdFx0XHRcdCFpc1NlbGVjdGlvbkdyb3VwZWQgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKHNlbGVjdGVkID0+IHtcclxuXHRcdFx0XHRjb25zdCBkID0gc2VsZWN0ZWQuZGF0YSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNTZWxlY3Rpb25FbmFibGVkICYmIChpc1NlbGVjdGlvbkdyb3VwZWQgfHwgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkpKSB7XHJcblx0XHRcdFx0XHRldmVudFJlY3Quc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChkLCBjb250ZXh0KTtcclxuXHRcdFx0XHRcdCQkLnNob3dHcmlkRm9jdXMoZCk7XHJcblxyXG5cdFx0XHRcdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHRcdFx0XHRzZWxlY3RlZC5lYWNoKGQgPT4gJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgsIGQuaWQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBpZCwgcmVzZXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Y29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkICYmXHJcblx0XHRcdCQkLmV4cGFuZENpcmNsZXMoaW5kZXgsIGlkLCByZXNldCk7XHJcblxyXG5cdFx0JCQuZXhwYW5kQmFycyhpbmRleCwgaWQsIHJlc2V0KTtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gZG8gbm90aGluZyB3aGVuIGRyYWdnaW5nXHJcblx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKGNvbnRleHQpO1xyXG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5tb3VzZW92ZXIgJiYgKCFjbG9zZXN0IHx8IGNsb3Nlc3QuaWQgIT09IHN0YXRlLm1vdXNlb3Zlci5pZCkpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfb25vdXQuY2FsbCgkJC5hcGksIHN0YXRlLm1vdXNlb3Zlcik7XHJcblx0XHRcdHN0YXRlLm1vdXNlb3ZlciA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNsb3Nlc3QpIHtcclxuXHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzYW1lWERhdGEgPSAoXHJcblx0XHRcdCQkLmlzQnViYmxlVHlwZShjbG9zZXN0KSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGNsb3Nlc3QpIHx8ICFjb25maWcudG9vbHRpcF9ncm91cGVkXHJcblx0XHQpID8gW2Nsb3Nlc3RdIDogJCQuZmlsdGVyQnlYKHRhcmdldHNUb1Nob3csIGNsb3Nlc3QueCk7XHJcblxyXG5cdFx0Ly8gc2hvdyB0b29sdGlwIHdoZW4gY3Vyc29yIGlzIGNsb3NlIHRvIHNvbWUgcG9pbnRcclxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IHNhbWVYRGF0YS5tYXAoZCA9PiAkJC5hZGROYW1lKGQpKTtcclxuXHJcblx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xyXG5cclxuXHRcdC8vIGV4cGFuZCBwb2ludHNcclxuXHRcdCQkLmV4cGFuZENpcmNsZXNCYXJzKGNsb3Nlc3QuaW5kZXgsIGNsb3Nlc3QuaWQsIHRydWUpO1xyXG5cclxuXHRcdC8vIFNob3cgeGdyaWQgZm9jdXMgbGluZVxyXG5cdFx0JCQuc2hvd0dyaWRGb2N1cyhzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdC8vIFNob3cgY3Vyc29yIGFzIHBvaW50ZXIgaWYgcG9pbnQgaXMgY2xvc2UgdG8gbW91c2UgcG9zaXRpb25cclxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0JCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XHJcblxyXG5cdFx0XHRpZiAoIXN0YXRlLm1vdXNlb3Zlcikge1xyXG5cdFx0XHRcdGNvbmZpZy5kYXRhX29ub3Zlci5jYWxsKCQkLmFwaSwgY2xvc2VzdCk7XHJcblx0XHRcdFx0c3RhdGUubW91c2VvdmVyID0gY2xvc2VzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuc2VsZWN0IEV2ZW50UmVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UmVjdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnN0eWxlKFwiY3Vyc29yXCIsIG51bGwpO1xyXG5cdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0JCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdCQkLl9oYW5kbGVMaW5rZWRDaGFydHMoZmFsc2UpO1xyXG5cdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHQkJC51bmV4cGFuZEJhcnMoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgZXZlbnRSZWN0IGZvciBlYWNoIGRhdGEgb24gdGhlIHgtYXhpcy5cclxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0RW50ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlci5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gXCJwb2ludGVyXCIgOiBudWxsKVxyXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yU2luZ2xlWC5iaW5kKHRoaXMpKGQsICQkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xyXG5cdFx0XHRyZWN0XHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGQgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbmZpZy50b29sdGlwX2dyb3VwZWQgJiYgJCQuc2V0T3Zlck91dCh0cnVlLCBkLmluZGV4KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5kcmFnZ2luZyB8fCBzdGF0ZS5mbG93aW5nIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gZC5pbmRleDtcclxuXHRcdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9LSR7aW5kZXh9YCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkgJiZcclxuXHRcdFx0XHRcdFx0Y29uZmlnLmxpbmVfc3RlcF90eXBlID09PSBcInN0ZXAtYWZ0ZXJcIiAmJlxyXG5cdFx0XHRcdFx0XHRkM01vdXNlKHRoaXMpWzBdIDwgJCQuc2NhbGUueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKVxyXG5cdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdGluZGV4IC09IDE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW5kZXggPT09IC0xID9cclxuXHRcdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOiAkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKHRoaXMsIGV2ZW50UmVjdCwgaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEFzIG9mIGluZGl2aWR1YWwgZGF0YSBwb2ludChvciA8cGF0aD4pIGVsZW1lbnQgY2FuJ3QgYmluZCBtb3VzZW92ZXIvb3V0IGV2ZW50XHJcblx0XHRcdFx0XHQvLyB0byBkZXRlcm1pbmUgY3VycmVudCBpbnRlcmFjdGluZyBlbGVtZW50LCBzbyB1c2UgJ21vdXNlbW92ZScgZXZlbnQgaW5zdGVhZC5cclxuXHRcdFx0XHRcdGlmICghY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGluZGV4ICE9PSAtMSwgZC5pbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxyXG5cdFx0XHRcdFx0aWYgKCFjb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGQuaW5kZXgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdGNsaWNrSGFuZGxlckZvclNpbmdsZVgoZCwgY3R4KSB7XHJcblx0XHRjb25zdCAkJCA9IGN0eDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCBzdGF0ZS5jYW5jZWxDbGljaykge1xyXG5cdFx0XHRzdGF0ZS5jYW5jZWxDbGljayAmJiAoc3RhdGUuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qge2luZGV4fSA9IGQ7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQyKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICQkLmlzV2l0aGluU2hhcGUodGhpcywgZDIpKSB7XHJcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBkMiwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5iaW5kKCQkLmFwaSkoZDIsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGFuIGV2ZW50UmVjdCxcclxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0RW50ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBpbnB1dFR5cGV9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0Y29uc3QgcmVjdCA9IGV2ZW50UmVjdEVudGVyXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgMClcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdClcclxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUy5iaW5kKHRoaXMpKCQkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xyXG5cclxuXHRcdGlmIChpbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xyXG5cdFx0XHRyZWN0XHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyIG1vdXNlbW92ZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKHRoaXMpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gY2hhcnQgaXMgZGVzdHJveWVkXHJcblx0XHRcdFx0XHRpZiAoISQkLmNvbmZpZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdGNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMoY3R4KSB7XHJcblx0XHRjb25zdCAkJCA9IGN0eDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UodGhpcyk7XHJcblx0XHRjb25zdCBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XHJcblxyXG5cdFx0aWYgKCFjbG9zZXN0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgaWYgc2VsZWN0aW9uIGVuYWJsZWRcclxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0JCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChjbG9zZXN0LmlkKX1gKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2Nsb3Nlc3QuaW5kZXh9YClcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGNsb3Nlc3QpKSB7XHJcblx0XHRcdFx0XHRcdCQkLnRvZ2dsZVNoYXBlKHRoaXMsIGNsb3Nlc3QsIGNsb3Nlc3QuaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRjb25maWcuZGF0YV9vbmNsaWNrLmJpbmQoJCQuYXBpKShjbG9zZXN0LCB0aGlzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtcclxuXHRicnVzaFggYXMgZDNCcnVzaFgsXHJcblx0YnJ1c2hZIGFzIGQzQnJ1c2hZLFxyXG5cdGJydXNoU2VsZWN0aW9uIGFzIGQzQnJ1c2hTZWxlY3Rpb25cclxufSBmcm9tIFwiZDMtYnJ1c2hcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2JydXNoRW1wdHksIGNhcGl0YWxpemUsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGdldFJhbmRvbSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBicnVzaC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCcnVzaCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCAkZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdC8vIHNldCB0aGUgYnJ1c2hcclxuXHRcdCQkLmJydXNoID0gaXNSb3RhdGVkID8gZDNCcnVzaFkoKSA6IGQzQnJ1c2hYKCk7XHJcblxyXG5cdFx0Ly8gc2V0IFwiYnJ1c2hcIiBldmVudFxyXG5cdFx0Y29uc3QgYnJ1c2hIYW5kbGVyID0gKCkgPT4ge1xyXG5cdFx0XHQkJC5yZWRyYXdGb3JCcnVzaCgpO1xyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGdldEJydXNoU2l6ZSA9ICgpID0+IHtcclxuXHRcdFx0Y29uc3QgYnJ1c2ggPSAkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9IC5vdmVybGF5YCk7XHJcblx0XHRcdGNvbnN0IGJydXNoU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcclxuXHJcblx0XHRcdGlmIChicnVzaC5zaXplKCkpIHtcclxuXHRcdFx0XHRicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpO1xyXG5cdFx0XHRcdGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGJydXNoU2l6ZVtpc1JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXTtcclxuXHRcdH07XHJcblxyXG5cdFx0bGV0IGxhc3REb21haW47XHJcblx0XHRsZXQgdGltZW91dDtcclxuXHJcblx0XHQkJC5icnVzaFxyXG5cdFx0XHQub24oXCJzdGFydFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0JCQuc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgJCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0XHRicnVzaEhhbmRsZXIoKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKFwiYnJ1c2hcIiwgYnJ1c2hIYW5kbGVyKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdGxhc3REb21haW4gPSBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQkJC5icnVzaC51cGRhdGVSZXNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdFx0XHRsYXN0RG9tYWluICYmIGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uLm5vZGUoKSkgJiZcclxuXHRcdFx0XHRcdHRoaXMubW92ZShzZWxlY3Rpb24sIGxhc3REb21haW4ubWFwKHNjYWxlLnN1Ylgub3JnU2NhbGUoKSkpO1xyXG5cdFx0XHR9LCAwKTtcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuYnJ1c2gudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMuZXh0ZW50KCkoKTtcclxuXHJcblx0XHRcdGlmIChleHRlbnRbMV0uZmlsdGVyKHYgPT4gaXNOYU4odikpLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHN1YmNoYXJ0Lm1haW4gJiYgc3ViY2hhcnQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLmNhbGwodGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGJydXNoIGV4dGVudFxyXG5cdFx0JCQuYnJ1c2guc2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xyXG5cdFx0XHRjb25zdCBoID0gY29uZmlnLnN1YmNoYXJ0X3NpemVfaGVpZ2h0IHx8IGdldEJydXNoU2l6ZSgpO1xyXG5cdFx0XHRsZXQgZXh0ZW50ID0gJCQuZ2V0RXh0ZW50KCk7XHJcblxyXG5cdFx0XHRpZiAoIWV4dGVudCAmJiBzY2FsZS5yYW5nZSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IFtbMCwgMF0sIFtzY2FsZS5yYW5nZSgpWzFdLCBoXV07XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShleHRlbnQpKSB7XHJcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50Lm1hcCgodiwgaSkgPT4gW3YsIGkgPiAwID8gaCA6IGldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gW1t4MCwgeTBdLCBbeDEsIHkxXV0sIHdoZXJlIFt4MCwgeTBdIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgYW5kIFt4MSwgeTFdIGlzIHRoZSBib3R0b20tcmlnaHQgY29ybmVyXHJcblx0XHRcdGlzUm90YXRlZCAmJiBleHRlbnRbMV0ucmV2ZXJzZSgpO1xyXG5cdFx0XHR0aGlzLmV4dGVudChleHRlbnQpO1xyXG5cclxuXHRcdFx0Ly8gd2hlbiBleHRlbnQgdXBkYXRlcywgYnJ1c2ggc2VsZWN0aW9uIGFsc28gYmUgcmUtYXBwbGllZFxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvaXNzdWVzLzI5MThcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uID0gKCkgPT4gKFxyXG5cdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdHN1YmNoYXJ0Lm1haW4gPyBzdWJjaGFydC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9YCkgOiBkM1NlbGVjdChbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgc3ViY2hhcnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0U3ViY2hhcnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCEkJC5oYXNBeGlzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXB9LCAkZWw6IHtkZWZzLCBzdmcsIHN1YmNoYXJ0LCBheGlzfX0gPSAkJDtcclxuXHRcdGNvbnN0IHZpc2liaWxpdHkgPSBjb25maWcuc3ViY2hhcnRfc2hvdyA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcclxuXHRcdGNvbnN0IGNsaXBJZCA9IGAke2NsaXAuaWR9LXN1YmNoYXJ0YDtcclxuXHRcdGNvbnN0IGNsaXBQYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcElkKTtcclxuXHJcblx0XHRjbGlwLmlkU3ViY2hhcnQgPSBjbGlwSWQ7XHJcblx0XHQkJC5hcHBlbmRDbGlwKGRlZnMsIGNsaXBJZCk7XHJcblx0XHQkJC5pbml0QnJ1c2goKTtcclxuXHJcblx0XHRzdWJjaGFydC5tYWluID0gc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJjb250ZXh0XCIpKTtcclxuXHJcblx0XHRjb25zdCB7bWFpbn0gPSBzdWJjaGFydDtcclxuXHJcblx0XHRtYWluLnN0eWxlKFwidmlzaWJpbGl0eVwiLCB2aXNpYmlsaXR5KTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0KTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgYmFyIGNoYXJ0IGFyZWFcclxuXHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgbGluZSBjaGFydCBhcmVhXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcclxuXHJcblx0XHQvLyBBZGQgZXh0ZW50IHJlY3QgZm9yIEJydXNoXHJcblx0XHRtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYnJ1c2gpXHJcblx0XHRcdC5jYWxsKCQkLmJydXNoKTtcclxuXHJcblx0XHQvLyBBVFRFTlRJT046IFRoaXMgbXVzdCBiZSBjYWxsZWQgQUZURVIgY2hhcnQgYWRkZWRcclxuXHRcdC8vIEFkZCBBeGlzXHJcblx0XHRheGlzLnN1YlggPSBtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzWClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwic3ViWFwiKSlcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiBjbGlwLnBhdGhYQXhpcylcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcuc3ViY2hhcnRfYXhpc194X3Nob3cgPyB2aXNpYmlsaXR5IDogXCJoaWRkZW5cIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHN1YiBjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9ICQkLmRhdGEudGFyZ2V0c1xyXG5cdCAqL1xyXG5cdHVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7c3ViY2hhcnQ6IHttYWlufX19ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xyXG5cdFx0XHQvLyAtLSBCYXIgLS0vL1xyXG5cdFx0XHRjb25zdCBiYXJVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcik7XHJcblx0XHRcdGNvbnN0IGJhckVudGVyID0gYmFyVXBkYXRlLmVudGVyKClcclxuXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxyXG5cdFx0XHRcdC5tZXJnZShiYXJVcGRhdGUpO1xyXG5cclxuXHRcdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXHJcblx0XHRcdGJhckVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycyk7XHJcblxyXG5cdFx0XHQvLyAtLSBMaW5lIC0tLy9cclxuXHRcdFx0Y29uc3QgbGluZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRMaW5lfWApXHJcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKTtcclxuXHRcdFx0Y29uc3QgbGluZUVudGVyID0gbGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdFx0Lm1lcmdlKGxpbmVVcGRhdGUpO1xyXG5cclxuXHRcdFx0Ly8gTGluZXMgZm9yIGVhY2ggZGF0YVxyXG5cdFx0XHRsaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XHJcblxyXG5cdFx0XHQvLyBBcmVhXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJhcmVhXCIpICYmIGxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcclxuXHJcblx0XHRcdC8vIC0tIEJydXNoIC0tLy9cclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJydXNofSByZWN0YClcclxuXHRcdFx0XHQuYXR0cihjb25maWcuYXhpc19yb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IHN0YXRlLndpZHRoMiA6IHN0YXRlLmhlaWdodDIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkdXJhdGlvbkZvckV4aXRcclxuXHQgKi9cclxuXHR1cGRhdGVCYXJGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblxyXG5cdFx0c3ViY2hhcnQuYmFyID0gc3ViY2hhcnQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9YClcclxuXHRcdFx0LmRhdGEoJCQuYmFyRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYmFyXHJcblx0XHRcdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYmFyID0gc3ViY2hhcnQuYmFyXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NCYXIuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBcIm5vbmVcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmJhcilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBiYXIgb2YgdGhlIHN1YmNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBpbiBzdWJjaGFydCBiYXJcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHRyZWRyYXdCYXJGb3JTdWJjaGFydChkcmF3QmFyT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xyXG5cdFx0Y29uc3Qge2Jhcn0gPSB0aGlzLiRlbC5zdWJjaGFydDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBiYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogYmFyKVxyXG5cdFx0XHQuYXR0cihcImRcIiwgZHJhd0Jhck9uU3ViKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxpbmUgb2YgdGhlIHN1YiBjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHR1cGRhdGVMaW5lRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmxpbmUgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZVxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmxpbmUgPSBzdWJjaGFydC5saW5lXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NMaW5lLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5tZXJnZShzdWJjaGFydC5saW5lKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGxpbmUgb2YgdGhlIHN1YmNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBpbiBzdWJjaGFydCBsaW5lXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHRyZWRyYXdMaW5lRm9yU3ViY2hhcnQoZHJhd0xpbmVPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCB7bGluZX0gPSB0aGlzLiRlbC5zdWJjaGFydDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBsaW5lLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGxpbmUpXHJcblx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3TGluZU9uU3ViKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGFyZWEgb2YgdGhlIHN1YiBjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHR1cGRhdGVBcmVhRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmFyZWEgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYVxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmFyZWEgPSBzdWJjaGFydC5hcmVhXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnN0YXRlLm9yZ0FyZWFPcGFjaXR5ID0gZDNTZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpO1xyXG5cdFx0XHRcdHJldHVybiBcIjBcIjtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmFyZWEpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cdH0sXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBhcmVhIG9mIHRoZSBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3QXJlYUZvclN1YmNoYXJ0KGRyYXdBcmVhT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xyXG5cdFx0Y29uc3Qge2FyZWF9ID0gdGhpcy4kZWwuc3ViY2hhcnQ7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gYXJlYS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOiBhcmVhKVxyXG5cdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWFPblN1YilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIHRoaXMuc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyBzdWJjaGFydC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFN1YmNoYXJ0IHdoZXRoZXIgb3Igbm90IHRvIHNob3cgc3ViY2hhcnRcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gZHVyYXRpb25cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2hhcGUgU2hhcGUncyBpbmZvXHJcblx0ICovXHJcblx0cmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0LCBkdXJhdGlvbiwgc2hhcGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3N1YmNoYXJ0OiB7bWFpbn19fSA9ICQkO1xyXG5cclxuXHRcdG1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcclxuXHJcblx0XHQvLyBzdWJjaGFydFxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdC8vIHJlZmxlY3QgbWFpbiBjaGFydCB0byBleHRlbnQgb24gc3ViY2hhcnQgaWYgem9vbWVkXHJcblx0XHRcdGlmIChkM0V2ZW50ICYmIGQzRXZlbnQudHlwZSA9PT0gXCJ6b29tXCIpIHtcclxuXHRcdFx0XHQkJC5icnVzaC51cGRhdGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHN1YmNoYXJ0IGVsZW1lbnRzIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAod2l0aFN1YmNoYXJ0KSB7XHJcblx0XHRcdFx0Ly8gZXh0ZW50IHJlY3RcclxuXHRcdFx0XHQhYnJ1c2hFbXB0eSgkJCkgJiYgJCQuYnJ1c2gudXBkYXRlKCk7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHNoYXBlLnR5cGUpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gY2FwaXRhbGl6ZSh2KTtcclxuXHRcdFx0XHRcdGNvbnN0IGRyYXcgPSAkJFtgZ2VuZXJhdGVEcmF3JHtuYW1lfWBdKHNoYXBlLmluZGljZXNbdl0sIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdCQkW2B1cGRhdGUke25hbWV9Rm9yU3ViY2hhcnRgXShkdXJhdGlvbik7XHJcblx0XHRcdFx0XHQkJFtgcmVkcmF3JHtuYW1lfUZvclN1YmNoYXJ0YF0oZHJhdywgZHVyYXRpb24sIGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYnJ1c2guXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdGb3JCcnVzaCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWc6IHtzdWJjaGFydF9vbmJydXNoLCB6b29tX3Jlc2NhbGU6IHdpdGhZfSwgc2NhbGV9ID0gJCQ7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoWSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHRzdWJjaGFydF9vbmJydXNoLmJpbmQoJCQuYXBpKShzY2FsZS54Lm9yZ0RvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gY29udGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmRpY2F0ZXMgdHJhbnNpdGlvbiBpcyBlbmFibGVkXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGdlbmVyYXRlVHJhbnNpdGlvbnMgbWV0aG9kIG9mIEF4aXMuXHJcblx0ICovXHJcblx0dHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbC5zdWJjaGFydDtcclxuXHRcdGxldCBzdWJYQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1N1YlgpIHtcclxuXHRcdFx0c3ViWEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzU3ViWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1YlhBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0c3ViWEF4aXMgPSBzdWJYQXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtYWluLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblx0XHRzdWJYQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YlhcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBleHRlbnQgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZGVmYXVsdCBleHRlbnRcclxuXHQgKi9cclxuXHRnZXRFeHRlbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGxldCBleHRlbnQgPSBjb25maWcuYXhpc194X2V4dGVudDtcclxuXHJcblx0XHRpZiAoZXh0ZW50KSB7XHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGV4dGVudCkpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQuYmluZCgkJC5hcGkpKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSwgc2NhbGUuc3ViWCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNUaW1lU2VyaWVzKCkgJiYgZXh0ZW50LmV2ZXJ5KGlzTmFOKSkge1xyXG5cdFx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKHYgPT4gc2NhbGUuc3ViWChmbih2KSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4dGVudDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdGV2ZW50IGFzIGQzRXZlbnQsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xyXG5pbXBvcnQge3pvb20gYXMgZDNab29tfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgZGlmZkRvbWFpbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzRnVuY3Rpb259IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgem9vbS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRab29tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlWm9vbSgpO1xyXG5cdFx0JCQuaW5pdFpvb21CZWhhdmlvdXIoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBCaW5kIHpvb20gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRab29tRXZlbnQoYmluZCA9IHRydWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xyXG5cclxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcclxuXHJcblx0XHRpZiAoem9vbUVuYWJsZWQgJiYgYmluZCkge1xyXG5cdFx0XHQvLyBEbyBub3QgYmluZCB6b29tIGV2ZW50IHdoZW4gc3ViY2hhcnQgaXMgc2hvd25cclxuXHRcdFx0IWNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdFx0JCQuYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB6b29tRW5hYmxlZC50eXBlKTtcclxuXHRcdH0gZWxzZSBpZiAoYmluZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYXBpLnVuem9vbSgpO1xyXG5cclxuXHRcdFx0ZXZlbnRSZWN0c1xyXG5cdFx0XHRcdC5vbihcIi56b29tXCIsIG51bGwpXHJcblx0XHRcdFx0Lm9uKFwiLmRyYWdcIiwgbnVsbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVab29tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnLCBzY2FsZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB6b29tID0gZDNab29tKCkuZHVyYXRpb24oMClcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgJCQub25ab29tU3RhcnQuYmluZCgkJCkpXHJcblx0XHRcdC5vbihcInpvb21cIiwgJCQub25ab29tLmJpbmQoJCQpKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgJCQub25ab29tRW5kLmJpbmQoJCQpKTtcclxuXHJcblx0XHQvLyBnZXQgem9vbSBleHRlbnRcclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20ub3JnU2NhbGVFeHRlbnQgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IGNvbmZpZy56b29tX2V4dGVudCB8fCBbMSwgMTBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtleHRlbnRbMF0sIE1hdGgubWF4KCQkLmdldE1heERhdGFDb3VudCgpIC8gZXh0ZW50WzFdLCBleHRlbnRbMV0pXTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS51cGRhdGVTY2FsZUV4dGVudCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCByYXRpbyA9IGRpZmZEb21haW4oJCQuc2NhbGUueC5vcmdEb21haW4oKSkgLyBkaWZmRG9tYWluKCQkLmdldFpvb21Eb21haW4oKSk7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSA9IHRyYW5zZm9ybSA9PiB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgcmVzaXplLCB1cGRhdGUgcmFuZ2Ugb2Ygb3JnWFNjYWxlXHJcblx0XHRcdG9yZy54U2NhbGUgJiYgb3JnLnhTY2FsZS5yYW5nZShzY2FsZS54LnJhbmdlKCkpO1xyXG5cclxuXHRcdFx0Ly8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxyXG5cdFx0XHRjb25zdCBuZXdTY2FsZSA9IHRyYW5zZm9ybVtcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJyZXNjYWxlWVwiIDogXCJyZXNjYWxlWFwiXHJcblx0XHRcdF0ob3JnLnhTY2FsZSB8fCBzY2FsZS54KTtcclxuXHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9ICQkLnRyaW1YRG9tYWluKG5ld1NjYWxlLmRvbWFpbigpKTtcclxuXHRcdFx0Y29uc3QgcmVzY2FsZSA9IGNvbmZpZy56b29tX3Jlc2NhbGU7XHJcblxyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4oZG9tYWluLCBvcmcueERvbWFpbik7XHJcblxyXG5cdFx0XHRzY2FsZS56b29tID0gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKG5ld1NjYWxlKTtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0aWYgKHJlc2NhbGUpIHtcclxuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgaW5pdGlhbCB4IHNjYWxlIGluIGNhc2Ugb2YgcmVzY2FsZSBvcHRpb24gaXMgdXNlZFxyXG5cdFx0XHRcdCFvcmcueFNjYWxlICYmIChvcmcueFNjYWxlID0gc2NhbGUueC5jb3B5KCkpO1xyXG5cdFx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbSA9IHpvb207XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ3N0YXJ0JyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tU3RhcnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFldmVudCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuem9vbS5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tc3RhcnQsICQkLmFwaSwgZXZlbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICd6b29tJyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIG9yZ30gPSAkJDtcclxuXHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHRcdGNvbnN0IHtzb3VyY2VFdmVudH0gPSBldmVudDtcclxuXHJcblx0XHRpZiAoXHJcblx0XHRcdCFjb25maWcuem9vbV9lbmFibGVkIHx8XHJcblx0XHRcdCFldmVudC5zb3VyY2VFdmVudCB8fFxyXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoID09PSAwIHx8XHJcblx0XHRcdCghc2NhbGUuem9vbSAmJiBzb3VyY2VFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xICYmIHNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc01vdXNlbW92ZSA9IHNvdXJjZUV2ZW50LnR5cGUgPT09IFwibW91c2Vtb3ZlXCI7XHJcblx0XHRjb25zdCBpc1pvb21PdXQgPSBzb3VyY2VFdmVudC53aGVlbERlbHRhIDwgMDtcclxuXHRcdGNvbnN0IHt0cmFuc2Zvcm19ID0gZXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFpc01vdXNlbW92ZSAmJiBpc1pvb21PdXQgJiYgc2NhbGUueC5kb21haW4oKS5ldmVyeSgodiwgaSkgPT4gdiAhPT0gb3JnLnhEb21haW5baV0pKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKG9yZy54RG9tYWluKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKHRyYW5zZm9ybSk7XHJcblxyXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiBzY2FsZS54Lm9yZ0RvbWFpbigpWzBdID09PSBvcmcueERvbWFpblswXSkge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihbb3JnLnhEb21haW5bMF0gLSAxZS0xMCwgc2NhbGUueC5vcmdEb21haW4oKVsxXV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcclxuXHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXHJcblx0XHRcdHdpdGhTdWJjaGFydDogZmFsc2UsXHJcblx0XHRcdHdpdGhFdmVudFJlY3Q6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRGltZW5zaW9uOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0JCQuc3RhdGUuY2FuY2VsQ2xpY2sgPSBpc01vdXNlbW92ZTtcclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb20sICQkLmFwaSwgc2NhbGUuem9vbS5kb21haW4oKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ2VuZCcgZXZlbnQgbGlzdGVuZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uWm9vbUVuZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0bGV0IHtzdGFydEV2ZW50fSA9ICQkLnpvb207XHJcblx0XHRsZXQgZXZlbnQgPSBkM0V2ZW50ICYmIGQzRXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKChzdGFydEV2ZW50ICYmIHN0YXJ0RXZlbnQudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMSkpIHtcclxuXHRcdFx0c3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHRcdGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgY2xpY2ssIGRvIG5vdGhpbmcuIG90aGVyd2lzZSwgY2xpY2sgaW50ZXJhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cclxuXHRcdGlmICghc3RhcnRFdmVudCB8fFxyXG5cdFx0XHQoZXZlbnQgJiYgc3RhcnRFdmVudC5jbGllbnRYID09PSBldmVudC5jbGllbnRYICYmIHN0YXJ0RXZlbnQuY2xpZW50WSA9PT0gZXZlbnQuY2xpZW50WSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVkcmF3RXZlbnRSZWN0KCk7XHJcblx0XHQkJC51cGRhdGVab29tKCk7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbWVuZCwgJCQuYXBpLCBzY2FsZVtzY2FsZS56b29tID8gXCJ6b29tXCIgOiBcInN1YlhcIl0uZG9tYWluKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB6b29tIGRvbWFpblxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gem9vbSBkb21haW5cclxuIFx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRab29tRG9tYWluKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnfSA9ICQkO1xyXG5cdFx0bGV0IFttaW4sIG1heF0gPSBvcmcueERvbWFpbjtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWluKSkge1xyXG5cdFx0XHRtaW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW21pbiwgY29uZmlnLnpvb21feF9taW5dKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWF4KSkge1xyXG5cdFx0XHRtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgW21heCwgY29uZmlnLnpvb21feF9tYXhdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW21pbiwgbWF4XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgem9vbVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2UgdW56b29tXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVab29tKGZvcmNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQge3N1YlgsIHgsIHpvb219ID0gJCQuc2NhbGU7XHJcblxyXG5cdFx0aWYgKHpvb20pIHtcclxuXHRcdFx0Y29uc3Qgem9vbURvbWFpbiA9IHpvb20uZG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSBzdWJYLmRvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBkZWx0YSA9IDAuMDE1OyAvLyBhcmJpdHJhcnkgdmFsdWVcclxuXHJcblx0XHRcdGNvbnN0IGlzZnVsbHlTaG93biA9ICh6b29tRG9tYWluWzBdIDw9IHhEb21haW5bMF0gfHwgKHpvb21Eb21haW5bMF0gLSBkZWx0YSkgPD0geERvbWFpblswXSkgJiZcclxuXHRcdFx0XHQoeERvbWFpblsxXSA8PSB6b29tRG9tYWluWzFdIHx8IHhEb21haW5bMV0gPD0gKHpvb21Eb21haW5bMV0gLSBkZWx0YSkpO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHpvb21lZCBjaGFydCBpcyBmdWxseSBzaG93biwgdGhlbiByZXNldCBzY2FsZSB3aGVuIHpvb20gaXMgb3V0IGFzIGluaXRpYWxcclxuXHRcdFx0aWYgKGZvcmNlIHx8IGlzZnVsbHlTaG93bikge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5zY2FsZShzdWJYKTtcclxuXHRcdFx0XHR4LmRvbWFpbihzdWJYLm9yZ0RvbWFpbigpKTtcclxuXHRcdFx0XHR6b29tID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEF0dGFjaCB6b29tIGV2ZW50IG9uIDxyZWN0PlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBiZWhhdmlvdXIgPSB0eXBlID09PSBcImRyYWdcIiA/ICQkLnpvb21CZWhhdmlvdXIgOiAkJC56b29tO1xyXG5cclxuXHRcdGV2ZW50UmVjdHNcclxuXHRcdFx0LmNhbGwoYmVoYXZpb3VyKVxyXG5cdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIGRyYWcgYmVoYXZpb3VyIHVzZWQgZm9yIHpvb21pbmcuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0Wm9vbUJlaGF2aW91cigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gMDtcclxuXHRcdGxldCB6b29tUmVjdDtcclxuXHJcblx0XHRjb25zdCBwcm9wID0ge1xyXG5cdFx0XHRheGlzOiBpc1JvdGF0ZWQgPyBcInlcIiA6IFwieFwiLFxyXG5cdFx0XHRhdHRyOiBpc1JvdGF0ZWQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxyXG5cdFx0XHRpbmRleDogaXNSb3RhdGVkID8gMSA6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbUJlaGF2aW91ciA9IGQzRHJhZygpXHJcblx0XHRcdC5jbGlja0Rpc3RhbmNlKDQpXHJcblx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmICghem9vbVJlY3QpIHtcclxuXHRcdFx0XHRcdHpvb21SZWN0ID0gJCQuJGVsLm1haW4uYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBzdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbUJydXNoKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogMClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0c3RhcnQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xyXG5cdFx0XHRcdGVuZCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBzdGFydClcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XHJcblxyXG5cdFx0XHRcdCQkLm9uWm9vbVN0YXJ0KCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGVuZCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIE1hdGgubWluKHN0YXJ0LCBlbmQpKVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCBNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGUuem9vbSB8fCAkJC5zY2FsZS54O1xyXG5cclxuXHRcdFx0XHQkJC5zZXREcmFnU3RhdHVzKGZhbHNlKTtcclxuXHJcblx0XHRcdFx0em9vbVJlY3RcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgMClcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XHJcblxyXG5cdFx0XHRcdGlmIChzdGFydCA+IGVuZCkge1xyXG5cdFx0XHRcdFx0W3N0YXJ0LCBlbmRdID0gW2VuZCwgc3RhcnRdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkge1xyXG5cdFx0XHRcdFx0ZW5kICs9IE1hdGguYWJzKHN0YXJ0KTtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzdGFydCAhPT0gZW5kKSB7XHJcblx0XHRcdFx0XHQkJC5hcGkuem9vbShbc3RhcnQsIGVuZF0ubWFwKHYgPT4gc2NhbGUuaW52ZXJ0KHYpKSk7XHJcblx0XHRcdFx0XHQkJC5vblpvb21FbmQoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcclxuXHRcdFx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUy5iaW5kKHRoaXMpKCQkKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudC5zb3VyY2VFdmVudCB8fCBkM0V2ZW50O1xyXG5cdFx0XHRcdFx0XHRjb25zdCBbeCwgeV0gPSBcImNsaWVudFhcIiBpbiBldmVudCA/IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXSA6IFtldmVudC54LCBldmVudC55XTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcclxuXHJcblx0XHRcdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0YXJnZXQpKGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKSwgJCQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0c2V0Wm9vbVJlc2V0QnV0dG9uKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHJlc2V0QnV0dG9uID0gY29uZmlnLnpvb21fcmVzZXRCdXR0b247XHJcblxyXG5cdFx0aWYgKHJlc2V0QnV0dG9uICYmIGNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCIpIHtcclxuXHRcdFx0aWYgKCEkJC56b29tLnJlc2V0QnRuKSB7XHJcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0biA9ICQkLiRlbC5jaGFydC5hcHBlbmQoXCJkaXZcIilcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmJ1dHRvbiwgdHJ1ZSlcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJzcGFuXCIpXHJcblx0XHRcdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0aXNGdW5jdGlvbihyZXNldEJ1dHRvbi5vbmNsaWNrKSAmJiByZXNldEJ1dHRvbi5vbmNsaWNrLmJpbmQoJCQuYXBpKSh0aGlzKTtcclxuXHRcdFx0XHRcdFx0JCQuYXBpLnVuem9vbSgpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmJ1dHRvblpvb21SZXNldCwgdHJ1ZSlcclxuXHRcdFx0XHRcdC50ZXh0KHJlc2V0QnV0dG9uLnRleHQgfHwgXCJSZXNldCBab29tXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDYXRlZ29yeSBOYW1lXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBnYXRlZ29yeSBOYW1lXHJcblx0ICovXHJcblx0Y2F0ZWdvcnlOYW1lKGkpIHtcclxuXHRcdGNvbnN0IHtheGlzX3hfY2F0ZWdvcmllczogY2F0ZWdvcmllc30gPSB0aGlzLmNvbmZpZztcclxuXHJcblx0XHRyZXR1cm4gaSA8IGNhdGVnb3JpZXMubGVuZ3RoID8gY2F0ZWdvcmllc1tpXSA6IGk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRDbGlwKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NsaXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2xpcElkIG5lZWRzIHRvIGJlIHVuaXF1ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBleGlzdFxyXG5cdFx0Y2xpcC5pZCA9IGAkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LWNsaXBgO1xyXG5cdFx0Y2xpcC5pZFhBeGlzID0gYCR7Y2xpcC5pZH0teGF4aXNgO1xyXG5cdFx0Y2xpcC5pZFlBeGlzID0gYCR7Y2xpcC5pZH0teWF4aXNgO1xyXG5cdFx0Y2xpcC5pZEdyaWQgPSBgJHtjbGlwLmlkfS1ncmlkYDtcclxuXHJcblx0XHQvLyBEZWZpbmUgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIHZhbHVlc1xyXG5cdFx0Y2xpcC5wYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZCk7XHJcblx0XHRjbGlwLnBhdGhYQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRYQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhZQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRZQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhHcmlkID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZEdyaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldENsaXBQYXRoKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcclxuXHRcdFx0KCFjb25maWcuYXhpc194X2NsaXBQYXRoICYmIC8tY2xpcC14YXhpcyQvLnRlc3QoaWQpKSB8fFxyXG5cdFx0XHQoIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XHJcblx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvblxyXG5cdFx0XHRcdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llIDkuXCIpID49IDAgOiBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gYHVybCgkeyhpc0lFOSA/IFwiXCIgOiBkb2N1bWVudC5VUkwuc3BsaXQoXCIjXCIpWzBdKX0jJHtpZH0pYDtcclxuXHR9LFxyXG5cclxuXHRhcHBlbmRDbGlwKHBhcmVudCwgaWQpIHtcclxuXHRcdHJldHVybiBwYXJlbnQuYXBwZW5kKFwiY2xpcFBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJpZFwiLCBpZClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBYKGZvckhvcml6b250YWwpIHtcclxuXHRcdGNvbnN0IHttYXJnaW59ID0gdGhpcy5zdGF0ZTtcclxuXHRcdC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLSgxICsgbGVmdCkgOiAtKGxlZnQgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcFkoZm9ySG9yaXpvbnRhbCkge1xyXG5cdFx0Y29uc3Qge21hcmdpbn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLTIwIDogLW1hcmdpbi50b3A7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwWCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYQXhpc0NsaXBZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcFgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgP1xyXG5cdFx0XHQtMSA6ICQkLmdldEF4aXNDbGlwWCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBXaWR0aChmb3JIb3Jpem9udGFsKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFyZ2luLCB3aWR0aH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cdFx0Y29uc3QgcmlnaHQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLnJpZ2h0KTtcclxuXHJcblx0XHQvLyB3aWR0aCArIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnQvcmlnaHRcclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID9cclxuXHRcdFx0d2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogbWFyZ2luLmxlZnQgKyAyMDtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsKSB7XHJcblx0XHRjb25zdCB7bWFyZ2luLCBoZWlnaHR9ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHQvLyBsZXNzIHRoYW4gMjAgaXMgbm90IGVub3VnaCB0byBzaG93IHRoZSBheGlzIGxhYmVsICdvdXRlcicgd2l0aG91dCBsZWdlbmRcclxuXHRcdHJldHVybiAoZm9ySG9yaXpvbnRhbCA/IG1hcmdpbi5ib3R0b20gOiAobWFyZ2luLnRvcCArIGhlaWdodCkpICsgMjA7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwV2lkdGgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcEhlaWdodCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcFdpZHRoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFdpZHRoKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpICsgKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAyMCA6IDApO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcEhlaWdodCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzQXJyYXksIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gR3JpZCBwb3NpdGlvbiBhbmQgdGV4dCBhbmNob3IgaGVscGVyc1xyXG5jb25zdCBnZXRHcmlkVGV4dEFuY2hvciA9IGQgPT4gaXNWYWx1ZShkLnBvc2l0aW9uKSB8fCBcImVuZFwiO1xyXG5jb25zdCBnZXRHcmlkVGV4dER4ID0gZCA9PiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiID8gNCA6IChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiID8gMCA6IC00KSk7XHJcblxyXG5mdW5jdGlvbiBnZXRHcmlkVGV4dFgoaXNYLCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0bGV0IHggPSBpc1ggPyAwIDogd2lkdGg7XHJcblxyXG5cdFx0aWYgKGQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xyXG5cdFx0XHR4ID0gaXNYID8gLWhlaWdodCA6IDA7XHJcblx0XHR9IGVsc2UgaWYgKGQucG9zaXRpb24gPT09IFwibWlkZGxlXCIpIHtcclxuXHRcdFx0eCA9IChpc1ggPyAtaGVpZ2h0IDogd2lkdGgpIC8gMjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzbW9vdGhMaW5lcyhlbCwgdHlwZSkge1xyXG5cdGlmICh0eXBlID09PSBcImdyaWRcIikge1xyXG5cdFx0ZWwuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZyA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0W1wieDFcIiwgXCJ4MlwiLCBcInkxXCIsIFwieTJcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IGcuYXR0cih2LCBNYXRoLmNlaWwoK2cuYXR0cih2KSkpKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRHcmlkKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmluaXRHcmlkTGluZXMoKTtcclxuXHRcdCQkLmluaXRGb2N1c0dyaWQoKTtcclxuXHR9LFxyXG5cclxuXHRpbml0R3JpZExpbmVzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjbGlwfSwgJGVsOiB7Z3JpZExpbmVzLCBtYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcclxuXHRcdFx0Z3JpZExpbmVzLm1haW4gPSBtYWluLmluc2VydChcImdcIiwgYC4ke0NMQVNTLmNoYXJ0fSR7Y29uZmlnLmdyaWRfbGluZXNfZnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YClcclxuXHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwLnBhdGhHcmlkKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYCR7Q0xBU1MuZ3JpZH0gJHtDTEFTUy5ncmlkTGluZXN9YCk7XHJcblxyXG5cdFx0XHRncmlkTGluZXMubWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZExpbmVzKTtcclxuXHRcdFx0Z3JpZExpbmVzLm1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRMaW5lcyk7XHJcblxyXG5cdFx0XHRncmlkTGluZXMueCA9IGQzU2VsZWN0QWxsKFtdKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVYR3JpZCh3aXRob3V0VXBkYXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGUsICRlbDoge21haW4sIGdyaWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHhncmlkRGF0YSA9ICQkLmdlbmVyYXRlR3JpZERhdGEoY29uZmlnLmdyaWRfeF90eXBlLCBzY2FsZS54KTtcclxuXHRcdGNvbnN0IHRpY2tPZmZzZXQgPSAkJC5pc0NhdGVnb3JpemVkKCkgPyAkJC5heGlzLngudGlja09mZnNldCgpIDogMDtcclxuXHRcdGNvbnN0IHBvcyA9IGQgPT4gKChzY2FsZS56b29tIHx8IHNjYWxlLngpKGQpICsgdGlja09mZnNldCkgKiAoaXNSb3RhdGVkID8gLTEgOiAxKTtcclxuXHJcblx0XHRzdGF0ZS54Z3JpZEF0dHIgPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdFwieDFcIjogMCxcclxuXHRcdFx0XCJ4MlwiOiBzdGF0ZS53aWR0aCxcclxuXHRcdFx0XCJ5MVwiOiBwb3MsXHJcblx0XHRcdFwieTJcIjogcG9zLFxyXG5cdFx0fSA6IHtcclxuXHRcdFx0XCJ4MVwiOiBwb3MsXHJcblx0XHRcdFwieDJcIjogcG9zLFxyXG5cdFx0XHRcInkxXCI6IDAsXHJcblx0XHRcdFwieTJcIjogc3RhdGUuaGVpZ2h0LFxyXG5cdFx0fTtcclxuXHJcblx0XHRncmlkLnggPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueGdyaWRzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnhncmlkfWApXHJcblx0XHRcdC5kYXRhKHhncmlkRGF0YSk7XHJcblxyXG5cdFx0Z3JpZC54LmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRncmlkLnggPSBncmlkLnguZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkKVxyXG5cdFx0XHQubWVyZ2UoZ3JpZC54KTtcclxuXHJcblx0XHRpZiAoIXdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0Z3JpZC54LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgZ3JpZCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRPYmplY3Qua2V5cyhzdGF0ZS54Z3JpZEF0dHIpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRcdFx0Z3JpZC5hdHRyKGlkLCBzdGF0ZS54Z3JpZEF0dHJbaWRdKVxyXG5cdFx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICgpID0+IChcclxuXHRcdFx0XHRcdFx0XHRncmlkLmF0dHIoaXNSb3RhdGVkID8gXCJ5MVwiIDogXCJ4MVwiKSA9PT0gKGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IDApID9cclxuXHRcdFx0XHRcdFx0XHRcdFwiMFwiIDogXCIxXCJcclxuXHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVlHcmlkKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2dyaWQsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGdyaWRWYWx1ZXMgPSAkJC5heGlzLnkudGlja1ZhbHVlcygpIHx8ICQkLnNjYWxlLnkudGlja3MoY29uZmlnLmdyaWRfeV90aWNrcyk7XHJcblx0XHRjb25zdCBwb3MgPSBkID0+IE1hdGguY2VpbCgkJC5zY2FsZS55KGQpKTtcclxuXHJcblx0XHRncmlkLnkgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkfWApXHJcblx0XHRcdC5kYXRhKGdyaWRWYWx1ZXMpO1xyXG5cclxuXHRcdGdyaWQueS5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Z3JpZC55ID0gZ3JpZC55XHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWQpXHJcblx0XHRcdC5tZXJnZShncmlkLnkpO1xyXG5cclxuXHRcdGdyaWQueS5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gcG9zIDogMClcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBwb3MgOiBzdGF0ZS53aWR0aClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IHBvcyk7XHJcblxyXG5cdFx0c21vb3RoTGluZXMoZ3JpZC55LCBcImdyaWRcIik7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlR3JpZChkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge2dyaWQsIGdyaWRMaW5lc319ID0gJCQ7XHJcblxyXG5cdFx0IWdyaWRMaW5lcy5tYWluICYmICQkLmluaXRHcmlkTGluZXMoKTtcclxuXHJcblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXHJcblx0XHRncmlkLm1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsICQkLmhhc0FyY1R5cGUoKSA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIik7XHJcblxyXG5cdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0JCQudXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbik7XHJcblx0XHQkJC51cGRhdGVZR3JpZExpbmVzKGR1cmF0aW9uKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgWCBHcmlkIGxpbmVzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVYR3JpZExpbmVzKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtncmlkTGluZXMsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25maWcuZ3JpZF94X3Nob3cgJiYgJCQudXBkYXRlWEdyaWQoKTtcclxuXHJcblx0XHRsZXQgeExpbmVzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLnhncmlkTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWRMaW5lfWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3hfbGluZXMpO1xyXG5cclxuXHRcdC8vIGV4aXRcclxuXHRcdHhMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB4Z3JpZExpbmUgPSB4TGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhMaW5lcyA9IHhncmlkTGluZS5tZXJnZSh4TGluZXMpO1xyXG5cclxuXHRcdHhMaW5lc1xyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueGdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcclxuXHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcclxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0Z3JpZExpbmVzLnggPSB4TGluZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIFkgR3JpZCBsaW5lc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWUdyaWRMaW5lcyhkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiYgJCQudXBkYXRlWUdyaWQoKTtcclxuXHJcblx0XHRsZXQgeWdyaWRMaW5lcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy55Z3JpZExpbmV9YClcclxuXHRcdFx0LmRhdGEoY29uZmlnLmdyaWRfeV9saW5lcyk7XHJcblxyXG5cdFx0Ly8gZXhpdFxyXG5cdFx0eWdyaWRMaW5lcy5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQvLyBlbnRlclxyXG5cdFx0Y29uc3QgeWdyaWRMaW5lID0geWdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lLmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJyb3RhdGUoLTkwKVwiIDogXCJcIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lcyA9IHlncmlkTGluZS5tZXJnZSh5Z3JpZExpbmVzKTtcclxuXHJcblx0XHQvLyB1cGRhdGVcclxuXHRcdGNvbnN0IHl2ID0gJCQueXYuYmluZCgkJCk7XHJcblxyXG5cdFx0eWdyaWRMaW5lc1xyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueWdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcclxuXHRcdFx0LnNlbGVjdChcImxpbmVcIilcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8geXYgOiAwKVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHl2IDogd2lkdGgpXHJcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gMCA6IHl2KVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IGhlaWdodCA6IHl2KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cclxuXHRcdHlncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxyXG5cdFx0XHQuYXR0cihcImR4XCIsIGdldEdyaWRUZXh0RHgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuYXR0cihcImR5XCIsIC01KVxyXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKGlzUm90YXRlZCwgd2lkdGgsIGhlaWdodCkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCB5dilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0JGVsLmdyaWRMaW5lcy55ID0geWdyaWRMaW5lcztcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdHcmlkKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGNvbmZpZzoge2F4aXNfcm90YXRlZDogaXNSb3RhdGVkfSxcclxuXHRcdFx0c3RhdGU6IHt3aWR0aCwgaGVpZ2h0fSxcclxuXHRcdFx0JGVsOiB7Z3JpZExpbmVzfVxyXG5cdFx0fSA9ICQkO1xyXG5cdFx0Y29uc3QgeHYgPSAkJC54di5iaW5kKCQkKTtcclxuXHJcblx0XHRsZXQgbGluZXMgPSBncmlkTGluZXMueC5zZWxlY3QoXCJsaW5lXCIpO1xyXG5cdFx0bGV0IHRleHRzID0gZ3JpZExpbmVzLnguc2VsZWN0KFwidGV4dFwiKTtcclxuXHJcblx0XHRsaW5lcyA9ICh3aXRoVHJhbnNpdGlvbiA/IGxpbmVzLnRyYW5zaXRpb24oKSA6IGxpbmVzKVxyXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyB3aWR0aCA6IHh2KVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IHh2IDogMClcclxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyB4diA6IGhlaWdodCk7XHJcblxyXG5cdFx0dGV4dHMgPSAod2l0aFRyYW5zaXRpb24gPyB0ZXh0cy50cmFuc2l0aW9uKCkgOiB0ZXh0cylcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIGdldEdyaWRUZXh0WCghaXNSb3RhdGVkLCB3aWR0aCwgaGVpZ2h0KSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHh2KVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dCk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGluaXRGb2N1c0dyaWQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXB9LCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc0Zyb250ID0gY29uZmlnLmdyaWRfZnJvbnQ7XHJcblx0XHRjb25zdCBjbGFzc05hbWUgPSBgLiR7Q0xBU1NbaXNGcm9udCAmJiAkZWwuZ3JpZC5tYWluID8gXCJncmlkTGluZXNcIiA6IFwiY2hhcnRcIl19JHtpc0Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWA7XHJcblxyXG5cdFx0Y29uc3QgZ3JpZCA9ICRlbC5ncmlkLm1haW4gPSAkZWwubWFpbi5pbnNlcnQoXCJnXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcC5wYXRoR3JpZClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ncmlkKTtcclxuXHJcblx0XHRjb25maWcuZ3JpZF94X3Nob3cgJiZcclxuXHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZHMpO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3lfc2hvdyAmJlxyXG5cdFx0XHRncmlkLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5ncmlkX2ZvY3VzX3Nob3cpIHtcclxuXHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZEZvY3VzKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZEZvY3VzKTtcclxuXHJcblx0XHRcdC8vIHRvIHNob3cgeHkgZm9jdXMgZ3JpZCBsaW5lLCBzaG91bGQgYmUgJ3Rvb2x0aXAuZ3JvdXBlZD1mYWxzZSdcclxuXHRcdFx0aWYgKGNvbmZpZy5ncmlkX2ZvY3VzX3kgJiYgIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRncmlkLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRGb2N1cylcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkRm9jdXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBncmlkIGZvY3VzIGxpbmVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZERhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpZHRoLCBoZWlnaHR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cclxuXHRcdC8vIEhpZGUgd2hlbiBidWJibGUvc2NhdHRlci9zdGFuZm9yZCBwbG90IGV4aXN0c1xyXG5cdFx0aWYgKCFjb25maWcudG9vbHRpcF9zaG93IHx8IGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBmb2N1c0VsID0gJCQuJGVsLm1haW4uc2VsZWN0QWxsKGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c30sIGxpbmUuJHtDTEFTUy55Z3JpZEZvY3VzfWApO1xyXG5cdFx0Y29uc3QgaXNFZGdlID0gY29uZmlnLmdyaWRfZm9jdXNfZWRnZSAmJiAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZDtcclxuXHRcdGNvbnN0IHh4ID0gJCQueHguYmluZCgkJCk7XHJcblxyXG5cdFx0Zm9jdXNFbFxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxyXG5cdFx0XHQuZGF0YShkYXRhVG9TaG93LmNvbmNhdChkYXRhVG9TaG93KSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IGVsID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgcG9zID0ge1xyXG5cdFx0XHRcdFx0eDogeHgoZCksXHJcblx0XHRcdFx0XHR5OiAkJC5nZXRZU2NhbGUoZC5pZCkoZC52YWx1ZSlcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGxldCB4eTtcclxuXHJcblx0XHRcdFx0aWYgKGVsLmNsYXNzZWQoQ0xBU1MueGdyaWRGb2N1cykpIHtcclxuXHRcdFx0XHRcdC8vIHdpbGwgY29udGFpbiAneDEsIHkxLCB4MiwgeTInIG9yZGVyXHJcblx0XHRcdFx0XHR4eSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRcdFtcclxuXHRcdFx0XHRcdFx0XHRudWxsLCAvLyB4MVxyXG5cdFx0XHRcdFx0XHRcdHBvcy54LCAvLyB5MVxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSA/IHBvcy55IDogd2lkdGgsIC8vIHgyXHJcblx0XHRcdFx0XHRcdFx0cG9zLnggLy8geTJcclxuXHRcdFx0XHRcdFx0XSA6IFtcclxuXHRcdFx0XHRcdFx0XHRwb3MueCxcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgPyBwb3MueSA6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0cG9zLngsXHJcblx0XHRcdFx0XHRcdFx0aGVpZ2h0XHJcblx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IGlzWTIgPSAkJC5heGlzLmdldElkKGQuaWQpID09PSBcInkyXCI7XHJcblxyXG5cdFx0XHRcdFx0eHkgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFx0XHRbXHJcblx0XHRcdFx0XHRcdFx0cG9zLnksIC8vIHgxXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmICFpc1kyID8gcG9zLnggOiBudWxsLCAvLyB5MVxyXG5cdFx0XHRcdFx0XHRcdHBvcy55LCAvLyB4MlxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiBpc1kyID8gcG9zLnggOiBoZWlnaHQgLy8geTJcclxuXHRcdFx0XHRcdFx0XSA6IFtcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgaXNZMiA/IHBvcy54IDogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRwb3MueSxcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgIWlzWTIgPyBwb3MueCA6IHdpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdHBvcy55XHJcblx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRbXCJ4MVwiLCBcInkxXCIsIFwieDJcIiwgXCJ5MlwiXVxyXG5cdFx0XHRcdFx0LmZvckVhY2goKHYsIGkpID0+IGVsLmF0dHIodiwgeHlbaV0pKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0c21vb3RoTGluZXMoZm9jdXNFbCwgXCJncmlkXCIpO1xyXG5cdH0sXHJcblxyXG5cdGhpZGVHcmlkRm9jdXMoKSB7XHJcblx0XHR0aGlzLiRlbC5tYWluLnNlbGVjdEFsbChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9LCBsaW5lLiR7Q0xBU1MueWdyaWRGb2N1c31gKVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZWdyaWRGb2N1cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3QoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfWApXHJcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IC0xMClcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyB3aWR0aCA6IC0xMClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAtMTAgOiAwKVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IC0xMCA6IGhlaWdodCk7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHcmlkRGF0YSh0eXBlLCBzY2FsZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGlja051bSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YClcclxuXHRcdFx0LnNlbGVjdEFsbChcIi50aWNrXCIpXHJcblx0XHRcdC5zaXplKCk7XHJcblx0XHRsZXQgZ3JpZERhdGE6IERhdGVbXSA9IFtdO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSBcInllYXJcIikge1xyXG5cdFx0XHRjb25zdCB4RG9tYWluID0gJCQuZ2V0WERvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBmaXJzdFllYXIgPSB4RG9tYWluWzBdLmdldEZ1bGxZZWFyKCk7XHJcblx0XHRcdGNvbnN0IGxhc3RZZWFyID0geERvbWFpblsxXS5nZXRGdWxsWWVhcigpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IGZpcnN0WWVhcjsgaSA8PSBsYXN0WWVhcjsgaSsrKSB7XHJcblx0XHRcdFx0Z3JpZERhdGEucHVzaChuZXcgRGF0ZShgJHtpfS0wMS0wMSAwMDowMDowMGApKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Z3JpZERhdGEgPSBzY2FsZS50aWNrcygxMCk7XHJcblxyXG5cdFx0XHRpZiAoZ3JpZERhdGEubGVuZ3RoID4gdGlja051bSkgeyAvLyB1c2Ugb25seSBpbnRcclxuXHRcdFx0XHRncmlkRGF0YSA9IGdyaWREYXRhLmZpbHRlcihkID0+IFN0cmluZyhkKS5pbmRleE9mKFwiLlwiKSA8IDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdyaWREYXRhO1xyXG5cdH0sXHJcblxyXG5cdGdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpIHtcclxuXHRcdHJldHVybiBwYXJhbXMgPyBsaW5lID0+IHtcclxuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHQoaXNBcnJheShwYXJhbXMpID8gcGFyYW1zLmNvbmNhdCgpIDogW3BhcmFtc10pLmZvckVhY2gocGFyYW0gPT4ge1xyXG5cdFx0XHRcdGlmICgoKFwidmFsdWVcIiBpbiBwYXJhbSAmJiBsaW5lLnZhbHVlID09PSBwYXJhbS52YWx1ZSkgfHwgKFwiY2xhc3NcIiBpbiBwYXJhbSAmJiBsaW5lLmNsYXNzID09PSBwYXJhbS5jbGFzcykpKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBmb3VuZDtcclxuXHRcdH0gOiAoKSA9PiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZvclgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0b1JlbW92ZSA9ICQkLmdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpO1xyXG5cdFx0Y29uc3QgdG9TaG93ID0gbGluZSA9PiAhdG9SZW1vdmUobGluZSk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gZm9yWCA/IENMQVNTLnhncmlkTGluZXMgOiBDTEFTUy55Z3JpZExpbmVzO1xyXG5cdFx0Y29uc3QgY2xhc3NMaW5lID0gZm9yWCA/IENMQVNTLnhncmlkTGluZSA6IENMQVNTLnlncmlkTGluZTtcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3QoYC4ke2NsYXNzTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Y2xhc3NMaW5lfWApXHJcblx0XHRcdC5maWx0ZXIodG9SZW1vdmUpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0Y29uc3QgZ3JpZExpbmVzID0gYGdyaWRfJHtmb3JYID8gXCJ4XCIgOiBcInlcIn1fbGluZXNgO1xyXG5cclxuXHRcdGNvbmZpZ1tncmlkTGluZXNdID0gY29uZmlnW2dyaWRMaW5lc10uZmlsdGVyKHRvU2hvdyk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiOyAvLyBzZWxlY3Rpb25cclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzVmFsdWUsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJlZ2lvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluID0gJGVsLm1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5zdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MucmVnaW9ucyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmVnaW9uKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gaGlkZSBpZiBhcmMgdHlwZVxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpO1xyXG5cclxuXHRcdC8vIHNlbGVjdCA8Zz4gZWxlbWVudFxyXG5cdFx0bGV0IGxpc3QgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MucmVnaW9ufWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5yZWdpb25zKTtcclxuXHJcblx0XHRsaXN0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGxpc3QgPSBsaXN0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0Lm1lcmdlKGxpc3QpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NSZWdpb24uYmluZCgkJCkpO1xyXG5cclxuXHRcdGxpc3RcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHQkZWwucmVnaW9uLmxpc3QgPSBsaXN0O1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JlZ2lvbih3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwucmVnaW9uLmxpc3Quc2VsZWN0KFwicmVjdFwiKTtcclxuXHJcblx0XHRyZWdpb25zID0gKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLnJlZ2lvblkuYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLnJlZ2lvbkhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBkID0+IChpc1ZhbHVlKGQub3BhY2l0eSkgPyBkLm9wYWNpdHkgOiBcIjAuMVwiKSlcclxuXHRcdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3NhcnkgcmVjdCBhZnRlciB0cmFuc2l0aW9uXHJcblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzLnBhcmVudE5vZGUpXHJcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJyZWN0Om5vdChbeF0pXCIpXHJcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25YWSh0eXBlLCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1ggPSB0eXBlID09PSBcInhcIjtcclxuXHRcdGxldCBrZXkgPSBcInN0YXJ0XCI7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IHBvcyA9IDA7XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1gpIHtcclxuXHRcdFx0XHRrZXkgPSBcImVuZFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzWCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdFx0Y3VyclNjYWxlID0gc2NhbGVbZC5heGlzXTtcclxuXHRcdFx0XHRwb3MgPSBjdXJyU2NhbGUoZFtrZXldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgoaXNYID8gIWlzUm90YXRlZCA6IGlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0Y3VyclNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cdFx0XHRwb3MgPSBjdXJyU2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyBwYXJzZURhdGUuY2FsbCgkJCwgZFtrZXldKSA6IGRba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvcztcclxuXHR9LFxyXG5cclxuXHRyZWdpb25YKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieFwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRyZWdpb25ZKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieVwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25TaXplKHR5cGUsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiO1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSAkJFtpc1dpZHRoID8gXCJyZWdpb25YXCIgOiBcInJlZ2lvbllcIl0oZCk7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IGtleSA9IFwiZW5kXCI7XHJcblx0XHRsZXQgZW5kID0gc3RhdGVbdHlwZV07XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1dpZHRoKSB7XHJcblx0XHRcdFx0a2V5ID0gXCJzdGFydFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzV2lkdGggPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlW2QuYXhpc107XHJcblx0XHRcdFx0ZW5kID0gY3VyclNjYWxlKGRba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRjdXJyU2NhbGUgPSBzY2FsZS56b29tIHx8IHNjYWxlLng7XHJcblx0XHRcdGVuZCA9IGN1cnJTY2FsZSgkJC5pc1RpbWVTZXJpZXMoKSA/IHBhcnNlRGF0ZS5jYWxsKCQkLCBkW2tleV0pIDogZFtrZXldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZW5kIDwgc3RhcnQgPyAwIDogZW5kIC0gc3RhcnQ7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uV2lkdGgoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcIndpZHRoXCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvbkhlaWdodChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwiaGVpZ2h0XCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmVnaW9uT25YKGQpIHtcclxuXHRcdHJldHVybiAhZC5heGlzIHx8IGQuYXhpcyA9PT0gXCJ4XCI7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge3JnYiBhcyBkM1JnYn0gZnJvbSBcImQzLWNvbG9yXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNlbGVjdCBhIHBvaW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBvaW50XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKi9cclxuXHRzZWxlY3RQb2ludCh0YXJnZXQsIGQsIGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGN4ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGN5ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFNlbGVjdFIuYmluZCgkJCk7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29uc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gYWRkIHNlbGVjdGVkLWNpcmNsZSBvbiBsb3cgbGF5ZXIgZ1xyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcclxuXHRcdFx0LmRhdGEoW2RdKVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiY2lyY2xlXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKCkgPT4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zZWxlY3RlZENpcmNsZSwgaSkpXHJcblx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpXHJcblx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpXHJcblx0XHRcdC5hdHRyKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgZDIgPT4gJCQucG9pbnRTZWxlY3RSKGQyKSAqIDEuNClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgcik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5lbGVjdCBhIHBvaW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBvaW50XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKi9cclxuXHR1bnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIHNlbGVjdGVkLWNpcmNsZSBmcm9tIGxvdyBsYXllciBnXHJcblx0XHQkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgMClcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBwb2ludHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHRvZ2dsZVBvaW50KHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcclxuXHRcdGNvbnN0IG1ldGhvZCA9IGAke3NlbGVjdGVkID8gXCJcIiA6IFwidW5cIn1zZWxlY3RQb2ludGA7XHJcblxyXG5cdFx0dGhpc1ttZXRob2RdKHRhcmdldCwgZCwgaSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2VsZWN0IGEgcGF0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwYXRoXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKi9cclxuXHRzZWxlY3RQYXRoKHRhcmdldCwgZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2JyaWdodGVuKSB7XHJcblx0XHRcdHRhcmdldC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgKCkgPT4gZDNSZ2IoJCQuY29sb3IoZCkpLmJyaWdodGVyKDAuNzUpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmVsZWN0IGEgcGF0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwYXRoXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKi9cclxuXHR1bnNlbGVjdFBhdGgodGFyZ2V0LCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xyXG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICgpID0+ICQkLmNvbG9yKGQpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgbGluZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHRvZ2dsZVBhdGgoc2VsZWN0ZWQsIHRhcmdldCwgZCwgaSkge1xyXG5cdFx0dGhpc1tcclxuXHRcdFx0YCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBhdGhgXHJcblx0XHRdKHRhcmdldCwgZCwgaSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdG9nZ2xlIG1ldGhvZCBvZiB0aGUgdGFyZ2V0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRvZ2dsZSBtZXRob2RcclxuXHQgKi9cclxuXHRnZXRUb2dnbGUodGhhdCwgZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiB0aGF0Lm5vZGVOYW1lID09PSBcInBhdGhcIiA/XHJcblx0XHRcdCQkLnRvZ2dsZVBhdGggOiAoXHJcblx0XHRcdFx0JCQuaXNTdGVwVHlwZShkKSA/XHJcblx0XHRcdFx0XHQoKSA9PiB7fSA6IC8vIGNpcmNsZSBpcyBoaWRkZW4gaW4gc3RlcCBjaGFydCwgc28gdHJlYXQgYXMgd2l0aGluIHRoZSBjbGljayBhcmVhXHJcblx0XHRcdFx0XHQkJC50b2dnbGVQb2ludFxyXG5cdFx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBzaGFwZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHRvZ2dsZVNoYXBlKHRoYXQsIGQsIGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGF0KTtcclxuXHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGF0LCBkKS5iaW5kKCQkKTtcclxuXHRcdGxldCB0b2dnbGVkU2hhcGU7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpKSB7XHJcblx0XHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlKSB7XHJcblx0XHRcdFx0bGV0IHNlbGVjdG9yID0gYC4ke0NMQVNTLnNoYXBlc31gO1xyXG5cclxuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdHNlbGVjdG9yICs9ICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWFpbi5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpKSB7XHJcblx0XHRcdFx0XHRcdFx0dG9nZ2xlZFNoYXBlID0gc2hhcGU7XHJcblx0XHRcdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCF0b2dnbGVkU2hhcGUgfHwgdG9nZ2xlZFNoYXBlLm5vZGUoKSAhPT0gc2hhcGUubm9kZSgpKSB7XHJcblx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgIWlzU2VsZWN0ZWQpO1xyXG5cdFx0XHRcdHRvZ2dsZSghaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge21vdXNlIGFzIGQzTW91c2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFJhbmRvbSwgZ2V0UmVjdFNlZ0xpc3QsIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRCYXIoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NCYXJzID0gJCQuY2xhc3NCYXJzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XHJcblxyXG5cdFx0aWYgKCEkZWwuYmFyKSB7XHJcblx0XHRcdCQkLmluaXRCYXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYWluQmFyVXBkYXRlID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRCYXIoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluQmFyRW50ZXIgPSBtYWluQmFyVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHQvLyBCYXJzIGZvciBlYWNoIGRhdGFcclxuXHRcdG1haW5CYXJFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgYmFyRGF0YSA9ICQkLmJhckRhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0JhciA9ICQkLmNsYXNzQmFyLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgaW5pdGlhbE9wYWNpdHkgPSAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKTtcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfWApXHJcblx0XHRcdC5kYXRhKGJhckRhdGEpO1xyXG5cclxuXHRcdCRlbC5iYXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0JGVsLmJhciA9ICRlbC5iYXIuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5tZXJnZSgkZWwuYmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGluaXRpYWxPcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdCYXIoZHJhd0Jhciwgd2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0IHtiYXJ9ID0gdGhpcy4kZWw7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gYmFyLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogYmFyKVxyXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QmFyKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRnZXRCYXJXKGF4aXMsIGJhclRhcmdldHNOdW0pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgbWF4RGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XHJcblx0XHRjb25zdCBpc0dyb3VwZWQgPSBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgdGlja0ludGVydmFsID0gKHNjYWxlLnpvb20gfHwgJCQpICYmICEkJC5pc0NhdGVnb3JpemVkKCkgP1xyXG5cdFx0XHQkJC54eChzY2FsZS5zdWJYLmRvbWFpbigpWzFdKSAvIG1heERhdGFDb3VudCA6IGF4aXMudGlja0ludGVydmFsKG1heERhdGFDb3VudCk7XHJcblx0XHRsZXQgcmVzdWx0O1xyXG5cclxuXHRcdGNvbnN0IGdldFdpZHRoID0gKGlkPzogc3RyaW5nKSA9PiB7XHJcblx0XHRcdGNvbnN0IHdpZHRoID0gaWQgPyBjb25maWcuYmFyX3dpZHRoW2lkXSA6IGNvbmZpZy5iYXJfd2lkdGg7XHJcblx0XHRcdGNvbnN0IHJhdGlvID0gaWQgPyB3aWR0aC5yYXRpbyA6IGNvbmZpZy5iYXJfd2lkdGhfcmF0aW87XHJcblx0XHRcdGNvbnN0IG1heCA9IGlkID8gd2lkdGgubWF4IDogY29uZmlnLmJhcl93aWR0aF9tYXg7XHJcblx0XHRcdGNvbnN0IHcgPSBpc051bWJlcih3aWR0aCkgP1xyXG5cdFx0XHRcdHdpZHRoIDogYmFyVGFyZ2V0c051bSA/ICh0aWNrSW50ZXJ2YWwgKiByYXRpbykgLyBiYXJUYXJnZXRzTnVtIDogMDtcclxuXHJcblx0XHRcdHJldHVybiBtYXggJiYgdyA+IG1heCA/IG1heCA6IHc7XHJcblx0XHR9O1xyXG5cclxuXHRcdHJlc3VsdCA9IGdldFdpZHRoKCk7XHJcblxyXG5cdFx0aWYgKCFpc0dyb3VwZWQgJiYgaXNPYmplY3RUeXBlKGNvbmZpZy5iYXJfd2lkdGgpKSB7XHJcblx0XHRcdHJlc3VsdCA9IHt3aWR0aDogcmVzdWx0LCB0b3RhbDogW119O1xyXG5cclxuXHRcdFx0JCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5iYXJfd2lkdGhbdi5pZF0pIHtcclxuXHRcdFx0XHRcdHJlc3VsdFt2LmlkXSA9IGdldFdpZHRoKHYuaWQpO1xyXG5cdFx0XHRcdFx0cmVzdWx0LnRvdGFsLnB1c2gocmVzdWx0W3YuaWRdIHx8IHJlc3VsdC53aWR0aCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0sXHJcblxyXG5cdGdldEJhcnMoaSwgaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IHN1ZmZpeCA9IChpc1ZhbHVlKGkpID8gYC0ke2l9YCA6IGBgKTtcclxuXHJcblx0XHRyZXR1cm4gKGlkID8gbWFpblxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApIDogbWFpbilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfSR7c3VmZml4fWApO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJhcnMoaSwgaWQsIHJlc2V0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRCYXJzKCk7XHJcblx0XHQkJC5nZXRCYXJzKGksIGlkKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZEJhcnMoaSkge1xyXG5cdFx0dGhpcy5nZXRCYXJzKGkpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURyYXdCYXIoYmFySW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldEJhclBvaW50cyhiYXJJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaXNHcm91cGVkID0gY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGJhclJhZGl1cyA9IGNvbmZpZy5iYXJfcmFkaXVzO1xyXG5cdFx0Y29uc3QgYmFyUmFkaXVzUmF0aW8gPSBjb25maWcuYmFyX3JhZGl1c19yYXRpbztcclxuXHJcblx0XHQvLyBnZXQgdGhlIGJhciByYWRpdXNcclxuXHRcdGNvbnN0IGdldFJhZGl1cyA9IGlzTnVtYmVyKGJhclJhZGl1cykgJiYgYmFyUmFkaXVzID4gMCA/XHJcblx0XHRcdCgpID0+IGJhclJhZGl1cyA6IChcclxuXHRcdFx0XHRpc051bWJlcihiYXJSYWRpdXNSYXRpbykgPyB3ID0+IHcgKiBiYXJSYWRpdXNSYXRpbyA6IG51bGxcclxuXHRcdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGdldFBvaW50cyhkLCBpKTtcclxuXHJcblx0XHRcdC8vIHN3aXRjaCBwb2ludHMgaWYgYXhpcyBpcyByb3RhdGVkLCBub3QgYXBwbGljYWJsZSBmb3Igc3ViIGNoYXJ0XHJcblx0XHRcdGNvbnN0IGluZGV4WCA9ICtpc1JvdGF0ZWQ7XHJcblx0XHRcdGNvbnN0IGluZGV4WSA9ICshaW5kZXhYO1xyXG5cclxuXHRcdFx0Y29uc3QgaXNOZWdhdGl2ZSA9IGQudmFsdWUgPCAwO1xyXG5cdFx0XHRjb25zdCBwYXRoUmFkaXVzID0gW1wiXCIsIFwiXCJdO1xyXG5cdFx0XHRsZXQgcmFkaXVzID0gMDtcclxuXHJcblx0XHRcdGlmIChnZXRSYWRpdXMgJiYgIWlzR3JvdXBlZCkge1xyXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gaXNSb3RhdGVkID8gaW5kZXhZIDogaW5kZXhYO1xyXG5cdFx0XHRcdGNvbnN0IGJhclcgPSBwb2ludHNbMl1baW5kZXhdIC0gcG9pbnRzWzBdW2luZGV4XTtcclxuXHJcblx0XHRcdFx0cmFkaXVzID0gZ2V0UmFkaXVzKGJhclcpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBhcmMgPSBgYSR7cmFkaXVzfSwke3JhZGl1c30gJHtpc05lZ2F0aXZlID8gYDEgMCAwYCA6IGAwIDAgMWB9IGA7XHJcblxyXG5cdFx0XHRcdHBhdGhSYWRpdXNbKyFpc1JvdGF0ZWRdID0gYCR7YXJjfSR7cmFkaXVzfSwke3JhZGl1c31gO1xyXG5cdFx0XHRcdHBhdGhSYWRpdXNbK2lzUm90YXRlZF0gPSBgJHthcmN9JHtbLXJhZGl1cywgcmFkaXVzXVtpc1JvdGF0ZWQgPyBcInNvcnRcIiA6IFwicmV2ZXJzZVwiXSgpfWA7XHJcblxyXG5cdFx0XHRcdGlzTmVnYXRpdmUgJiYgcGF0aFJhZGl1cy5yZXZlcnNlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHBhdGggc3RyaW5nIGRhdGEgc2hvdWxkbid0IGJlIGNvbnRhaW5pbmcgbmV3IGxpbmUgY2hhcnNcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvNTMwXHJcblx0XHRcdGNvbnN0IHBhdGggPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdGBIJHtwb2ludHNbMV1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzBdfVYke3BvaW50c1syXVtpbmRleFldIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMV19SCR7cG9pbnRzWzNdW2luZGV4WF19YCA6XHJcblx0XHRcdFx0YFYke3BvaW50c1sxXVtpbmRleFldICsgKGlzTmVnYXRpdmUgPyAtcmFkaXVzIDogcmFkaXVzKX0gJHtwYXRoUmFkaXVzWzBdfUgke3BvaW50c1syXVtpbmRleFhdIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMV19ViR7cG9pbnRzWzNdW2luZGV4WV19YDtcclxuXHJcblx0XHRcdHJldHVybiBgTSR7cG9pbnRzWzBdW2luZGV4WF19LCR7cG9pbnRzWzBdW2luZGV4WV19JHtwYXRofXpgO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldEJhclBvaW50cyhiYXJJbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXMgPSBpc1N1YiA/ICQkLmF4aXMuc3ViWCA6ICQkLmF4aXMueDtcclxuXHRcdGNvbnN0IGJhclRhcmdldHNOdW0gPSAkJC5nZXRJbmRpY2VzTWF4KGJhckluZGljZXMpICsgMTtcclxuXHRcdGNvbnN0IGJhclcgPSAkJC5nZXRCYXJXKGF4aXMsIGJhclRhcmdldHNOdW0pO1xyXG5cdFx0Y29uc3QgYmFyWCA9ICQkLmdldFNoYXBlWChiYXJXLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IGJhclkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBiYXJPZmZzZXQgPSAkJC5nZXRTaGFwZU9mZnNldCgkJC5pc0JhclR5cGUsIGJhckluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKDApO1xyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBiYXJPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBiYXIgY2hhcnRcclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBpc051bWJlcihiYXJXKSA/IGJhclcgOiBiYXJXW2QuaWRdIHx8IGJhclcud2lkdGg7XHJcblx0XHRcdGNvbnN0IHBvc1ggPSBiYXJYKGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IGJhclkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBvc1kgLT0gKHkwIC0gb2Zmc2V0KTtcclxuXHJcblx0XHRcdC8vIDQgcG9pbnRzIHRoYXQgbWFrZSBhIGJhclxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdLFxyXG5cdFx0XHRcdFtwb3NYLCBwb3NZXSxcclxuXHRcdFx0XHRbcG9zWCArIHdpZHRoLCBwb3NZXSxcclxuXHRcdFx0XHRbcG9zWCArIHdpZHRoLCBvZmZzZXRdXHJcblx0XHRcdF07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGlzV2l0aGluQmFyKHRoYXQpIHtcclxuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZSh0aGF0KTtcclxuXHRcdGNvbnN0IGxpc3QgPSBnZXRSZWN0U2VnTGlzdCh0aGF0KTtcclxuXHRcdGNvbnN0IFtzZWcwLCBzZWcxXSA9IGxpc3Q7XHJcblx0XHRjb25zdCB4ID0gTWF0aC5taW4oc2VnMC54LCBzZWcxLngpO1xyXG5cdFx0Y29uc3QgeSA9IE1hdGgubWluKHNlZzAueSwgc2VnMS55KTtcclxuXHRcdGNvbnN0IG9mZnNldCA9IHRoaXMuY29uZmlnLmJhcl9zZW5zaXRpdml0eTtcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoYXQuZ2V0QkJveCgpO1xyXG5cdFx0Y29uc3Qgc3ggPSB4IC0gb2Zmc2V0O1xyXG5cdFx0Y29uc3QgZXggPSB4ICsgd2lkdGggKyBvZmZzZXQ7XHJcblx0XHRjb25zdCBzeSA9IHkgKyBoZWlnaHQgKyBvZmZzZXQ7XHJcblx0XHRjb25zdCBleSA9IHkgLSBvZmZzZXQ7XHJcblxyXG5cdFx0cmV0dXJuIHN4IDwgbW91c2VbMF0gJiZcclxuXHRcdFx0bW91c2VbMF0gPCBleCAmJlxyXG5cdFx0XHRleSA8IG1vdXNlWzFdICYmXHJcblx0XHRcdG1vdXNlWzFdIDwgc3k7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7Z2V0TWluTWF4LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNPYmplY3R9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0QnViYmxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xyXG5cdFx0XHRjb25maWcucG9pbnRfc2hvdyA9IHRydWU7XHJcblx0XHRcdGNvbmZpZy5wb2ludF90eXBlID0gXCJjaXJjbGVcIjtcclxuXHRcdFx0Y29uZmlnLnBvaW50X3NlbnNpdGl2aXR5ID0gMjU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHVzZXIgYWdlbnQncyBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgcGF0aCBpbiB1c2VyIHVuaXRzXHJcblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dlb21ldHJ5RWxlbWVudC9nZXRUb3RhbExlbmd0aFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEJhc2VMZW5ndGgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpc30gPSAkJC4kZWw7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJGJhc2VMZW5ndGhcIjtcclxuXHRcdGxldCBiYXNlTGVuZ3RoID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIWJhc2VMZW5ndGgpIHtcclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCBiYXNlTGVuZ3RoID0gZ2V0TWluTWF4KFwibWluXCIsIFtcclxuXHRcdFx0XHRheGlzLnguc2VsZWN0KFwicGF0aFwiKS5ub2RlKClcclxuXHRcdFx0XHRcdC5nZXRUb3RhbExlbmd0aCgpLFxyXG5cdFx0XHRcdGF4aXMueS5zZWxlY3QoXCJwYXRoXCIpLm5vZGUoKVxyXG5cdFx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKClcclxuXHRcdFx0XSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBiYXNlTGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcmFkaXVzIHZhbHVlIGZvciBidWJibGUgY2lyY2xlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuIFx0ICovXHJcblx0Z2V0QnViYmxlUihkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgbWF4UiA9ICQkLmNvbmZpZy5idWJibGVfbWF4UjtcclxuXHJcblx0XHRpZiAoaXNGdW5jdGlvbihtYXhSKSkge1xyXG5cdFx0XHRtYXhSID0gbWF4Ui5iaW5kKCQkLmFwaSkoZCk7XHJcblx0XHR9IGVsc2UgaWYgKCFpc051bWJlcihtYXhSKSkge1xyXG5cdFx0XHRtYXhSID0gKCQkLmdldEJhc2VMZW5ndGgoKSAvICgkJC5nZXRNYXhEYXRhQ291bnQoKSAqIDIpKSArIDEyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1heCA9IGdldE1pbk1heChcIm1heFwiLCAkJC5nZXRNaW5NYXhEYXRhKCkubWF4Lm1hcChkID0+IChcclxuXHRcdFx0JCQuaXNCdWJibGVaVHlwZShkKSA/XHJcblx0XHRcdFx0JCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ5XCIpIDogKFxyXG5cdFx0XHRcdFx0aXNPYmplY3QoZC52YWx1ZSkgPyBkLnZhbHVlLm1pZCA6IGQudmFsdWVcclxuXHRcdFx0XHQpXHJcblx0XHQpKSk7XHJcblx0XHRjb25zdCBtYXhBcmVhID0gbWF4UiAqIG1heFIgKiBNYXRoLlBJO1xyXG5cdFx0Y29uc3QgYXJlYSA9ICgkJC5pc0J1YmJsZVpUeXBlKGQpID8gJCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ6XCIpIDogZC52YWx1ZSkgKiAobWF4QXJlYSAvIG1heCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydChhcmVhIC8gTWF0aC5QSSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGJ1YmJsZSBkaW1lbnNpb24gZGF0YVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkIGRhdGEgdmFsdWVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHkgb3IgelxyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEJ1YmJsZVpEYXRhKGQsIHR5cGUpIHtcclxuXHRcdHJldHVybiBpc09iamVjdChkKSA/IGRbdHlwZV0gOiBkW3R5cGUgPT09IFwieVwiID8gMCA6IDFdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZSBpZiBidWJibGUgaGFzIGRpbWVuc2lvbiBkYXRhXHJcblx0ICogQHBhcmFtIHtPYmplY3R8YXJyYXl9IGQgZGF0YSB2YWx1ZVxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc0J1YmJsZVpUeXBlKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuaXNCdWJibGVUeXBlKGQpICYmIChcclxuXHRcdFx0KGlzT2JqZWN0KGQudmFsdWUpICYmIChcInpcIiBpbiBkLnZhbHVlIHx8IFwieVwiIGluIGQudmFsdWUpKSB8fFxyXG5cdFx0XHQoaXNBcnJheShkLnZhbHVlKSAmJiBkLnZhbHVlLmxlbmd0aCA9PT0gMilcclxuXHRcdCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0YXJlYSBhcyBkM0FyZWEsXHJcblx0bGluZSBhcyBkM0xpbmVcclxufSBmcm9tIFwiZDMtc2hhcGVcIjtcclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFJhbmRvbSwgaXNBcnJheSwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1VuZGVmaW5lZCwgaXNWYWx1ZSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0TGluZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yTGluZSh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XHJcblxyXG5cdFx0aWYgKCEkZWwubGluZSkge1xyXG5cdFx0XHQkJC5pbml0TGluZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1haW5MaW5lVXBkYXRlID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0TGluZX1gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydExpbmUoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluTGluZUVudGVyID0gbWFpbkxpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXHJcblx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcclxuXHJcblx0XHQvLyBBcmVhc1xyXG5cdFx0aWYgKCQkLmhhc1R5cGVPZihcIkFyZWFcIikpIHtcclxuXHRcdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNRU1POiBjYW4gbm90IGtlZXAgc2FtZSBjb2xvci4uLlxyXG5cdFx0Ly8gbWFpbkxpbmVVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Zm9ybWF0OiB7ZXh0cmFMaW5lQ2xhc3Nlc30sICRlbH0gPSAkJDtcclxuXHJcblx0XHQkZWwubGluZSA9ICRlbC5tYWluXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmV9YClcclxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdCRlbC5saW5lLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCRlbC5saW5lID0gJGVsLmxpbmUuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7JCQuY2xhc3NMaW5lLmJpbmQoJCQpKGQpfSAke2V4dHJhTGluZUNsYXNzZXMoZCkgfHwgXCJcIn1gKVxyXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5tZXJnZSgkZWwubGluZSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwic2hhcGUtcmVuZGVyaW5nXCIsIGQgPT4gKCQkLmlzU3RlcFR5cGUoZCkgPyBcImNyaXNwRWRnZXNcIiA6IFwiXCIpKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdMaW5lKGRyYXdMaW5lLCB3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3Qge2xpbmV9ID0gdGhpcy4kZWw7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gbGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IGxpbmUpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lKVxyXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY3VydmUgaW50ZXJwb2xhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRDdXJ2ZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWRTdGVwVHlwZSA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgJCQuaXNTdGVwVHlwZShkKTtcclxuXHJcblx0XHQvLyB3aGVuIGlzIHN0ZXAgJiByb3RhdGVkLCBzaG91bGQgYmUgY29tcHV0ZWQgaW4gZGlmZmVyZW50IHdheVxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvNDcxXHJcblx0XHRyZXR1cm4gaXNSb3RhdGVkU3RlcFR5cGUgPyBjb250ZXh0ID0+IHtcclxuXHRcdFx0Y29uc3Qgc3RlcCA9ICQkLmdldEludGVycG9sYXRlKGQpKGNvbnRleHQpO1xyXG5cclxuXHRcdFx0Ly8ga2VlcCB0aGUgb3JpZ2luYWwgbWV0aG9kXHJcblx0XHRcdHN0ZXAub3JnUG9pbnQgPSBzdGVwLnBvaW50O1xyXG5cclxuXHRcdFx0Ly8gdG8gZ2V0IHJvdGF0ZWQgcGF0aCBkYXRhXHJcblx0XHRcdHN0ZXAucG9pbnRSb3RhdGVkID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdHRoaXMuX3BvaW50ID09PSAxICYmICh0aGlzLl9wb2ludCA9IDIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCB5MSA9IHRoaXMuX3kgKiAoMSAtIHRoaXMuX3QpICsgeSAqIHRoaXMuX3Q7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkxKTtcclxuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5MSk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0XHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0c3RlcC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMCA/IHRoaXMub3JnUG9pbnQoeCwgeSkgOiB0aGlzLnBvaW50Um90YXRlZCh4LCB5KTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBzdGVwO1xyXG5cdFx0fSA6ICQkLmdldEludGVycG9sYXRlKGQpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRHJhd0xpbmUobGluZUluZGljZXMsIGlzU3ViKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGxpbmVDb25uZWN0TnVsbCA9IGNvbmZpZy5saW5lX2Nvbm5lY3ROdWxsO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25zdCBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZUdldHRlciA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xyXG5cclxuXHRcdGNvbnN0IHhWYWx1ZSA9IGQgPT4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XHJcblx0XHRjb25zdCB5VmFsdWUgPSAoZCwgaSkgPT4gKFxyXG5cdFx0XHQkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRcdGdldFBvaW50cyhkLCBpKVswXVsxXSA6XHJcblx0XHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKCQkLmdldEJhc2VWYWx1ZShkKSlcclxuXHRcdCk7XHJcblxyXG5cdFx0bGV0IGxpbmUgPSBkM0xpbmUoKTtcclxuXHJcblx0XHRsaW5lID0gaXNSb3RhdGVkID9cclxuXHRcdFx0bGluZS54KHlWYWx1ZSkueSh4VmFsdWUpIDogbGluZS54KHhWYWx1ZSkueSh5VmFsdWUpO1xyXG5cclxuXHRcdGlmICghbGluZUNvbm5lY3ROdWxsKSB7XHJcblx0XHRcdGxpbmUgPSBsaW5lLmRlZmluZWQoZCA9PiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHggPSBpc1N1YiA/IHNjYWxlLnN1YlggOiBzY2FsZS54O1xyXG5cclxuXHRcdHJldHVybiBkID0+IHtcclxuXHRcdFx0Y29uc3QgeSA9IHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKTtcclxuXHRcdFx0bGV0IHZhbHVlcyA9IGxpbmVDb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXM7XHJcblx0XHRcdGxldCB4MCA9IDA7XHJcblx0XHRcdGxldCB5MCA9IDA7XHJcblx0XHRcdGxldCBwYXRoO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzTGluZVR5cGUoZCkpIHtcclxuXHRcdFx0XHRjb25zdCByZWdpb25zID0gY29uZmlnLmRhdGFfcmVnaW9uc1tkLmlkXTtcclxuXHJcblx0XHRcdFx0aWYgKHJlZ2lvbnMpIHtcclxuXHRcdFx0XHRcdHBhdGggPSAkJC5saW5lV2l0aFJlZ2lvbnModmFsdWVzLCB4LCB5LCByZWdpb25zKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBhdGggPSBsaW5lLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSB4KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0geSh2YWx1ZXNbMF0udmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGlzUm90YXRlZCA/IGBNICR7eTB9ICR7eDB9YCA6IGBNICR7eDB9ICR7eTB9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGggfHwgXCJNIDAgMFwiO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViVmFsdWUpIHsgLy8gcGFydGlhbCBkdXBsaWNhdGlvbiBvZiBnZW5lcmF0ZUdldEJhclBvaW50c1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzU3ViID0gISFpc1N1YlZhbHVlO1xyXG5cdFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBsaW5lSW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgeSA9ICQkLmdldFNoYXBlWShpc1N1Yik7XHJcblx0XHRjb25zdCBsaW5lT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNMaW5lVHlwZSwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgwKTtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gbGluZU9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGFyZWEgY2hhcnRcclxuXHRcdFx0Y29uc3QgcG9zWCA9IHgoZCk7XHJcblx0XHRcdGxldCBwb3NZID0geShkKTtcclxuXHJcblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXHJcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcclxuXHRcdFx0KSkge1xyXG5cdFx0XHRcdHBvc1kgPSB5MDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBsaW5lIHBvc2l0aW9uXHJcblx0XHRcdGNvbnN0IHBvaW50ID0gW3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXTtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnQsIC8vIGZyb20gaGVyZSBhbmQgYmVsb3csIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdF07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGxpbmVXaXRoUmVnaW9ucyhkLCB4LCB5LCBfcmVnaW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKTtcclxuXHRcdGNvbnN0IHhPZmZzZXQgPSAkJC5pc0NhdGVnb3JpemVkKCkgPyAwLjUgOiAwO1xyXG5cdFx0Y29uc3QgcmVnaW9uczogYW55W10gPSBbXTtcclxuXHRcdGNvbnN0IGRhc2hhcnJheSA9IFwiMiAyXCI7IC8vIGRlZmF1bHQgdmFsdWVcclxuXHJcblx0XHRsZXQgeHA7XHJcblx0XHRsZXQgeXA7XHJcblx0XHRsZXQgZGlmZjtcclxuXHRcdGxldCBkaWZmeDI7XHJcblxyXG5cdFx0Ly8gY2hlY2sgd2VhdGhlciBkYXRhIGlzIHdpdGhpbiByZWdpb25cclxuXHRcdGNvbnN0IGlzV2l0aGluUmVnaW9ucyA9ICh3aXRoaW5YLCB3aXRoaW5SZWdpb25zKSA9PiB7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSB3aXRoaW5SZWdpb25zW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHJlZy5zdGFydCA8IHdpdGhpblggJiYgd2l0aGluWCA8PSByZWcuZW5kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcmVnLnN0eWxlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBDaGVjayBzdGFydC9lbmQgb2YgcmVnaW9uc1xyXG5cdFx0aWYgKGlzRGVmaW5lZChfcmVnaW9ucykpIHtcclxuXHRcdFx0Y29uc3QgZ2V0VmFsdWUgPSAodjogRGF0ZSB8IGFueSwgZGVmOiBudW1iZXIpOiBEYXRlIHwgYW55ID0+IChcclxuXHRcdFx0XHRpc1VuZGVmaW5lZCh2KSA/IGRlZiA6IChpc1RpbWVTZXJpZXMgPyBwYXJzZURhdGUuY2FsbCgkJCwgdikgOiB2KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHJlZzsgKHJlZyA9IF9yZWdpb25zW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBnZXRWYWx1ZShyZWcuc3RhcnQsIGRbMF0ueCk7XHJcblx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0VmFsdWUocmVnLmVuZCwgZFtkLmxlbmd0aCAtIDFdLngpO1xyXG5cdFx0XHRcdGNvbnN0IHN0eWxlID0gcmVnLnN0eWxlIHx8IHtkYXNoYXJyYXl9O1xyXG5cclxuXHRcdFx0XHRyZWdpb25zW2ldID0ge3N0YXJ0LCBlbmQsIHN0eWxlfTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCBzY2FsZXNcclxuXHRcdGNvbnN0IHhWYWx1ZSA9IGlzUm90YXRlZCA/IGR0ID0+IHkoZHQudmFsdWUpIDogZHQgPT4geChkdC54KTtcclxuXHRcdGNvbnN0IHlWYWx1ZSA9IGlzUm90YXRlZCA/IGR0ID0+IHgoZHQueCkgOiBkdCA9PiB5KGR0LnZhbHVlKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgc3ZnIGdlbmVyYXRvciBmdW5jdGlvbiBmb3IgcmVnaW9uXHJcblx0XHRjb25zdCBnZW5lcmF0ZU0gPSBwb2ludHMgPT4gYE0ke3BvaW50c1swXVswXX0sJHtwb2ludHNbMF1bMV19TCR7cG9pbnRzWzFdWzBdfSwke3BvaW50c1sxXVsxXX1gO1xyXG5cclxuXHRcdGNvbnN0IHNXaXRoUmVnaW9uID0gaXNUaW1lU2VyaWVzID8gKGQwLCBkMSwgaywgdGltZXNlcmllc0RpZmYpID0+IHtcclxuXHRcdFx0Y29uc3QgeDAgPSBkMC54LmdldFRpbWUoKTtcclxuXHRcdFx0Y29uc3QgeERpZmYgPSBkMS54IC0gZDAueDtcclxuXHRcdFx0Y29uc3QgeHYwID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIGspO1xyXG5cdFx0XHRjb25zdCB4djEgPSBuZXcgRGF0ZSh4MCArIHhEaWZmICogKGsgKyB0aW1lc2VyaWVzRGlmZikpO1xyXG5cclxuXHRcdFx0Y29uc3QgcG9pbnRzID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRbW3koeXAoaykpLCB4KHh2MCldLCBbeSh5cChrICsgZGlmZikpLCB4KHh2MSldXSA6XHJcblx0XHRcdFx0W1t4KHh2MCksIHkoeXAoaykpXSwgW3goeHYxKSwgeSh5cChrICsgZGlmZikpXV07XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2VuZXJhdGVNKHBvaW50cyk7XHJcblx0XHR9IDogKGQwLCBkMSwgaywgb3RoZXJEaWZmKSA9PiB7XHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0W1t5KHlwKGspLCB0cnVlKSwgeCh4cChrKSldLCBbeSh5cChrICsgb3RoZXJEaWZmKSwgdHJ1ZSksIHgoeHAoayArIG90aGVyRGlmZikpXV0gOlxyXG5cdFx0XHRcdFtbeCh4cChrKSwgdHJ1ZSksIHkoeXAoaykpXSwgW3goeHAoayArIG90aGVyRGlmZiksIHRydWUpLCB5KHlwKGsgKyBvdGhlckRpZmYpKV1dO1xyXG5cclxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBHZW5lcmF0ZVxyXG5cdFx0bGV0IHBhdGggPSBcIlwiO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwLCBkYXRhOyAoZGF0YSA9IGRbaV0pOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgcHJldkRhdGEgPSBkW2kgLSAxXTtcclxuXHRcdFx0Y29uc3QgaGFzUHJldkRhdGEgPSBwcmV2RGF0YSAmJiBpc1ZhbHVlKHByZXZEYXRhLnZhbHVlKTtcclxuXHRcdFx0bGV0IHN0eWxlID0gaXNXaXRoaW5SZWdpb25zKGRhdGEueCwgcmVnaW9ucyk7XHJcblxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy8xMTcyXHJcblx0XHRcdGlmICghaXNWYWx1ZShkYXRhLnZhbHVlKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBEcmF3IGFzIG5vcm1hbFxyXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQocmVnaW9ucykgfHwgIXN0eWxlIHx8ICFoYXNQcmV2RGF0YSkge1xyXG5cdFx0XHRcdHBhdGggKz0gYCR7aSAmJiBoYXNQcmV2RGF0YSA/IFwiTFwiIDogXCJNXCJ9JHt4VmFsdWUoZGF0YSl9LCR7eVZhbHVlKGRhdGEpfWA7XHJcblx0XHRcdH0gZWxzZSBpZiAoaGFzUHJldkRhdGEpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0c3R5bGUgPSBzdHlsZS5kYXNoYXJyYXkuc3BsaXQoXCIgXCIpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdHN0eWxlID0gZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIERyYXcgd2l0aCByZWdpb24gLy8gVE9ETzogRml4IGZvciBob3Jpem90YWwgY2hhcnRzXHJcblx0XHRcdFx0eHAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS54ICsgeE9mZnNldCwgZGF0YS54ICsgeE9mZnNldCwgaXNUaW1lU2VyaWVzKTtcclxuXHRcdFx0XHR5cCA9ICQkLmdldFNjYWxlKHByZXZEYXRhLnZhbHVlLCBkYXRhLnZhbHVlKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZHggPSB4KGRhdGEueCkgLSB4KHByZXZEYXRhLngpO1xyXG5cdFx0XHRcdGNvbnN0IGR5ID0geShkYXRhLnZhbHVlKSAtIHkocHJldkRhdGEudmFsdWUpO1xyXG5cdFx0XHRcdGNvbnN0IGRkID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XHJcblxyXG5cdFx0XHRcdGRpZmYgPSBzdHlsZVswXSAvIGRkO1xyXG5cdFx0XHRcdGRpZmZ4MiA9IGRpZmYgKiBzdHlsZVsxXTtcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IGRpZmY7IGogPD0gMTsgaiArPSBkaWZmeDIpIHtcclxuXHRcdFx0XHRcdHBhdGggKz0gc1dpdGhSZWdpb24ocHJldkRhdGEsIGRhdGEsIGosIGRpZmYpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHRvIG1ha2Ugc3VyZSBjb3JyZWN0IGxpbmUgZHJhd2luZ1xyXG5cdFx0XHRcdFx0aWYgKGogKyBkaWZmeDIgPj0gMSkge1xyXG5cdFx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCAxLCAwKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGF0aDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmVhR3JhZGllbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2RhdGV0aW1lSWR9LCAkZWw6IHtkZWZzfX0gPSAkJDtcclxuXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0Y29uc3QgaWQgPSBgJHtkYXRldGltZUlkfS1hcmVhR3JhZGllbnQkeyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWA7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNBcmVhVHlwZShkKSAmJiBkZWZzLnNlbGVjdChgIyR7aWR9YCkuZW1wdHkoKSkge1xyXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gJCQuY29sb3IoZCk7XHJcblx0XHRcdFx0Y29uc3Qge1xyXG5cdFx0XHRcdFx0eCA9IFswLCAwXSxcclxuXHRcdFx0XHRcdHkgPSBbMCwgMV0sXHJcblx0XHRcdFx0XHRzdG9wcyA9IFtbMCwgY29sb3IsIDFdLCBbMSwgY29sb3IsIDBdXVxyXG5cdFx0XHRcdH0gPSBjb25maWcuYXJlYV9saW5lYXJHcmFkaWVudDtcclxuXHJcblx0XHRcdFx0Y29uc3QgbGluZWFyR3JhZGllbnQgPSBkZWZzLmFwcGVuZChcImxpbmVhckdyYWRpZW50XCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImlkXCIsIGAke2lkfWApXHJcblx0XHRcdFx0XHQuYXR0cihcIngxXCIsIHhbMF0pXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHhbMV0pXHJcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHlbMF0pXHJcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHlbMV0pO1xyXG5cclxuXHRcdFx0XHRzdG9wcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qgc3RvcENvbG9yID0gaXNGdW5jdGlvbih2WzFdKSA/IHZbMV0uYmluZCgkJC5hcGkpKGQuaWQpIDogdlsxXTtcclxuXHJcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudC5hcHBlbmQoXCJzdG9wXCIpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwib2Zmc2V0XCIsIHZbMF0pXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1jb2xvclwiLCBzdG9wQ29sb3IgfHwgY29sb3IpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsIHZbMl0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmVhQ29sb3IoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/XHJcblx0XHRcdGB1cmwoIyR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX0pYCA6XHJcblx0XHRcdCQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ICYmICQkLnVwZGF0ZUFyZWFHcmFkaWVudCgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwuYXJlYS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYXJlYSA9ICRlbC5hcmVhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UoJGVsLmFyZWEpO1xyXG5cclxuXHRcdCRlbC5hcmVhXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7b3JnQXJlYU9wYWNpdHl9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQuJGVsLmFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiAkJC4kZWwuYXJlYSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+IFN0cmluZygkJC5pc0FyZWFSYW5nZVR5cGUoZCkgPyBvcmdBcmVhT3BhY2l0eSAvIDEuNzUgOiBvcmdBcmVhT3BhY2l0eSkpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXHJcblx0ICogQHBhcmFtIGFyZWFJbmRpY2VzXHJcblx0ICogQHBhcmFtIGlzU3ViXHJcblx0ICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiAoKnxzdHJpbmcpfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgdmFsdWUwID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoXHJcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cclxuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJoaWdoXCIpIDogMFxyXG5cdFx0XHQpKTtcclxuXHRcdGNvbnN0IHZhbHVlMSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzFdWzFdIDpcclxuXHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwibG93XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBkM0FyZWEoKTtcclxuXHJcblx0XHRcdFx0YXJlYSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRhcmVhLnkoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQueDAodmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueDEodmFsdWUxKSA6XHJcblx0XHRcdFx0XHRhcmVhLngoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdC55MChjb25maWcuYXJlYV9hYm92ZSA/IDAgOiB2YWx1ZTApXHJcblx0XHRcdFx0XHRcdC55MSh2YWx1ZTEpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xyXG5cdFx0XHRcdFx0YXJlYSA9IGFyZWEuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGFyZWEuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSAkJC5zY2FsZS54KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0gJCQuZ2V0WVNjYWxlKGQuaWQpKHZhbHVlc1swXS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBhcmVhT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNBcmVhVHlwZSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGFyZWFPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgYXJlYSBwb3NpdGlvblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdLFxyXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0gLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdF07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGlzV2l0aGluU3RlcCh0aGF0LCB5KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoeSAtIGQzTW91c2UodGhhdClbMV0pIDwgMzA7XHJcblx0fSxcclxuXHJcblx0c2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZCkge1xyXG5cdFx0Y29uc3QgbGluZVBvaW50ID0gdGhpcy5jb25maWcubGluZV9wb2ludDtcclxuXHJcblx0XHRyZXR1cm4gbGluZVBvaW50ID09PSB0cnVlIHx8XHJcblx0XHRcdChpc0FycmF5KGxpbmVQb2ludCkgJiYgbGluZVBvaW50LmluZGV4T2YoZC5pZCkgIT09IC0xKTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXMsXHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7Z2V0Qm91bmRpbmdSZWN0LCBnZXRSYW5kb20sIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc09iamVjdFR5cGUsIGlzVmFsdWUsIHRvQXJyYXksIG5vdEVtcHR5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRoYXNWYWxpZFBvaW50VHlwZSh0eXBlKSB7XHJcblx0XHRyZXR1cm4gL14oY2lyY2xlfHJlY3QoYW5nbGUpP3xwb2x5Z29ufGVsbGlwc2V8dXNlKSQvaS50ZXN0KHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZSk7XHJcblx0fSxcclxuXHJcblx0aGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHR5cGUpIHtcclxuXHRcdGNvbnN0IHBvaW50VHlwZSA9IHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZTtcclxuXHJcblx0XHRyZXR1cm4gaXNPYmplY3RUeXBlKHBvaW50VHlwZSkgJiZcclxuXHRcdFx0aXNGdW5jdGlvbihwb2ludFR5cGUuY3JlYXRlKSAmJiBpc0Z1bmN0aW9uKHBvaW50VHlwZS51cGRhdGUpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlKGQpIHtcclxuXHRcdGNvbnN0IHt3aXRob3V0RmFkZUlufSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyB0aGlzLm9wYWNpdHlGb3JDaXJjbGUoZCkgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHRvcGFjaXR5Rm9yQ2lyY2xlKGQpIHtcclxuXHRcdGNvbnN0IG9wYWNpdHkgPSB0aGlzLmNvbmZpZy5wb2ludF9zaG93ID8gXCIxXCIgOiBcIjBcIjtcclxuXHJcblx0XHRyZXR1cm4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkgP1xyXG5cdFx0XHQodGhpcy5pc0J1YmJsZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID9cclxuXHRcdFx0XHRcIjAuNVwiIDogb3BhY2l0eSkgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHRpbml0Q2lyY2xlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0JCQucG9pbnQgPSAkJC5nZW5lcmF0ZVBvaW50KCk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydENpcmNsZXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldEZvckNpcmNsZSh0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBkYXRhLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gdCB8fCBkYXRhLnRhcmdldHM7XHJcblx0XHRjb25zdCBjbGFzc0NpcmNsZXMgPSAkJC5jbGFzc0NpcmNsZXMuYmluZCgkJCk7XHJcblxyXG5cdFx0aWYgKCEkZWwuY2lyY2xlICYmIGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdCQkLmluaXRDaXJjbGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYWluQ2lyY2xlID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydENpcmNsZXN9YClcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NpcmNsZXMpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5DaXJjbGVFbnRlciA9IG1haW5DaXJjbGUuZW50ZXIoKTtcclxuXHJcblx0XHQvLyBDaXJjbGVzIGZvciBlYWNoIGRhdGEgcG9pbnQgb24gbGluZXNcclxuXHRcdGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIG1haW5DaXJjbGVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlcywgZC5pZCkpO1xyXG5cclxuXHRcdG1haW5DaXJjbGVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgZGF0ZSBmb3Igc2VsZWN0ZWQgY2lyY2xlc1xyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHQkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHQuaWQpfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKVxyXG5cdFx0XHRcdC5lYWNoKGQgPT4ge1xyXG5cdFx0XHRcdFx0ZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQ2lyY2xlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNpcmNsZXMgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGV9YClcclxuXHRcdFx0LmRhdGEoZCA9PiAhJCQuaXNCYXJUeXBlKGQpICYmIChcclxuXHRcdFx0XHQhJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5zaG91bGREcmF3UG9pbnRzRm9yTGluZShkKVxyXG5cdFx0XHQpICYmICQkLmxhYmVsaXNoRGF0YShkKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdGNpcmNsZXMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJjcmVhdGVcIiwgdGhpcywgJCQucG9pbnRSLmJpbmQoJCQpLCAkJC5jb2xvcik7XHJcblxyXG5cdFx0JGVsLmNpcmNsZSA9IGNpcmNsZXMuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKGZuKVxyXG5cdFx0XHQubWVyZ2UoY2lyY2xlcylcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdDaXJjbGUoY3gsIGN5LCB3aXRoVHJhbnNpdGlvbiwgZmxvdykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7cmVuZGVyZWR9LCAkZWw6IHtjaXJjbGUsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2VsZWN0ZWRDaXJjbGVzID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfWApO1xyXG5cclxuXHRcdGlmICghJCQuY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJ1cGRhdGVcIiwgJCQsIGN4LCBjeSwgJCQuY29sb3IsIHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpO1xyXG5cdFx0Y29uc3QgcG9zQXR0ciA9ICQkLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcclxuXHJcblx0XHRjb25zdCB0ID0gZ2V0UmFuZG9tKCk7XHJcblx0XHRjb25zdCBvcGFjaXR5U3R5bGVGbiA9ICQkLm9wYWNpdHlGb3JDaXJjbGUuYmluZCgkJCk7XHJcblxyXG5cdFx0Y29uc3QgbWFpbkNpcmNsZXMgPSBbXTtcclxuXHJcblx0XHRjaXJjbGUuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdGxldCByZXN1bHQgPSBmbi5iaW5kKHRoaXMpKGQpO1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gKCh3aXRoVHJhbnNpdGlvbiB8fCAhcmVuZGVyZWQpID8gcmVzdWx0LnRyYW5zaXRpb24odCkgOiByZXN1bHQpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbik7XHJcblxyXG5cdFx0XHRtYWluQ2lyY2xlcy5wdXNoKHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRtYWluQ2lyY2xlcyxcclxuXHRcdFx0c2VsZWN0ZWRDaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoYCR7cG9zQXR0cn14YCwgY3gpXHJcblx0XHRcdFx0LmF0dHIoYCR7cG9zQXR0cn15YCwgY3kpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGNpcmNsZVgoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3gsIHpvb219ID0gJCQuc2NhbGU7XHJcblx0XHRjb25zdCBoYXNWYWx1ZSA9IGlzVmFsdWUoZC54KTtcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLnpvb21fZW5hYmxlZCAmJiB6b29tID9cclxuXHRcdFx0KGhhc1ZhbHVlID8gem9vbShkLngpIDogbnVsbCkgOlxyXG5cdFx0XHQoaGFzVmFsdWUgPyB4KGQueCkgOiBudWxsKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVDaXJjbGVZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKCQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKSwgZmFsc2UpO1xyXG5cclxuXHRcdCQkLmNpcmNsZVkgPSAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBpZCA9IGQuaWQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuaXNHcm91cGVkKGlkKSA/XHJcblx0XHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcclxuXHRcdFx0XHQkJC5nZXRZU2NhbGUoaWQpKCQkLmdldEJhc2VWYWx1ZShkKSk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldENpcmNsZXMoaSwgaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHN1ZmZpeCA9IChpc1ZhbHVlKGkpID8gYC0ke2l9YCA6IGBgKTtcclxuXHJcblx0XHRyZXR1cm4gKGlkID8gJCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApIDogJCQuJGVsLm1haW4pXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZX0ke3N1ZmZpeH1gKTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRDaXJjbGVzKGksIGlkLCByZXNldCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50RXhwYW5kZWRSLmJpbmQoJCQpO1xyXG5cclxuXHRcdHJlc2V0ICYmICQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cclxuXHRcdGNvbnN0IGNpcmNsZXMgPSAkJC5nZXRDaXJjbGVzKGksIGlkKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHRcdGNvbnN0IHNjYWxlID0gcihjaXJjbGVzKSAvICQkLmNvbmZpZy5wb2ludF9yO1xyXG5cdFx0Y29uc3QgcmF0aW8gPSAxIC0gc2NhbGU7XHJcblxyXG5cdFx0aWYgKCQkLmlzQ2lyY2xlUG9pbnQoKSkge1xyXG5cdFx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHJhbnNmb3JtIG11c3QgYmUgYXBwbGllZCB0byBlYWNoIG5vZGUgaW5kaXZpZHVhbGx5XHJcblx0XHRcdGNpcmNsZXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy50YWdOYW1lID09PSBcImNpcmNsZVwiKSB7XHJcblx0XHRcdFx0XHRwb2ludC5hdHRyKFwiclwiLCByKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5nZXRCQm94KCk7XHJcblx0XHRcdFx0XHRjb25zdCB4ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ4XCIpICsgd2lkdGggLyAyKTtcclxuXHRcdFx0XHRcdGNvbnN0IHkgPSByYXRpbyAqICgrcG9pbnQuYXR0cihcInlcIikgKyBoZWlnaHQgLyAyKTtcclxuXHJcblx0XHRcdFx0XHRwb2ludC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt4fSAke3l9KSBzY2FsZSgke3NjYWxlfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVuZXhwYW5kQ2lyY2xlcyhpKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCByID0gJCQucG9pbnRSLmJpbmQoJCQpO1xyXG5cclxuXHRcdGNvbnN0IGNpcmNsZXMgPSAkJC5nZXRDaXJjbGVzKGkpXHJcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xyXG5cclxuXHRcdGNpcmNsZXMuYXR0cihcInJcIiwgcik7XHJcblxyXG5cdFx0ISQkLmlzQ2lyY2xlUG9pbnQoKSAmJlxyXG5cdFx0XHRjaXJjbGVzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHNjYWxlKCR7cihjaXJjbGVzKSAvICQkLmNvbmZpZy5wb2ludF9yfSlgKTtcclxuXHR9LFxyXG5cclxuXHRwb2ludFIoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0bGV0IHIgPSBwb2ludFI7XHJcblxyXG5cdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0ciA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xyXG5cdFx0XHRyID0gJCQuZ2V0QnViYmxlUihkKTtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwb2ludFIpKSB7XHJcblx0XHRcdHIgPSBwb2ludFIuYmluZCgkJC5hcGkpKGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50RXhwYW5kZWRSKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBzY2FsZSA9ICQkLmlzQnViYmxlVHlwZShkKSA/IDEuMTUgOiAxLjc1O1xyXG5cclxuXHRcdHJldHVybiBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgP1xyXG5cdFx0XHQoY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9yIHx8ICQkLnBvaW50UihkKSAqIHNjYWxlKSA6ICQkLnBvaW50UihkKTtcclxuXHR9LFxyXG5cclxuXHRwb2ludFNlbGVjdFIoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc2VsZWN0UiA9ICQkLmNvbmZpZy5wb2ludF9zZWxlY3RfcjtcclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihzZWxlY3RSKSA/XHJcblx0XHRcdHNlbGVjdFIoZCkgOiAoc2VsZWN0UiB8fCAkJC5wb2ludFIoZCkgKiA0KTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpbkNpcmNsZShub2RlLCByKSB7XHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2Uobm9kZSk7XHJcblx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3Qobm9kZSk7XHJcblx0XHRjb25zdCBwcmVmaXggPSB0aGlzLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcclxuXHJcblx0XHRsZXQgY3ggPSArZWxlbWVudC5hdHRyKGAke3ByZWZpeH14YCk7XHJcblx0XHRsZXQgY3kgPSArZWxlbWVudC5hdHRyKGAke3ByZWZpeH15YCk7XHJcblxyXG5cdFx0Ly8gaWYgbm9kZSBkb24ndCBoYXZlIGN4L3kgb3IgeC95IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdFx0aWYgKCEoY3ggfHwgY3kpICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcclxuXHRcdFx0Y29uc3Qge3gsIHl9ID0gZ2V0Qm91bmRpbmdSZWN0KG5vZGUpO1xyXG5cclxuXHRcdFx0Y3ggPSB4O1xyXG5cdFx0XHRjeSA9IHk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydChcclxuXHRcdFx0TWF0aC5wb3coY3ggLSBtb3VzZVswXSwgMikgKyBNYXRoLnBvdyhjeSAtIG1vdXNlWzFdLCAyKVxyXG5cdFx0KSA8IChyIHx8IHRoaXMuY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KTtcclxuXHR9LFxyXG5cclxuXHRpbnNlcnRQb2ludEluZm9EZWZzKHBvaW50LCBpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY29weUF0dHIgPSAoZnJvbSwgdGFyZ2V0KSA9PiB7XHJcblx0XHRcdGNvbnN0IGF0dHJpYnMgPSBmcm9tLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbmFtZTsgKG5hbWUgPSBhdHRyaWJzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0bmFtZSA9IG5hbWUubmFtZTtcclxuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBvaW50LCBcImltYWdlL3N2Zyt4bWxcIik7XHJcblx0XHRjb25zdCBub2RlID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XHJcblxyXG5cdFx0Y2xvbmUuaWQgPSBpZDtcclxuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcclxuXHRcdGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiO1xyXG5cclxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcclxuXHJcblx0XHRpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xyXG5cclxuXHRcdFx0aWYgKFwiaW5uZXJIVE1MXCIgaW4gY2xvbmUpIHtcclxuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9BcnJheShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCQkLiRlbC5kZWZzLm5vZGUoKS5hcHBlbmRDaGlsZChjbG9uZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRGcm9tRGVmcyhpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuJGVsLmRlZnMuc2VsZWN0KGAjJHtpZH1gKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVQb2ludENsYXNzKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjaXJjbGV9ID0gJCQuJGVsO1xyXG5cdFx0bGV0IHBvaW50Q2xhc3MgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoZCkgfHwgY2lyY2xlKSB7XHJcblx0XHRcdHBvaW50Q2xhc3MgPSBkID09PSB0cnVlID9cclxuXHRcdFx0XHRjaXJjbGUuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2lyY2xlLmJpbmQoJCQpKSA6XHJcblx0XHRcdFx0JCQuY2xhc3NDaXJjbGUoZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50Q2xhc3M7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVQb2ludCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7ZGF0ZXRpbWVJZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID8gY29uZmlnLnBvaW50X3BhdHRlcm4gOiBbY29uZmlnLnBvaW50X3R5cGVdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIC4uLmFyZ3MpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBpZDogc3RyaW5nID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcclxuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0cG9pbnQgPSAkJFtwb2ludF07XHJcblx0XHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRJZCA9IGAke2RhdGV0aW1lSWR9LXBvaW50LSR7aWR9YDtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50RnJvbURlZnMgPSAkJC5wb2ludEZyb21EZWZzKHBvaW50SWQpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwb2ludEZyb21EZWZzLnNpemUoKSA8IDEpIHtcclxuXHRcdFx0XHRcdFx0JCQuaW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgcG9pbnRJZCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1ldGhvZCA9PT0gXCJjcmVhdGVcIikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuY3VzdG9tLmNyZWF0ZS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIHBvaW50SWQsIC4uLmFyZ3MpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtZXRob2QgPT09IFwidXBkYXRlXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS51cGRhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCAuLi5hcmdzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBwb2ludFttZXRob2RdLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldFRyYW5zaXRpb25OYW1lKCkge1xyXG5cdFx0cmV0dXJuIGdldFJhbmRvbSgpO1xyXG5cdH0sXHJcblxyXG5cdGN1c3RvbToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGlkLCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInVzZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieGxpbms6aHJlZlwiLCBgIyR7aWR9YClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBmaWxsU3R5bGVGbixcclxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xyXG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGVsZW1lbnQubm9kZSgpLmdldEJCb3goKTtcclxuXHJcblx0XHRcdGNvbnN0IHhQb3NGbjIgPSBkID0+IHhQb3NGbihkKSAtIHdpZHRoIC8gMjtcclxuXHRcdFx0Y29uc3QgeVBvc0ZuMiA9IGQgPT4geVBvc0ZuKGQpIC0gaGVpZ2h0IC8gMjtcclxuXHRcdFx0bGV0IG1haW5DaXJjbGVzID0gZWxlbWVudDtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKTtcclxuXHJcblx0XHRcdFx0ZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwieFwiLCB4UG9zRm4yKTtcclxuXHJcblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcclxuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhQb3NGbjIpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlQb3NGbjIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGNpcmNsZToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcclxuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwiY2lyY2xlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcInJcIiwgc2l6ZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBmaWxsU3R5bGVGbixcclxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xyXG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0XHQvLyB3aGVuICcubG9hZCgpJyBjYWxsZWQsIGJ1YmJsZSBzaXplIHNob3VsZCBiZSB1cGRhdGVkXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpKSB7XHJcblx0XHRcdFx0bWFpbkNpcmNsZXMuYXR0cihcInJcIiwgJCQucG9pbnRSLmJpbmQoJCQpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiLCB4UG9zRm4pO1xyXG5cclxuXHRcdFx0XHRpZiAobWFpbkNpcmNsZXMuYXR0cihcImN4XCIpKSB7XHJcblx0XHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKFwiY3hcIiwgeFBvc0ZuKVxyXG5cdFx0XHRcdC5hdHRyKFwiY3lcIiwgeVBvc0ZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vICdyZWN0YW5nbGUnIGRhdGEgcG9pbnRcclxuXHRyZWN0YW5nbGU6IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdGNvbnN0IHJlY3RTaXplRm4gPSBkID0+IHNpemVGbihkKSAqIDIuMDtcclxuXHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgcmVjdFNpemVGbilcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCByZWN0U2l6ZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBmaWxsU3R5bGVGbixcclxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xyXG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRcdGNvbnN0IHIgPSAkJC5jb25maWcucG9pbnRfcjtcclxuXHRcdFx0Y29uc3QgcmVjdFhQb3NGbiA9IGQgPT4geFBvc0ZuKGQpIC0gcjtcclxuXHRcdFx0Y29uc3QgcmVjdFlQb3NGbiA9IGQgPT4geVBvc0ZuKGQpIC0gcjtcclxuXHJcblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9ICQkLmdldFRyYW5zaXRpb25OYW1lKCk7XHJcblxyXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcInhcIiwgcmVjdFhQb3NGbik7XHJcblxyXG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XHJcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCByZWN0WVBvc0ZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdGN1cnZlU3RlcEJlZm9yZSBhcyBkM0N1cnZlU3RlcEJlZm9yZSxcclxuXHRjdXJ2ZVN0ZXBBZnRlciBhcyBkM0N1cnZlU3RlcEFmdGVyLFxyXG5cdGN1cnZlQmFzaXNDbG9zZWQgYXMgZDNDdXJ2ZUJhc2lzQ2xvc2VkLFxyXG5cdGN1cnZlQmFzaXNPcGVuIGFzIGQzQ3VydmVCYXNpc09wZW4sXHJcblx0Y3VydmVCYXNpcyBhcyBkM0N1cnZlQmFzaXMsXHJcblx0Y3VydmVCdW5kbGUgYXMgZDNDdXJ2ZUJ1bmRsZSxcclxuXHRjdXJ2ZUNhcmRpbmFsQ2xvc2VkIGFzIGQzQ3VydmVDYXJkaW5hbENsb3NlZCxcclxuXHRjdXJ2ZUNhcmRpbmFsT3BlbiBhcyBkM0N1cnZlQ2FyZGluYWxPcGVuLFxyXG5cdGN1cnZlQ2FyZGluYWwgYXMgZDNDdXJ2ZUNhcmRpbmFsLFxyXG5cdGN1cnZlQ2F0bXVsbFJvbUNsb3NlZCBhcyBkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcclxuXHRjdXJ2ZUNhdG11bGxSb21PcGVuIGFzIGQzQ3VydmVDYXRtdWxsUm9tT3BlbixcclxuXHRjdXJ2ZUNhdG11bGxSb20gYXMgZDNDdXJ2ZUNhdG11bGxSb20sXHJcblx0Y3VydmVMaW5lYXJDbG9zZWQgYXMgZDNDdXJ2ZUxpbmVhckNsb3NlZCxcclxuXHRjdXJ2ZUxpbmVhciBhcyBkM0N1cnZlTGluZWFyLFxyXG5cdGN1cnZlTW9ub3RvbmVYIGFzIGQzQ3VydmVNb25vdG9uZVgsXHJcblx0Y3VydmVNb25vdG9uZVkgYXMgZDNDdXJ2ZU1vbm90b25lWSxcclxuXHRjdXJ2ZU5hdHVyYWwgYXMgZDNDdXJ2ZU5hdHVyYWwsXHJcblx0Y3VydmVTdGVwIGFzIGQzQ3VydmVTdGVwXHJcbn0gZnJvbSBcImQzLXNoYXBlXCI7XHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRVbmlxdWUsIGlzT2JqZWN0VHlwZSwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBub3RFbXB0eX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBzaGFwZSBkcmF3IGZ1bmN0aW9uXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RHJhd1NoYXBlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHtoYXNSYWRhcn0gPSAkJDtcclxuXHRcdGNvbnN0IHNoYXBlID0ge3R5cGU6IHt9LCBpbmRpY2VzOiB7fSwgcG9zOiB7fX07XHJcblxyXG5cdFx0Ly8gc2V0dXAgZHJhd2VyIC0gTUVNTzogdGhlc2UgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYXhpcyB1cGRhdGVkXHJcblx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiTGluZVwiKSB8fCAkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc1R5cGUoXCJzY2F0dGVyXCIpKSB7XHJcblx0XHRcdGNvbnN0IGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNMaW5lVHlwZSk7XHJcblxyXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmxpbmUgPSBpbmRpY2VzO1xyXG5cdFx0XHRzaGFwZS50eXBlLmxpbmUgPSAkJC5nZW5lcmF0ZURyYXdMaW5lID8gJCQuZ2VuZXJhdGVEcmF3TGluZShpbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xyXG5cdFx0XHRcdGNvbnN0IGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNBcmVhVHlwZSk7XHJcblxyXG5cdFx0XHRcdHNoYXBlLmluZGljZXMuYXJlYSA9IGluZGljZXM7XHJcblx0XHRcdFx0c2hhcGUudHlwZS5hcmVhID0gJCQuZ2VuZXJhdGVEcmF3QXJlYSA/ICQkLmdlbmVyYXRlRHJhd0FyZWEoaW5kaWNlcywgZmFsc2UpIDogdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJiYXJcIikpIHtcclxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0JhclR5cGUpO1xyXG5cclxuXHRcdFx0c2hhcGUuaW5kaWNlcy5iYXIgPSBpbmRpY2VzO1xyXG5cdFx0XHRzaGFwZS50eXBlLmJhciA9ICQkLmdlbmVyYXRlRHJhd0JhciA/ICQkLmdlbmVyYXRlRHJhd0JhcihpbmRpY2VzKSA6IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoISQkLmhhc0FyY1R5cGUoKSB8fCBoYXNSYWRhcikge1xyXG5cdFx0XHRzaGFwZS5wb3MgPSB7XHJcblx0XHRcdFx0eEZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIHRydWUpLFxyXG5cdFx0XHRcdHlGb3JUZXh0OiAkJC5nZW5lcmF0ZVhZRm9yVGV4dChzaGFwZS5pbmRpY2VzLCBmYWxzZSksXHJcblxyXG5cdFx0XHRcdC8vIGdlbmVyYXRlIGNpcmNsZSB4L3kgZnVuY3Rpb25zIGRlcGVuZGluZyBvbiB1cGRhdGVkIHBhcmFtc1xyXG5cdFx0XHRcdGN4OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVggOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpKS5iaW5kKCQkKSxcclxuXHRcdFx0XHRjeTogKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVZIDogKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKSkuYmluZCgkJClcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhcGU7XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVJbmRpY2VzKHR5cGVGaWx0ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4cyA9IGNvbmZpZy5kYXRhX3hzO1xyXG5cdFx0Y29uc3QgaGFzWHMgPSBub3RFbXB0eSh4cyk7XHJcblx0XHRjb25zdCBpbmRpY2VzID0ge307XHJcblx0XHRsZXQgaTogYW55ID0gaGFzWHMgPyB7fSA6IDA7XHJcblxyXG5cdFx0aWYgKGhhc1hzKSB7XHJcblx0XHRcdGdldFVuaXF1ZShPYmplY3Qua2V5cyh4cykubWFwKHYgPT4geHNbdl0pKVxyXG5cdFx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0aVt2XSA9IDA7XHJcblx0XHRcdFx0XHRpbmRpY2VzW3ZdID0ge307XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSlcclxuXHRcdFx0LmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgeEtleSA9IGQuaWQgaW4geHMgPyB4c1tkLmlkXSA6IFwiXCI7XHJcblx0XHRcdFx0Y29uc3QgaW5kID0geEtleSA/IGluZGljZXNbeEtleV0gOiBpbmRpY2VzO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgZ3JvdXBzOyAoZ3JvdXBzID0gY29uZmlnLmRhdGFfZ3JvdXBzW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHRpZiAoZ3JvdXBzLmluZGV4T2YoZC5pZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSAwLCByb3c7IChyb3cgPSBncm91cHNba10pOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKHJvdyBpbiBpbmQpIHtcclxuXHRcdFx0XHRcdFx0XHRpbmRbZC5pZF0gPSBpbmRbcm93XTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKGluZFtkLmlkXSkpIHtcclxuXHRcdFx0XHRcdGluZFtkLmlkXSA9IHhLZXkgPyBpW3hLZXldKysgOiBpKys7XHJcblx0XHRcdFx0XHRpbmQuX19tYXhfXyA9ICh4S2V5ID8gaVt4S2V5XSA6IGkpIC0gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBpbmRpY2VzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBpbmRpY2VzIHZhbHVlIGJhc2VkIG9uIGRhdGEgSUQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5kaWNlcyBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBEYXRhIGlkIHZhbHVlXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kaWNlcyhpbmRpY2VzLCBpZCkge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmNvbmZpZy5kYXRhX3hzO1xyXG5cclxuXHRcdHJldHVybiBub3RFbXB0eSh4cykgP1xyXG5cdFx0XHRpbmRpY2VzW3hzW2lkXV0gOiBpbmRpY2VzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBpbmRpY2VzIG1heCBudW1iZXJcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5kaWNlcyBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gTWF4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kaWNlc01heChpbmRpY2VzKSB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgP1xyXG5cdFx0XHQvLyBpZiBpcyBtdWx0aXBsZSB4cywgcmV0dXJuIHRvdGFsIHN1bSBvZiB4cycgX19tYXhfXyB2YWx1ZVxyXG5cdFx0XHRPYmplY3Qua2V5cyhpbmRpY2VzKVxyXG5cdFx0XHRcdC5tYXAodiA9PiBpbmRpY2VzW3ZdLl9fbWF4X18gfHwgMClcclxuXHRcdFx0XHQucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIpIDogaW5kaWNlcy5fX21heF9fO1xyXG5cdH0sXHJcblxyXG5cdGdldFNoYXBlWChvZmZzZXQsIGluZGljZXMsIGlzU3ViKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGN1cnJTY2FsZSA9IGlzU3ViID8gc2NhbGUuc3ViWCA6IChzY2FsZS56b29tIHx8IHNjYWxlLngpO1xyXG5cdFx0Y29uc3QgYmFyUGFkZGluZyA9IGNvbmZpZy5iYXJfcGFkZGluZztcclxuXHRcdGNvbnN0IHN1bSA9IChwLCBjKSA9PiBwICsgYztcclxuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGNvbnN0IGluZCA9ICQkLmdldEluZGljZXMoaW5kaWNlcywgZC5pZCk7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gZC5pZCBpbiBpbmQgPyBpbmRbZC5pZF0gOiAwO1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzTnVtID0gKGluZC5fX21heF9fIHx8IDApICsgMTtcclxuXHRcdFx0bGV0IHggPSAwO1xyXG5cclxuXHRcdFx0aWYgKG5vdEVtcHR5KGQueCkpIHtcclxuXHRcdFx0XHRjb25zdCB4UG9zID0gY3VyclNjYWxlKGQueCk7XHJcblxyXG5cdFx0XHRcdGlmIChoYWxmV2lkdGgpIHtcclxuXHRcdFx0XHRcdHggPSB4UG9zIC0gKG9mZnNldFtkLmlkXSB8fCBvZmZzZXQud2lkdGgpICtcclxuXHRcdFx0XHRcdFx0b2Zmc2V0LnRvdGFsLnNsaWNlKDAsIGluZGV4ICsgMSkucmVkdWNlKHN1bSkgLVxyXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHggPSB4UG9zIC0gKGlzTnVtYmVyKG9mZnNldCkgPyBvZmZzZXQgOiBvZmZzZXQud2lkdGgpICogKHRhcmdldHNOdW0gLyAyIC0gaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRqdXN0IHggcG9zaXRpb24gZm9yIGJhci5wYWRkaW5nIG9wdGlvbnFcclxuXHRcdFx0aWYgKG9mZnNldCAmJiB4ICYmIHRhcmdldHNOdW0gPiAxICYmIGJhclBhZGRpbmcpIHtcclxuXHRcdFx0XHRpZiAoaW5kZXgpIHtcclxuXHRcdFx0XHRcdHggKz0gYmFyUGFkZGluZyAqIGluZGV4O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRhcmdldHNOdW0gPiAyKSB7XHJcblx0XHRcdFx0XHR4IC09ICh0YXJnZXRzTnVtIC0gMSkgKiBiYXJQYWRkaW5nIC8gMjtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldHNOdW0gPT09IDIpIHtcclxuXHRcdFx0XHRcdHggLT0gYmFyUGFkZGluZyAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4geDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVZKGlzU3ViKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc1N0YWNrTm9ybWFsaXplZCA9ICQkLmlzU3RhY2tOb3JtYWxpemVkKCk7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGlzU3RhY2tOb3JtYWxpemVkID8gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCBkLCB0cnVlKSA6IChcclxuXHRcdFx0XHQkJC5pc0J1YmJsZVpUeXBlKGQpID8gJCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ5XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIChpc1N1YiA/ICQkLmdldFN1YllTY2FsZShkLmlkKSA6ICQkLmdldFlTY2FsZShkLmlkKSkodmFsdWUpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgU2hhcGUncyBvZmZzZXQgZGF0YVxyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KTogYm9vbGVhbn0gdHlwZUZpbHRlclxyXG5cdCAqIEByZXR1cm4ge3tzaGFwZU9mZnNldFRhcmdldHM6IFNoYXBlT2Zmc2V0VGFyZ2V0W10sIGluZGV4TWFwQnlUYXJnZXRJZDogb2JqZWN0fX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFNoYXBlT2Zmc2V0RGF0YSh0eXBlRmlsdGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpKTtcclxuXHRcdGNvbnN0IHNoYXBlT2Zmc2V0VGFyZ2V0cyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiB7XHJcblx0XHRcdGxldCByb3dWYWx1ZXMgPSB0YXJnZXQudmFsdWVzO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUodGFyZ2V0KSkge1xyXG5cdFx0XHRcdHJvd1ZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAocm93VmFsdWVzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdCByb3dWYWx1ZU1hcEJ5WFZhbHVlID0gcm93VmFsdWVzLnJlZHVjZSgob3V0LCB2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdG91dFtOdW1iZXIodmFsdWUueCldID0gdmFsdWU7XHJcblx0XHRcdFx0cmV0dXJuIG91dDtcclxuXHRcdFx0fSwge30pO1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWVzID0gcm93VmFsdWVzLm1hcChcclxuXHRcdFx0XHQkJC5pc1N0YWNrTm9ybWFsaXplZCgpID9cclxuXHRcdFx0XHRcdHYgPT4gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCB2LCB0cnVlKSA6XHJcblx0XHRcdFx0XHQoe3ZhbHVlfSkgPT4gdmFsdWVcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0aWQ6IHRhcmdldC5pZCxcclxuXHRcdFx0XHRyb3dWYWx1ZXMsXHJcblx0XHRcdFx0cm93VmFsdWVNYXBCeVhWYWx1ZSxcclxuXHRcdFx0XHR2YWx1ZXMsXHJcblx0XHRcdH07XHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGluZGV4TWFwQnlUYXJnZXRJZCA9IHRhcmdldHMucmVkdWNlKChvdXQsIHtpZH0sIGluZGV4KSA9PiB7XHJcblx0XHRcdG91dFtpZF0gPSBpbmRleDtcclxuXHRcdFx0cmV0dXJuIG91dDtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRyZXR1cm4ge2luZGV4TWFwQnlUYXJnZXRJZCwgc2hhcGVPZmZzZXRUYXJnZXRzfTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaGFwZU9mZnNldCh0eXBlRmlsdGVyLCBpbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NoYXBlT2Zmc2V0VGFyZ2V0cywgaW5kZXhNYXBCeVRhcmdldElkfSA9ICQkLmdldFNoYXBlT2Zmc2V0RGF0YSh0eXBlRmlsdGVyKTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGlkeCkgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlKGQuaWQpIDogJCQuZ2V0WVNjYWxlKGQuaWQpO1xyXG5cdFx0XHRjb25zdCB5MCA9IHNjYWxlKDApO1xyXG5cdFx0XHRjb25zdCBkYXRhWEFzTnVtYmVyID0gTnVtYmVyKGQueCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSB5MDtcclxuXHJcblx0XHRcdHNoYXBlT2Zmc2V0VGFyZ2V0c1xyXG5cdFx0XHRcdC5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qgcm93VmFsdWVzID0gdC5yb3dWYWx1ZXM7XHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSB0LnZhbHVlcztcclxuXHJcblx0XHRcdFx0XHRpZiAodC5pZCA9PT0gZC5pZCB8fCBpbmRbdC5pZF0gIT09IGluZFtkLmlkXSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKGluZGV4TWFwQnlUYXJnZXRJZFt0LmlkXSA8IGluZGV4TWFwQnlUYXJnZXRJZFtkLmlkXSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgcm93VmFsdWUgPSByb3dWYWx1ZXNbaWR4XTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSB4IHZhbHVlcyBsaW5lIHVwXHJcblx0XHRcdFx0XHRcdGlmICghcm93VmFsdWUgfHwgTnVtYmVyKHJvd1ZhbHVlLngpICE9PSBkYXRhWEFzTnVtYmVyKSB7XHJcblx0XHRcdFx0XHRcdFx0cm93VmFsdWUgPSB0LnJvd1ZhbHVlTWFwQnlYVmFsdWVbZGF0YVhBc051bWJlcl07XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3dWYWx1ZSAmJiByb3dWYWx1ZS52YWx1ZSAqIGQudmFsdWUgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSBzY2FsZSh2YWx1ZXNbcm93VmFsdWUuaW5kZXhdKSAtIHkwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblNoYXBlKHRoYXQsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XHJcblx0XHRsZXQgaXNXaXRoaW47XHJcblxyXG5cdFx0aWYgKCEkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZSh0aGF0Lm5vZGVOYW1lKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9ICQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmlzV2l0aGluU3RlcCh0aGF0LCAkJC5nZXRZU2NhbGUoZC5pZCkoZC52YWx1ZSkpIDpcclxuXHRcdFx0XHQkJC5pc1dpdGhpbkNpcmNsZSh0aGF0LCAkJC5pc0J1YmJsZVR5cGUoZCkgPyAkJC5wb2ludFNlbGVjdFIoZCkgKiAxLjUgOiAwKTtcclxuXHRcdH0gZWxzZSBpZiAodGhhdC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcclxuXHRcdFx0aXNXaXRoaW4gPSBzaGFwZS5jbGFzc2VkKENMQVNTLmJhcikgPyAkJC5pc1dpdGhpbkJhcih0aGF0KSA6IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzV2l0aGluO1xyXG5cdH0sXHJcblxyXG5cdGdldEludGVycG9sYXRlKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGludGVycG9sYXRpb24gPSAkJC5nZXRJbnRlcnBvbGF0ZVR5cGUoZCk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0XCJiYXNpc1wiOiBkM0N1cnZlQmFzaXMsXHJcblx0XHRcdFwiYmFzaXMtY2xvc2VkXCI6IGQzQ3VydmVCYXNpc0Nsb3NlZCxcclxuXHRcdFx0XCJiYXNpcy1vcGVuXCI6IGQzQ3VydmVCYXNpc09wZW4sXHJcblx0XHRcdFwiYnVuZGxlXCI6IGQzQ3VydmVCdW5kbGUsXHJcblx0XHRcdFwiY2FyZGluYWxcIjogZDNDdXJ2ZUNhcmRpbmFsLFxyXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiOiBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXHJcblx0XHRcdFwiY2FyZGluYWwtb3BlblwiOiBkM0N1cnZlQ2FyZGluYWxPcGVuLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tXCI6IGQzQ3VydmVDYXRtdWxsUm9tLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiOiBkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcclxuXHRcdFx0XCJjYXRtdWxsLXJvbS1vcGVuXCI6IGQzQ3VydmVDYXRtdWxsUm9tT3BlbixcclxuXHRcdFx0XCJtb25vdG9uZS14XCI6IGQzQ3VydmVNb25vdG9uZVgsXHJcblx0XHRcdFwibW9ub3RvbmUteVwiOiBkM0N1cnZlTW9ub3RvbmVZLFxyXG5cdFx0XHRcIm5hdHVyYWxcIjogZDNDdXJ2ZU5hdHVyYWwsXHJcblx0XHRcdFwibGluZWFyLWNsb3NlZFwiOiBkM0N1cnZlTGluZWFyQ2xvc2VkLFxyXG5cdFx0XHRcImxpbmVhclwiOiBkM0N1cnZlTGluZWFyLFxyXG5cdFx0XHRcInN0ZXBcIjogZDNDdXJ2ZVN0ZXAsXHJcblx0XHRcdFwic3RlcC1hZnRlclwiOiBkM0N1cnZlU3RlcEFmdGVyLFxyXG5cdFx0XHRcInN0ZXAtYmVmb3JlXCI6IGQzQ3VydmVTdGVwQmVmb3JlXHJcblx0XHR9W2ludGVycG9sYXRpb25dO1xyXG5cdH0sXHJcblxyXG5cdGdldEludGVycG9sYXRlVHlwZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdHlwZSA9IGNvbmZpZy5zcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlO1xyXG5cdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9ICQkLmlzSW50ZXJwb2xhdGlvblR5cGUodHlwZSkgPyB0eXBlIDogXCJjYXJkaW5hbFwiO1xyXG5cclxuXHRcdHJldHVybiAkJC5pc1NwbGluZVR5cGUoZCkgP1xyXG5cdFx0XHRpbnRlcnBvbGF0aW9uIDogKFxyXG5cdFx0XHRcdCQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdFx0Y29uZmlnLmxpbmVfc3RlcF90eXBlIDogXCJsaW5lYXJcIlxyXG5cdFx0XHQpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogTW9kdWxlcyBleHBvcnRzIGZvciBBeGlzIGJhc2VkIGNoYXJ0XHJcbiAqL1xyXG4vLyBDaGFydFxyXG5pbXBvcnQgYXBpQXhpcyBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2F4aXNcIjtcclxuaW1wb3J0IGFwaUNhdGVnb3J5IGZyb20gXCIuLi8uLi9DaGFydC9hcGkvY2F0ZWdvcnlcIjtcclxuaW1wb3J0IGFwaUZsb3cgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9mbG93XCI7XHJcbmltcG9ydCBhcGlYR3JpZCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2dyaWQueFwiO1xyXG5pbXBvcnQgYXBpWUdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9ncmlkLnlcIjtcclxuaW1wb3J0IGFwaUdyb3VwIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZ3JvdXBcIjtcclxuaW1wb3J0IGFwaVJlZ2lvbiBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL3JlZ2lvbnNcIjtcclxuaW1wb3J0IGFwaVNlbGVjdGlvbiBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQgYXBpWCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL3hcIjtcclxuaW1wb3J0IGFwaVpvb20gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS96b29tXCI7XHJcblxyXG4vLyBDaGFydEludGVybmFsXHJcbmltcG9ydCBkcmFnIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9kcmFnXCI7XHJcbmltcG9ydCBmbG93IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9mbG93XCI7XHJcbmltcG9ydCBldmVudHJlY3QgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL2V2ZW50cmVjdFwiO1xyXG5pbXBvcnQgc3ViY2hhcnQgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL3N1YmNoYXJ0XCI7XHJcbmltcG9ydCB6b29tIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy96b29tXCI7XHJcblxyXG5pbXBvcnQgY2F0ZWdvcnkgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NhdGVnb3J5XCI7XHJcbmltcG9ydCBjbGlwIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVybmFscy9jbGlwXCI7XHJcbmltcG9ydCBncmlkIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVybmFscy9ncmlkXCI7XHJcbmltcG9ydCByZWdpb24gZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3JlZ2lvblwiO1xyXG5pbXBvcnQgc2VsZWN0aW9uIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVybmFscy9zZWxlY3Rpb25cIjtcclxuXHJcbmltcG9ydCBiYXIgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYmFyXCI7XHJcbmltcG9ydCBidWJibGUgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYnViYmxlXCI7XHJcbmltcG9ydCBsaW5lIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL2xpbmVcIjtcclxuaW1wb3J0IHBvaW50IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL3BvaW50XCI7XHJcbmltcG9ydCBzaGFwZSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9zaGFwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGFwaTogW1xyXG5cdFx0YXBpQXhpcyxcclxuXHRcdGFwaUNhdGVnb3J5LFxyXG5cdFx0YXBpRmxvdyxcclxuXHRcdGFwaVhHcmlkLFxyXG5cdFx0YXBpWUdyaWQsXHJcblx0XHRhcGlHcm91cCxcclxuXHRcdGFwaVJlZ2lvbixcclxuXHRcdGFwaVNlbGVjdGlvbixcclxuXHRcdGFwaVgsXHJcblx0XHRhcGlab29tXHJcblx0XSxcclxuXHRpbnRlcm5hbDogW1xyXG5cdFx0Y2F0ZWdvcnksXHJcblx0XHRkcmFnLFxyXG5cdFx0ZmxvdyxcclxuXHRcdHN1YmNoYXJ0LFxyXG5cdFx0em9vbSxcclxuXHJcblx0XHRjbGlwLFxyXG5cdFx0Z3JpZCxcclxuXHRcdHJlZ2lvbixcclxuXHRcdHNlbGVjdGlvbixcclxuXHRcdGV2ZW50cmVjdCxcclxuXHJcblx0XHRiYXIsXHJcblx0XHRidWJibGUsXHJcblx0XHRsaW5lLFxyXG5cdFx0cG9pbnQsXHJcblx0XHRzaGFwZVxyXG5cdF1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdGFyYyBhcyBkM0FyYyxcclxuXHRwaWUgYXMgZDNQaWVcclxufSBmcm9tIFwiZDMtc2hhcGVcIjtcclxuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBkM0ludGVycG9sYXRlfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UGllKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFUeXBlID0gY29uZmlnLmRhdGFfdHlwZTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XHJcblx0XHRjb25zdCBzdGFydGluZ0FuZ2xlID0gY29uZmlnW2Ake2RhdGFUeXBlfV9zdGFydGluZ0FuZ2xlYF0gfHwgMDtcclxuXHRcdGNvbnN0IHBhZEFuZ2xlID0gKFxyXG5cdFx0XHQkJC5oYXNUeXBlKFwicGllXCIpICYmIHBhZGRpbmcgPyBwYWRkaW5nICogMC4wMSA6XHJcblx0XHRcdFx0Y29uZmlnW2Ake2RhdGFUeXBlfV9wYWRBbmdsZWBdXHJcblx0XHQpIHx8IDA7XHJcblx0XHRjb25zdCBzb3J0VmFsdWU6IGFueSA9ICQkLmlzT3JkZXJBc2MoKSB8fCAkJC5pc09yZGVyRGVzYygpID9cclxuXHRcdFx0KGEsIGIpID0+ICgkJC5pc09yZGVyQXNjKCkgPyBhIC0gYiA6IGIgLSBhKSA6IG51bGw7XHJcblxyXG5cdFx0JCQucGllID0gZDNQaWUoKVxyXG5cdFx0XHQuc3RhcnRBbmdsZShzdGFydGluZ0FuZ2xlKVxyXG5cdFx0XHQuZW5kQW5nbGUoc3RhcnRpbmdBbmdsZSArICgyICogTWF0aC5QSSkpXHJcblx0XHRcdC5wYWRBbmdsZShwYWRBbmdsZSlcclxuXHRcdFx0LnNvcnRWYWx1ZXMoc29ydFZhbHVlKVxyXG5cdFx0XHQudmFsdWUoKGQ6IGFueSkgPT4gZC52YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGl1cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnBpZV9pbm5lclJhZGl1cztcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XHJcblx0XHRjb25zdCB3ID0gY29uZmlnLmdhdWdlX3dpZHRoIHx8IGNvbmZpZy5kb251dF93aWR0aDtcclxuXHRcdGNvbnN0IGdhdWdlQXJjV2lkdGggPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoICpcclxuXHRcdFx0Y29uZmlnLmdhdWdlX2FyY3NfbWluV2lkdGg7XHJcblxyXG5cdFx0c3RhdGUucmFkaXVzRXhwYW5kZWQgPSBNYXRoLm1pbihzdGF0ZS5hcmNXaWR0aCwgc3RhdGUuYXJjSGVpZ2h0KSAvIDIgKiAoJCQuaGFzTXVsdGlBcmNHYXVnZSgpID8gMC44NSA6IDEpO1xyXG5cdFx0c3RhdGUucmFkaXVzID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgKiAwLjk1O1xyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA9IHcgPyAoc3RhdGUucmFkaXVzIC0gdykgLyBzdGF0ZS5yYWRpdXMgOiAwLjY7XHJcblx0XHRzdGF0ZS5nYXVnZUFyY1dpZHRoID0gdyB8fCAoXHJcblx0XHRcdGdhdWdlQXJjV2lkdGggPD0gc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzIDpcclxuXHRcdFx0XHQoZ2F1Z2VBcmNXaWR0aCA8PSBzdGF0ZS5yYWRpdXMgPyBnYXVnZUFyY1dpZHRoIDogc3RhdGUucmFkaXVzKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyB8fCAoXHJcblx0XHRcdHBhZGRpbmcgPyBwYWRkaW5nICogKHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gKyAwLjEpIDogMFxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBOT1RFOiBpbm5lclJhZGl1cyBjYW4gYmUgYW4gb2JqZWN0IGJ5IHVzZXIgc2V0dGluZywgb25seSBmb3IgJ3BpZScgdHlwZVxyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID9cclxuXHRcdFx0c3RhdGUucmFkaXVzICogc3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA6IGlubmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdGdldElubmVyUmFkaXVzKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB7aW5uZXJSYWRpdXN9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0aWYgKCFpc051bWJlcihpbm5lclJhZGl1cykgJiYgZCkge1xyXG5cdFx0XHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzW2QuZGF0YS5pZF0gfHwgMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5uZXJSYWRpdXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJjKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnN2Z0FyYyA9ICQkLmdldFN2Z0FyYygpO1xyXG5cdFx0JCQuc3ZnQXJjRXhwYW5kZWQgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFuZ2xlKGRWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBwaWUgPSAkJC5waWU7XHJcblx0XHRsZXQgZCA9IGRWYWx1ZTtcclxuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICghY29uZmlnKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJhZGl1cyA9IE1hdGguUEkgKiAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XHJcblx0XHRjb25zdCBnU3RhcnQgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkpIHtcclxuXHRcdFx0Y29uc3QgdG90YWxTdW0gPSAkJC5nZXRUb3RhbERhdGFTdW0oKTtcclxuXHJcblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gdG90YWxTdW0sIG1ha2UgdG90YWxTdW0gdG8gbWF4IHZhbHVlXHJcblx0XHRcdGlmICh0b3RhbFN1bSA+IGNvbmZpZy5nYXVnZV9tYXgpIHtcclxuXHRcdFx0XHRjb25maWcuZ2F1Z2VfbWF4ID0gdG90YWxTdW07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGdFbmQgPSByYWRpdXMgKiAodG90YWxTdW0gLyAoY29uZmlnLmdhdWdlX21heCAtIGNvbmZpZy5nYXVnZV9taW4pKTtcclxuXHJcblx0XHRcdHBpZSA9IHBpZVxyXG5cdFx0XHRcdC5zdGFydEFuZ2xlKGdTdGFydClcclxuXHRcdFx0XHQuZW5kQW5nbGUoZ0VuZCArIGdTdGFydCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cGllKCQkLmZpbHRlclRhcmdldHNUb1Nob3coKSlcclxuXHRcdFx0LmZvckVhY2goKHQsIGkpID0+IHtcclxuXHRcdFx0XHRpZiAoIWZvdW5kICYmIHQuZGF0YS5pZCA9PT0gZC5kYXRhLmlkKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRkID0gdDtcclxuXHRcdFx0XHRcdGQuaW5kZXggPSBpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzTmFOKGQuc3RhcnRBbmdsZSkpIHtcclxuXHRcdFx0ZC5zdGFydEFuZ2xlID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4oZC5lbmRBbmdsZSkpIHtcclxuXHRcdFx0ZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmhhc011bHRpQXJjR2F1Z2UoKSkge1xyXG5cdFx0XHRjb25zdCBtYXhWYWx1ZSA9ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XHJcblxyXG5cdFx0XHQvLyBpZiBnYXVnZV9tYXggbGVzcyB0aGFuIG1heFZhbHVlLCBtYWtlIG1heFZhbHVlIHRvIG1heCB2YWx1ZVxyXG5cdFx0XHRpZiAobWF4VmFsdWUgPiBjb25maWcuZ2F1Z2VfbWF4KSB7XHJcblx0XHRcdFx0Y29uZmlnLmdhdWdlX21heCA9IG1heFZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBnTWluID0gY29uZmlnLmdhdWdlX21pbjtcclxuXHRcdFx0Y29uc3QgZ01heCA9IGNvbmZpZy5nYXVnZV9tYXg7XHJcblx0XHRcdGNvbnN0IGdUaWMgPSByYWRpdXMgLyAoZ01heCAtIGdNaW4pO1xyXG5cdFx0XHRjb25zdCBnVmFsdWUgPSBkLnZhbHVlIDwgZ01pbiA/IDAgOiBkLnZhbHVlIDwgZ01heCA/IGQudmFsdWUgLSBnTWluIDogKGdNYXggLSBnTWluKTtcclxuXHJcblx0XHRcdGQuc3RhcnRBbmdsZSA9IGdTdGFydDtcclxuXHRcdFx0ZC5lbmRBbmdsZSA9IGdTdGFydCArIGdUaWMgKiBnVmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZvdW5kID8gZCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ZnQXJjKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXIgPSAkJC5nZXRJbm5lclJhZGl1cygpO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bGV0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID8gKHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCkgOiBzdGF0ZS5yYWRpdXMpKVxyXG5cdFx0XHQuaW5uZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6XHJcblx0XHRcdFx0aXNOdW1iZXIoaXIpID8gaXIgOiAwKSk7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXJjID0gZnVuY3Rpb24oZCwgd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRsZXQgcGF0aDogc3RyaW5nIHwgbnVsbCA9IFwiTSAwIDBcIjtcclxuXHJcblx0XHRcdGlmIChkLnZhbHVlIHx8IGQuZGF0YSkge1xyXG5cdFx0XHRcdGlmICghaXNOdW1iZXIoaXIpKSB7XHJcblx0XHRcdFx0XHRhcmMgPSBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0XHRpZiAod2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRcdFx0cGF0aCA9IGFyYyhkKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdHBhdGggPSBhcmModXBkYXRlZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aDtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cclxuXHRcdG5ld0FyYy5jZW50cm9pZCA9IGFyYy5jZW50cm9pZDtcclxuXHJcblx0XHRyZXR1cm4gbmV3QXJjO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0FyY0V4cGFuZGVkKHJhdGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IG5ld1JhdGUgPSByYXRlIHx8IDE7XHJcblx0XHRjb25zdCBzaW5nbGVBcmNXaWR0aCA9IHN0YXRlLmdhdWdlQXJjV2lkdGggLyAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoO1xyXG5cdFx0Y29uc3QgaGFzTXVsdGlBcmNHYXVnZSA9ICQkLmhhc011bHRpQXJjR2F1Z2UoKTtcclxuXHRcdGNvbnN0IGV4cGFuZFdpZHRoID0gTWF0aC5taW4oc3RhdGUucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlIC0gc3RhdGUucmFkaXVzLFxyXG5cdFx0XHRzaW5nbGVBcmNXaWR0aCAqIDAuOCAtICgxIC0gbmV3UmF0ZSkgKiAxMDBcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3QgYXJjID0gZDNBcmMoKVxyXG5cdFx0XHQub3V0ZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCArIGV4cGFuZFdpZHRoIDpcclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXNFeHBhbmRlZCAqIG5ld1JhdGUpXHJcblx0XHRcdClcclxuXHRcdFx0LmlubmVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIChkLmluZGV4ICsgMSkgOiBzdGF0ZS5pbm5lclJhZGl1cykpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRcdGhhc011bHRpQXJjR2F1Z2UgPyBhcmMgOiBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpXHJcblx0XHRcdFx0KSh1cGRhdGVkKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJNIDAgMFwiO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldEFyYyhkLCB3aXRob3V0VXBkYXRlLCBmb3JjZSkge1xyXG5cdFx0cmV0dXJuIGZvcmNlIHx8IHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyB0aGlzLnN2Z0FyYyhkLCB3aXRob3V0VXBkYXRlKSA6IFwiTSAwIDBcIjtcclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1Gb3JBcmNMYWJlbChkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3JhZGl1cywgcmFkaXVzRXhwYW5kZWR9fSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdGxldCB0cmFuc2xhdGUgPSBcIlwiO1xyXG5cclxuXHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdGlmICgkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcclxuXHRcdFx0XHRjb25zdCB5MSA9IE1hdGguc2luKHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHggPSBNYXRoLmNvcyh1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpICogKHJhZGl1c0V4cGFuZGVkICsgMjUpO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSB5MSAqIChyYWRpdXNFeHBhbmRlZCArIDE1IC0gTWF0aC5hYnMoeTEgKiAxMCkpICsgMztcclxuXHJcblx0XHRcdFx0dHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYDtcclxuXHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVHlwZShcImdhdWdlXCIpIHx8ICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0Y29uc3QgYyA9IHRoaXMuc3ZnQXJjLmNlbnRyb2lkKHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IHggPSBpc05hTihjWzBdKSA/IDAgOiBjWzBdO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSBpc05hTihjWzFdKSA/IDAgOiBjWzFdO1xyXG5cdFx0XHRcdGNvbnN0IGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblxyXG5cdFx0XHRcdGxldCByYXRpbyA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvKSB8fFxyXG5cdFx0XHRcdFx0KCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgY29uZmlnLnBpZV9sYWJlbF9yYXRpbyk7XHJcblxyXG5cdFx0XHRcdGlmIChyYXRpbykge1xyXG5cdFx0XHRcdFx0cmF0aW8gPSBpc0Z1bmN0aW9uKHJhdGlvKSA/IHJhdGlvLmJpbmQoJCQuYXBpKShkLCByYWRpdXMsIGgpIDogcmF0aW87XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gcmFkaXVzICYmIChcclxuXHRcdFx0XHRcdFx0aCA/ICgzNiAvIHJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvIHJhZGl1cyA6IDAuOCkgKiByYWRpdXMgLyBoIDogMFxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4ICogcmF0aW99LCR7eSAqIHJhdGlvfSlgO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyYW5zbGF0ZTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VG9BcmNEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmFkZE5hbWUoe1xyXG5cdFx0XHRpZDogZC5kYXRhLmlkLFxyXG5cdFx0XHR2YWx1ZTogZC52YWx1ZSxcclxuXHRcdFx0cmF0aW86IHRoaXMuZ2V0UmF0aW8oXCJhcmNcIiwgZCksXHJcblx0XHRcdGluZGV4OiBkLmluZGV4LFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dGV4dEZvckFyY0xhYmVsKHNlbGVjdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdGlmICgkJC5zaG91bGRTaG93QXJjTGFiZWwoKSkge1xyXG5cdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHVwZGF0ZWQgPyB1cGRhdGVkLnZhbHVlIDogZC52YWx1ZTtcclxuXHRcdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldFJhdGlvKFwiYXJjXCIsIHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhLmlkO1xyXG5cdFx0XHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVW5kZXJUaHJlc2hvbGQgPSAhKFxyXG5cdFx0XHRcdFx0IWhhc0dhdWdlICYmICEkJC5tZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1VuZGVyVGhyZXNob2xkKSB7XHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0ID0gKFxyXG5cdFx0XHRcdFx0XHQkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdFxyXG5cdFx0XHRcdFx0KSh2YWx1ZSwgcmF0aW8sIGlkKS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRcdHNldFRleHRWYWx1ZShub2RlLCB0ZXh0LCBbLTEsIDFdLCBoYXNHYXVnZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yR2F1Z2VNaW5NYXgodmFsdWUsIGlzTWF4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZm9ybWF0ID0gY29uZmlnLmdhdWdlX2xhYmVsX2V4dGVudHM7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdC5iaW5kKCQkLmFwaSkodmFsdWUsIGlzTWF4KSA6IHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEFyYyh0YXJnZXRJZHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge3RyYW5zaXRpbmd9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gTUVNTzogYXZvaWQgdG8gY2FuY2VsIHRyYW5zaXRpb25cclxuXHRcdGlmICh0cmFuc2l0aW5nKSB7XHJcblx0XHRcdGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG5cdFx0XHRcdGlmICghdHJhbnNpdGluZykge1xyXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcblxyXG5cdFx0XHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkfWApLnNpemUoKSA+IDAgJiZcclxuXHRcdFx0XHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCAxMCk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbmV3VGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZiAoISQkLnNob3VsZEV4cGFuZChkLmRhdGEuaWQpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBleHBhbmREdXJhdGlvbiA9ICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIik7XHJcblx0XHRcdFx0Y29uc3Qgc3ZnQXJjRXhwYW5kZWRTdWIgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgkJC5nZXRFeHBhbmRDb25maWcoZC5kYXRhLmlkLCBcInJhdGVcIikpO1xyXG5cclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJwYXRoXCIpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24pXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWQpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24gKiAyKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIHN2Z0FyY0V4cGFuZGVkU3ViKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dW5leHBhbmRBcmModGFyZ2V0SWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHt0cmFuc2l0aW5nfSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRpZiAodHJhbnNpdGluZykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbmV3VGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRzdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyhuZXdUYXJnZXRJZHMsIGAuJHtDTEFTUy5jaGFydEFyY31gKSlcclxuXHRcdFx0LnNlbGVjdEFsbChcInBhdGhcIilcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZCA9PiAkJC5nZXRFeHBhbmRDb25maWcoZC5kYXRhLmlkLCBcImR1cmF0aW9uXCIpKVxyXG5cdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjKTtcclxuXHJcblx0XHRzdmcuc2VsZWN0QWxsKGAke0NMQVNTLmFyY31gKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZXhwYW5kIGNvbmZpZyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBkYXRhIElEXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGtleSBjb25maWcga2V5OiAnZHVyYXRpb24gfCByYXRlJ1xyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEV4cGFuZENvbmZpZyhpZCwga2V5KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZGVmID0ge1xyXG5cdFx0XHRkdXJhdGlvbjogNTAsXHJcblx0XHRcdHJhdGU6IDAuOThcclxuXHRcdH07XHJcblx0XHRsZXQgdHlwZTtcclxuXHJcblx0XHRpZiAoJCQuaXNEb251dFR5cGUoaWQpKSB7XHJcblx0XHRcdHR5cGUgPSBcImRvbnV0XCI7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmlzR2F1Z2VUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJnYXVnZVwiO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc1BpZVR5cGUoaWQpKSB7XHJcblx0XHRcdHR5cGUgPSBcInBpZVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0eXBlID8gY29uZmlnW2Ake3R5cGV9X2V4cGFuZF8ke2tleX1gXSA6IGRlZltrZXldO1xyXG5cdH0sXHJcblxyXG5cdHNob3VsZEV4cGFuZChpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gKCQkLmlzRG9udXRUeXBlKGlkKSAmJiBjb25maWcuZG9udXRfZXhwYW5kKSB8fFxyXG5cdFx0XHQoJCQuaXNHYXVnZVR5cGUoaWQpICYmIGNvbmZpZy5nYXVnZV9leHBhbmQpIHx8XHJcblx0XHRcdCgkJC5pc1BpZVR5cGUoaWQpICYmIGNvbmZpZy5waWVfZXhwYW5kKTtcclxuXHR9LFxyXG5cclxuXHRzaG91bGRTaG93QXJjTGFiZWwoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCJdXHJcblx0XHRcdC5zb21lKHYgPT4gJCQuaGFzVHlwZSh2KSAmJiBjb25maWdbYCR7dn1fbGFiZWxfc2hvd2BdKTtcclxuXHR9LFxyXG5cclxuXHRtZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGhyZXNob2xkID0gJCQuaGFzVHlwZShcImRvbnV0XCIpID8gY29uZmlnLmRvbnV0X2xhYmVsX3RocmVzaG9sZCA6IGNvbmZpZy5waWVfbGFiZWxfdGhyZXNob2xkO1xyXG5cclxuXHRcdHJldHVybiByYXRpbyA+PSB0aHJlc2hvbGQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QXJjTGFiZWxGb3JtYXQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IGZvcm1hdCA9IGNvbmZpZy5waWVfbGFiZWxfZm9ybWF0O1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcclxuXHRcdFx0Zm9ybWF0ID0gY29uZmlnLmdhdWdlX2xhYmVsX2Zvcm1hdDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVHlwZShcImRvbnV0XCIpKSB7XHJcblx0XHRcdGZvcm1hdCA9IGNvbmZpZy5kb251dF9sYWJlbF9mb3JtYXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdC5iaW5kKCQkLmFwaSkgOiBmb3JtYXQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QXJjVGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0eXBlID0gKCQkLmhhc1R5cGUoXCJkb251dFwiKSAmJiBcImRvbnV0XCIpIHx8ICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgXCJnYXVnZVwiKTtcclxuXHJcblx0XHRyZXR1cm4gdHlwZSA/ICQkLmNvbmZpZ1tgJHt0eXBlfV90aXRsZWBdIDogXCJcIjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydEFyYyA9ICQkLmNsYXNzQ2hhcnRBcmMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0FyY3MgPSAkJC5jbGFzc0FyY3MuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IG1haW5QaWVVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXHJcblx0XHRcdC5kYXRhKCQkLnBpZSh0YXJnZXRzKSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRBcmMoZCkgKyBjbGFzc0ZvY3VzKGQuZGF0YSkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5QaWVFbnRlciA9IG1haW5QaWVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEFyYyk7XHJcblxyXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyY3MpXHJcblx0XHRcdC5tZXJnZShtYWluUGllVXBkYXRlKTtcclxuXHJcblx0XHRtYWluUGllRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcImR5XCIsIGhhc0dhdWdlICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IFwiLS4xZW1cIiA6IFwiLjM1ZW1cIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi4sIGJ1dCBub3QgYmFkIHRvIHVwZGF0ZSBjb2xvciBpbiByZWRyYXdcclxuXHRcdC8vIG1haW5QaWVVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRBcmMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cclxuXHRcdCRlbC5hcmNzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QXJjcylcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiYXJjXCIpKTtcclxuXHJcblx0XHQkJC5zZXRBcmNUaXRsZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhcmMgdGl0bGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0QXJjVGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0aXRsZSA9ICQkLmdldEFyY1RpdGxlKCk7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHJcblx0XHRpZiAodGl0bGUpIHtcclxuXHRcdFx0Y29uc3QgdGV4dCA9ICQkLiRlbC5hcmNzLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTW2hhc0dhdWdlID8gXCJjaGFydEFyY3NHYXVnZVRpdGxlXCIgOiBcImNoYXJ0QXJjc1RpdGxlXCJdKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xyXG5cclxuXHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0wLjNlbVwiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMjdweFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2V0VGV4dFZhbHVlKHRleHQsIHRpdGxlLCBoYXNHYXVnZSA/IHVuZGVmaW5lZCA6IFstMC42LCAxLjM1XSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QXJjKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHdpdGhUcmFuc2Zvcm0pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0ludGVyYWN0aW9uID0gY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQ7XHJcblxyXG5cdFx0bGV0IG1haW5BcmMgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmN9YClcclxuXHRcdFx0LmRhdGEoJCQuYXJjRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0bWFpbkFyYy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRtYWluQXJjID0gbWFpbkFyYy5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyYy5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQuZGF0YSkpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChoYXNJbnRlcmFjdGlvbiAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSkge1xyXG5cdFx0XHRcdFx0ZC5zdGFydEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblx0XHRcdFx0XHRkLmVuZEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9jdXJyZW50ID0gZDtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm1lcmdlKG1haW5BcmMpO1xyXG5cclxuXHRcdCQkLmhhc011bHRpQXJjR2F1Z2UoKSAmJiAkJC5yZWRyYXdNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bWFpbkFyY1xyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+ICghJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgwKVwiIDogXCJcIikpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdHJldHVybiBkID09PSB0aGlzLl9jdXJyZW50ID8gXCIwXCIgOiBcIjFcIjtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdHN0YXRlLnRyYW5zaXRpbmcgPSB0cnVlO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHJUd2VlbihcImRcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdFx0aWYgKCF1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4gXCJNIDAgMFwiO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5lbmRBbmdsZSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuZW5kQW5nbGUgPSB0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgdXBkYXRlZCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZCA9IGludGVycG9sYXRlKHQpO1xyXG5cclxuXHRcdFx0XHRcdGludGVycG9sYXRlZC5kYXRhID0gZC5kYXRhOyAvLyBkYXRhLmlkIHdpbGwgYmUgdXBkYXRlZCBieSBpbnRlcnBvcmF0b3JcclxuXHRcdFx0XHRcdHJldHVybiAkJC5nZXRBcmMoaW50ZXJwb2xhdGVkLCB0cnVlKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgxKVwiIDogXCJcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+IHtcclxuXHRcdFx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0XHRcdGlmICgkJC5sZXZlbENvbG9yKSB7XHJcblx0XHRcdFx0XHRjb2xvciA9ICQkLmxldmVsQ29sb3IoZC5kYXRhLnZhbHVlc1swXS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGRhdGEncyBjb2xvclxyXG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfY29sb3JzW2QuZGF0YS5pZF0gPSBjb2xvcjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29sb3IgPSAkJC5jb2xvcihkLmRhdGEuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQvLyBXaGVyZSBnYXVnZSByZWFkaW5nIGNvbG9yIHdvdWxkIHJlY2VpdmUgY3VzdG9taXphdGlvbi5cclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdFx0LmNhbGwoJCQuZW5kYWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoJCQubGV2ZWxDb2xvcikge1xyXG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZDogYW55ID0gcGF0aC5kYXR1bSgpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihkLmRhdGEuaWQsIHBhdGguc3R5bGUoXCJmaWxsXCIpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN0YXRlLnRyYW5zaXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkLmFwaSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vIGJpbmQgYXJjIGV2ZW50c1xyXG5cdFx0aGFzSW50ZXJhY3Rpb24gJiYgJCQuYmluZEFyY0V2ZW50KG1haW5BcmMpO1xyXG5cclxuXHRcdCQkLnJlZHJhd0FyY1RleHQoZHVyYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd011bHRpQXJjR2F1Z2UoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2hpZGRlblRhcmdldElkc30gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRjb25zdCBhcmNMYWJlbExpbmVzID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY0xhYmVsTGluZX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluQXJjTGFiZWxMaW5lID0gYXJjTGFiZWxMaW5lcy5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy5hcmNMYWJlbExpbmV9ICR7Q0xBU1MudGFyZ2V0fSAke0NMQVNTLnRhcmdldH0tJHtkLmRhdGEuaWR9YClcclxuXHRcdFx0Lm1lcmdlKGFyY0xhYmVsTGluZXMpO1xyXG5cclxuXHRcdG1haW5BcmNMYWJlbExpbmVcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICgkJC5sZXZlbENvbG9yID8gJCQubGV2ZWxDb2xvcihkLmRhdGEudmFsdWVzWzBdLnZhbHVlKSA6ICQkLmNvbG9yKGQuZGF0YSkpKVxyXG5cdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gXCJcIiA6IFwibm9uZVwiKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0bGV0IGxpbmVMZW5ndGggPSAwO1xyXG5cdFx0XHRcdGNvbnN0IGxpbmVUaGlja25lc3MgPSAyO1xyXG5cdFx0XHRcdGxldCB4ID0gMDtcclxuXHRcdFx0XHRsZXQgeSA9IDA7XHJcblx0XHRcdFx0bGV0IHRyYW5zZm9ybSA9IFwiXCI7XHJcblxyXG5cdFx0XHRcdGlmIChoaWRkZW5UYXJnZXRJZHMuaW5kZXhPZihkLmRhdGEuaWQpIDwgMCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5uZXJMaW5lTGVuZ3RoID0gc3RhdGUuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggKlxyXG5cdFx0XHRcdFx0XHQodXBkYXRlZC5pbmRleCArIDEpO1xyXG5cdFx0XHRcdFx0Y29uc3QgbGluZUFuZ2xlID0gdXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjSW5uZXJSYWRpdXMgPSBzdGF0ZS5yYWRpdXMgLSBpbm5lckxpbmVMZW5ndGg7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lUG9zaXRpb25pbmdBbmdsZSA9IGxpbmVBbmdsZSAtIChhcmNJbm5lclJhZGl1cyA9PT0gMCA/IDAgOiAoMSAvIGFyY0lubmVyUmFkaXVzKSk7XHJcblxyXG5cdFx0XHRcdFx0bGluZUxlbmd0aCA9IHN0YXRlLnJhZGl1c0V4cGFuZGVkIC0gc3RhdGUucmFkaXVzICsgaW5uZXJMaW5lTGVuZ3RoO1xyXG5cdFx0XHRcdFx0eCA9IE1hdGguY29zKGxpbmVQb3NpdGlvbmluZ0FuZ2xlKSAqIGFyY0lubmVyUmFkaXVzO1xyXG5cdFx0XHRcdFx0eSA9IE1hdGguc2luKGxpbmVQb3NpdGlvbmluZ0FuZ2xlKSAqIGFyY0lubmVyUmFkaXVzO1xyXG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gYHJvdGF0ZSgke2xpbmVBbmdsZSAqIDE4MCAvIE1hdGguUEl9LCAke3h9LCAke3l9KWA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeSlcclxuXHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbGluZUxlbmd0aClcclxuXHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGxpbmVUaGlja25lc3MpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGAwLCAke2xpbmVMZW5ndGggKyBsaW5lVGhpY2tuZXNzfSwgMGApO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRiaW5kQXJjRXZlbnQoYXJjKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGlzTW91c2UgPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwibW91c2VcIjtcclxuXHJcblx0XHRmdW5jdGlvbiBzZWxlY3RBcmMoX3RoaXMsIGFyY0RhdGEsIGlkKSB7XHJcblx0XHRcdC8vIHRyYW5zaXRpb25zXHJcblx0XHRcdCQkLmV4cGFuZEFyYyhpZCk7XHJcblx0XHRcdCQkLmFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKGlkLCB0cnVlKTtcclxuXHRcdFx0JCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCBfdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YT8pIHtcclxuXHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHQkJC51bmV4cGFuZEFyYyhpZCk7XHJcblx0XHRcdCQkLmFwaS5yZXZlcnQoKTtcclxuXHRcdFx0JCQucmV2ZXJ0TGVnZW5kKCk7XHJcblx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0YXJjXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0bGV0IGFyY0RhdGE7XHJcblxyXG5cdFx0XHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRhcmNEYXRhID0gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKTtcclxuXHJcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSAmJiAkJC50b2dnbGVTaGFwZSh0aGlzLCBhcmNEYXRhLCBpKTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suYmluZCgkJC5hcGkpKGFyY0RhdGEsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gbW91c2UgZXZlbnRzXHJcblx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRhcmNcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdFx0c2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQodHJ1ZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpO1xyXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIHRoaXMpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvdWNoIGV2ZW50c1xyXG5cdFx0aWYgKGlzVG91Y2ggJiYgJCQuaGFzQXJjVHlwZSgpICYmICEkJC5yYWRhcnMpIHtcclxuXHRcdFx0Y29uc3QgZ2V0RXZlbnRBcmMgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG91Y2ggPSBkM0V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBldmVudEFyYztcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoc3RhdGUudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZ2V0RXZlbnRBcmMoKTtcclxuXHRcdFx0XHRjb25zdCBkYXR1bTogYW55ID0gZXZlbnRBcmMuZGF0dW0oKTtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gKGRhdHVtICYmIGRhdHVtLmRhdGEgJiYgZGF0dW0uZGF0YS5pZCkgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goYXJjRGF0YSk7XHJcblxyXG5cdFx0XHRcdGlzVW5kZWZpbmVkKGlkKSA/XHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpIDogc2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdCQkLiRlbC5zdmdcclxuXHRcdFx0XHQub24oXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZXIpXHJcblx0XHRcdFx0Lm9uKFwidG91Y2htb3ZlXCIsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyY1RleHQoZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWluLCBhcmNzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0Y29uc3QgaGFzTXVsdGlBcmNHYXVnZSA9ICQkLmhhc011bHRpQXJjR2F1Z2UoKTtcclxuXHRcdGxldCB0ZXh0O1xyXG5cclxuXHRcdC8vIGZvciBnYXVnZSB0eXBlLCB1cGRhdGUgdGV4dCB3aGVuIGhhcyBubyB0aXRsZSAmIG11bHRpIGRhdGFcclxuXHRcdGlmICghKGhhc0dhdWdlICYmICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgY29uZmlnLmdhdWdlX3RpdGxlKSkge1xyXG5cdFx0XHR0ZXh0ID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSA/IENMQVNTLmdhdWdlVmFsdWUgOiBudWxsKSlcclxuXHRcdFx0XHQuY2FsbCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQudHJhbnNmb3JtRm9yQXJjTGFiZWwuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIGQgPT4gKFxyXG5cdFx0XHRcdFx0JCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID09PSAxICYmICFoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRcdFx0YCR7TWF0aC5yb3VuZChzdGF0ZS5yYWRpdXMgLyA1KX1weGAgOiBudWxsXHJcblx0XHRcdFx0KSlcclxuXHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZCA9PiAoJCQuaXNUYXJnZXRUb1Nob3coZC5kYXRhLmlkKSAmJiAkJC5pc0FyY1R5cGUoZC5kYXRhKSA/IFwiMVwiIDogXCIwXCIpKTtcclxuXHJcblx0XHRcdGhhc011bHRpQXJjR2F1Z2UgJiYgdGV4dC5hdHRyKFwiZHlcIiwgXCItLjFlbVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzVGl0bGV9YClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgaGFzR2F1Z2UgPyBcIjFcIiA6IFwiMFwiKTtcclxuXHJcblx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0Y29uc3QgaXNGdWxsQ2lyY2xlID0gY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGU7XHJcblx0XHRcdGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyO1xyXG5cdFx0XHRjb25zdCBlbmRBbmdsZSA9IChpc0Z1bGxDaXJjbGUgPyAtNCA6IC0xKSAqIHN0YXJ0QW5nbGU7XHJcblxyXG5cdFx0XHRpc0Z1bGxDaXJjbGUgJiYgdGV4dCAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBgJHtNYXRoLnJvdW5kKHN0YXRlLnJhZGl1cyAvIDE0KX1gKTtcclxuXHJcblx0XHRcdGxldCBiYWNrZ3JvdW5kQXJjID0gJCQuJGVsLmFyY3Muc2VsZWN0KFxyXG5cdFx0XHRcdGAke2hhc011bHRpQXJjR2F1Z2UgPyBcImdcIiA6IFwiXCJ9LiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRpZiAoaGFzTXVsdGlBcmNHYXVnZSkge1xyXG5cdFx0XHRcdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMgPSBiYWNrZ3JvdW5kQXJjXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKGBwYXRoLiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gKVxyXG5cdFx0XHRcdFx0LmRhdGEoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZEFyYy5lbnRlcigpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH0gJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfS0ke2l9YClcclxuXHRcdFx0XHRcdC5tZXJnZShiYWNrZ3JvdW5kQXJjKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGQxID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5pbmRleE9mKGQxLmlkKSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiTSAwIDBcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZCA9IHtcclxuXHRcdFx0XHRcdFx0XHRkYXRhOiBbe3ZhbHVlOiBjb25maWcuZ2F1Z2VfbWF4fV0sXHJcblx0XHRcdFx0XHRcdFx0c3RhcnRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRlbmRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRpbmRleDogaW5kZXgrK1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmV4aXQoKS5yZW1vdmUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmF0dHIoXCJkXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGQgPSB7XHJcblx0XHRcdFx0XHRcdGRhdGE6IFt7dmFsdWU6IGNvbmZpZy5nYXVnZV9tYXh9XSxcclxuXHRcdFx0XHRcdFx0c3RhcnRBbmdsZSxcclxuXHRcdFx0XHRcdFx0ZW5kQW5nbGVcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdH1gKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuNzVlbVwiKVxyXG5cdFx0XHRcdC50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gY29uZmlnLmdhdWdlX3VuaXRzIDogXCJcIik7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cpIHtcclxuXHRcdFx0XHRhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW59YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7LTEgKiAoc3RhdGUuaW5uZXJSYWRpdXMgKyAoKHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzKSAvIChpc0Z1bGxDaXJjbGUgPyAxIDogMikpKX1weGApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcclxuXHRcdFx0XHRcdC50ZXh0KCQkLnRleHRGb3JHYXVnZU1pbk1heChjb25maWcuZ2F1Z2VfbWluLCBmYWxzZSkpO1xyXG5cclxuXHRcdFx0XHQvLyBzaG93IG1heCB0ZXh0IHdoZW4gaXNuJ3QgZnVsbENpcmNsZVxyXG5cdFx0XHRcdCFpc0Z1bGxDaXJjbGUgJiYgYXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlTWF4fWApXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIGAke3N0YXRlLmlubmVyUmFkaXVzICsgKChzdGF0ZS5yYWRpdXMgLSBzdGF0ZS5pbm5lclJhZGl1cykgLyAyKX1weGApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcclxuXHRcdFx0XHRcdC50ZXh0KCQkLnRleHRGb3JHYXVnZU1pbk1heChjb25maWcuZ2F1Z2VfbWF4LCB0cnVlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0R2F1Z2UoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHthcmNzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGFwcGVuZFRleHQgPSBjbGFzc05hbWUgPT4ge1xyXG5cdFx0XHRhcmNzLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRhcmNzLmFwcGVuZCgkJC5oYXNNdWx0aUFyY0dhdWdlKCkgPyBcImdcIiA6IFwicGF0aFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZCk7XHJcblxyXG5cdFx0XHRjb25maWcuZ2F1Z2VfdW5pdHMgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZVVuaXQpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XHJcblx0XHRcdFx0YXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1pbik7XHJcblx0XHRcdFx0IWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlICYmIGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0R2F1Z2VMYWJlbEhlaWdodCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gMjAgOiAwO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0TWluTWF4LCBnZXRSYW5nZSwgaXNEZWZpbmVkLCBpc0VtcHR5LCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZSwgdG9BcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBwb3NpdGlvbiB2YWx1ZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xvY2t3aXNlIElmIHRoZSBkaXJlY3Rpb24gaXMgY2xvY2t3aXNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIENvb3JkaW5hdGUgdHlwZSAneCcgb3IgJ3knXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlIE51bWJlciBvZiBlZGdlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgVGhlIGluZGV4ZWQgcG9zaXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihpc0Nsb2Nrd2lzZSwgdHlwZSwgZWRnZSwgcG9zLCByYW5nZSwgcmF0aW8pIHtcclxuXHRjb25zdCBpbmRleCA9IGlzQ2xvY2t3aXNlICYmIHBvcyA+IDAgPyBlZGdlIC0gcG9zIDogcG9zO1xyXG5cdGNvbnN0IHIgPSAyICogTWF0aC5QSTtcclxuXHRjb25zdCBmdW5jID0gdHlwZSA9PT0gXCJ4XCIgPyBNYXRoLnNpbiA6IE1hdGguY29zO1xyXG5cclxuXHRyZXR1cm4gcmFuZ2UgKiAoMSAtIHJhdGlvICogZnVuYyhpbmRleCAqIHIgLyBlZGdlKSk7XHJcbn1cclxuXHJcbi8vIGNhY2hlIGtleVxyXG5jb25zdCBjYWNoZUtleSA9IFwiJHJhZGFyUG9pbnRzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJhZGFyKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcInJhZGFyXCIpKSB7XHJcblx0XHRcdCQkLnJhZGFycyA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRSYWRhcnMpO1xyXG5cclxuXHRcdFx0Ly8gbGV2ZWxcclxuXHRcdFx0JCQucmFkYXJzLmxldmVscyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZXZlbHMpO1xyXG5cclxuXHRcdFx0Ly8gYXhpc1xyXG5cdFx0XHQkJC5yYWRhcnMuYXhlcyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzKTtcclxuXHJcblx0XHRcdC8vIHNoYXBlc1xyXG5cdFx0XHQkJC5yYWRhcnMuc2hhcGVzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnNoYXBlcyk7XHJcblxyXG5cdFx0XHQkJC5tYXhWYWx1ZSA9IGNvbmZpZy5yYWRhcl9heGlzX21heCB8fCAkJC5nZXRNaW5NYXhEYXRhKCkubWF4WzBdLnZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFJhZGFyU2l6ZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7YXJjV2lkdGgsIGFyY0hlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA8IDQgPyAtMjAgOiAxMDtcclxuXHRcdGNvbnN0IHNpemUgPSAoTWF0aC5taW4oYXJjV2lkdGgsIGFyY0hlaWdodCkgLSBwYWRkaW5nKSAvIDI7XHJcblxyXG5cdFx0cmV0dXJuIFtzaXplLCBzaXplXTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X2NhdGVnb3JpZXMpKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGdldFJhbmdlKDAsIGdldE1pbk1heChcIm1heFwiLCB0YXJnZXRzLm1hcCh2ID0+IHYudmFsdWVzLmxlbmd0aCkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkYXJQb3NpdGlvbih0eXBlLCBpbmRleCwgcmFuZ2UsIHJhdGlvKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGlzQ2xvY2t3aXNlID0gY29uZmlnLnJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U7XHJcblxyXG5cdFx0Y29uc3QgcG9zID0gdG9BcnJheSh0eXBlKS5tYXAodiA9PiBnZXRQb3NpdGlvbihcclxuXHRcdFx0aXNDbG9ja3dpc2UsXHJcblx0XHRcdHYsXHJcblx0XHRcdGVkZ2UsXHJcblx0XHRcdGluZGV4LFxyXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UpID8gcmFuZ2UgOiAodHlwZSA9PT0gXCJ4XCIgPyB3aWR0aCA6IGhlaWdodCksXHJcblx0XHRcdGlzTnVtYmVyKHJhdGlvKSA/IHJhdGlvIDogY29uZmlnLnJhZGFyX3NpemVfcmF0aW9cclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiBwb3MubGVuZ3RoID09PSAxID8gcG9zWzBdIDogcG9zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVJhZGFyUG9pbnRzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cztcclxuXHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmNhY2hlLmdldChjYWNoZUtleSkgfHwge307XHJcblx0XHRjb25zdCBzaXplID0gcG9pbnRzLl9zaXplO1xyXG5cclxuXHRcdC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9ubHkgd2hlbiB0aGUgcHJldmlvdXMgZGltZW5zaW9uIGhhcyBiZWVuIGNoYW5nZWRcclxuXHRcdGlmICghc2l6ZSB8fCAoc2l6ZS53aWR0aCAhPT0gd2lkdGggJiYgc2l6ZS5oZWlnaHQgIT09IGhlaWdodCkpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdHBvaW50c1tkLmlkXSA9IGQudmFsdWVzLm1hcCgodiwgaSkgPT4gKFxyXG5cdFx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgdW5kZWZpbmVkLCAkJC5nZXRSYXRpbyhcInJhZGFyXCIsIHYpKVxyXG5cdFx0XHRcdCkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBvaW50cy5fc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JhZGFyKGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gJCQuZ2V0VHJhbnNsYXRlKFwicmFkYXJcIik7XHJcblxyXG5cdFx0Ly8gQWRqdXN0IHJhZGFyLCBjaXJjbGVzIGFuZCB0ZXh0cycgcG9zaXRpb25cclxuXHRcdGlmICh0cmFuc2xhdGUpIHtcclxuXHRcdFx0JCQucmFkYXJzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKTtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xyXG5cdFx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XHJcblxyXG5cdFx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyTGV2ZWwoKTtcclxuXHRcdFx0JCQudXBkYXRlUmFkYXJBeGVzKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldFJhZGFyUG9pbnRzKCkge1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1tkLmlkXVtpXTtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJMZXZlbCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IGRlcHRoID0gY29uZmlnLnJhZGFyX2xldmVsX2RlcHRoO1xyXG5cdFx0Y29uc3QgZWRnZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XHJcblx0XHRjb25zdCBzaG93VGV4dCA9IGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X3Nob3c7XHJcblxyXG5cdFx0Y29uc3QgcmFkYXJMZXZlbHMgPSAkJC5yYWRhcnMubGV2ZWxzO1xyXG5cdFx0Y29uc3QgbGV2ZWxEYXRhID0gZ2V0UmFuZ2UoMCwgZGVwdGgpO1xyXG5cclxuXHRcdGNvbnN0IHJhZGl1cyA9IGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvICogTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XHJcblx0XHRjb25zdCBsZXZlbFJhdGlvID0gbGV2ZWxEYXRhLm1hcChsID0+IHJhZGl1cyAqICgobCArIDEpIC8gZGVwdGgpKTtcclxuXHRcdGNvbnN0IGxldmVsVGV4dEZvcm1hdCA9IChjb25maWcucmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQgfHwgZnVuY3Rpb24oKXt9KS5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgcG9pbnRzXHJcblx0XHRjb25zdCBwb2ludHMgPSBsZXZlbERhdGEubWFwKHYgPT4ge1xyXG5cdFx0XHRjb25zdCByYW5nZSA9IGxldmVsUmF0aW9bdl07XHJcblx0XHRcdGNvbnN0IHBvcyA9IGdldFJhbmdlKDAsIGVkZ2UpLm1hcChpID0+IChcclxuXHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCByYW5nZSwgMSkpLmpvaW4oXCIsXCIpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9zLmpvaW4oXCIgXCIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWwgPSByYWRhckxldmVsc1xyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZXZlbH1gKVxyXG5cdFx0XHQuZGF0YShsZXZlbERhdGEpO1xyXG5cclxuXHRcdGxldmVsLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBsZXZlbEVudGVyID0gbGV2ZWwuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmxldmVsfSAke0NMQVNTLmxldmVsfS0ke2l9YCk7XHJcblxyXG5cdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnJhZGFyX2xldmVsX3Nob3cgPyBudWxsIDogXCJoaWRkZW5cIik7XHJcblxyXG5cdFx0aWYgKHNob3dUZXh0KSB7XHJcblx0XHRcdGlmIChyYWRhckxldmVscy5zZWxlY3QoXCJ0ZXh0XCIpLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRyYWRhckxldmVsc1xyXG5cdFx0XHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0uN2VtXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxyXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gbGV2ZWxUZXh0Rm9ybWF0KDApKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuXHRcdFx0XHQudGV4dChkID0+IGxldmVsVGV4dEZvcm1hdChcclxuXHRcdFx0XHRcdCQkLm1heFZhbHVlIC8gbGV2ZWxEYXRhLmxlbmd0aCAqIChkICsgMSlcclxuXHRcdFx0XHQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXZlbEVudGVyXHJcblx0XHRcdC5tZXJnZShsZXZlbClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7d2lkdGggLSBsZXZlbFJhdGlvW2RdfSwgJHtoZWlnaHQgLSBsZXZlbFJhdGlvW2RdfSlgKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwicG9seWdvblwiKVxyXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkXSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGxldmVsIHRleHQgcG9zaXRpb25cclxuXHRcdGlmIChzaG93VGV4dCkge1xyXG5cdFx0XHRyYWRhckxldmVscy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIGQgPT4gKGlzVW5kZWZpbmVkKGQpID8gd2lkdGggOiBwb2ludHNbZF0uc3BsaXQoXCIsXCIpWzBdKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyBoZWlnaHQgOiAwKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJBeGVzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgY2F0ZWdvcmllcyA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcclxuXHJcblx0XHRsZXQgYXhpcyA9ICQkLnJhZGFycy5heGVzLnNlbGVjdEFsbChcImdcIilcclxuXHRcdFx0LmRhdGEoY2F0ZWdvcmllcyk7XHJcblxyXG5cdFx0YXhpcy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Y29uc3QgYXhpc0VudGVyID0gYXhpcy5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuYXhpc30tJHtpfWApO1xyXG5cclxuXHRcdGNvbmZpZy5yYWRhcl9heGlzX2xpbmVfc2hvdyAmJiBheGlzRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcclxuXHRcdGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdyAmJiBheGlzRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcclxuXHJcblx0XHRheGlzID0gYXhpc0VudGVyLm1lcmdlKGF4aXMpO1xyXG5cclxuXHRcdC8vIGF4aXMgbGluZVxyXG5cdFx0aWYgKGNvbmZpZy5yYWRhcl9heGlzX2xpbmVfc2hvdykge1xyXG5cdFx0XHRheGlzLnNlbGVjdChcImxpbmVcIilcclxuXHRcdFx0XHQuYXR0cihcIngxXCIsIHdpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgaGVpZ2h0KVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGkpKVxyXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ5XCIsIGkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBheGlzIHRleHRcclxuXHRcdGlmIChjb25maWcucmFkYXJfYXhpc190ZXh0X3Nob3cpIHtcclxuXHRcdFx0Y29uc3Qge3ggPSAwLCB5ID0gMH0gPSBjb25maWcucmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uO1xyXG5cclxuXHRcdFx0YXhpcy5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuXHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLjVlbVwiKVxyXG5cdFx0XHRcdC5jYWxsKHNlbGVjdGlvbiA9PiB7XHJcblx0XHRcdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHNldFRleHRWYWx1ZShkM1NlbGVjdCh0aGlzKSwgU3RyaW5nKGQpLCBbLTAuNiwgMS4yXSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5kYXR1bSgoZCwgaSkgPT4gKHtpbmRleDogaX0pKVxyXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh0aGlzLndpZHRoKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBjYWNoZSBldmFsdWF0ZWQgYXhpcyB0ZXh0IHdpZHRoXHJcblx0XHRcdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gMjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgcG9zWCA9ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGQuaW5kZXgsIHVuZGVmaW5lZCwgMSk7XHJcblx0XHRcdFx0XHRsZXQgcG9zWSA9IE1hdGgucm91bmQoJCQuZ2V0UmFkYXJQb3NpdGlvbihcInlcIiwgZC5pbmRleCwgdW5kZWZpbmVkLCAxKSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHBvc1ggPiB3aWR0aCkge1xyXG5cdFx0XHRcdFx0XHRwb3NYICs9IHRoaXMud2lkdGggKyB4O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChNYXRoLnJvdW5kKHBvc1gpIDwgd2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0cG9zWCAtPSB0aGlzLndpZHRoICsgeDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAocG9zWSA+IGhlaWdodCkge1xyXG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdmVydGljYWwgY2VudGVyZWQgZWRnZSBheGlzIHRleHQgZHkgcG9zaXRpb25cclxuXHRcdFx0XHRcdFx0aWYgKHBvc1kgLyAyID09PSBoZWlnaHQgJiYgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgPT09IFwidHNwYW5cIikge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBcIjBlbVwiKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cG9zWSArPSB5O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3NZIDwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHBvc1kgLT0geTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgke3Bvc1h9ICR7cG9zWX0pYDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5iaW5kRXZlbnQoKTtcclxuXHR9LFxyXG5cclxuXHRiaW5kRXZlbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2lucHV0VHlwZSwgdHJhbnNpdGluZ30sICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdGNvbnN0IGlzTW91c2UgPSBpbnB1dFR5cGUgPT09IFwibW91c2VcIjtcclxuXHRcdFx0Y29uc3QgZ2V0SW5kZXggPSAoKSA9PiB7XHJcblx0XHRcdFx0bGV0IHRhcmdldCA9IGQzRXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIG11bHRpbGluZWQgYXhpcyB0ZXh0XHJcblx0XHRcdFx0aWYgKC90c3Bhbi9pLnRlc3QodGFyZ2V0LnRhZ05hbWUpKSB7XHJcblx0XHRcdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGQ6IGFueSA9IGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGQgJiYgT2JqZWN0LmtleXMoZCkubGVuZ3RoID09PSAxID8gZC5pbmRleCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29uc3QgaGlkZSA9ICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XHJcblx0XHRcdFx0Y29uc3Qgbm9JbmRleCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcclxuXHJcblx0XHRcdFx0aWYgKGlzTW91c2UgfHwgbm9JbmRleCkge1xyXG5cdFx0XHRcdFx0dGhpcy5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0XHRcdFx0dGhpcy51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBpbmRleCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdCQkLnJhZGFycy5zZWxlY3QoYC4ke0NMQVNTLmF4aXN9YClcclxuXHRcdFx0XHQub24oaXNNb3VzZSA/IFwibW91c2VvdmVyIFwiIDogXCJ0b3VjaHN0YXJ0XCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGlmICh0cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JTaW5nbGUoc3ZnLm5vZGUoKSwgbnVsbCwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0aXNNb3VzZSA/ICQkLnNldE92ZXJPdXQodHJ1ZSwgaW5kZXgpIDogJCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBpc01vdXNlID8gaGlkZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0aWYgKCFpc01vdXNlKSB7XHJcblx0XHRcdFx0c3ZnLm9uKFwidG91Y2hzdGFydFwiLCBoaWRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRjb25zdCBhcmVhcyA9ICQkLnJhZGFycy5zaGFwZXNcclxuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgYXJlYXNFbnRlciA9IGFyZWFzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2hhcnRSYWRhci5iaW5kKCQkKSk7XHJcblxyXG5cdFx0YXJlYXMuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0YXJlYXNFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwicG9seWdvblwiKVxyXG5cdFx0XHQubWVyZ2UoYXJlYXMpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZC5pZF0uam9pbihcIiBcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIHBvaW50IHggY29vcmRpbmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmFkYXJDaXJjbGVYKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlLmdldChjYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgcG9pbnQgeSBjb29yZGluYXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyYWRhckNpcmNsZVkoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVsxXTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIE1vZHVsZXMgZXhwb3J0cyBmb3IgQXJjIGJhc2VkIGNoYXJ0XHJcbiAqL1xyXG4vLyBzaGFwZVxyXG5pbXBvcnQgYXJjIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL2FyY1wiO1xyXG5pbXBvcnQgcmFkYXIgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbnRlcm5hbDogW1xyXG5cdFx0YXJjLFxyXG5cdFx0cmFkYXJcclxuXHRdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHRpbWVQYXJzZSBhcyBkM1RpbWVQYXJzZSxcclxuXHR0aW1lRm9ybWF0IGFzIGQzVGltZUZvcm1hdCxcclxuXHR1dGNQYXJzZSBhcyBkM1V0Y1BhcnNlLFxyXG5cdHV0Y0Zvcm1hdCBhcyBkM1V0Y0Zvcm1hdFxyXG59IGZyb20gXCJkMy10aW1lLWZvcm1hdFwiO1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCBTdG9yZSBmcm9tIFwiLi4vY29uZmlnL1N0b3JlXCI7XHJcbmltcG9ydCBPcHRpb25zIGZyb20gXCIuLi9jb25maWcvT3B0aW9ucy9PcHRpb25zXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDYWNoZSBmcm9tIFwiLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCB7ZXh0ZW5kLCBub3RFbXB0eSwgY29udmVydElucHV0VHlwZSwgZ2V0T3B0aW9uLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVGFiVmlzaWJsZSwgaXNWYWx1ZSwgY2FsbEZuLCBwYXJzZURhdGUsIHNvcnRWYWx1ZX0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vLyBmb3IgVHlwZXNcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG4vLyBBeGlzXHJcbmltcG9ydCBBeGlzIGZyb20gXCIuL0F4aXMvQXhpc1wiO1xyXG5cclxuLy8gZGF0YVxyXG5pbXBvcnQgZGF0YUNvbnZlcnQgZnJvbSBcIi4vZGF0YS9kYXRhLmNvbnZlcnRcIjtcclxuaW1wb3J0IGRhdGEgZnJvbSBcIi4vZGF0YS9kYXRhXCI7XHJcbmltcG9ydCBkYXRhTG9hZCBmcm9tIFwiLi9kYXRhL2RhdGEubG9hZFwiO1xyXG5cclxuLy8gaW50ZXJhY3Rpb25zXHJcbmltcG9ydCBpbnRlcmFjdGlvbiBmcm9tIFwiLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25cIjtcclxuXHJcbi8vIGludGVybmFsc1xyXG5pbXBvcnQgY2xhc3NNb2R1bGUgZnJvbSBcIi4vaW50ZXJuYWxzL2NsYXNzXCI7XHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9pbnRlcm5hbHMvY29sb3JcIjtcclxuaW1wb3J0IGRvbWFpbiBmcm9tIFwiLi9pbnRlcm5hbHMvZG9tYWluXCI7XHJcbmltcG9ydCBmb3JtYXQgZnJvbSBcIi4vaW50ZXJuYWxzL2Zvcm1hdFwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2ludGVybmFscy9sZWdlbmRcIjtcclxuaW1wb3J0IHNjYWxlIGZyb20gXCIuL2ludGVybmFscy9zY2FsZVwiO1xyXG5pbXBvcnQgc2l6ZSBmcm9tIFwiLi9pbnRlcm5hbHMvc2l6ZVwiO1xyXG5pbXBvcnQgdGV4dCBmcm9tIFwiLi9pbnRlcm5hbHMvdGV4dFwiO1xyXG5pbXBvcnQgdGl0bGUgZnJvbSBcIi4vaW50ZXJuYWxzL3RpdGxlXCI7XHJcbmltcG9ydCB0b29sdGlwIGZyb20gXCIuL2ludGVybmFscy90b29sdGlwXCI7XHJcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vaW50ZXJuYWxzL3RyYW5zZm9ybVwiO1xyXG5pbXBvcnQgdHlwZSBmcm9tIFwiLi9pbnRlcm5hbHMvdHlwZVwiO1xyXG5cclxuaW1wb3J0IG1vZHVsZUF4aXMgZnJvbSBcIi4uL2NvbmZpZy9yZXNvbHZlci9heGlzXCI7XHJcbmltcG9ydCBtb2R1bGVBcmMgZnJvbSBcIi4uL2NvbmZpZy9yZXNvbHZlci9hcmNcIjtcclxuXHJcbnR5cGUgTiA9IGQzU2VsZWN0aW9ufG51bGw7XHJcbnR5cGUgRiA9IEZ1bmN0aW9ufG51bGw7XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgY2hhcnQgY2xhc3MuXHJcbiAqIC0gTm90ZTogSW5zdGFudGlhdGVkIGludGVybmFsbHksIG5vdCBleHBvc2VkIGZvciBwdWJsaWMuXHJcbiAqIEBjbGFzcyBDaGFydEludGVybmFsXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJ0SW50ZXJuYWwge1xyXG5cdHB1YmxpYyBhcGk7XHQgICAvLyBBUEkgaW50ZXJmYWNlXHJcblx0cHVibGljIGNvbmZpZzsgLy8gY29uZmlnIG9iamVjdFxyXG5cdHB1YmxpYyBjYWNoZTsgIC8vIGNhY2hlIGluc3RhbmNlXHJcblx0cHVibGljIHN0YXRlOyAgLy8gc3RhdGUgdmFyaWFibGVzXHJcblx0cHVibGljIGNoYXJ0czsgLy8gYWxsIENoYXJ0IGluc3RhbmNlcyBhcnJheSB3aXRoaW4gcGFnZSAoZXF1aXZhbGVudCBvZiAnYmIuaW5zdGFuY2VzJylcclxuXHRwdWJsaWMgaXNBcmMgPSBmYWxzZTsgLy8gaWYgaXMgQXJjIHR5cGUgY2hhcnRcclxuXHJcblx0Ly8gZGF0YSBvYmplY3RcclxuXHRwdWJsaWMgZGF0YSA9IHtcclxuXHRcdHhzOiB7fSxcclxuXHRcdHRhcmdldHM6IFtdXHJcblx0fTtcclxuXHJcblx0Ly8gc2VsZWN0aW9uc1xyXG5cdHB1YmxpYyAkZWw6IHtcclxuXHRcdFtrZXk6IHN0cmluZ106IE4gfCB7W2tleTogc3RyaW5nXTogTn1cclxuXHR9ID0ge1xyXG5cdFx0Y2hhcnQ6IG51bGwsXHJcblx0XHRtYWluOiBudWxsLFxyXG5cdFx0c3ZnOiBudWxsLFxyXG5cdFx0YXhpczogeyAgLy8gYXhlc1xyXG5cdFx0XHR4OiBudWxsLFxyXG5cdFx0XHR5OiBudWxsLFxyXG5cdFx0XHR5MjogbnVsbCxcclxuXHRcdFx0c3ViWDogbnVsbFxyXG5cdFx0fSxcclxuXHRcdGRlZnM6IG51bGwsXHJcblx0XHR0b29sdGlwOiBudWxsLFxyXG5cdFx0bGVnZW5kOiBudWxsLFxyXG5cdFx0dGl0bGU6IG51bGwsXHJcblx0XHRzdWJjaGFydDoge1xyXG5cdFx0XHRtYWluOiBudWxsLCAvLyAkJC5jb250ZXh0XHJcblx0XHRcdGJhcjogbnVsbCwgLy8gJCQuY29udGV4dEJhclxyXG5cdFx0XHRsaW5lOiBudWxsLCAvLyAkJC5jb250ZXh0TGluZVxyXG5cdFx0XHRhcmVhOiBudWxsIC8vICQkLmNvbnRleHRBcmVhXHJcblx0XHR9LFxyXG5cclxuXHRcdGFyY3M6IG51bGwsXHJcblx0XHRiYXI6IG51bGwsIC8vbWFpbkJhcixcclxuXHRcdGxpbmU6IG51bGwsIC8vbWFpbkxpbmUsXHJcblx0XHRhcmVhOiBudWxsLCAvL21haW5BcmVhLFxyXG5cdFx0Y2lyY2xlOiBudWxsLCAvL21haW5DaXJjbGUsXHJcblx0XHR0ZXh0OiBudWxsLCAvL21haW5UZXh0LFxyXG5cdFx0Z3JpZDoge1xyXG5cdFx0XHRtYWluOiBudWxsLCAgLy8gZ3JpZCAoYWxzbyBmb2N1cylcclxuXHRcdFx0eDogbnVsbCwgLy8geGdyaWQsXHJcblx0XHRcdHk6IG51bGwsIC8vIHlncmlkLFxyXG5cdFx0fSxcclxuXHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRtYWluOiBudWxsLCAgLy8gZ3JpZExpbmVzXHJcblx0XHRcdHg6IG51bGwsIC8vIHhncmlkTGluZXMsXHJcblx0XHRcdHk6IG51bGwsIC8vIHlncmlkTGluZXNcclxuXHRcdH0sXHJcblx0XHRyZWdpb246IHtcclxuXHRcdFx0bWFpbjogbnVsbCwgLy9yZWdpb25cclxuXHRcdFx0bGlzdDogbnVsbCAvLyBtYWluUmVnaW9uXHJcblx0XHR9LFxyXG5cdFx0ZXZlbnRSZWN0OiBudWxsXHJcblx0fTtcclxuXHJcblx0Ly8gQXhpc1xyXG5cdHB1YmxpYyBheGlzOyAvLyBBeGlzXHJcblxyXG5cdC8vIHNjYWxlc1xyXG5cdHB1YmxpYyBzY2FsZSA9IHtcclxuXHRcdHg6IG51bGwsXHJcblx0XHR5OiBudWxsLFxyXG5cdFx0eTI6IG51bGwsXHJcblx0XHRzdWJYOiBudWxsLFxyXG5cdFx0c3ViWTogbnVsbCxcclxuXHRcdHN1YlkyOiBudWxsLFxyXG5cdFx0em9vbTogbnVsbFxyXG5cdH1cclxuXHJcblx0Ly8gb3JpZ2luYWwgdmFsdWVzXHJcblx0cHVibGljIG9yZyA9IHtcclxuXHRcdHhTY2FsZTogbnVsbCxcclxuXHRcdHhEb21haW46IG51bGxcclxuXHR9O1xyXG5cclxuXHQvLyBmb3JtYXR0ZXIgZnVuY3Rpb25cclxuXHRwdWJsaWMgY29sb3I7XHJcblx0cHVibGljIHBhdHRlcm5zO1xyXG5cdHB1YmxpYyBsZXZlbENvbG9yO1xyXG5cdHB1YmxpYyBwb2ludDtcclxuXHRwdWJsaWMgYnJ1c2g7XHJcblxyXG5cdC8vIGZvcm1hdCBmdW5jdGlvblxyXG5cdHB1YmxpYyBmb3JtYXQgPSB7XHJcblx0XHRleHRyYUxpbmVDbGFzc2VzOiBudWxsLFxyXG5cdFx0eEF4aXNUaWNrOiBudWxsLFxyXG5cdFx0ZGF0YVRpbWU6IG51bGwsIC8vIGRhdGFUaW1lRm9ybWF0XHJcblx0XHRkZWZhdWx0QXhpc1RpbWU6IG51bGwsIC8vIGRlZmF1bHRBeGlzVGltZUZvcm1hdFxyXG5cdFx0YXhpc1RpbWU6IG51bGwgLy8gYXhpc1RpbWVGb3JtYXRcclxuXHR9O1xyXG5cclxuXHRwdWJsaWMgaGFzQXhpcztcclxuXHRwdWJsaWMgaGFzUmFkYXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmFwaSA9IGFwaTtcclxuXHRcdCQkLmNvbmZpZyA9IG5ldyBPcHRpb25zKCk7XHJcblx0XHQkJC5jYWNoZSA9IG5ldyBDYWNoZSgpO1xyXG5cdFx0JCQuc3RhdGUgPSBuZXcgU3RvcmUoKTsgLy8gc3RhdHVzIHZhcmlhYmxlc1xyXG5cdH1cclxuXHJcblx0YmVmb3JlSW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRiZWZvcmVJbml0XCIpO1xyXG5cclxuXHRcdC8vIGNhbiBkbyBzb21ldGhpbmdcclxuXHRcdGNhbGxGbigkJC5jb25maWcub25iZWZvcmVpbml0LCAkJC5hcGkpO1xyXG5cdH1cclxuXHJcblx0YWZ0ZXJJbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGFmdGVySW5pdFwiKTtcclxuXHJcblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLm9uYWZ0ZXJpbml0LCAkJC5hcGkpO1xyXG5cdH1cclxuXHJcblx0aW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHQkJC5oYXNBeGlzID0gISQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdCQkLmhhc1JhZGFyID0gISQkLmhhc0F4aXMgJiYgJCQuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdCQkLmluaXRQYXJhbXMoKTtcclxuXHJcblx0XHRjb25zdCBiaW5kdG8gPSB7XHJcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXHJcblx0XHRcdGNsYXNzbmFtZTogXCJiYlwiXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWcuYmluZHRvKSkge1xyXG5cdFx0XHRiaW5kdG8uZWxlbWVudCA9IGNvbmZpZy5iaW5kdG8uZWxlbWVudCB8fCBcIiNjaGFydFwiO1xyXG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XHJcblx0XHQkZWwuY2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cclxuXHRcdFx0Y29uZmlnLmJpbmR0by5lbGVtZW50IDogZDNTZWxlY3QoYmluZHRvLmVsZW1lbnQgfHwgW10pO1xyXG5cclxuXHRcdGlmICgkZWwuY2hhcnQuZW1wdHkoKSkge1xyXG5cdFx0XHQkZWwuY2hhcnQgPSBkM1NlbGVjdChkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuY2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKGJpbmR0by5jbGFzc25hbWUsIHRydWUpO1xyXG5cclxuXHRcdCQkLmluaXRUb1JlbmRlcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3NcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlZCBGb3JjZSB0byByZW5kZXIgcHJvY2Vzc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRvUmVuZGVyKGZvcmNlZD86IGJvb2xlYW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc0hpZGRlbiA9ICgpID0+IGNoYXJ0LnN0eWxlKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIgfHwgY2hhcnQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiO1xyXG5cclxuXHRcdGNvbnN0IGlzTGF6eSA9IGNvbmZpZy5yZW5kZXIubGF6eSB8fCBpc0hpZGRlbigpO1xyXG5cdFx0Y29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xyXG5cclxuXHRcdGlmIChpc0xhenkgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBjb25maWcucmVuZGVyLm9ic2VydmUgIT09IGZhbHNlICYmICFmb3JjZWQpIHtcclxuXHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9uLCBvYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdGlmICghaXNIaWRkZW4oKSkge1xyXG5cdFx0XHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG5cdFx0XHRcdFx0IXN0YXRlLnJlbmRlcmVkICYmICQkLmluaXRUb1JlbmRlcih0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pLm9ic2VydmUoY2hhcnQubm9kZSgpLCB7XHJcblx0XHRcdFx0YXR0cmlidXRlczogdHJ1ZSxcclxuXHRcdFx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCIsIFwic3R5bGVcIl1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc0xhenkgfHwgZm9yY2VkKSB7XHJcblx0XHRcdGNvbnN0IGNvbnZlcnRlZERhdGEgPSAkJC5jb252ZXJ0RGF0YShjb25maWcsICQkLmluaXRXaXRoRGF0YSk7XHJcblxyXG5cdFx0XHRjb252ZXJ0ZWREYXRhICYmICQkLmluaXRXaXRoRGF0YShjb252ZXJ0ZWREYXRhKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGluaXRQYXJhbXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXQsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBkYXRldGltZSB0byBiZSB1c2VkIGZvciB1bmlxdWVuZXNzXHJcblx0XHRzdGF0ZS5kYXRldGltZUlkID0gYGJiLSR7K25ldyBEYXRlKCl9YDtcclxuXHJcblx0XHQkJC5jb2xvciA9ICQkLmdlbmVyYXRlQ29sb3IoKTtcclxuXHRcdCQkLmxldmVsQ29sb3IgPSAkJC5nZW5lcmF0ZUxldmVsQ29sb3IoKTtcclxuXHJcblx0XHQvL0BUT0RPOkF4aXMgJiBSYWRhclxyXG5cdFx0aWYgKCQkLmhhc1BvaW50VHlwZSgpKSB7XHJcblx0XHRcdCQkLnBvaW50ID0gJCQuZ2VuZXJhdGVQb2ludCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgkJC5oYXNBeGlzKSB7XHJcblx0XHRcdCQkLmluaXRDbGlwKCk7XHJcbi8vXHRcdFx0JCQucG9pbnQgPSAkJC5nZW5lcmF0ZVBvaW50KCk7XHJcblxyXG5cdFx0XHRmb3JtYXQuZXh0cmFMaW5lQ2xhc3NlcyA9ICQkLmdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKTtcclxuXHRcdFx0Zm9ybWF0LmRhdGFUaW1lID0gY29uZmlnLmRhdGFfeExvY2FsdGltZSA/IGQzVGltZVBhcnNlIDogZDNVdGNQYXJzZTtcclxuXHRcdFx0Zm9ybWF0LmF4aXNUaW1lID0gY29uZmlnLmF4aXNfeF9sb2NhbHRpbWUgPyBkM1RpbWVGb3JtYXQgOiBkM1V0Y0Zvcm1hdDtcclxuXHJcblx0XHRcdGNvbnN0IGlzRHJhZ1pvb20gPSAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLmNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCI7XHJcblxyXG5cdFx0XHRmb3JtYXQuZGVmYXVsdEF4aXNUaW1lID0gZCA9PiB7XHJcblx0XHRcdFx0Y29uc3Qge3gsIHpvb219ID0gJCQuc2NhbGU7XHJcblx0XHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gem9vbSA6XHJcblx0XHRcdFx0XHR6b29tICYmIHgub3JnRG9tYWluKCkudG9TdHJpbmcoKSAhPT0gem9vbS5kb21haW4oKS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzcGVjaWZpZXI6IHN0cmluZyA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXRTZWNvbmRzKCkgJiYgXCIuOiVTXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXRNaW51dGVzKCkgJiYgXCIlSTolTVwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXREYXRlKCkgIT09IDEgJiYgXCIlYiAlZFwiKSB8fFxyXG5cdFx0XHRcdFx0KGlzWm9vbWVkICYmIGQuZ2V0RGF0ZSgpID09PSAxICYmIFwiJWJcXCcleVwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZm9ybWF0LmF4aXNUaW1lKHNwZWNpZmllcikoZCk7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwicmlnaHRcIjtcclxuXHRcdHN0YXRlLmlzTGVnZW5kSW5zZXQgPSBjb25maWcubGVnZW5kX3Bvc2l0aW9uID09PSBcImluc2V0XCI7XHJcblxyXG5cdFx0c3RhdGUuaXNMZWdlbmRUb3AgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1yaWdodFwiO1xyXG5cdFx0c3RhdGUuaXNMZWdlbmRMZWZ0ID0gY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwidG9wLWxlZnRcIiB8fFxyXG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJib3R0b20tbGVmdFwiO1xyXG5cclxuXHRcdHN0YXRlLnJvdGF0ZWRQYWRkaW5nUmlnaHQgPSBpc1JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3hfc2hvdyA/IDAgOiAzMDtcclxuXHRcdHN0YXRlLmlucHV0VHlwZSA9IGNvbnZlcnRJbnB1dFR5cGUoY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZSwgY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaCk7XHJcblx0fVxyXG5cclxuXHRpbml0V2l0aERhdGEoZGF0YSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRjb25maWcsIHN0YXRlLCAkZWwsXHJcblx0XHRcdGhhc0F4aXMsXHJcblx0XHRcdHNjYWxlOiB7XHJcblx0XHRcdFx0eCwgeSwgeTIsIHN1YlgsIHN1YlksIHN1YlkyXHJcblx0XHRcdH0sXHJcblx0XHRcdG9yZ1xyXG5cdFx0fSA9ICQkO1xyXG5cclxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXHJcblx0XHQvLyAkJC5oYXNBcmNUeXBlKCkgJiYgW1wieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGlkID0+IChjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID0gZmFsc2UpKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXhpcykge1xyXG5cdFx0XHQkJC5heGlzID0gbmV3IEF4aXMoJCQpO1xyXG5cdFx0XHRjb25maWcuem9vbV9lbmFibGVkICYmICQkLmluaXRab29tKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5pdCBkYXRhIGFzIHRhcmdldHNcclxuXHRcdCQkLmRhdGEueHMgPSB7fTtcclxuXHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpO1xyXG5cclxuXHRcdGlmIChjb25maWcuZGF0YV9maWx0ZXIpIHtcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcihjb25maWcuZGF0YV9maWx0ZXIuYmluZCgkJC5hcGkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgdGFyZ2V0cyB0byBoaWRlIGlmIG5lZWRlZFxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2hpZGUpIHtcclxuXHRcdFx0JCQuYWRkSGlkZGVuVGFyZ2V0SWRzKFxyXG5cdFx0XHRcdGNvbmZpZy5kYXRhX2hpZGUgPT09IHRydWUgP1xyXG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5kYXRhX2hpZGVcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHRcdGlmIChjb25maWcubGVnZW5kX2hpZGUpIHtcclxuXHRcdFx0JCQuYWRkSGlkZGVuTGVnZW5kSWRzKFxyXG5cdFx0XHRcdGNvbmZpZy5sZWdlbmRfaGlkZSA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmxlZ2VuZF9oaWRlXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5pdCBzaXplcyBhbmQgc2NhbGVzXHJcblx0XHQkJC51cGRhdGVTaXplcygpO1xyXG5cdFx0JCQudXBkYXRlU2NhbGVzKHRydWUpO1xyXG5cclxuXHRcdC8vIFNldCBkb21haW5zIGZvciBlYWNoIHNjYWxlXHJcblx0XHRpZiAoeCkge1xyXG5cdFx0XHR4LmRvbWFpbihzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpKSk7XHJcblx0XHRcdHN1YlguZG9tYWluKHguZG9tYWluKCkpO1xyXG5cclxuXHRcdFx0Ly8gU2F2ZSBvcmlnaW5hbCB4IGRvbWFpbiBmb3Igem9vbSB1cGRhdGVcclxuXHRcdFx0b3JnLnhEb21haW4gPSB4LmRvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh5KSB7XHJcblx0XHRcdHkuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInlcIikpO1xyXG5cdFx0XHRzdWJZLmRvbWFpbih5LmRvbWFpbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoeTIpIHtcclxuXHRcdFx0eTIuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInkyXCIpKTtcclxuXHRcdFx0c3ViWTIgJiYgc3ViWTIuZG9tYWluKHkyLmRvbWFpbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLSBCYXNpYyBFbGVtZW50cyAtLVxyXG5cdFx0JGVsLnN2ZyA9ICRlbC5jaGFydC5hcHBlbmQoXCJzdmdcIilcclxuXHRcdFx0LnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiBzdGF0ZS5pbnB1dFR5cGUpIHtcclxuXHRcdFx0Y29uc3QgaXNUb3VjaCA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xyXG5cclxuXHRcdFx0JGVsLnN2Z1xyXG5cdFx0XHRcdC5vbihpc1RvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZW50ZXJcIiwgKCkgPT4gY2FsbEZuKGNvbmZpZy5vbm92ZXIsICQkLmFwaSkpXHJcblx0XHRcdFx0Lm9uKGlzVG91Y2ggPyBcInRvdWNoZW5kXCIgOiBcIm1vdXNlbGVhdmVcIiwgKCkgPT4gY2FsbEZuKGNvbmZpZy5vbm91dCwgJCQuYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnN2Z19jbGFzc25hbWUgJiYgJGVsLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xyXG5cclxuXHRcdC8vIERlZmluZSBkZWZzXHJcblx0XHRjb25zdCBoYXNDb2xvclBhdHRlcm5zID0gKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSAmJiAkJC5wYXR0ZXJucyk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0F4aXMgfHwgaGFzQ29sb3JQYXR0ZXJucykge1xyXG5cdFx0XHQkZWwuZGVmcyA9ICRlbC5zdmcuYXBwZW5kKFwiZGVmc1wiKTtcclxuXHJcblx0XHRcdGlmICgkJC5oYXNBeGlzKSB7XHJcblx0XHRcdFx0W1wiaWRcIiwgXCJpZFhBeGlzXCIsIFwiaWRZQXhpc1wiLCBcImlkR3JpZFwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0JCQuYXBwZW5kQ2xpcCgkZWwuZGVmcywgc3RhdGUuY2xpcFt2XSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNldCBjb2xvciBwYXR0ZXJuc1xyXG5cdFx0XHRpZiAoaGFzQ29sb3JQYXR0ZXJucykge1xyXG5cdFx0XHRcdCQkLnBhdHRlcm5zLmZvckVhY2gocCA9PiAkZWwuZGVmcy5hcHBlbmQoKCkgPT4gcC5ub2RlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHJlZ2lvbnNcclxuXHRcdGNvbnN0IG1haW4gPSAkZWwuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHQkZWwubWFpbiA9IG1haW47XHJcblxyXG5cdFx0Ly8gaW5pdGlhbGl6ZSBzdWJjaGFydCB3aGVuIHN1YmNoYXJ0IHNob3cgb3B0aW9uIGlzIHNldFxyXG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQuaW5pdFN1YmNoYXJ0KCk7XHJcblxyXG5cdFx0JCQuaW5pdFRvb2x0aXAgJiYgJCQuaW5pdFRvb2x0aXAoKTtcclxuXHRcdCQkLmluaXRMZWdlbmQgJiYgJCQuaW5pdExlZ2VuZCgpO1xyXG5cdFx0JCQuaW5pdFRpdGxlICYmICQkLmluaXRUaXRsZSgpO1xyXG5cclxuXHRcdC8vIC0tIE1haW4gUmVnaW9uIC0tXHJcblxyXG5cdFx0Ly8gdGV4dCB3aGVuIGVtcHR5XHJcblx0XHRpZiAoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCkge1xyXG5cdFx0XHRtYWluLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGAke0NMQVNTLnRleHR9ICR7Q0xBU1MuZW1wdHl9YClcclxuXHRcdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIC8vIGhvcml6b250YWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeCBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdFx0LmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKTsgLy8gdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeSBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMsIGV4Y2VwdCBJRS5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJCQuaGFzQXhpcykge1xyXG5cdFx0XHQvLyBSZWdpb25zXHJcblx0XHRcdCQkLmluaXRSZWdpb24gJiYgJCQuaW5pdFJlZ2lvbigpO1xyXG5cclxuXHRcdFx0Ly8gQWRkIEF4aXMgaGVyZSwgd2hlbiBjbGlwUGF0aCBpcyAnZmFsc2UnXHJcblx0XHRcdCFjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcy5pbml0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcclxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnQpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIHN0YXRlLmNsaXAucGF0aCk7XHJcblxyXG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkaW5pdFwiKTtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQvLyBDb3ZlciB3aG9sZSB3aXRoIHJlY3RzIGZvciBldmVudHNcclxuXHRcdFx0JCQuaW5pdEV2ZW50UmVjdCAmJiAkJC5pbml0RXZlbnRSZWN0KCk7XHJcblxyXG5cdFx0XHQvLyBHcmlkc1xyXG5cdFx0XHQkJC5pbml0R3JpZCAmJiAkJC5pbml0R3JpZCgpO1xyXG5cclxuXHRcdFx0Ly8gaWYgem9vbSBwcml2aWxlZ2VkLCBpbnNlcnQgcmVjdCB0byBmb3JlZnJvbnRcclxuXHRcdFx0Ly8gaWYgKGNvbmZpZy56b29tX2VuYWJsZWQpIHtcclxuXHRcdFx0Ly8gXHRtYWluLmluc2VydChcInJlY3RcIiwgY29uZmlnLnpvb21fcHJpdmlsZWdlZCA/IG51bGwgOiBgZy4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0Ly8gXHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbVJlY3QpXHJcblx0XHRcdC8vIFx0XHQuYXR0cihcIndpZHRoXCIsICQkLnN0YXRlLndpZHRoKVxyXG5cdFx0XHQvLyBcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuc3RhdGUuaGVpZ2h0KVxyXG5cdFx0XHQvLyBcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0Ly8gXHRcdC5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XHJcblx0XHRcdC8vIH1cclxuXHJcblx0XHRcdC8vIEFkZCBBeGlzIGhlcmUsIHdoZW4gY2xpcFBhdGggaXMgJ3RydWUnXHJcblx0XHRcdGNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzICYmICQkLmF4aXMuaW5pdCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmluaXRDaGFydEVsZW1lbnRzKCk7XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBEcmF3IHdpdGggdGFyZ2V0c1xyXG5cdFx0JCQudXBkYXRlRGltZW5zaW9uKCk7XHJcblxyXG5cdFx0Ly8gb25pbml0IGNhbGxiYWNrXHJcblx0XHRjYWxsRm4oY29uZmlnLm9uaW5pdCwgJCQuYXBpKTtcclxuXHJcblx0XHQvLyBTZXQgYmFja2dyb3VuZFxyXG5cdFx0JCQuc2V0QmFja2dyb3VuZCgpO1xyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlLFxyXG5cdFx0XHRpbml0aWFsaXppbmc6IHRydWVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGRhdGEub25taW4vbWF4IGNhbGxiYWNrXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfb25taW4gfHwgY29uZmlnLmRhdGFfb25tYXgpIHtcclxuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4RGF0YSgpO1xyXG5cclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29ubWluLCAkJC5hcGksIG1pbk1heC5taW4pO1xyXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25tYXgsICQkLmFwaSwgbWluTWF4Lm1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmluZCByZXNpemUgZXZlbnRcclxuXHRcdCQkLmJpbmRSZXNpemUoKTtcclxuXHJcblx0XHQvLyBleHBvcnQgZWxlbWVudCBvZiB0aGUgY2hhcnRcclxuXHRcdCQkLmFwaS5lbGVtZW50ID0gJGVsLmNoYXJ0Lm5vZGUoKTtcclxuXHJcblx0XHRzdGF0ZS5yZW5kZXJlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRpbml0Q2hhcnRFbGVtZW50cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtoYXNSYWRhcn0gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGVzID0gW107XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGVPZihcIkFyY1wiKSkge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFwiQXJjXCIpO1xyXG5cclxuXHRcdFx0aWYgKCFoYXNSYWRhcikge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goXCJQaWVcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFwiR2F1Z2VcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoaGFzUmFkYXIpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFwiUmFkYXJcIik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgdHlwZXMucHVzaChcIkJhclwiKTtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJ1YmJsZVwiKSAmJiB0eXBlcy5wdXNoKFwiQnViYmxlXCIpO1xyXG5cdFx0XHQkJC5oYXNUeXBlT2YoXCJMaW5lXCIpICYmIHR5cGVzLnB1c2goXCJMaW5lXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHR5cGVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdCQkW2Bpbml0JHt2fWBdKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRub3RFbXB0eSgkJC5jb25maWcuZGF0YV9sYWJlbHMpICYmICQkLmluaXRUZXh0KCk7XHJcblx0fVxyXG5cclxuXHRzZXRDaGFydEVsZW1lbnRzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHJcblx0XHQkJC5hcGkuJCA9IHtcclxuXHRcdFx0Y2hhcnQ6ICRlbC5jaGFydCxcclxuXHRcdFx0c3ZnOiAkZWwuc3ZnLFxyXG5cdFx0XHRkZWZzOiAkZWwuZGVmcyxcclxuXHRcdFx0bWFpbjogJGVsLm1haW4sXHJcblx0XHRcdHRvb2x0aXA6ICRlbC50b29sdGlwLFxyXG5cdFx0XHRsZWdlbmQ6ICRlbC5sZWdlbmQsXHJcblx0XHRcdHRpdGxlOiAkZWwudGl0bGUsXHJcblx0XHRcdGdyaWQ6ICRlbC5ncmlkLFxyXG5cdFx0XHRhcmM6ICRlbC5hcmNzLFxyXG5cdFx0XHRjaXJjbGVzOiAkZWwuY2lyY2xlLFxyXG5cdFx0XHRiYXI6IHtcclxuXHRcdFx0XHRiYXJzOiAkZWwuYmFyXHJcblx0XHRcdH0sXHJcblx0XHRcdGxpbmU6IHtcclxuXHRcdFx0XHRsaW5lczogJGVsLmxpbmUsXHJcblx0XHRcdFx0YXJlYXM6ICRlbC5hcmVhXHJcblx0XHRcdH0sXHJcblx0XHRcdHRleHQ6IHtcclxuXHRcdFx0XHR0ZXh0czogJGVsLnRleHRcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBiYWNrZ3JvdW5kIGVsZW1lbnQvaW1hZ2VcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEJhY2tncm91bmQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YmFja2dyb3VuZDogYmd9LCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChub3RFbXB0eShiZykpIHtcclxuXHRcdFx0Y29uc3QgZWxlbWVudCA9IHN2Zy5zZWxlY3QoYC4ke0NMQVNTWyQkLmhhc0FyY1R5cGUoKSA/IFwiY2hhcnRcIiA6IFwicmVnaW9uc1wiXX1gKVxyXG5cdFx0XHRcdC5pbnNlcnQoYmcuaW1nVXJsID8gXCJpbWFnZVwiIDogXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xyXG5cclxuXHRcdFx0aWYgKGJnLmltZ1VybCkge1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cihcImhyZWZcIiwgYmcuaW1nVXJsKTtcclxuXHRcdFx0fSBlbHNlIGlmIChiZy5jb2xvcikge1xyXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUoXCJmaWxsXCIsIGJnLmNvbG9yKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxlbWVudFxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYmcuY2xhc3MgfHwgbnVsbClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0YXJnZXRlZCBlbGVtZW50IHdpdGggZ2l2ZW4gZGF0YVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzIERhdGEgb2JqZWN0IGZvcm1hdHRlZCBhcyAndGFyZ2V0J1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0cyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7aGFzQXhpcywgaGFzUmFkYXJ9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gVGV4dFxyXG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gY2lyY2xlXHJcblx0XHRpZiAoJCQuaGFzUG9pbnRUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0Rm9yQ2lyY2xlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpOyAvLyBCYXJcclxuXHRcdFx0JCQuaGFzVHlwZU9mKFwiTGluZVwiKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yTGluZSh0YXJnZXRzKTsgLy8gTGluZVxyXG5cclxuXHRcdFx0Ly8gU3ViIENoYXJ0XHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCAmJlxyXG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEFyYyAmIFJhZGFyXHJcblx0XHRcdCQkLmhhc0FyY1R5cGUodGFyZ2V0cykgJiYgKFxyXG5cdFx0XHRcdGhhc1JhZGFyID9cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6XHJcblx0XHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFkZS1pbiBlYWNoIGNoYXJ0XHJcblx0XHQkJC5zaG93VGFyZ2V0cygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGxheSB0YXJnZXRlZCBlbGVtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd1RhcmdldHMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnRhcmdldH1gKVxyXG5cdFx0XHQuZmlsdGVyKGQgPT4gJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9XHJcblxyXG5cdGdldFdpdGhPcHRpb24ob3B0aW9ucykge1xyXG5cdFx0Y29uc3Qgd2l0aE9wdGlvbnMgPSB7XHJcblx0XHRcdFk6IHRydWUsXHJcblx0XHRcdFN1YmNoYXJ0OiB0cnVlLFxyXG5cdFx0XHRUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRFdmVudFJlY3Q6IHRydWUsXHJcblx0XHRcdERpbWVuc2lvbjogdHJ1ZSxcclxuXHRcdFx0VHJpbVhEb21haW46IHRydWUsXHJcblx0XHRcdFRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdFVwZGF0ZVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHRVcGRhdGVPcmdYRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0TGVnZW5kOiBmYWxzZSxcclxuXHRcdFx0VXBkYXRlWEF4aXM6IFwiVXBkYXRlWERvbWFpblwiLFxyXG5cdFx0XHRUcmFuc2l0aW9uRm9yRXhpdDogXCJUcmFuc2l0aW9uXCIsXHJcblx0XHRcdFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRsZXQgZGVmVmFsID0gd2l0aE9wdGlvbnNba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc1N0cmluZyhkZWZWYWwpKSB7XHJcblx0XHRcdFx0ZGVmVmFsID0gd2l0aE9wdGlvbnNbZGVmVmFsXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2l0aE9wdGlvbnNba2V5XSA9IGdldE9wdGlvbihvcHRpb25zLCBgd2l0aCR7a2V5fWAsIGRlZlZhbCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gd2l0aE9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRyZWRyYXcob3B0aW9ucyA9IHt9LCB0cmFuc2l0aW9uc1ZhbHVlPykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbCwgaGFzUmFkYXJ9ID0gJCQ7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkZWw7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdGNvbnN0IGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nO1xyXG5cdFx0Y29uc3QgZmxvdyA9IG9wdGlvbnMuZmxvdztcclxuXHRcdGNvbnN0IHd0aCA9ICQkLmdldFdpdGhPcHRpb24ob3B0aW9ucyk7XHJcblx0XHRjb25zdCBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JFeGl0ID0gd3RoLlRyYW5zaXRpb25Gb3JFeGl0ID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JBeGlzID0gd3RoLlRyYW5zaXRpb25Gb3JBeGlzID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICQkLmF4aXMgJiYgJCQuYXhpcy5nZW5lcmF0ZVRyYW5zaXRpb25zKGR1cmF0aW9uRm9yQXhpcyk7XHJcblxyXG5cdFx0IShpbml0aWFsaXppbmcgJiYgY29uZmlnLnRvb2x0aXBfaW5pdF9zaG93KSAmJlxyXG5cdFx0XHRzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAkJC5oaWRlVG9vbHRpcCgpO1xyXG5cclxuXHRcdCQkLnVwZGF0ZVNpemVzKGluaXRpYWxpemluZyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGxlZ2VuZCBhbmQgdHJhbnNmb3JtIGVhY2ggZ1xyXG5cclxuXHRcdGlmICh3dGguTGVnZW5kICYmIGNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSwgb3B0aW9ucywgdHJhbnNpdGlvbnMpO1xyXG5cdFx0fSBlbHNlIGlmICh3dGguRGltZW5zaW9uKSB7XHJcblx0XHRcdC8vIG5lZWQgdG8gdXBkYXRlIGRpbWVuc2lvbiAoZS5nLiBheGlzLnkudGljay52YWx1ZXMpIGJlY2F1c2UgeSB0aWNrIHZhbHVlcyBzaG91bGQgY2hhbmdlXHJcblx0XHRcdC8vIG5vIG5lZWQgdG8gdXBkYXRlIGF4aXMgaW4gaXQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgdXBkYXRlZCBpbiByZWRyYXcoKVxyXG5cdFx0XHQkJC51cGRhdGVEaW1lbnNpb24odHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGV4dFxyXG5cdFx0JCQuaGFzRGF0YUxhYmVsKCkgJiYgJCQudXBkYXRlVGV4dChkdXJhdGlvbkZvckV4aXQpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjaXJjbGVZIGJhc2VkIG9uIHVwZGF0ZWQgcGFyYW1ldGVyc1xyXG5cdFx0aWYgKCEkJC5oYXNBcmNUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQudXBkYXRlQ2lyY2xlWSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vQFRPRE86IEF4aXMgJiBSYWRhciB0eXBlXHJcblx0XHRpZiAoJCQuaGFzUG9pbnRUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQudXBkYXRlQ2lyY2xlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGF4aXNcclxuXHRcdGlmICgkJC5oYXNBeGlzKSB7XHJcblx0XHRcdC8vIEBUT0RPOiBNYWtlICdpbml0JyBzdGF0ZSB0byBiZSBhY2Nlc3NpYmxlIGV2ZXJ5d2hlcmUgbm90IHBhc3NpbmcgYXMgYXJndW1lbnQuXHJcblx0XHRcdCQkLmF4aXMucmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpbml0aWFsaXppbmcpO1xyXG5cclxuXHRcdFx0Ly8geGdyaWQgZm9jdXNcclxuXHRcdFx0JCQudXBkYXRlZ3JpZEZvY3VzKCk7XHJcblxyXG5cdFx0XHQvLyBEYXRhIGVtcHR5IGxhYmVsIHBvc2l0aW9uaW5nIGFuZCB0ZXh0LlxyXG5cdFx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCBzdGF0ZS53aWR0aCAvIDIpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHN0YXRlLmhlaWdodCAvIDIpXHJcblx0XHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIHRhcmdldHNUb1Nob3cubGVuZ3RoID8gXCJub25lXCIgOiBudWxsKTtcclxuXHJcblx0XHRcdC8vIGdyaWRcclxuXHRcdFx0JCQudXBkYXRlR3JpZChkdXJhdGlvbik7XHJcblxyXG5cdFx0XHQvLyByZWN0IGZvciByZWdpb25zXHJcblx0XHRcdCQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XHJcblxyXG5cdFx0XHQvLyBiYXJzXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgJCQudXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCk7XHJcblxyXG5cdFx0XHQvLyBsaW5lcywgYXJlYXMgYW5kIGNpcmNsZXNcclxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkxpbmVcIikpIHtcclxuXHRcdFx0XHQkJC51cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJBcmVhXCIpKSB7XHJcblx0XHRcdFx0JCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjaXJjbGVzIGZvciBzZWxlY3RcclxuXHRcdFx0JGVsLnRleHQgJiYgbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc31gKVxyXG5cdFx0XHRcdC5maWx0ZXIoJCQuaXNCYXJUeXBlLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHQvLyBldmVudCByZWN0cyB3aWxsIHJlZHJhd24gd2hlbiBmbG93IGNhbGxlZFxyXG5cdFx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgIWZsb3cgJiYgd3RoLkV2ZW50UmVjdCkge1xyXG5cdFx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gYXJjXHJcblx0XHRcdCRlbC5hcmNzICYmICQkLnJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3dGguVHJhbnNmb3JtKTtcclxuXHJcblx0XHRcdC8vIHJhZGFyXHJcblx0XHRcdCQkLnJhZGFycyAmJiAkJC5yZWRyYXdSYWRhcihkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRpdGxlXHJcblx0XHQkJC5yZWRyYXdUaXRsZSAmJiAkJC5yZWRyYXdUaXRsZSgpO1xyXG5cclxuXHRcdGluaXRpYWxpemluZyAmJiAkJC5zZXRDaGFydEVsZW1lbnRzKCk7XHJcblxyXG5cdFx0JCQuZ2VuZXJhdGVSZWRyYXdMaXN0KHRhcmdldHNUb1Nob3csIGZsb3csIGR1cmF0aW9uLCB3dGguU3ViY2hhcnQpO1xyXG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkcmVkcmF3XCIsIG9wdGlvbnMsIGR1cmF0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIHJlZHJhdyBsaXN0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHMgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGZsb3dcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZHVyYXRpb25cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0cywgZmxvdywgZHVyYXRpb24sIHdpdGhTdWJjaGFydCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBzaGFwZSA9ICQkLmdldERyYXdTaGFwZSgpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBeGlzKSB7XHJcblx0XHRcdC8vIHN1YmNoYXJ0XHJcblx0XHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICQkLnJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydCwgZHVyYXRpb24sIHNoYXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZW5lcmF0ZSBmbG93XHJcblx0XHRjb25zdCBmbG93Rm4gPSBmbG93ICYmICQkLmdlbmVyYXRlRmxvdyh7XHJcblx0XHRcdHRhcmdldHMsXHJcblx0XHRcdGZsb3csXHJcblx0XHRcdGR1cmF0aW9uOiBmbG93LmR1cmF0aW9uLFxyXG5cdFx0XHRzaGFwZSxcclxuXHRcdFx0eHY6ICQkLnh2LmJpbmQoJCQpXHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGlzVHJhbnNpdGlvbiA9IChkdXJhdGlvbiB8fCBmbG93Rm4pICYmIGlzVGFiVmlzaWJsZSgpO1xyXG5cclxuXHRcdC8vIHJlZHJhdyBsaXN0XHJcblx0XHRjb25zdCByZWRyYXdMaXN0ID0gJCQuZ2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIGFmdGVyIHJlZHJhdyBlbmRzXHJcblx0XHRjb25zdCBhZnRlclJlZHJhdyA9IGZsb3cgfHwgY29uZmlnLm9ucmVuZGVyZWQgPyAoKSA9PiB7XHJcblx0XHRcdGZsb3dGbiAmJiBmbG93Rm4oKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5vbnJlbmRlcmVkLCAkJC5hcGkpO1xyXG5cdFx0fSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKGFmdGVyUmVkcmF3KSB7XHJcblx0XHRcdC8vIE9ubHkgdXNlIHRyYW5zaXRpb24gd2hlbiBjdXJyZW50IHRhYiBpcyB2aXNpYmxlLlxyXG5cdFx0XHRpZiAoaXNUcmFuc2l0aW9uICYmIHJlZHJhd0xpc3QubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gV2FpdCBmb3IgZW5kIG9mIHRyYW5zaXRpb25zIGZvciBjYWxsYmFja1xyXG5cdFx0XHRcdGNvbnN0IHdhaXRGb3JEcmF3ID0gJCQuZ2VuZXJhdGVXYWl0KCk7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zaXRpb24gc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSBvbmUgdHJhbnNpdGlvblxyXG5cdFx0XHRcdGQzVHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRyZWRyYXdMaXN0XHJcblx0XHRcdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCB0MSkgPT4gYWNjLmNvbmNhdCh0MSksIFtdKVxyXG5cdFx0XHRcdFx0XHRcdC5mb3JFYWNoKHQgPT4gd2FpdEZvckRyYXcuYWRkKHQpKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQuY2FsbCh3YWl0Rm9yRHJhdywgYWZ0ZXJSZWRyYXcpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFzdGF0ZS50cmFuc2l0aW5nKSB7XHJcblx0XHRcdFx0YWZ0ZXJSZWRyYXcoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBmYWRlaW4gY29uZGl0aW9uXHJcblx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRzdGF0ZS53aXRob3V0RmFkZUluW2lkXSA9IHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGdldFJlZHJhd0xpc3Qoc2hhcGUsIGZsb3csIGZsb3dGbiwgaXNUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBoYXNBeGlzLCBoYXNSYWRhcn0gPSAkJDtcclxuXHRcdGNvbnN0IHtjeCwgY3ksIHhGb3JUZXh0LCB5Rm9yVGV4dH0gPSBzaGFwZS5wb3M7XHJcblx0XHRjb25zdCBsaXN0ID0gW107XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0Y29uc3Qge2FyZWEsIGJhciwgbGluZX0gPSBzaGFwZS50eXBlO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5ncmlkX3hfbGluZXMubGVuZ3RoIHx8IGNvbmZpZy5ncmlkX3lfbGluZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0dyaWQoaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcucmVnaW9ucy5sZW5ndGgpIHtcclxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3UmVnaW9uKGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlT2YoXCJMaW5lXCIpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdMaW5lKGxpbmUsIGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHQkJC5oYXNUeXBlT2YoXCJBcmVhXCIpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdBcmVhKGFyZWEsIGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdCYXIoYmFyLCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoISQkLmhhc0FyY1R5cGUoKSB8fCBoYXNSYWRhcikge1xyXG5cdFx0XHRub3RFbXB0eShjb25maWcuZGF0YV9sYWJlbHMpICYmXHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd1RleHQoeEZvclRleHQsIHlGb3JUZXh0LCBmbG93LCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJCQuaGFzUG9pbnRUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0NpcmNsZShjeCwgY3ksIGlzVHJhbnNpdGlvbiwgZmxvd0ZuKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVBbmRSZWRyYXcob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IHRyYW5zaXRpb25zO1xyXG5cclxuXHRcdC8vIHNhbWUgd2l0aCByZWRyYXdcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2Zvcm1cIiwgZmFsc2UpO1xyXG5cdFx0b3B0aW9ucy53aXRoTGVnZW5kID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aExlZ2VuZFwiLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gTk9UIHNhbWUgd2l0aCByZWRyYXdcclxuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZVhEb21haW4gPSB0cnVlO1xyXG5cdFx0b3B0aW9ucy53aXRoVXBkYXRlT3JnWERvbWFpbiA9IHRydWU7XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yRXhpdCA9IGZhbHNlO1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIG9wdGlvbnMud2l0aFRyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIE1FTU86IGNhbGxlZCBpbiB1cGRhdGVMZWdlbmQgaW4gcmVkcmF3IGlmIHdpdGhMZWdlbmRcclxuXHRcdGlmICghKG9wdGlvbnMud2l0aExlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpKSB7XHJcblx0XHRcdHRyYW5zaXRpb25zID0gJCQuYXhpcy5nZW5lcmF0ZVRyYW5zaXRpb25zKFxyXG5cdFx0XHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JBeGlzID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgc2NhbGVzXHJcblx0XHRcdCQkLnVwZGF0ZVNjYWxlcygpO1xyXG5cdFx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgZyBwb3NpdGlvbnNcclxuXHRcdFx0JCQudHJhbnNmb3JtQWxsKG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEcmF3IHdpdGggbmV3IHNpemVzICYgc2NhbGVzXHJcblx0XHQkJC5yZWRyYXcob3B0aW9ucywgdHJhbnNpdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0cmVkcmF3V2l0aG91dFJlc2NhbGUoKSB7XHJcblx0XHR0aGlzLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhZOiBmYWxzZSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yQXhpczogZmFsc2VcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0aXNDYXRlZ29yaXplZCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZS5pbmRleE9mKFwiY2F0ZWdvcnlcIikgPj0gMCB8fCB0aGlzLmhhc1JhZGFyO1xyXG5cdH1cclxuXHJcblx0aXNDdXN0b21YKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gISQkLmlzVGltZVNlcmllcygpICYmIChjb25maWcuZGF0YV94IHx8IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSk7XHJcblx0fVxyXG5cclxuXHRpc1RpbWVTZXJpZXMoaWQgPSBcInhcIikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnW2BheGlzXyR7aWR9X3R5cGVgXSA9PT0gXCJ0aW1lc2VyaWVzXCI7XHJcblx0fVxyXG5cclxuXHRpc1RpbWVTZXJpZXNZKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUaW1lU2VyaWVzKFwieVwiKTtcclxuXHR9XHJcblxyXG5cdGluaXRpYWxPcGFjaXR5KGQpIHtcclxuXHRcdGNvbnN0IHt3aXRob3V0RmFkZUlufSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyBcIjFcIiA6IFwiMFwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB6b29tIG9yIHVuem9vbWVkIHNjYWxlZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8T2JqZWN0fSBkIERhdGEgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHh4KGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlOiB7eCwgem9vbX19ID0gJCQ7XHJcblx0XHRjb25zdCBmbiA9IGNvbmZpZy56b29tX2VuYWJsZWQgJiYgem9vbSA/XHJcblx0XHRcdHpvb20gOiB4O1xyXG5cclxuXHRcdHJldHVybiBkID8gZm4oaXNWYWx1ZShkLngpID8gZC54IDogZCkgOiBudWxsO1xyXG5cdH1cclxuXHJcblx0eHYoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGU6IHt4fX0gPSAkJDtcclxuXHRcdGxldCB2YWx1ZSA9ICQkLmdldEJhc2VWYWx1ZShkKTtcclxuXHJcblx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0dmFsdWUgPSBwYXJzZURhdGUuY2FsbCgkJCwgdmFsdWUpO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0NhdGVnb3JpemVkKCkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodmFsdWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeCh2YWx1ZSkpO1xyXG5cdH1cclxuXHJcblx0eXYoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NjYWxlOiB7eSwgeTJ9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gZC5heGlzICYmIGQuYXhpcyA9PT0gXCJ5MlwiID8geTIgOiB5O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeVNjYWxlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH1cclxuXHJcblx0c3VieHgoZCkge1xyXG5cdFx0cmV0dXJuIGQgPyB0aGlzLnNjYWxlLnN1YlgoZC54KSA6IG51bGw7XHJcblx0fVxyXG5cclxuXHRiaW5kUmVzaXplKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHQkJC5yZXNpemVGdW5jdGlvbiA9ICQkLmdlbmVyYXRlUmVzaXplKCk7XHJcblx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4gY2FsbEZuKGNvbmZpZy5vbnJlc2l6ZSwgJCQuYXBpKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5yZXNpemVfYXV0bykge1xyXG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4ge1xyXG5cdFx0XHRcdGlmICgkJC5yZXNpemVUaW1lb3V0KSB7XHJcblx0XHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCQkLnJlc2l6ZVRpbWVvdXQpO1xyXG5cdFx0XHRcdFx0JCQucmVzaXplVGltZW91dCA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQkJC5yZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRcdFx0JCQuYXBpLmZsdXNoKGZhbHNlLCB0cnVlKTtcclxuXHRcdFx0XHR9LCAyMDApO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4gY2FsbEZuKGNvbmZpZy5vbnJlc2l6ZWQsICQkLmFwaSkpO1xyXG5cclxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uKTtcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlUmVzaXplKCkge1xyXG5cdFx0Y29uc3QgcmVzaXplRnVuY3Rpb25zID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FsbFJlc2l6ZUZ1bmN0aW9ucygpIHtcclxuXHRcdFx0cmVzaXplRnVuY3Rpb25zLmZvckVhY2goZiA9PiBmKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMuYWRkID0gZiA9PiByZXNpemVGdW5jdGlvbnMucHVzaChmKTtcclxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMucmVtb3ZlID0gZiA9PiByZXNpemVGdW5jdGlvbnMuc3BsaWNlKHJlc2l6ZUZ1bmN0aW9ucy5pbmRleE9mKGYpLCAxKTtcclxuXHJcblx0XHRyZXR1cm4gY2FsbFJlc2l6ZUZ1bmN0aW9ucztcclxuXHR9XHJcblxyXG5cdGVuZGFsbCh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IG4gPSAwO1xyXG5cclxuXHRcdHRyYW5zaXRpb25cclxuXHRcdFx0LmVhY2goKCkgPT4gKytuKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRcdCEtLW4gJiYgY2FsbGJhY2suYXBwbHkodGhpcywgLi4uYXJncyk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVXYWl0KCkge1xyXG5cdFx0bGV0IHRyYW5zaXRpb25zVG9XYWl0ID0gW107XHJcblx0XHRjb25zdCBmID0gZnVuY3Rpb24odCwgY2FsbGJhY2spIHtcclxuXHRcdFx0bGV0IHRpbWVyO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbG9vcCgpIHtcclxuXHRcdFx0XHRsZXQgZG9uZSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCB0OyAodCA9IHRyYW5zaXRpb25zVG9XYWl0W2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAodC5lbXB0eSgpKSB7XHJcblx0XHRcdFx0XHRcdGRvbmUrKztcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dC50cmFuc2l0aW9uKCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGRvbmUrKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG5cdFx0XHRcdGlmIChkb25lID09PSB0cmFuc2l0aW9uc1RvV2FpdC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChsb29wLCA1MCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsb29wKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGYuYWRkID0gZnVuY3Rpb24odCkge1xyXG5cdFx0XHRpc0FycmF5KHQpID9cclxuXHRcdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodCkpIDpcclxuXHRcdFx0XHR0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGwgcGx1Z2luIGhvb2tcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGhhc2UgVGhlIGxpZmVjeWNsZSBwaGFzZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsbFBsdWdpbkhvb2socGhhc2UsIC4uLmFyZ3MpIHtcclxuXHRcdHRoaXMuY29uZmlnLnBsdWdpbnMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0aWYgKHBoYXNlID09PSBcIiRiZWZvcmVJbml0XCIpIHtcclxuXHRcdFx0XHR2LiQkID0gdGhpcztcclxuXHRcdFx0XHR0aGlzLmFwaS5wbHVnaW5zLnB1c2godik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZbcGhhc2VdKC4uLmFyZ3MpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIFtcclxuXHQvLyBjb21tb25cclxuXHRkYXRhQ29udmVydCxcclxuXHRkYXRhLFxyXG5cdGRhdGFMb2FkLFxyXG5cdGNsYXNzTW9kdWxlLFxyXG5cdGNvbG9yLFxyXG5cdGRvbWFpbixcclxuXHRpbnRlcmFjdGlvbixcclxuXHRmb3JtYXQsXHJcblx0bGVnZW5kLFxyXG5cdHNjYWxlLFxyXG5cdHNpemUsXHJcblx0dGV4dCxcclxuXHR0aXRsZSxcclxuXHR0b29sdGlwLFxyXG5cdHRyYW5zZm9ybSxcclxuXHR0eXBlLFxyXG5cdC4uLm1vZHVsZUFyYy5pbnRlcm5hbCxcclxuXHQuLi5tb2R1bGVBeGlzLmludGVybmFsXHJcbl0pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IHtsb2FkQ29uZmlnfTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGNvbmZpZ3VyYXRpb24gb3B0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVXNlcidzIGdlbmVyYXRpb24gY29uZmlnIHZhbHVlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkQ29uZmlnKGNvbmZpZykge1xyXG5cdGNvbnN0IHRoaXNDb25maWcgPSB0aGlzLmNvbmZpZztcclxuXHRsZXQgdGFyZ2V0O1xyXG5cdGxldCBrZXlzO1xyXG5cdGxldCByZWFkO1xyXG5cclxuXHRjb25zdCBmaW5kID0gKCkgPT4ge1xyXG5cdFx0Y29uc3Qga2V5ID0ga2V5cy5zaGlmdCgpO1xyXG5cclxuXHRcdGlmIChrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0W2tleV07XHJcblx0XHRcdHJldHVybiBmaW5kKCk7XHJcblx0XHR9IGVsc2UgaWYgKCFrZXkpIHtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH07XHJcblxyXG5cdE9iamVjdC5rZXlzKHRoaXNDb25maWcpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdHRhcmdldCA9IGNvbmZpZztcclxuXHRcdGtleXMgPSBrZXkuc3BsaXQoXCJfXCIpO1xyXG5cdFx0cmVhZCA9IGZpbmQoKTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKHJlYWQpKSB7XHJcblx0XHRcdHRoaXNDb25maWdba2V5XSA9IHJlYWQ7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogUmVzaXplIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIHJlc2l6ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaXplIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHMuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBSZXNpemUgdG8gNjQweDQ4MFxyXG5cdCAqIGNoYXJ0LnJlc2l6ZSh7XHJcblx0ICogICAgd2lkdGg6IDY0MCxcclxuXHQgKiAgICBoZWlnaHQ6IDQ4MFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdHJlc2l6ZShzaXplPzoge3dpZHRoPzogbnVtYmVyLCBoZWlnaHQ/OiBudW1iZXJ9KSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0Y29uZmlnLnNpemVfd2lkdGggPSBzaXplID8gc2l6ZS53aWR0aCA6IG51bGw7XHJcblx0XHRjb25maWcuc2l6ZV9oZWlnaHQgPSBzaXplID8gc2l6ZS5oZWlnaHQgOiBudWxsO1xyXG5cclxuXHRcdHRoaXMuZmx1c2goZmFsc2UsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvcmNlIHRvIHJlZHJhdy5cclxuXHQgKiBAbWV0aG9kIGZsdXNoXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbc29mdF0gRm9yIHNvZnQgcmVkcmF3LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZmx1c2goKTtcclxuXHQgKlxyXG5cdCAqIC8vIGZvciBzb2Z0IHJlZHJhd1xyXG5cdCAqIGNoYXJ0LmZsdXNoKHRydWUpO1xyXG5cdCAqL1xyXG5cdGZsdXNoKHNvZnQ/OiBib29sZWFuLCBfaXNGcm9tUmVzaXplPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHJcblx0XHRpZiAoJCQuc3RhdGUucmVuZGVyZWQpIHtcclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgem9vbSBzY2FsZSB3aGVuIGlzIGNhbGxlZCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0XHRpZiAoX2lzRnJvbVJlc2l6ZSkge1xyXG5cdFx0XHRcdCQkLmJydXNoICYmICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHJlLXVwZGF0ZSBjb25maWcgaW5mb1xyXG5cdFx0XHRcdCQkLmF4aXMgJiYgJCQuYXhpcy5zZXRPcmllbnQoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JCQuc2NhbGUuem9vbSA9IG51bGw7XHJcblxyXG5cdFx0XHRzb2Z0ID8gJCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHRcdFx0fSkgOiAkJC51cGRhdGVBbmRSZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWUsXHJcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5pbml0VG9SZW5kZXIodHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgdGhlIGNoYXJ0IG9iamVjdCBhbmQgcmVtb3ZlIGVsZW1lbnQgYW5kIGV2ZW50cyBjb21wbGV0ZWx5LlxyXG5cdCAqIEBtZXRob2QgZGVzdHJveVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZGVzdHJveSgpO1xyXG5cdCAqL1xyXG5cdGRlc3Ryb3koKTogbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7JGVsOiB7Y2hhcnQsIHN2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG5vdEVtcHR5KCQkKSkge1xyXG5cdFx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiR3aWxsRGVzdHJveVwiKTtcclxuXHRcdFx0JCQuY2hhcnRzLnNwbGljZSgkJC5jaGFydHMuaW5kZXhPZih0aGlzKSwgMSk7XHJcblxyXG5cdFx0XHQvLyBjbGVhciB0aW1lcnMgJiYgcGVuZGluZyB0cmFuc2l0aW9uXHJcblx0XHRcdHN2Zy5zZWxlY3QoXCIqXCIpLmludGVycnVwdCgpO1xyXG5cdFx0XHRpc0RlZmluZWQoJCQucmVzaXplVGltZW91dCkgJiYgd2luZG93LmNsZWFyVGltZW91dCgkJC5yZXNpemVUaW1lb3V0KTtcclxuXHJcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uKTtcclxuXHRcdFx0Y2hhcnQuY2xhc3NlZChcImJiXCIsIGZhbHNlKS5odG1sKFwiXCIpO1xyXG5cclxuXHRcdFx0Ly8gcmVsZWFzaW5nIHJlZmVyZW5jZXNcclxuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdGtleSA9PT0gXCJpbnRlcm5hbFwiICYmIE9iamVjdC5rZXlzKCQkKS5mb3JFYWNoKGsgPT4ge1xyXG5cdFx0XHRcdFx0JCRba10gPSBudWxsO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzW2tleV0gPSBudWxsO1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBvciBzZXQgc2luZ2xlIGNvbmZpZyBvcHRpb24gdmFsdWUuXHJcblx0ICogQG1ldGhvZCBjb25maWdcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgb3B0aW9uIGtleSBuYW1lLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgYWNjZXB0ZWQgZm9yIGluZGljYXRlZCBvcHRpb24uXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVkcmF3XSBTZXQgdG8gcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb24gY2hhbmdlcy5cclxuXHQgKiAtICoqTk9URToqKiBEb2Vzbid0IGd1YXJhbnRlZSB3b3JrIGluIGFsbCBjaXJjdW1zdGFuY2VzLiBJdCBjYW4gYmUgYXBwbGllZCBmb3IgbGltaXRlZCBvcHRpb25zIG9ubHkuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXR0ZXJcclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIik7XHJcblx0ICpcclxuXHQgKiAvLyBTZXR0ZXJcclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIiwgMTAwKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNldHRlciAmIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCwgdHJ1ZSk7XHJcblx0ICovXHJcblx0Y29uZmlnKG5hbWU6IHN0cmluZywgdmFsdWU/OiBhbnksIHJlZHJhdz86IGJvb2xlYW4pOiBhbnkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGtleSA9IG5hbWUgJiYgbmFtZS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xyXG5cdFx0bGV0IHJlcztcclxuXHJcblx0XHRpZiAoa2V5IGluIGNvbmZpZykge1xyXG5cdFx0XHRpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG5cdFx0XHRcdGNvbmZpZ1trZXldID0gdmFsdWU7XHJcblx0XHRcdFx0cmVzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdHJlZHJhdyAmJiB0aGlzLmZsdXNoKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzID0gY29uZmlnW2tleV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBjb2xvclxyXG5cdCAqIEBtZXRob2QgY29sb3JcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY29sb3IoXCJkYXRhMVwiKTtcclxuXHQgKi9cclxuXHRjb2xvcihpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5jb2xvcihpZCk7IC8vIG1vcmUgcGF0dGVybnNcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmQsIGlzVW5kZWZpbmVkLCBpc0FycmF5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG4gKiBAbWV0aG9kIGRhdGFcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIHJldHVybnMgdGhlIHNwZWNpZmllZCB0YXJnZXQgZGF0YS4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcclxuICogQGV4YW1wbGVcclxuICogLy8gR2V0IG9ubHkgZGF0YTEgZGF0YVxyXG4gKiBjaGFydC5kYXRhKFwiZGF0YTFcIik7XHJcbiAqIC8vIC0tPiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IEFycmF5KDYpfSwgLi4uXVxyXG4gKlxyXG4gKiAvLyBHZXQgZGF0YTEgYW5kIGRhdGEyIGRhdGFcclxuICogY2hhcnQuZGF0YShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuICpcclxuICogLy8gR2V0IGFsbCBkYXRhXHJcbiAqIGNoYXJ0LmRhdGEoKTtcclxuICovXHJcbmZ1bmN0aW9uIGRhdGEodGFyZ2V0SWRzKSB7XHJcblx0Y29uc3Qge3RhcmdldHN9ID0gdGhpcy5pbnRlcm5hbC5kYXRhO1xyXG5cclxuXHRpZiAoIWlzVW5kZWZpbmVkKHRhcmdldElkcykpIHtcclxuXHRcdGNvbnN0IGlkcyA9IGlzQXJyYXkodGFyZ2V0SWRzKSA/IHRhcmdldElkcyA6IFt0YXJnZXRJZHNdO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXRzLmZpbHRlcih0ID0+IGlkcy5zb21lKHYgPT4gdiA9PT0gdC5pZCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldHM7XHJcbn1cclxuXHJcbmV4dGVuZChkYXRhLCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgc2hvd24gaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgZGF0YeKApHNob3duXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSBmaWx0ZXJzIHRoZSBkYXRhIHdpdGggc3BlY2lmaWVkIHRhcmdldCBpZHMuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgc2hvd24gZGF0YSB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIG9ubHkgZGF0YTEgZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cclxuXHQgKlxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIGRhdGExIGFuZCBkYXRhMiBkYXRhXHJcblx0ICogY2hhcnQuZGF0YS5zaG93bihbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEdldCBhbGwgc2hvd24gZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oKTtcclxuXHQgKi9cclxuXHRzaG93bjogZnVuY3Rpb24odGFyZ2V0SWRzOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZmlsdGVyVGFyZ2V0c1RvU2hvdyh0aGlzLmRhdGEodGFyZ2V0SWRzKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHZhbHVlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgZGF0YeKApHZhbHVlc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgVGhpcyBBUEkgcmV0dXJucyB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB0YXJnZXQuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBudWxsIHdpbGwgYmUgcmV0cnVuZWRcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSB2YWx1ZXNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBkYXRhMSB2YWx1ZXNcclxuXHQgKiBjaGFydC5kYXRhLnZhbHVlcyhcImRhdGExXCIpO1xyXG5cdCAqIC8vIC0tPiBbMTAsIDIwLCAzMCwgNDBdXHJcblx0ICovXHJcblx0dmFsdWVzOiBmdW5jdGlvbih0YXJnZXRJZD86IHN0cmluZyB8IHN0cmluZ1tdLCBmbGF0OiBib29sZWFuID0gdHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlcztcclxuXHJcblx0XHRpZiAodGFyZ2V0SWQpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IHRoaXMuZGF0YSh0YXJnZXRJZCk7XHJcblxyXG5cdFx0XHRpZiAodGFyZ2V0cyAmJiBpc0FycmF5KHRhcmdldHMpKSB7XHJcblx0XHRcdFx0dmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRcdHRhcmdldHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGRhdGFWYWx1ZSA9IHYudmFsdWVzLm1hcChkID0+IGQudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdGZsYXQgPyAodmFsdWVzID0gdmFsdWVzLmNvbmNhdChkYXRhVmFsdWUpKSA6IHZhbHVlcy5wdXNoKGRhdGFWYWx1ZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IG5hbWVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQG1ldGhvZCBkYXRh4oCkbmFtZXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbmFtZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG5hbWVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IG5hbWVzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhc1xyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IG5hbWVzXHJcblx0ICogY2hhcnQuZGF0YS5uYW1lcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwidGVzdDFcIiwgZGF0YTI6IFwidGVzdDJcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBuYW1lc1xyXG5cdCAqIGNoYXJ0LmRhdGEubmFtZXMoe1xyXG5cdCAqICBkYXRhMTogXCJOZXcgTmFtZSAxXCIsXHJcblx0ICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxyXG5cdCAqfSk7XHJcblx0ICovXHJcblx0bmFtZXM6IGZ1bmN0aW9uKG5hbWVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KToge1trZXk6IHN0cmluZ106IHN0cmluZ30ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdC8vIHJlc2V0IGV4aXN0aW5nIGxlZ2VuZCBpdGVtIGRpbWVuc2lvbiBkYXRhXHJcblx0XHQkJC5nZXRMZWdlbmRJdGVtVGV4dEJveCgpO1xyXG5cclxuXHRcdHJldHVybiAkJC51cGRhdGVEYXRhQXR0cmlidXRlcyhcIm5hbWVzXCIsIG5hbWVzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBjb2xvcnMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIGRhdGHigKRjb2xvcnNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjb2xvcnMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgY29sb3JzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBbZGF0YS5jb2xvcnNdKC4vT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sb3JzKS5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgZGF0YSBjb2xvciB2YWx1ZSBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZS5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IGNvbG9yc1xyXG5cdCAqIGNoYXJ0LmRhdGEuY29sb3JzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCIjMDBjNzNjXCIsIGRhdGEyOiBcIiNmYTcxNzFcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBjb2xvcnNcclxuXHQgKiBjaGFydC5kYXRhLmNvbG9ycyh7XHJcblx0ICogIGRhdGExOiBcIiNGRkZGRkZcIixcclxuXHQgKiAgZGF0YTI6IFwiIzAwMDAwMFwiXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0Y29sb3JzOiBmdW5jdGlvbihjb2xvcnM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfT4pIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiY29sb3JzXCIsIGNvbG9ycyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIC0gKipOT1RFOioqIElmIGFsbCBkYXRhIGlzIHJlbGF0ZWQgdG8gb25lIG9mIHRoZSBheGVzLCB0aGUgZG9tYWluIG9mIGF4aXMgd2l0aG91dCByZWxhdGVkIGRhdGEgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZG9tYWluIGZyb20gdGhlIGF4aXMgd2l0aCByZWxhdGVkIGRhdGFcclxuXHQgKiBAbWV0aG9kIGRhdGHigKRheGVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGF4ZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGF4ZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgYXhlcyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXNcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgYXhlcyB2YWx1ZSBmb3IgZGF0YSwgaWYgc3BlY2lmaWVkIGF4ZXMgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5heGVzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ5XCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcyh7XHJcblx0ICogIGRhdGExOiBcInlcIixcclxuXHQgKiAgZGF0YTI6IFwieTJcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGF4ZXM6IGZ1bmN0aW9uKGF4ZXM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Pik6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwudXBkYXRlRGF0YUF0dHJpYnV0ZXMoXCJheGVzXCIsIGF4ZXMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluaW11bSBkYXRhIHZhbHVlIGJvdW5kIHRvIHRoZSBjaGFydFxyXG5cdCAqIEBtZXRob2QgZGF0YeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IGF4ZXNcclxuXHQgKiBjaGFydC5kYXRhLm1pbigpO1xyXG5cdCAqIC8vIC0tPiBbe3g6IDAsIHZhbHVlOiAzMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDB9LCAuLi5dXHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbigpOiB7IHg6IG51bWJlciwgdmFsdWU6IG51bWJlciwgaWQ6IHN0cmluZywgaW5kZXg6IG51bWJlciB9W10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1pbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1heGltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcclxuXHQgKiBAbWV0aG9kIGRhdGHigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5tYXgoKTtcclxuXHQgKiAvLyAtLT4gW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLl1cclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKCk6IHt4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGlkOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9W10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1heDtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2RhdGF9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7aXNGdW5jdGlvbiwgdG9BcnJheSwgZ2V0Q3NzUnVsZXN9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB0byBiYXNlNjRcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nXHJcbiAqL1xyXG5jb25zdCBiNjRFbmNvZGVVbmljb2RlID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IGJ0b2EoXHJcblx0ZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcclxuXHRcdC5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAobWF0Y2gsIHA6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlcihgMHgke3B9YCkpKVxyXG4pO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc3ZnIG5vZGUgdG8gZGF0YSB1cmxcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc2l6ZVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlVG9TdmdEYXRhVXJsKG5vZGUsIHNpemUpIHtcclxuXHRjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcclxuXHRjb25zdCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xyXG5cdGNvbnN0IGNzc1RleHQgPSBnZXRDc3NSdWxlcyh0b0FycmF5KGRvY3VtZW50LnN0eWxlU2hlZXRzKSlcclxuXHRcdC5maWx0ZXIoKHI6IGFueSk6IGFueVtdID0+IHIuY3NzVGV4dClcclxuXHRcdC5tYXAoKHI6IGFueSk6IGFueVtdPT4gci5jc3NUZXh0KTtcclxuXHJcblx0Y2xvbmUuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgZDNOYW1lc3BhY2VzLnhodG1sKTtcclxuXHJcblx0Y29uc3Qgbm9kZVhtbCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoY2xvbmUpO1xyXG5cclxuXHQvLyBlc2NhcGUgY3NzIGZvciBYTUxcclxuXHRjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHJcblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dC5qb2luKFwiXFxuXCIpKSk7XHJcblxyXG5cdGNvbnN0IHN0eWxlWG1sID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdHlsZSk7XHJcblxyXG5cdC8vIGZvcmVpZ25PYmplY3Qgbm90IHN1cHBvcnRlZCBpbiBJRTExIGFuZCBiZWxvd1xyXG5cdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFxyXG5cdGNvbnN0IGRhdGFTdHIgPSBgPHN2ZyB4bWxucz1cIiR7ZDNOYW1lc3BhY2VzLnN2Z31cIiB3aWR0aD1cIiR7c2l6ZS53aWR0aH1cIiBoZWlnaHQ9XCIke3NpemUuaGVpZ2h0fVwiPlxyXG5cdFx0XHQ8Zm9yZWlnbk9iamVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XHJcblx0XHRcdFx0JHtzdHlsZVhtbH1cclxuXHRcdFx0XHQke25vZGVYbWwucmVwbGFjZSgvKHVybFxcKClbXiNdKy9nLCBcIiQxXCIpfVxyXG5cdFx0XHQ8L2ZvcmVpZ25PYmplY3Q+PC9zdmc+YFxyXG5cdFx0LnJlcGxhY2UoXCIvXFxuL2dcIiwgXCIlMEFcIik7XHJcblxyXG5cdHJldHVybiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2I2NEVuY29kZVVuaWNvZGUoZGF0YVN0cil9YDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEV4cG9ydCBjaGFydCBhcyBhbiBpbWFnZS5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBJRTExIGFuZCBiZWxvdyBub3Qgd29yayBwcm9wZXJseSBkdWUgdG8gdGhlIGxhY2sgb2YgdGhlIGZlYXR1cmUoPGEgaHJlZj1cImh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFwiPmZvcmVpZ25PYmplY3Q8L2E+KSBzdXBwb3J0XHJcblx0ICogICAtIFRoZSBiYXNpYyBDU1MgZmlsZShleC4gYmlsbGJvYXJkLmNzcykgc2hvdWxkIGJlIGF0IHNhbWUgZG9tYWluIGFzIEFQSSBjYWxsIGNvbnRleHQgdG8gZ2V0IGNvcnJlY3Qgc3R5bGVkIGV4cG9ydCBpbWFnZS5cclxuXHQgKiBAbWV0aG9kIGV4cG9ydFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9aW1hZ2UvcG5nXSBUaGUgZGVzaXJlZCBvdXRwdXQgaW1hZ2UgZm9ybWF0LiAoZXguICdpbWFnZS9wbmcnIGZvciBwbmcsICdpbWFnZS9qcGVnJyBmb3IganBlZyBmb3JtYXQpXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGV4cG9ydCBpcyByZWFkeS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGFVUklcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC5leHBvcnQoKTtcclxuXHQgKiAgLy8gLS0+IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4uLi5cIlxyXG5cdCAqXHJcblx0ICogIC8vIEluaXRpYWxpemUgdGhlIGRvd25sb2FkIGF1dG9tYXRpY2FsbHlcclxuXHQgKiAgY2hhcnQuZXhwb3J0KFwiaW1hZ2UvcG5nXCIsIGRhdGFVcmwgPT4ge1xyXG5cdCAqICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcblx0ICpcclxuXHQgKiAgICAgbGluay5kb3dubG9hZCA9IGAke0RhdGUubm93KCl9LnBuZ2A7XHJcblx0ICogICAgIGxpbmsuaHJlZiA9IGRhdGFVcmw7XHJcblx0ICogICAgIGxpbmsuaW5uZXJIVE1MID0gXCJEb3dubG9hZCBjaGFydCBhcyBpbWFnZVwiO1xyXG5cdCAqXHJcblx0ICogICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdGV4cG9ydChtaW1lVHlwZT86IHN0cmluZywgY2FsbGJhY2s/OiAoZGF0YVVybDogc3RyaW5nKSA9PiB2b2lkKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjdXJyZW50V2lkdGg6IHdpZHRoLCBjdXJyZW50SGVpZ2h0OiBoZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBzaXplID0ge3dpZHRoLCBoZWlnaHR9O1xyXG5cdFx0Y29uc3Qgc3ZnRGF0YVVybCA9IG5vZGVUb1N2Z0RhdGFVcmwodGhpcy5lbGVtZW50LCBzaXplKTtcclxuXHJcblx0XHRpZiAoY2FsbGJhY2sgJiYgaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuXHRcdFx0Y29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcblxyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xyXG5cdFx0XHRpbWcub25sb2FkID0gKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcblx0XHRcdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gc2l6ZS53aWR0aDtcclxuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG5cclxuXHRcdFx0XHRjYWxsYmFjay5iaW5kKHRoaXMpKGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUpKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGltZy5zcmMgPSBzdmdEYXRhVXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdmdEYXRhVXJsO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgaGlnaGxpZ2h0cyBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgZmFkZSBvdXQgdGhlIG90aGVycy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQG1ldGhvZCBmb2N1c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWRzIHRvIGJlIGhpZ2hsaWdodGVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGRhdGExIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcclxuXHQgKiAgY2hhcnQuZm9jdXMoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgZmFkZWQgb3V0XHJcblx0ICogY2hhcnQuZm9jdXMoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIGhpZ2hsaWdodGVkXHJcblx0ICogY2hhcnQuZm9jdXMoKTtcclxuXHQgKi9cclxuXHRmb2N1cyh0YXJnZXRJZHNWYWx1ZT86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoXHJcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMucmV2ZXJ0KCk7XHJcblx0XHR0aGlzLmRlZm9jdXMoKTtcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgdHJ1ZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpICYmICEkJC5oYXNSYWRhcikge1xyXG5cdFx0XHQkJC5leHBhbmRBcmModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJlxyXG5cdFx0XHRcdCQkLm1hcmtPdmVybGFwcGVkKHRhcmdldElkc1ZhbHVlLCAkJCwgYC4ke0NMQVNTLmdhdWdlVmFsdWV9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCB0cnVlKTtcclxuXHJcblx0XHRzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gc3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSBmYWRlcyBvdXQgc3BlY2lmaWVkIHRhcmdldHMgYW5kIHJldmVydHMgdGhlIG90aGVycy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxyXG5cdCAqIEBtZXRob2QgZGVmb2N1c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBUYXJnZXQgaWRzIHRvIGJlIGZhZGVkIG91dC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQuZGVmb2N1cyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQuZGVmb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxyXG5cdCAqIGNoYXJ0LmRlZm9jdXMoKTtcclxuXHQgKi9cclxuXHRkZWZvY3VzKHRhcmdldElkc1ZhbHVlPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcclxuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSAkJC4kZWwuc3ZnLnNlbGVjdEFsbChcclxuXHRcdFx0JCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcy5maWx0ZXIoJCQuaXNUYXJnZXRUb1Nob3csICQkKSlcclxuXHRcdCk7XHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIGZhbHNlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHQkJC51bmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdFx0JCQuaGFzVHlwZShcImdhdWdlXCIpICYmXHJcblx0XHRcdFx0JCQudW5kb01hcmtPdmVybGFwcGVkKCQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC50b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIGZhbHNlKTtcclxuXHJcblx0XHRzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzID0gc3RhdGUuZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0XHRzdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMgPSB0YXJnZXRJZHM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgcmV2ZXJ0cyBzcGVjaWZpZWQgdGFyZ2V0cy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogQG1ldGhvZCByZXZlcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gVGFyZ2V0IGlkcyB0byBiZSByZXZlcnRlZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gZGF0YTEgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5yZXZlcnQoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LnJldmVydChbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQucmV2ZXJ0KCk7XHJcblx0ICovXHJcblx0cmV2ZXJ0KHRhcmdldElkc1ZhbHVlPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpOyAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIGZhbHNlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xyXG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHQkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKTtcclxuXHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gW107XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBEZWZpbmUgbGVnZW5kXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IGxlZ2VuZCA9IHtcclxuXHQvKipcclxuXHQgKiBTaG93IGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXHJcblx0ICogQG1ldGhvZCBsZWdlbmTigKRzaG93XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1xyXG5cdCAqIC0gSWYgdGFyZ2V0SWRzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXHJcblx0ICogLSBJZiBvbmx5IG9uZSB0YXJnZXQgaXMgdGhlIGNhbmRpZGF0ZSwgU3RyaW5nIGNhbiBiZSBwYXNzZWQuXHJcblx0ICogLSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIHNob3duLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gU2hvdyBsZWdlbmQgZm9yIGRhdGExLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5zaG93KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBTaG93IGxlZ2VuZCBmb3IgZGF0YTEgYW5kIGRhdGEyLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gU2hvdyBhbGwgbGVnZW5kLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5zaG93KCk7XHJcblx0ICovXHJcblx0c2hvdzogZnVuY3Rpb24odGFyZ2V0SWRzPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHQkJC5zaG93TGVnZW5kKCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykpO1xyXG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSBsZWdlbmQgZm9yIGVhY2ggdGFyZ2V0LlxyXG5cdCAqIEBtZXRob2QgbGVnZW5k4oCkaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNcclxuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cclxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBIaWRlIGxlZ2VuZCBmb3IgZGF0YTEgYW5kIGRhdGEyLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gSGlkZSBhbGwgbGVnZW5kLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKCk7XHJcblx0ICovXHJcblx0aGlkZTogZnVuY3Rpb24odGFyZ2V0SWRzPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHQkJC5oaWRlTGVnZW5kKCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykpO1xyXG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2xlZ2VuZH07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1N0cmluZywgaXNBcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogTG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgdG9nZ2xlcy5cclxuXHQgKiAtIDxiPk5vdGU6PC9iPlxyXG5cdCAqICAgLSB1bmxvYWQgc2hvdWxkIGJlIHVzZWQgaWYgc29tZSBkYXRhIG5lZWRzIHRvIGJlIHVubG9hZGVkIHNpbXVsdGFuZW91c2x5LlxyXG5cdCAqICAgICBJZiB5b3UgY2FsbCB1bmxvYWQgQVBJIHNvb24gYWZ0ZXIvYmVmb3JlIGxvYWQgaW5zdGVhZCBvZiB1bmxvYWQgcGFyYW0sIGNoYXJ0IHdpbGwgbm90IGJlIHJlbmRlcmVkIHByb3Blcmx5IGJlY2F1c2Ugb2YgY2FuY2VsIG9mIGFuaW1hdGlvbi48YnI+XHJcblx0ICogICAtIGRvbmUgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuXHJcblx0ICogICAgIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nXHJcblx0ICogQG1ldGhvZCBsb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IC0gdXJsPGJyPi0ganNvbjxicj4tIHJvd3M8YnI+LSBjb2x1bW5zIHwgVGhlIGRhdGEgd2lsbCBiZSBsb2FkZWQuIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB1cGRhdGVkLiBPdGhlcndpc2UsIG5ldyB0YXJnZXQgd2lsbCBiZSBhZGRlZCB8XHJcblx0ICogICAgfCBkYXRhIHwgRGF0YSBvYmplY3RzIHRvIGJlIGxvYWRlZC4gQ2hlY2tvdXQgdGhlIGV4YW1wbGUuIHxcclxuXHQgKiAgICB8IG5hbWVzIHwgU2FtZSBhcyBkYXRhLm5hbWVzKCkgfFxyXG5cdCAqICAgIHwgeHMgfCBTYW1lIGFzIGRhdGEueHMgb3B0aW9uICB8XHJcblx0ICogICAgfCBjbGFzc2VzIHwgVGhlIGNsYXNzZXMgc3BlY2lmaWVkIGJ5IGRhdGEuY2xhc3NlcyB3aWxsIGJlIHVwZGF0ZWQuIGNsYXNzZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGNhdGVnb3JpZXMgfCBUaGUgY2F0ZWdvcmllcyBzcGVjaWZpZWQgYnkgYXhpcy54LmNhdGVnb3JpZXMgb3IgZGF0YS54IHdpbGwgYmUgdXBkYXRlZC4gY2F0ZWdvcmllcyBtdXN0IGJlIEFycmF5LiB8XHJcblx0ICogICAgfCBheGVzIHwgVGhlIGF4ZXMgc3BlY2lmaWVkIGJ5IGRhdGEuYXhlcyB3aWxsIGJlIHVwZGF0ZWQuIGF4ZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGNvbG9ycyB8IFRoZSBjb2xvcnMgc3BlY2lmaWVkIGJ5IGRhdGEuY29sb3JzIHdpbGwgYmUgdXBkYXRlZC4gY29sb3JzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XHJcblx0ICogICAgfCBoZWFkZXJzIHwgIFNldCByZXF1ZXN0IGhlYWRlciBpZiBsb2FkaW5nIHZpYSBgZGF0YS51cmxgLjxicj5Ac2VlIFtkYXRh4oCkaGVhZGVyc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0aGVhZGVycykgfFxyXG5cdCAqICAgIHwga2V5cyB8ICBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3RzIGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuPGJyPioqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS48YnI+QHNlZSBbZGF0YeKApGtleXNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGtleXMpIHxcclxuXHQgKiAgICB8IG1pbWVUeXBlIHwgIFNldCAnanNvbicgaWYgbG9hZGluZyBKU09OIHZpYSB1cmwuPGJyPkBzZWUgW2RhdGHigKRtaW1lVHlwZV0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0bWltZVR5cGUpIHxcclxuXHQgKiAgICB8IC0gdHlwZTxicj4tIHR5cGVzIHwgVGhlIHR5cGUgb2YgdGFyZ2V0cyB3aWxsIGJlIHVwZGF0ZWQuIHR5cGUgbXVzdCBiZSBTdHJpbmcgYW5kIHR5cGVzIG11c3QgYmUgT2JqZWN0LiB8XHJcblx0ICogICAgfCB1bmxvYWQgfCBTcGVjaWZ5IHRoZSBkYXRhIHdpbGwgYmUgdW5sb2FkZWQgYmVmb3JlIGxvYWRpbmcgbmV3IGRhdGEuIElmIHRydWUgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIElmIHRhcmdldCBpZHMgZ2l2ZW4gYXMgU3RyaW5nIG9yIEFycmF5LCBzcGVjaWZpZWQgdGFyZ2V0cyB3aWxsIGJlIHVubG9hZGVkLiBJZiBhYnNlbnQgb3IgZmFsc2UgZ2l2ZW4sIHVubG9hZCB3aWxsIG5vdCBvY2N1ci4gfFxyXG5cdCAqICAgIHwgZG9uZSB8IFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQufFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFGcm9tVVJMKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gTG9hZCBkYXRhMSBhbmQgdW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICBjb2x1bW5zOiBbXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDEwMCwgMjAwLCAxNTAsIC4uLl0sXHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgIF0sXHJcblx0ICogICAgdW5sb2FkOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxyXG5cdCAqICAgIHVybDogXCIuLi5cIixcclxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHsgLi4uIH1cclxuXHQgKiB9KTtcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIG15QVBJLmpzb25cclxuXHQgKiAvLyB7XHJcblx0ICogLy8gICBcImRhdGExXCI6IFsyMjAsIDI0MCwgMjcwLCAyNTAsIDI4MF0sXHJcblx0ICogLy8gICBcImRhdGEyXCI6IFsxODAsIDE1MCwgMzAwLCA3MCwgMTIwXVxyXG5cdCAqIC8vIH1cclxuXHQgKlxyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICB1cmw6ICcuL2RhdGEvbXlBUEkuanNvbicsXHJcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIixcclxuXHQgKlxyXG5cdCAqICAgICAvLyBzZXQgcmVxdWVzdCBoZWFkZXIgaWYgaXMgbmVlZGVkXHJcblx0ICogICAgIGhlYWRlcnM6IHtcclxuXHQgKiAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvanNvblwiXHJcblx0ICogICAgIH1cclxuXHQgKiB9KTtcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICBkYXRhOiBbXHJcblx0ICogICAgICAgLy8gZXF1aXZhbGVudCBhczogY29sdW1uczogW1tcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1dXHJcblx0ICogICAgICAge1wiZGF0YTFcIjogMzB9LCB7XCJkYXRhMVwiOiAyMDB9LCB7XCJkYXRhMVwiOiAxMDB9XHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBvclxyXG5cdCAqICAgICAgIC8vIGVxdWl2YWxlbnQgYXM6IGNvbHVtbnM6IFtbXCJkYXRhMVwiLCAxMCwgMjBdLCBbXCJkYXRhMlwiLCAxMywgMzBdXVxyXG5cdCAqICAgICAgIC8vIHtcImRhdGExXCI6IDEwLCBcImRhdGEyXCI6IDEzfSwge1wiZGF0YTFcIjogMjAsIFwiZGF0YTJcIjogMzB9fVxyXG5cdCAqICAgICBdXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bG9hZChhcmdzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB4cyBpZiBzcGVjaWZpZWRcclxuXHRcdGFyZ3MueHMgJiYgJCQuYWRkWHMoYXJncy54cyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIG5hbWVzIGlmIGV4aXN0c1xyXG5cdFx0XCJuYW1lc1wiIGluIGFyZ3MgJiYgdGhpcy5kYXRhLm5hbWVzKGFyZ3MubmFtZXMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjbGFzc2VzIGlmIGV4aXN0c1xyXG5cdFx0XCJjbGFzc2VzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNsYXNzZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9jbGFzc2VzW2lkXSA9IGFyZ3MuY2xhc3Nlc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2F0ZWdvcmllcyBpZiBleGlzdHNcclxuXHRcdGlmIChcImNhdGVnb3JpZXNcIiBpbiBhcmdzICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBhcmdzLmNhdGVnb3JpZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGF4ZXMgaWYgZXhpc3RzXHJcblx0XHRcImF4ZXNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuYXhlcykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbmZpZy5kYXRhX2F4ZXNbaWRdID0gYXJncy5heGVzW2lkXTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjb2xvcnMgaWYgZXhpc3RzXHJcblx0XHRcImNvbG9yc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5jb2xvcnMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9jb2xvcnNbaWRdID0gYXJncy5jb2xvcnNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gdW5sb2FkIGlmIG5lZWRlZFxyXG5cdFx0aWYgKFwidW5sb2FkXCIgaW4gYXJncyAmJiBhcmdzLnVubG9hZCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0Ly8gVE9ETzogZG8gbm90IHVubG9hZCBpZiB0YXJnZXQgd2lsbCBsb2FkIChpbmNsdWRlZCBpbiB1cmwvcm93cy9jb2x1bW5zKVxyXG5cdFx0XHQkJC51bmxvYWQoJCQubWFwVG9UYXJnZXRJZHMoYXJncy51bmxvYWQgPT09IHRydWUgPyBudWxsIDogYXJncy51bmxvYWQpLCAoKSA9PlxyXG5cdFx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKVxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0JCQubG9hZEZyb21BcmdzKGFyZ3MpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVubG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgdG9nZ2xlcy5cclxuXHQgKiAtIDxiPk5vdGU6PC9iPlxyXG5cdCAqIElmIHlvdSBjYWxsIGxvYWQgQVBJIHNvb24gYWZ0ZXIvYmVmb3JlIHVubG9hZCwgdW5sb2FkIHBhcmFtIG9mIGxvYWQgc2hvdWxkIGJlIHVzZWQuIE90aGVyd2lzZSBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxyXG5cdCAqIGBkb25lYCB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy4gSXQncyBiZWNhdXNlIHJlbmRlcmluZyB3aWxsIGZpbmlzaCBhZnRlciBzb21lIHRyYW5zaXRpb24gYW5kIHRoZXJlIGlzIHNvbWUgdGltZSBsYWcgYmV0d2VlbiBsb2FkaW5nIGFuZCByZW5kZXJpbmcuXHJcblx0ICogQG1ldGhvZCB1bmxvYWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xyXG5cdCAqICB8IGtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgfCBpZHMgfCBTdHJpbmcgJnZlcnQ7IEFycmF5IHwgVGFyZ2V0IGlkIGRhdGEgdG8gYmUgdW5sb2FkZWQuIElmIG5vdCBnaXZlbiwgYWxsIGRhdGEgd2lsbCBiZSB1bmxvYWRlZC4gfFxyXG5cdCAqICB8IGRvbmUgfCBGdWN0aW9uIHwgQ2FsbGJhY2sgYWZ0ZXIgZGF0YSBpcyB1bmxvYWRlZC4gfFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFVubG9hZCBkYXRhMiBhbmQgZGF0YTNcclxuXHQgKiAgY2hhcnQudW5sb2FkKHtcclxuXHQgKiAgICBpZHM6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXHJcblx0ICogICAgZG9uZTogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSB1bmxvYWRlZFxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0dW5sb2FkKGFyZ3NWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0bGV0IGFyZ3MgPSBhcmdzVmFsdWUgfHwge307XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkoYXJncykpIHtcclxuXHRcdFx0YXJncyA9IHtpZHM6IGFyZ3N9O1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhhcmdzKSkge1xyXG5cdFx0XHRhcmdzID0ge2lkczogW2FyZ3NdfTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb1RhcmdldElkcyhhcmdzLmlkcyk7XHJcblxyXG5cdFx0JCQudW5sb2FkKGlkcywgKCkgPT4ge1xyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5yZW1vdmUoaWRzKTtcclxuXHRcdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZS5jYWxsKHRoaXMpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcblxyXG4vKipcclxuICogU2hvdy9IaWRlIGRhdGEgc2VyaWVzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzaG93SGlkZShzaG93LCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucykge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblxyXG5cdCQkW2Ake3Nob3cgPyBcInJlbW92ZVwiIDogXCJhZGRcIn1IaWRkZW5UYXJnZXRJZHNgXSh0YXJnZXRJZHMpO1xyXG5cclxuXHRjb25zdCB0YXJnZXRzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpO1xyXG5cdGNvbnN0IG9wYWNpdHkgPSBzaG93ID8gXCIxXCIgOiBcIjBcIjtcclxuXHJcblx0dGFyZ2V0cy50cmFuc2l0aW9uKClcclxuXHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSwgXCJpbXBvcnRhbnRcIilcclxuXHRcdC5jYWxsKCQkLmVuZGFsbCwgKCkgPT4ge1xyXG5cdFx0XHR0YXJnZXRzLnN0eWxlKFwib3BhY2l0eVwiLCBudWxsKS5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XHJcblx0XHR9KTtcclxuXHJcblx0b3B0aW9ucy53aXRoTGVnZW5kICYmICQkW2Ake3Nob3cgPyBcInNob3dcIiA6IFwiaGlkZVwifUxlZ2VuZGBdKHRhcmdldElkcyk7XHJcblxyXG5cdCQkLnJlZHJhdyh7XHJcblx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0d2l0aExlZ2VuZDogdHJ1ZVxyXG5cdH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2hvdyBkYXRhIHNlcmllcyBvbiBjaGFydFxyXG5cdCAqIEBtZXRob2Qgc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWVdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgQm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBzaG93ICdkYXRhMSdcclxuXHQgKiBjaGFydC5zaG93KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBzaG93ICdkYXRhMScgYW5kICdkYXRhMydcclxuXHQgKiBjaGFydC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHNob3codGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmdbXSB8IHN0cmluZywgb3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIHRydWUsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGRhdGEgc2VyaWVzIGZyb20gY2hhcnRcclxuXHQgKiBAbWV0aG9kIGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlPWFsbF0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGhpZGUgJ2RhdGExJ1xyXG5cdCAqIGNoYXJ0LmhpZGUoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGhpZGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xyXG5cdCAqIGNoYXJ0LmhpZGUoW1wiZGF0YTFcIiwgXCJkYXRhM1wiXSk7XHJcblx0ICovXHJcblx0aGlkZSh0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIGZhbHNlLCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIGRhdGEgc2VyaWVzIG9uIGNoYXJ0LiBXaGVuIHRhcmdldCBkYXRhIGlzIGhpZGRlbiwgaXQgd2lsbCBzaG93LiBJZiBpcyBzaG93biwgaXQgd2lsbCBoaWRlIGluIHZpY2UgdmVyc2EuXHJcblx0ICogQG1ldGhvZCB0b2dnbGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlPWFsbF0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnXHJcblx0ICogY2hhcnQudG9nZ2xlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyB0b2dnbGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xyXG5cdCAqIGNoYXJ0LnRvZ2dsZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcclxuXHQgKi9cclxuXHR0b2dnbGUodGFyZ2V0SWRzLCBvcHRpb25zID0ge30pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSB7c2hvdzogW10sIGhpZGU6IFtdfTtcclxuXHJcblx0XHQvLyBzb3J0IHNob3cgJiBoaWRlIHRhcmdldCBpZHNcclxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcylcclxuXHRcdFx0LmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHRhcmdldHNbJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gXCJoaWRlXCIgOiBcInNob3dcIl0ucHVzaChpZCkpO1xyXG5cclxuXHRcdC8vIHBlcmZvcm0gc2hvdyAmIGhpZGUgdGFzayBzZXBhcmF0ZWx5XHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy80NTRcclxuXHRcdHRhcmdldHMuc2hvdy5sZW5ndGggJiYgdGhpcy5zaG93KHRhcmdldHMuc2hvdywgb3B0aW9ucyk7XHJcblx0XHR0YXJnZXRzLmhpZGUubGVuZ3RoICYmIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oaWRlKHRhcmdldHMuaGlkZSwgb3B0aW9ucyksIDApO1xyXG5cdH1cclxufTtcclxuXHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1ZhbHVlLCBpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIERlZmluZSB0b29sdGlwXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IHRvb2x0aXAgPSB7XHJcblx0LyoqXHJcblx0ICogU2hvdyB0b29sdGlwXHJcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgaW5kZXggfCBOdW1iZXIgfCBEZXRlcm1pbmUgZm9jdXMgYnkgaW5kZXggfFxyXG5cdCAqICAgIHwgeCB8IE51bWJlciAmdmVydDsgRGF0ZSB8IERldGVybWluZSBmb2N1cyBieSB4IEF4aXMgaW5kZXggfFxyXG5cdCAqICAgIHwgbW91c2UgfCBBcnJheSB8IERldGVybWluZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWUgcmVsYXRpdmUgdGhlIHRhcmdldGVkICcuYmItZXZlbnQtcmVjdCcgeCBBeGlzLjxicj5JdCBzaG91bGQgYmUgdXNlZCBhbG9uZyB3aXRoIGBkYXRhYCwgYGluZGV4YCBvciBgeGAgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCBhcyBgWzAsMF1gIHxcclxuXHQgKiAgICB8IGRhdGEgfCBPYmplY3QgfCBXaGVuIFtkYXRhLnhzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTR4cykgb3B0aW9uIGlzIHVzZWQgb3IgW3Rvb2x0aXAuZ3JvdXBlZF0oT3B0aW9ucy5odG1sIy50b29sdGlwKSBzZXQgdG8gJ2ZhbHNlJywgYHNob3VsZCBiZSB1c2VkIGdpdmluZyB0aGlzIHBhcmFtYC48YnI+PGJyPioqS2V5OioqPGJyPi0geCB7TnVtYmVyICZ2ZXJiYXI7IERhdGV9OiB4IEF4aXMgdmFsdWU8YnI+LSBpbmRleCB7TnVtYmVyfTogeCBBeGlzIGluZGV4ICh1c2VsZXNzIGZvciBkYXRhLnhzKTxicj4tIGlkIHtTdHJpbmd9OiBkYXRhIGlkPGJyPi0gdmFsdWUge051bWJlcn06IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciB0b29sdGlwLiB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBzaG93IHRoZSAybmQgeCBBeGlzIGNvb3JkaW5hdGUgdG9vbHRpcFxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIGluZGV4OiAxXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHNob3cgdG9vbHRpcCBmb3IgdGhlIDNyZCB4IEF4aXMgaW4geDo1MCBhbmQgeToxMDAgY29vcmRpbmF0ZSBvZiAnLmJiLWV2ZW50LXJlY3QnIG9mIHRoZSB4IEF4aXMuXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgeDogMixcclxuXHQgKiAgICBtb3VzZTogWzUwLCAxMDBdXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHNob3cgdG9vbHRpcCBmb3IgdGltZXNlcmllcyB4IGF4aXNcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICB4OiBuZXcgRGF0ZShcIjIwMTgtMDEtMDIgMDA6MDBcIilcclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzIHVzZWRcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICBkYXRhOiB7XHJcblx0ICogICAgICAgIHg6IDMsICAvLyB4IEF4aXMgdmFsdWVcclxuXHQgKiAgICAgICAgaWQ6IFwiZGF0YTFcIiwgIC8vIGRhdGEgaWRcclxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzbid0IHVzZWQsIGJ1dCB0b29sdGlwLmdyb3VwZWQ9ZmFsc2UgaXMgc2V0XHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgZGF0YToge1xyXG5cdCAqICAgICAgICBpbmRleDogMywgIC8vIG9yICd4JyBrZXkgdmFsdWVcclxuXHQgKiAgICAgICAgaWQ6IFwiZGF0YTFcIiwgIC8vIGRhdGEgaWRcclxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0c2hvdzogZnVuY3Rpb24oYXJncykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtpbnB1dFR5cGV9fSA9ICQkO1xyXG5cdFx0bGV0IGluZGV4O1xyXG5cdFx0bGV0IG1vdXNlO1xyXG5cclxuXHRcdC8vIGRldGVybWluZSBtb3VzZSBwb3NpdGlvbiBvbiB0aGUgY2hhcnRcclxuXHRcdGlmIChhcmdzLm1vdXNlKSB7XHJcblx0XHRcdG1vdXNlID0gYXJncy5tb3VzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgZm9jdXMgZGF0YVxyXG5cdFx0aWYgKGFyZ3MuZGF0YSkge1xyXG5cdFx0XHRjb25zdCB5ID0gJCQuZ2V0WVNjYWxlKGFyZ3MuZGF0YS5pZCkoYXJncy5kYXRhLnZhbHVlKTtcclxuXHJcblx0XHRcdGlmICgkJC5pc011bHRpcGxlWCgpKSB7XHJcblx0XHRcdFx0Ly8gaWYgbXVsdGlwbGUgeHMsIHRhcmdldCBwb2ludCB3aWxsIGJlIGRldGVybWluZWQgYnkgbW91c2VcclxuXHRcdFx0XHRtb3VzZSA9IFskJC5zY2FsZS54KGFyZ3MuZGF0YS54KSwgeV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0XHRtb3VzZSA9IFswLCB5XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gaXNWYWx1ZShhcmdzLmRhdGEuaW5kZXgpID8gYXJncy5kYXRhLmluZGV4IDogJCQuZ2V0SW5kZXhCeVgoYXJncy5kYXRhLngpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLngpKSB7XHJcblx0XHRcdGluZGV4ID0gJCQuZ2V0SW5kZXhCeVgoYXJncy54KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MuaW5kZXgpKSB7XHJcblx0XHRcdGluZGV4ID0gYXJncy5pbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBlbXVsYXRlIGV2ZW50cyB0byBzaG93XHJcblx0XHQoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIgP1xyXG5cdFx0XHRbXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIl0gOiBbXCJ0b3VjaHN0YXJ0XCJdXHJcblx0XHQpLmZvckVhY2goZXZlbnROYW1lID0+IHtcclxuXHRcdFx0JCQuZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIGluZGV4LCBtb3VzZSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIHRvb2x0aXBcclxuXHQgKiBAbWV0aG9kIHRvb2x0aXDigKRoaWRlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICovXHJcblx0aGlkZTogZnVuY3Rpb24oKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuaGlkZVRvb2x0aXAodHJ1ZSk7XHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHt0b29sdGlwfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vQ2hhcnRJbnRlcm5hbC9DaGFydEludGVybmFsXCI7XHJcbmltcG9ydCB7VFlQRVN9IGZyb20gXCIuLi9jb25maWcvY29uc3RcIjtcclxuaW1wb3J0IHtsb2FkQ29uZmlnfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xyXG5pbXBvcnQge2V4dGVuZCwgaXNGdW5jdGlvbn0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5pbXBvcnQgYXBpQ2hhcnQgZnJvbSBcIi4vYXBpL2NoYXJ0XCI7XHJcbmltcG9ydCBhcGlDb2xvciBmcm9tIFwiLi9hcGkvY29sb3JcIjtcclxuaW1wb3J0IGFwaURhdGEgZnJvbSBcIi4vYXBpL2RhdGFcIjtcclxuaW1wb3J0IGFwaUV4cG9ydCBmcm9tIFwiLi9hcGkvZXhwb3J0XCI7XHJcbmltcG9ydCBhcGlGb2N1cyBmcm9tIFwiLi9hcGkvZm9jdXNcIjtcclxuaW1wb3J0IGFwaUxlZ2VuZCBmcm9tIFwiLi9hcGkvbGVnZW5kXCI7XHJcbmltcG9ydCBhcGlMb2FkIGZyb20gXCIuL2FwaS9sb2FkXCI7XHJcbmltcG9ydCBhcGlTaG93IGZyb20gXCIuL2FwaS9zaG93XCI7XHJcbmltcG9ydCBhcGlUb29sdGlwIGZyb20gXCIuL2FwaS90b29sdGlwXCI7XHJcblxyXG5pbXBvcnQgbW9kdWxlQXhpcyBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2F4aXNcIjtcclxuXHJcbi8qKlxyXG4gKiBNYWluIGNoYXJ0IGNsYXNzLlxyXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCB2aWEgYGJiLmdlbmVyYXRlKClgLlxyXG4gKiBAY2xhc3MgQ2hhcnRcclxuICogQGV4YW1wbGVcclxuICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG4gKiAgZGF0YToge1xyXG4gKiAgICBjb2x1bW5zOiBbXHJcbiAqXHQgICAgW1wieFwiLCBcIjIwMTUtMTEtMDJcIiwgXCIyMDE1LTEyLTAxXCIsIFwiMjAxNi0wMS0wMVwiLCBcIjIwMTYtMDItMDFcIiwgXCIyMDE2LTAzLTAxXCJdLFxyXG4gKiBcdCAgICBbXCJjb3VudDFcIiwgMTEsIDgsIDcsIDYsIDUgXSxcclxuICpcdCAgICBbXCJjb3VudDJcIiwgOSwgMywgNiwgMiwgOCBdXHJcbiAqICAgXX1cclxuICogfVxyXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuKi9cclxuLyoqXHJcbiAqIEFjY2VzcyBpbnN0YW5jZSdzIHByaW1hcnkgbm9kZSBlbGVtZW50c1xyXG4gKiBAbWVtYmVyIHtPYmplY3R9ICRcclxuICogQHByb3BlcnR5IHtPYmplY3R9ICRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuY2hhcnQgV3JhcHBlciBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnN2ZyBNYWluIHN2ZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmRlZnMgRGVmaW5pdGlvbiBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLm1haW4gTWFpbiBncm91cGluZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRvb2x0aXAgVG9vbHRpcCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxlZ2VuZCBMZWdlbmQgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50aXRsZSBUaXRsZSBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmdyaWQgR3JpZCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmFyYyBBcmMgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5jaXJjbGVzIERhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLmJhclxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5iYXIuYmFycyBCYXIgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtPYmplY3R9ICQubGluZVxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmxpbmVzIExpbmUgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5hcmVhcyBBcmVhcyBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC50ZXh0XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRleHQudGV4dHMgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRzXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7IC4uLiB9KTtcclxuICpcclxuICogY2hhcnQuJC5jaGFydDsgLy8gd3JhcHBlciBlbGVtZW50XHJcbiAqIGNoYXJ0LiQubGluZS5jaXJjbGVzOyAgLy8gYWxsIGRhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydCB7XHJcblx0LyoqXHJcblx0ICogUGx1Z2luIGluc3RhbmNlIGFycmF5XHJcblx0ICogQG1lbWJlciB7QXJyYXl9IHBsdWdpbnNcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcblx0ICogICAgIC4uLlxyXG5cdCAqICAgICBwbHVnaW5zOiBbXHJcblx0ICogICAgICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXHJcblx0ICogICAgICAgIG5ldyBQbHVnaW5BKClcclxuXHQgKiAgICAgXVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICBjaGFydC5wbHVnaW5zOyAvLyBbU3RhbmZvcmQsIFBsdWdpbkFdIC0gaW5zdGFuY2UgYXJyYXlcclxuXHQgKi9cclxuXHRwdWJsaWMgcGx1Z2lucyA9IFtdO1xyXG5cdHB1YmxpYyBpbnRlcm5hbDogQ2hhcnRJbnRlcm5hbDtcclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xyXG5cdFx0Y29uc3QgY3R4ID0gdGhpcztcclxuXHRcdGNvbnN0IHt0eXBlLCB0eXBlc30gPSBvcHRpb25zLmRhdGE7XHJcblx0XHQvLyBsZXQgaXNBcmMgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiAodHlwZSkge1xyXG5cdFx0Ly8gXHRpc0FyYyA9IFRZUEVTLkFyYy5pbmRleE9mKHR5cGUpID4gLTE7XHJcblx0XHQvLyB9IGVsc2UgaWYgKHR5cGVzKSB7XHJcblx0XHQvLyBcdGZvciAoY29uc3QgeCBpbiB0eXBlcykge1xyXG5cdFx0Ly8gXHRcdGlmIChUWVBFUy5BcmMuaW5kZXhPZih0eXBlc1t4XSkgPiAtMSkge1xyXG5cdFx0Ly8gXHRcdFx0aXNBcmMgPSB0cnVlO1xyXG5cdFx0Ly8gXHRcdFx0YnJlYWs7XHJcblx0XHQvLyBcdFx0fVxyXG5cdFx0Ly8gXHR9XHJcblx0XHQvLyB9XHJcblxyXG5cdFx0Y29uc3QgJCQgPSBuZXcgQ2hhcnRJbnRlcm5hbChjdHgpO1xyXG5cclxuXHRcdHRoaXMuaW50ZXJuYWwgPSAkJDtcclxuXHJcblx0XHQvLyBiaW5kIHRvIG5hbWVzcGFjZWQgQVBJc1xyXG5cdFx0KGZ1bmN0aW9uIGJpbmRUaGlzKGZuLCB0YXJnZXQsIGFyZ1RoaXMpIHtcclxuXHRcdFx0T2JqZWN0LmtleXMoZm4pLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRjb25zdCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGZuW2tleV0pO1xyXG5cdFx0XHRcdGNvbnN0IGlzQ2hpbGQgPSB0YXJnZXQgIT09IGFyZ1RoaXM7XHJcblx0XHRcdFx0Y29uc3QgaGFzQ2hpbGQgPSBPYmplY3Qua2V5cyhmbltrZXldKS5sZW5ndGggPiAwO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNGdW5jICYmICgoIWlzQ2hpbGQgJiYgaGFzQ2hpbGQpIHx8IGlzQ2hpbGQpKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IGZuW2tleV0uYmluZChhcmdUaGlzKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFpc0Z1bmMpIHtcclxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0ge307XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRoYXNDaGlsZCAmJiBiaW5kVGhpcyhmbltrZXldLCB0YXJnZXRba2V5XSwgYXJnVGhpcyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSkoQ2hhcnQucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcclxuXHJcblx0XHRsb2FkQ29uZmlnLmNhbGwoJCQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdCQkLmJlZm9yZUluaXQoKTtcclxuXHRcdCQkLmluaXQoKTtcclxuXHRcdCQkLmFmdGVySW5pdCgpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gZXh0ZW5kIGNvbW1vbiBBUElzIGFzIHBhcnQgb2YgQ2hhcnQgY2xhc3NcclxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwgW1xyXG5cdGFwaUNoYXJ0LFxyXG5cdGFwaUNvbG9yLFxyXG5cdGFwaURhdGEsXHJcblx0YXBpRXhwb3J0LFxyXG5cdGFwaUZvY3VzLFxyXG5cdGFwaUxlZ2VuZCxcclxuXHRhcGlMb2FkLFxyXG5cdGFwaVNob3csXHJcblx0YXBpVG9vbHRpcCxcclxuXHQuLi5tb2R1bGVBeGlzLmFwaVxyXG5dKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnQvQ2hhcnRcIjtcclxuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2VPYmp9IGZyb20gXCIuL21vZHVsZS91dGlsXCI7XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcclxuZXhwb3J0IHtiYiwgYmIgYXMgZGVmYXVsdH07XHJcblxyXG5sZXQgZGVmYXVsdHMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIGJiXHJcbiAqIEB2ZXJzaW9uIDIuMC4wLWFscGhhXHJcbiAqL1xyXG5jb25zdCBiYiA9IHtcclxuXHQvKipcclxuXHQgKiBWZXJzaW9uIGluZm9ybWF0aW9uXHJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IHZlcnNpb24gdmVyc2lvblxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogICAgYmIudmVyc2lvbjsgIC8vIFwiMS4wLjBcIlxyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqL1xyXG5cdHZlcnNpb246IFwiMi4wLjAtYWxwaGFcIixcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgY2hhcnRcclxuXHQgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqIEByZXR1cm4ge0NoYXJ0fVxyXG5cdCAqIEBzZWUge0BsaW5rIE9wdGlvbnN9IGZvciBkaWZmZXJlbnQgZ2VuZXJhdGlvbiBvcHRpb25zXHJcblx0ICogQHNlZSB7QGxpbmsgQ2hhcnR9IGZvciBkaWZmZXJlbnQgbWV0aG9kcyBBUElcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICA8IS0tIGNoYXJ0IGhvbGRlciAtLT5cclxuXHQgKiA8ZGl2IGlkPVwiTGluZUNoYXJ0XCI+PC9kaXY+XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgIC8vIGdlbmVyYXRlIGNoYXJ0IHdpdGggb3B0aW9uc1xyXG5cdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcblx0ICogICAgICBcImJpbmR0b1wiOiBcIiNMaW5lQ2hhcnRcIlxyXG5cdCAqICAgICAgXCJkYXRhXCI6IHtcclxuXHQgKiAgICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAqICAgICAgICAgICAgICBbXCJkYXRhMVwiLCAzMCwgMjAwLCAxMDAsIDQwMCwgMTUwLCAyNTBdLFxyXG5cdCAqICAgICAgICAgICAgICBbXCJkYXRhMlwiLCA1MCwgMjAsIDEwLCA0MCwgMTUsIDI1XVxyXG5cdCAqICAgICAgICAgICBdXHJcblx0ICogICAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIGNhbGwgc29tZSBBUElcclxuXHQgKiAgLy8gZXgpIGdldCB0aGUgZGF0YSBvZiAnZGF0YTEnXHJcblx0ICogIGNoYXJ0LmRhdGEoXCJkYXRhMVwiKTtcclxuXHQgKi9cclxuXHRnZW5lcmF0ZShjb25maWcpIHtcclxuXHRcdGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9iaih7fSwgZGVmYXVsdHMsIGNvbmZpZyk7XHJcblx0XHRjb25zdCBpbnN0ID0gbmV3IENoYXJ0KG9wdGlvbnMpO1xyXG5cclxuXHRcdGluc3QuaW50ZXJuYWwuY2hhcnRzID0gdGhpcy5pbnN0YW5jZTtcclxuXHRcdHRoaXMuaW5zdGFuY2UucHVzaChpbnN0KTtcclxuXHJcblx0XHRyZXR1cm4gaW5zdDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgb3IgZ2V0IGdsb2JhbCBkZWZhdWx0IG9wdGlvbnMuXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gVGhlIG9wdGlvbnMgdmFsdWVzIHNldHRpbmdzIGFyZSB2YWxpZCB3aXRoaW4gcGFnZSBjb250ZXh0IG9ubHkuXHJcblx0ICogICAtIElmIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgd2lsbCBvdmVycmlkZSB0aGUgbGFzdCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqIEByZXR1cm4ge09wdGlvbnN9XHJcblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFNldCBzYW1lIG9wdGlvbiB2YWx1ZSBhcyBmb3IgYC5nZW5lcmF0ZSgpYFxyXG5cdCAqIGJiLmRlZmF1bHRzKHtcclxuXHQgKiAgIGRhdGE6IHtcclxuXHQgKiAgICAgdHlwZTogXCJiYXJcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqXHJcblx0ICogYmIuZGVmYXVsdHMoKTsgIC8vIHtkYXRhOnt0eXBlOiBcImJhclwifX1cclxuXHQgKlxyXG5cdCAqIC8vIGRhdGEudHlwZSBkZWZhdWx0cyB0byAnYmFyJ1xyXG5cdCAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG5cdCAqL1xyXG5cdGRlZmF1bHRzKG9wdGlvbnMpIHtcclxuXHRcdGlmIChpc09iamVjdChvcHRpb25zKSkge1xyXG5cdFx0XHRkZWZhdWx0cyA9IG9wdGlvbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRlZmF1bHRzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2UgY3JlYXRlZFxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IGluc3RhbmNlIGluc3RhbmNlIGFycmF5XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZ2VuZXJhdGUgY2hhcnRzXHJcblx0ICogIHZhciBjaGFydDEgPSBiYi5nZW5lcmF0ZSguLi4pO1xyXG5cdCAqICB2YXIgY2hhcnQyID0gYmIuZ2VuZXJhdGUoLi4uKTtcclxuXHQgKlxyXG5cdCAqICBiYi5pbnN0YW5jZTsgIC8vIFsgY2hhcnQxLCBjaGFydDIsIC4uLiBdXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0aW5zdGFuY2U6IFtdLFxyXG5cclxuXHQvKipcclxuXHQgKiBOYW1lc3BhY2UgZm9yIHBsdWdpbnNcclxuXHQgKiBAcHJvcGVydHkge09iamVjdH0gcGx1Z2luIHBsdWdpbiBuYW1lc3BhY2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTdGFuZm9yZCBkaWFncmFtIHBsdWdpblxyXG5cdCAqICBiYi5wbHVnaW4uc3RhbmZvcmQ7XHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0cGx1Z2luOiB7fVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9
{"version":3,"file":"billboard.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AAEA;;;AClMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAEA;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2EA;AACA;AACA;AAEA;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkJA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6CA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiDA;;;AC5bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+NA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;;ACnPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0LA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;;;AC17BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsCA;AACA;AACA;AACA;AAEA;;;;;ACpCA;AACA;AAKA;AAQA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAQA;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AAEA;AAyDA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAQA;AAQA;AAWA;AACA;AACA;AASA;AACA;AAEA;AAEA;AACA;AAUA;AACA;AAEA;AACA;AACA;AAQA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAQA;AACA;AAGA;AAUA;AAMA;AACA;AAAA;AAGA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAQA;AAQA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAQA;AAGA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AASA;AAnRA;AAoRA;AAEA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAQA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AAWA;AAKA;AAEA;AACA;AAAA;AAGA;AAKA;AAAA;AAEA;AASA;AACA;AACA;AASA;AACA;AACA;AAUA;AACA;AACA;AAIA;AACA;AAYA;AACA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAGA;AAQA;AACA;AAEA;AAIA;AAAA;AAGA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAIA;AASA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AAQA;AASA;AACA;AAKA;AAQA;AAUA;AACA;AACA;AAKA;AAEA;AAAA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AA9hBA;AA+hBA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AAQA;AAjjBA;AAkjBA;AAAA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAQA;AACA;AACA;AAEA;AAGA;AAQA;AACA;AACA;AAGA;AACA;AAQA;AACA;AACA;AASA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAGA;AACA;AASA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAGA;AACA;AASA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAGA;AACA;AAUA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAGA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AAAA;AACA;AAGA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AASA;AAtzBA;AAuzBA;AAEA;AACA;AAAA;AAEA;AAIA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AAGA;AACA;AAOA;AACA;AAEA;AACA;AASA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AACA;AAOA;AAn3BA;AAo3BA;AACA;AASA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAAA;AAOA;AAAA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAKA;AAGA;AACA;AAQA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAQA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;ACt8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAAA;AAIA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AApBA;AADA;AAtBA;;;ACcA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;;;AC5DA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACnKA;AACA;AAGA;AAAA;AACA;AAEA;AAQA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AAEA;;;;;;ACxBA;AAOA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AAEA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;ACnGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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CA;AAGA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAEA;AAAA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAEA;AAEA;AACA;AAGA;AAEA;AAIA;AACA;AAGA;AACA;AAEA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAGA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAEA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAIA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AAGA;AAGA;AACA;AAEA;AAGA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAGA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AA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AA;AAUA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAAA;AAEA;AAEA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AAIA;AAAA;AAGA;AAIA;AAGA;AAOA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAKA;AAEA;AACA;AAAA;AAGA;AAGA;AAAA;AAMA;AAMA;AACA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAKA;AACA;AAIA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAGA;AAKA;AACA;AAEA;AAGA;AAGA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAEA;;;;;ACr6BA;AACA;AACA;AACA;AAEA;AAAA;AATA;AAWA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AAIA;AAAA;AAIA;AAOA;AAEA;AAGA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAIA;AAMA;AACA;AACA;AAAA;AACA;AAGA;AAGA;AAGA;AAGA;AAGA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAIA;AAGA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAEA;AAEA;AAAA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AAEA;AAEA;AAGA;AAEA;AAEA;AAEA;AAEA;AAAA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AAAA;AAGA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AAGA;AAAA;AAIA;AAAA;AAEA;;;ACrPA;AAEA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1EA;AAoFA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AAQA;AACA;AAAA;AAIA;AACA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAGA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1IA;AAmJA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AAtLA;AAuLA;AAAA;AAGA;AACA;AAEA;AAEA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AAGA;AAAA;AAEA;;;AC3QA;AACA;AACA;AAQA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAGA;AAAA;AACA;AAGA;AAAA;AAKA;AAEA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAMA;AAEA;AACA;AAAA;AACA;AAGA;AAGA;AAEA;AACA;AAGA;AAAA;AACA;AA/HA;AAkIA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAKA;AAIA;AAIA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvLA;AAmMA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAOA;AACA;AAEA;AACA;AAAA;AAGA;AAUA;AACA;AACA;AAAA;AAGA;AACA;AAQA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AAKA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5TA;AAoUA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AAGA;AAGA;AAGA;AAEA;AAEA;AAKA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAIA;AAIA;AACA;AAAA;AAGA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;;;AC7cA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAEA;AAAA;AAEA;;;ACnDA;AAEA;AACA;AAYA;AAcA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAcA;AAzDA;AAgEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAGA;AACA;AASA;AAhHA;AAiHA;AACA;AAEA;AAKA;AASA;AAlIA;AAmIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAKA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlLA;AA0LA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAIA;AAGA;AAIA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AAIA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AAKA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AAKA;AAGA;AAEA;AACA;AAEA;AAAA;AAEA;AAAA;AAGA;AAAA;AAKA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AAGA;AAIA;AACA;AAAA;AAEA;AAAA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AAKA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAAA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjgBA;AA2gBA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AAUA;AAAA;AAIA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAOA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AAAA;AAEA;AAMA;AAAA;AACA;AAEA;AAEA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAroBA;AAgpBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAGA;AAGA;AACA;AAGA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAKA;AAEA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAEA;AAAA;AAEA;;;ACx0BA;AACA;AASA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAEA;AACA;AAEA;AAKA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAEA;AAEA;AAEA;;;AC5EA;AACA;AACA;AAeA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAEA;AAEA;AACA;AAKA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9CA;AAsDA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhGA;AA4GA;AACA;AAGA;AACA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AAMA;AAAA;AAGA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AAAA;AACA;AAKA;AACA;AAGA;AACA;AACA;AAAA;AAIA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAEA;AAEA;AAAA;AAEA;AAAA;AAGA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjSA;AA0SA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AA7TA;AA8TA;AAEA;AAEA;AAGA;AAAA;AAKA;AACA;AAAA;AAEA;AAAA;AACA;AAGA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3WA;AAsXA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlaA;AA8aA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAGA;AACA;AAEA;AAAA;AAGA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5jBA;AAokBA;AACA;AAEA;AAGA;AAEA;AAGA;AAKA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3nBA;AAqoBA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AChrBA;AACA;AAKA;AAAA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AAIA;AAIA;AAIA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAGA;AAAA;AAEA;;;AClGA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvDA;AAkEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAEA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA/GA;AAyHA;AACA;AAEA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAIA;AACA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AAIA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AASA;AACA;AAGA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AChSA;AAmBA;AAGA;AAaA;AAWA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AArJA;AAuJA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAzbA;AA4bA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AAGA;AAAA;AACA;AA9gBA;AAihBA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAEA;;;;;;ACzlBA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AAIA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAQA;AAOA;AAAA;AAGA;AAAA;AACA;AAGA;AAEA;AAGA;AAAA;AACA;AAGA;AAEA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAGA;AACA;AAEA;AAAA;AACA;AACA;AAIA;AAAA;AAGA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAIA;AAIA;AACA;AAAA;AAGA;AAKA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA1RA;AA6RA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AAQA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AA3VA;AA8VA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;AAIA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAIA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAGA;AAAA;AAGA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAIA;AAIA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;AAEA;AAIA;AAEA;AACA;AACA;AAAA;AACA;AAIA;AAGA;AACA;AAAA;AACA;AAGA;AAGA;AAGA;AAIA;AAGA;AAEA;AAEA;AACA;AAKA;AACA;AAGA;AAGA;AAEA;AAGA;AAAA;AAIA;AAIA;AAEA;AAEA;AAEA;AAGA;AAGA;AAAA;AAIA;AAGA;AAGA;AAGA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAEA;AAEA;AAGA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9pBA;AAsqBA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAAA;AAIA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAEA;AAAA;AAEA;AAAA;AAIA;AAEA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AAIA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACt1BA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAEA;;;AC1CA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApCA;AAoDA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AAAA;AAKA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAtGA;AAkHA;AACA;AAEA;AACA;AAEA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAMA;AAGA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsCA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAGA;AAAA;AAEA;;;AClNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAEA;;;ACZA;AAoBA;AACA;AAEA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAEA;AAEA;;;AC/LA;AACA;AAOA;AA4BA;AAxCA;AAyCA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AAGA;AAEA;AAEA;AAIA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAGA;AACA;AASA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAGA;AAAA;AAGA;AAAA;AAEA;AAAA;AACA;AAGA;AACA;AASA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkDA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAEA;;;AC5SA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AACA;AACA;AACA;AAAA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAGA;AACA;AAAA;AAEA;;;AC5HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAEA;AACA;AAAA;AAEA;AAEA;;;AC3DA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AACA;;;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACjFA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAC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;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAEA;AACA;AAAA;AAIA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AAGA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AAIA;AACA;AAEA;AAAA;AAGA;AACA;AAAA;AAGA;AAGA;AAAA;AAEA;AAIA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AAEA;AAEA;AAAA;AACA;AAvXA;AA0XA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAIA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AA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A;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAEA;AAMA;AAKA;AAAA;AACA;AAGA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AAKA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAIA;AAAA;AAGA;AAhOA;AAoOA;AAAA;AAGA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAMA;AAIA;AAMA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AAIA;AAEA;AAGA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AAhUA;AAmUA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AACA;AAIA;AAEA;AAIA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1XA;AAkYA;AACA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAIA;AAKA;AAAA;AAGA;AACA;AAEA;AAIA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAAA;AACA;AA3cA;AA8cA;AACA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AAvdA;AA0dA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAEA;AAIA;AAKA;AAAA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAEA;AAEA;AACA;AAIA;AAAA;AACA;AAGA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AAAA;AAEA;;;AC7iBA;AAGA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAIA;AAGA;AAIA;AAIA;AAIA;AAIA;AAIA;AArDA;AAsDA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AA9EA;AA+EA;AAAA;AA/EA;AAkFA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAjGA;AAqGA;AAAA;AAEA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AAGA;AAAA;AAEA;;;ACpLA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAEA;AAEA;AACA;AArBA;AAwBA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AAGA;AAAA;AACA;AACA;AAzCA;AA4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAIA;AAGA;AACA;AAAA;AAGA;AAEA;AAIA;AAIA;AAAA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAGA;AAQA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAAA;AAEA;;;ACvKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwCA;;;AC1vBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwCA;;;AC3gBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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ACA;AACA;AAIA;AAGA;AAKA;AACA;AAEA;;;ACjIA;AACA;AACA;AAWA;AAcA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAIA;AAIA;AAIA;AAGA;AAEA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAGA;AAGA;AAAA;AAGA;AAIA;AAEA;AAGA;AAGA;AACA;AACA;AAKA;AAGA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;AAIA;AAIA;AACA;AACA;AAEA;AAIA;AACA;AAAA;AACA;AAIA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AAEA;AACA;AAAA;AAGA;AAAA;AAEA;AAAA;AAGA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAKA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAIA;AAGA;AAGA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAEA;;;;;AC/ZA;AAEA;AAEA;AACA;AASA;AACA;AACA;AAEA;AAWA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAGA;AAOA;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AA1HA;AA2HA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3JA;AAmKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AAIA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAGA;AAIA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;;;ACpTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8IA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AChKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0DA;AACA;AACA;AAKA;AAEA;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+HA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;ACpJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAEA;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgDA;AACA;AACA;AAEA;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2CA;AACA;AACA;AACA;AACA;AAEA;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqCA;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;ACjJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BA;AAEA;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AC9IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AC3FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACzEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA;AACA;AACA;AAEA;;;AChDA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;AASA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAKA;AACA;AACA;AAGA;AAGA;AAGA;AAGA;AAGA;AACA;AACA;AAEA;AAIA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AAGA;;;AC7KA;AACA;AAEA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAEA;;;ACzJA;AACA;AAGA;AAIA;AAGA","sources":["webpack://billboard.js/webpack/universalModuleDefinition","webpack://billboard.js/external umd {\"commonjs\":\"d3-selection\",\"commonjs2\":\"d3-selection\",\"amd\":\"d3-selection\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-time-format\",\"commonjs2\":\"d3-time-format\",\"amd\":\"d3-time-format\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-brush\",\"commonjs2\":\"d3-brush\",\"amd\":\"d3-brush\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-dsv\",\"commonjs2\":\"d3-dsv\",\"amd\":\"d3-dsv\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-drag\",\"commonjs2\":\"d3-drag\",\"amd\":\"d3-drag\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-scale\",\"commonjs2\":\"d3-scale\",\"amd\":\"d3-scale\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-transition\",\"commonjs2\":\"d3-transition\",\"amd\":\"d3-transition\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-shape\",\"commonjs2\":\"d3-shape\",\"amd\":\"d3-shape\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-zoom\",\"commonjs2\":\"d3-zoom\",\"amd\":\"d3-zoom\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-axis\",\"commonjs2\":\"d3-axis\",\"amd\":\"d3-axis\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-ease\",\"commonjs2\":\"d3-ease\",\"amd\":\"d3-ease\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-interpolate\",\"commonjs2\":\"d3-interpolate\",\"amd\":\"d3-interpolate\",\"root\":\"d3\"}","webpack://billboard.js/external umd {\"commonjs\":\"d3-hierarchy\",\"commonjs2\":\"d3-hierarchy\",\"amd\":\"d3-hierarchy\",\"root\":\"d3\"}","webpack://billboard.js/webpack/bootstrap","webpack://billboard.js/webpack/runtime/define property getters","webpack://billboard.js/webpack/runtime/hasOwnProperty shorthand","webpack://billboard.js/webpack/runtime/make namespace object","webpack://billboard.js/./src/config/classes.ts","webpack://billboard.js/./src/config/Options/common/boost.ts","webpack://billboard.js/./src/config/Options/common/color.ts","webpack://billboard.js/./src/config/Options/common/legend.ts","webpack://billboard.js/./src/config/Options/common/main.ts","webpack://billboard.js/./src/config/Options/common/title.ts","webpack://billboard.js/./src/config/Options/common/tooltip.ts","webpack://billboard.js/./src/config/Options/data/data.ts","webpack://billboard.js/./src/config/Options/interaction/interaction.ts","webpack://billboard.js/./src/module/browser.ts","webpack://billboard.js/./src/module/util.ts","webpack://billboard.js/./src/config/Options/Options.ts","webpack://billboard.js/./src/config/Store/Element.ts","webpack://billboard.js/./src/config/Store/State.ts","webpack://billboard.js/./src/config/Store/Store.ts","webpack://billboard.js/./src/module/Cache.ts","webpack://billboard.js/./src/config/const.ts","webpack://billboard.js/./src/module/error.ts","webpack://billboard.js/./src/module/generator.ts","webpack://billboard.js/./src/module/worker.ts","webpack://billboard.js/./src/ChartInternal/data/convert.helper.ts","webpack://billboard.js/./src/ChartInternal/data/convert.ts","webpack://billboard.js/./src/ChartInternal/data/data.ts","webpack://billboard.js/./src/ChartInternal/data/load.ts","webpack://billboard.js/./src/ChartInternal/interactions/interaction.ts","webpack://billboard.js/./src/ChartInternal/internals/category.ts","webpack://billboard.js/./src/ChartInternal/internals/class.ts","webpack://billboard.js/./src/ChartInternal/internals/color.ts","webpack://billboard.js/./src/ChartInternal/internals/domain.ts","webpack://billboard.js/./src/ChartInternal/internals/format.ts","webpack://billboard.js/./src/ChartInternal/internals/legend.ts","webpack://billboard.js/./src/ChartInternal/internals/redraw.ts","webpack://billboard.js/./src/ChartInternal/internals/scale.ts","webpack://billboard.js/./src/ChartInternal/internals/size.ts","webpack://billboard.js/./src/ChartInternal/internals/style.ts","webpack://billboard.js/./src/ChartInternal/internals/text.ts","webpack://billboard.js/./src/ChartInternal/internals/title.ts","webpack://billboard.js/./src/ChartInternal/internals/tooltip.ts","webpack://billboard.js/./src/ChartInternal/internals/transform.ts","webpack://billboard.js/./src/ChartInternal/internals/type.ts","webpack://billboard.js/./src/ChartInternal/shape/shape.ts","webpack://billboard.js/./src/ChartInternal/ChartInternal.ts","webpack://billboard.js/./src/config/config.ts","webpack://billboard.js/./src/Chart/api/chart.ts","webpack://billboard.js/./src/Chart/api/color.ts","webpack://billboard.js/./src/Chart/api/data.ts","webpack://billboard.js/./src/Chart/api/export.ts","webpack://billboard.js/./src/Chart/api/focus.ts","webpack://billboard.js/./src/Chart/api/legend.ts","webpack://billboard.js/./src/Chart/api/load.ts","webpack://billboard.js/./src/Chart/api/show.ts","webpack://billboard.js/./src/Chart/api/tooltip.ts","webpack://billboard.js/./src/Chart/Chart.ts","webpack://billboard.js/./src/Chart/api/selection.ts","webpack://billboard.js/./src/Chart/api/subchart.ts","webpack://billboard.js/./src/Chart/api/zoom.ts","webpack://billboard.js/./src/ChartInternal/interactions/subchart.ts","webpack://billboard.js/./src/ChartInternal/interactions/zoom.ts","webpack://billboard.js/./src/ChartInternal/interactions/drag.ts","webpack://billboard.js/./src/ChartInternal/internals/selection.ts","webpack://billboard.js/./src/config/Options/data/selection.ts","webpack://billboard.js/./src/config/Options/interaction/subchart.ts","webpack://billboard.js/./src/config/Options/interaction/zoom.ts","webpack://billboard.js/./src/config/resolver/interaction.ts","webpack://billboard.js/./src/Chart/api/axis.ts","webpack://billboard.js/./src/Chart/api/category.ts","webpack://billboard.js/./src/Chart/api/flow.ts","webpack://billboard.js/./src/Chart/api/grid.ts","webpack://billboard.js/./src/Chart/api/group.ts","webpack://billboard.js/./src/Chart/api/regions.ts","webpack://billboard.js/./src/Chart/api/x.ts","webpack://billboard.js/./src/ChartInternal/Axis/AxisRendererHelper.ts","webpack://billboard.js/./src/ChartInternal/Axis/AxisRenderer.ts","webpack://billboard.js/./src/ChartInternal/Axis/Axis.ts","webpack://billboard.js/./src/ChartInternal/interactions/eventrect.ts","webpack://billboard.js/./src/ChartInternal/interactions/flow.ts","webpack://billboard.js/./src/ChartInternal/internals/clip.ts","webpack://billboard.js/./src/ChartInternal/internals/grid.ts","webpack://billboard.js/./src/ChartInternal/internals/region.ts","webpack://billboard.js/./src/ChartInternal/internals/size.axis.ts","webpack://billboard.js/./src/config/Options/axis/x.ts","webpack://billboard.js/./src/config/Options/axis/y.ts","webpack://billboard.js/./src/config/Options/axis/y2.ts","webpack://billboard.js/./src/config/Options/axis/axis.ts","webpack://billboard.js/./src/config/Options/common/grid.ts","webpack://billboard.js/./src/config/Options/data/axis.ts","webpack://billboard.js/./src/config/resolver/axis.ts","webpack://billboard.js/./src/ChartInternal/shape/arc.ts","webpack://billboard.js/./src/ChartInternal/shape/area.ts","webpack://billboard.js/./src/ChartInternal/shape/bar.ts","webpack://billboard.js/./src/ChartInternal/shape/bubble.ts","webpack://billboard.js/./src/ChartInternal/shape/candlestick.ts","webpack://billboard.js/./src/ChartInternal/shape/funnel.ts","webpack://billboard.js/./src/ChartInternal/shape/gauge.ts","webpack://billboard.js/./src/ChartInternal/shape/line.ts","webpack://billboard.js/./src/ChartInternal/shape/point.ts","webpack://billboard.js/./src/ChartInternal/shape/point.common.ts","webpack://billboard.js/./src/ChartInternal/shape/polar.ts","webpack://billboard.js/./src/ChartInternal/shape/radar.ts","webpack://billboard.js/./src/ChartInternal/shape/treemap.ts","webpack://billboard.js/./src/config/Options/common/point.ts","webpack://billboard.js/./src/config/Options/shape/area.ts","webpack://billboard.js/./src/config/Options/shape/bar.ts","webpack://billboard.js/./src/config/Options/shape/bubble.ts","webpack://billboard.js/./src/config/Options/shape/candlestick.ts","webpack://billboard.js/./src/config/Options/shape/line.ts","webpack://billboard.js/./src/config/Options/shape/scatter.ts","webpack://billboard.js/./src/config/Options/shape/spline.ts","webpack://billboard.js/./src/config/Options/shape/arc.ts","webpack://billboard.js/./src/config/Options/shape/donut.ts","webpack://billboard.js/./src/config/Options/shape/funnel.ts","webpack://billboard.js/./src/config/Options/shape/gauge.ts","webpack://billboard.js/./src/config/Options/shape/pie.ts","webpack://billboard.js/./src/config/Options/shape/polar.ts","webpack://billboard.js/./src/config/Options/shape/radar.ts","webpack://billboard.js/./src/config/Options/shape/treemap.ts","webpack://billboard.js/./src/config/resolver/shape.ts","webpack://billboard.js/./src/core.ts","webpack://billboard.js/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3-selection\"), require(\"d3-time-format\"), require(\"d3-brush\"), require(\"d3-dsv\"), require(\"d3-drag\"), require(\"d3-scale\"), require(\"d3-transition\"), require(\"d3-shape\"), require(\"d3-zoom\"), require(\"d3-axis\"), require(\"d3-ease\"), require(\"d3-interpolate\"), require(\"d3-hierarchy\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3-selection\", \"d3-time-format\", \"d3-brush\", \"d3-dsv\", \"d3-drag\", \"d3-scale\", \"d3-transition\", \"d3-shape\", \"d3-zoom\", \"d3-axis\", \"d3-ease\", \"d3-interpolate\", \"d3-hierarchy\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3-selection\"), require(\"d3-time-format\"), require(\"d3-brush\"), require(\"d3-dsv\"), require(\"d3-drag\"), require(\"d3-scale\"), require(\"d3-transition\"), require(\"d3-shape\"), require(\"d3-zoom\"), require(\"d3-axis\"), require(\"d3-ease\"), require(\"d3-interpolate\"), require(\"d3-hierarchy\")) : factory(root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"], root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__6__, __WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__11__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * CSS class names definition\n * @private\n */\nexport const $COMMON = {\n\tbutton: \"bb-button\",\n\tchart: \"bb-chart\",\n\tempty: \"bb-empty\",\n\tmain: \"bb-main\",\n\ttarget: \"bb-target\",\n\tEXPANDED: \"_expanded_\",\n\tdummy: \"_dummy_\"\n};\n\nexport const $ARC = {\n\tarc: \"bb-arc\",\n\tarcLabelLine: \"bb-arc-label-line\",\n\tarcRange: \"bb-arc-range\",\n\tarcs: \"bb-arcs\",\n\tchartArc: \"bb-chart-arc\",\n\tchartArcs: \"bb-chart-arcs\",\n\tchartArcsBackground: \"bb-chart-arcs-background\",\n\tchartArcsTitle: \"bb-chart-arcs-title\",\n\tneedle: \"bb-needle\"\n};\n\nexport const $AREA = {\n\tarea: \"bb-area\",\n\tareas: \"bb-areas\"\n};\n\nexport const $AXIS = {\n\taxis: \"bb-axis\",\n\taxisX: \"bb-axis-x\",\n\taxisXLabel: \"bb-axis-x-label\",\n\taxisY: \"bb-axis-y\",\n\taxisY2: \"bb-axis-y2\",\n\taxisY2Label: \"bb-axis-y2-label\",\n\taxisYLabel: \"bb-axis-y-label\",\n\taxisXTooltip: \"bb-axis-x-tooltip\",\n\taxisYTooltip: \"bb-axis-y-tooltip\",\n\taxisY2Tooltip: \"bb-axis-y2-tooltip\",\n\taxisTooltipX: \"bb-axis-tooltip-x\",\n\taxisTooltipY: \"bb-axis-tooltip-y\"\n};\n\nexport const $BAR = {\n\tbar: \"bb-bar\",\n\tbars: \"bb-bars\",\n\tchartBar: \"bb-chart-bar\",\n\tchartBars: \"bb-chart-bars\",\n\tbarConnectLine: \"bb-bar-connectLine\"\n};\n\nexport const $CANDLESTICK = {\n\tcandlestick: \"bb-candlestick\",\n\tcandlesticks: \"bb-candlesticks\",\n\tchartCandlestick: \"bb-chart-candlestick\",\n\tchartCandlesticks: \"bb-chart-candlesticks\",\n\tvalueDown: \"bb-value-down\",\n\tvalueUp: \"bb-value-up\"\n};\n\nexport const $CIRCLE = {\n\tchartCircles: \"bb-chart-circles\",\n\tcircle: \"bb-circle\",\n\tcircles: \"bb-circles\"\n};\n\nexport const $COLOR = {\n\tcolorPattern: \"bb-color-pattern\",\n\tcolorScale: \"bb-colorscale\"\n};\n\nexport const $DRAG = {\n\tdragarea: \"bb-dragarea\",\n\tINCLUDED: \"_included_\"\n};\n\nexport const $FUNNEL = {\n\tfunnel: \"bb-funnel\",\n\tchartFunnel: \"bb-chart-funnel\",\n\tchartFunnels: \"bb-chart-funnels\",\n\tfunnelBackground: \"bb-funnel-background\"\n};\n\nexport const $GAUGE = {\n\tchartArcsGaugeMax: \"bb-chart-arcs-gauge-max\",\n\tchartArcsGaugeMin: \"bb-chart-arcs-gauge-min\",\n\tchartArcsGaugeUnit: \"bb-chart-arcs-gauge-unit\",\n\tchartArcsGaugeTitle: \"bb-chart-arcs-gauge-title\",\n\tgaugeValue: \"bb-gauge-value\"\n};\n\nexport const $LEGEND = {\n\tlegend: \"bb-legend\",\n\tlegendBackground: \"bb-legend-background\",\n\tlegendItem: \"bb-legend-item\",\n\tlegendItemEvent: \"bb-legend-item-event\",\n\tlegendItemHidden: \"bb-legend-item-hidden\",\n\tlegendItemPoint: \"bb-legend-item-point\",\n\tlegendItemTile: \"bb-legend-item-tile\"\n};\n\nexport const $LINE = {\n\tchartLine: \"bb-chart-line\",\n\tchartLines: \"bb-chart-lines\",\n\tline: \"bb-line\",\n\tlines: \"bb-lines\"\n};\n\nexport const $EVENT = {\n\teventRect: \"bb-event-rect\",\n\teventRects: \"bb-event-rects\",\n\teventRectsMultiple: \"bb-event-rects-multiple\",\n\teventRectsSingle: \"bb-event-rects-single\"\n};\n\nexport const $FOCUS = {\n\tfocused: \"bb-focused\",\n\tdefocused: \"bb-defocused\",\n\tlegendItemFocused: \"bb-legend-item-focused\",\n\txgridFocus: \"bb-xgrid-focus\",\n\tygridFocus: \"bb-ygrid-focus\"\n};\n\nexport const $GRID = {\n\tgrid: \"bb-grid\",\n\tgridLines: \"bb-grid-lines\",\n\txgrid: \"bb-xgrid\",\n\txgridLine: \"bb-xgrid-line\",\n\txgridLines: \"bb-xgrid-lines\",\n\txgrids: \"bb-xgrids\",\n\tygrid: \"bb-ygrid\",\n\tygridLine: \"bb-ygrid-line\",\n\tygridLines: \"bb-ygrid-lines\",\n\tygrids: \"bb-ygrids\"\n};\n\nexport const $LEVEL = {\n\tlevel: \"bb-level\",\n\tlevels: \"bb-levels\"\n};\n\nexport const $RADAR = {\n\tchartRadar: \"bb-chart-radar\",\n\tchartRadars: \"bb-chart-radars\"\n};\n\nexport const $REGION = {\n\tregion: \"bb-region\",\n\tregions: \"bb-regions\"\n};\n\nexport const $SELECT = {\n\tselectedCircle: \"bb-selected-circle\",\n\tselectedCircles: \"bb-selected-circles\",\n\tSELECTED: \"_selected_\"\n};\n\nexport const $SHAPE = {\n\tshape: \"bb-shape\",\n\tshapes: \"bb-shapes\"\n};\n\nexport const $SUBCHART = {\n\tbrush: \"bb-brush\",\n\tsubchart: \"bb-subchart\"\n};\n\nexport const $TEXT = {\n\tchartText: \"bb-chart-text\",\n\tchartTexts: \"bb-chart-texts\",\n\ttext: \"bb-text\",\n\ttexts: \"bb-texts\",\n\ttitle: \"bb-title\",\n\tTextOverlapping: \"text-overlapping\",\n\ttextBorderRect: \"bb-text-border\"\n};\n\nexport const $TOOLTIP = {\n\ttooltip: \"bb-tooltip\",\n\ttooltipContainer: \"bb-tooltip-container\",\n\ttooltipName: \"bb-tooltip-name\"\n};\n\nexport const $TREEMAP = {\n\ttreemap: \"bb-treemap\",\n\tchartTreemap: \"bb-chart-treemap\",\n\tchartTreemaps: \"bb-chart-treemaps\"\n};\n\nexport const $ZOOM = {\n\tbuttonZoomReset: \"bb-zoom-reset\",\n\tzoomBrush: \"bb-zoom-brush\"\n};\n\nexport default {\n\t...$COMMON,\n\t...$ARC,\n\t...$AREA,\n\t...$AXIS,\n\t...$BAR,\n\t...$CANDLESTICK,\n\t...$CIRCLE,\n\t...$COLOR,\n\t...$DRAG,\n\t...$GAUGE,\n\t...$LEGEND,\n\t...$LINE,\n\t...$EVENT,\n\t...$FOCUS,\n\t...$FUNNEL,\n\t...$GRID,\n\t...$RADAR,\n\t...$REGION,\n\t...$SELECT,\n\t...$SHAPE,\n\t...$SUBCHART,\n\t...$TEXT,\n\t...$TOOLTIP,\n\t...$TREEMAP,\n\t...$ZOOM\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * boost config options\n */\nexport default {\n\t/**\n\t * Set boost options\n\t * @name boost\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} boost boost object\n\t * @property {boolean} [boost.useCssRule=false] Avoid setting inline styles for each shape elements.\n\t * - **NOTE:**\n\t *   - Will append &lt;style> to the head tag and will add shpes' CSS rules dynamically.\n\t *   - For now, covers colors related properties (fill, stroke, etc.) only.\n\t * @property {boolean} [boost.useWorker=false] Use Web Worker as possible for processing.\n\t * - **NOTE:**\n\t *   - For now, only applies for data conversion at the initial time.\n\t *   - As of Web Worker's async nature, handling chart instance synchrously is not recommended.\n\t * @example\n\t *  boost: {\n\t *      useCssRule: true,\n\t *      useWorker: false\n\t *  }\n\t */\n\tboost_useCssRule: false,\n\tboost_useWorker: false\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * color config options\n */\nexport default {\n\t/**\n\t * Set color of the data values\n\t * @name color\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} color color object\n\t * @property {string|object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.\n\t * @property {Array|null} [color.pattern=[]] Set custom color pattern. Passing `null` will not set a color for these elements, which requires the usage of custom CSS-based theming to work.\n\t * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).\n\t *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>\n\t *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>\n\t *    - `bb-colorize-pattern-red`\n\t *    - `bb-colorize-pattern-fff`\n\t * @property {object} [color.threshold] color threshold for gauge and tooltip color\n\t * @property {string} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.\n\t * @property {Array} [color.threshold.values] Threshold values for each steps\n\t * @property {number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.\n\t * @example\n\t *  color: {\n\t *      pattern: [\"#1f77b4\", \"#aec7e8\", ...],\n\t *\n\t *      // Set colors' patterns\n\t *      // it should return an array of SVGPatternElement\n\t *      tiles: function() {\n\t *         var pattern = document.createElementNS(\"http://www.w3.org/2000/svg\", \"pattern\");\n\t *         var g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n\t *         var circle1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n\t *\n\t *         pattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n\t *         pattern.setAttribute(\"width\", \"32\");\n\t *         pattern.setAttribute(\"height\", \"32\");\n\t *\n\t *         g.style.fill = \"#000\";\n\t *         g.style.opacity = \"0.2\";\n\t *\n\t *         circle1.setAttribute(\"cx\", \"3\");\n\t *         circle1.setAttribute(\"cy\", \"3\");\n\t *         circle1.setAttribute(\"r\", \"3\");\n\t *\n\t *         g.appendChild(circle1);\n\t *         pattern.appendChild(g);\n\t *\n\t *         return [pattern];\n\t *      },\n\t *\n\t *      // for threshold usage, pattern values should be set for each steps\n\t *      pattern: [\"grey\", \"green\", \"yellow\", \"orange\", \"red\"],\n\t *      threshold: {\n\t *          unit: \"value\",\n\t *\n\t *          // when value is 20 => 'green', value is 40 => 'orange' will be set.\n\t *          values: [10, 20, 30, 40, 50],\n\t *\n\t *          // the equation for max:\n\t *          // - unit == 'value': max => 30\n\t *          // - unit != 'value': max => value*100/30\n\t *          max: 30\n\t *      },\n\t *\n\t *      // set all data to 'red'\n\t *      onover: \"red\",\n\t *\n\t *      // set different color for data\n\t *      onover: {\n\t *          data1: \"red\",\n\t *          data2: \"yellow\"\n\t *      },\n\t *\n\t *      // will pass data object to the callback\n\t *      onover: function(d) {\n\t *          return d.id === \"data1\" ? \"red\" : \"green\";\n\t *      }\n\t *  }\n\t */\n\tcolor_pattern: <(string | null)[]>[],\n\tcolor_tiles: <(() => []) | undefined>undefined,\n\tcolor_threshold: <{unit?: string, values?: number[], max: number}>{},\n\tcolor_onover: <string | object | undefined>undefined\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * legend config options\n */\nexport default {\n\t/**\n\t * Legend options\n\t * @name legend\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} legend Legend object\n\t * @property {boolean} [legend.show=true] Show or hide legend.\n\t * @property {boolean} [legend.hide=false] Hide legend\n\t *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.\n\t * @property {string|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.\n\t * - **NOTE:** Should be used along with `legend.contents.template`.\n\t * @property {string|Function} [legend.contents.template=\"<span style='color:#fff;padding:5px;background-color:{=COLOR}'>{=TITLE}</span>\"] Set item's template.<br>\n\t *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:\n\t *    - {=COLOR}: data color value\n\t *    - {=TITLE}: data title value\n\t *  - If set `function` value, will pass following arguments to the given function:\n\t *   - title {string}: data's id value\n\t *   - color {string}: color string\n\t *   - data {Array}: data array\n\t * @property {string} [legend.position=bottom] Change the position of legend.<br>\n\t *  Available values are: `bottom`, `right` and `inset` are supported.\n\t * @property {object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>\n\t *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.\n\t *  - **anchor** decides the position of the legend:\n\t *   - top-left\n\t *   - top-right\n\t *   - bottom-left\n\t *   - bottom-right\n\t *  - **x** and **y**:\n\t *   - set the position of the legend based on the anchor.\n\t *  - **step**:\n\t *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).\n\t * @property {boolean} [legend.equally=false] Set to all items have same width size.\n\t * @property {number} [legend.padding=0] Set padding value\n\t * @property {boolean} [legend.item.interaction=true] Set legend item interaction.\n\t *  - **NOTE:**\n\t *    - This setting will not have effect on `.toggle()` method.\n\t *    - `legend.item.onXXX` listener options will work if set, regardless of this option value.\n\t * @property {boolean} [legend.item.interaction.dblclick=false] Set legend item to interact on double click.\n\t *  - **NOTE:**\n\t *    - Double clicking will make focused clicked dataseries only, hiding all others.\n\t *      - for single click case, `click + altKey(Win)/optionKey(Mac OS)` to have same effect.\n\t *    - To return initial state(which all dataseries are showing), double click current focused legend item again.\n\t *      - for single click case, `click + altKey(Win)/optionKey(Mac OS)` to have same effect.\n\t *    - In this case, default `click` interaction will be disabled.\n\t * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.\n\t *  - **NOTE:**\n\t *    - When set, default `click` interaction will be disabled.\n\t *    - When `interaction.dblclick=true` is set, will be called on double click.\n\t * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.\n\t *  - **NOTE:** When set, default `mouseover` interaction will be disabled.\n\t * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.\n\t *  - **NOTE:** When set, default `mouseout` interaction will be disabled.\n\t * @property {number} [legend.item.tile.width=10] Set width for 'rectangle' legend item tile element.\n\t * @property {number} [legend.item.tile.height=10] Set height for 'rectangle' legend item tile element.\n\t * @property {number} [legend.item.tile.r=5] Set the radius for 'circle' legend item tile type.\n\t * @property {string} [legend.item.tile.type=\"rectangle\"] Set legend item shape type.<br>\n\t * - **Available Values:**\n\t *   - circle\n\t *   - rectangle\n\t * @property {boolean} [legend.format] Set formatter function for legend text.\n\t * The argument:<br>\n\t *  - `id`: Legend text value. When `data.names` is specified, will pass from it, otherwise will pass data id.\n\t *  - `dataId`: When `data.names` specified, will pass the original data id. Otherwise will be undefined.\n\t * @property {boolean} [legend.tooltip=false] Show full legend text value using system tooltip(via `<title>` element).\n\t * @property {boolean} [legend.usePoint=false] Whether to use custom points in legend.\n\t * @see [Demo: format](https://naver.github.io/billboard.js/demo/#Legend.LegendFormat)\n\t * @see [Demo: item.interaction](https://naver.github.io/billboard.js/demo/#Legend.LegendItemInteraction)\n\t * @see [Demo: item.tile.type](https://naver.github.io/billboard.js/demo/#Legend.LegendItemTileType)\n\t * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)\n\t * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)\n\t * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)\n\t * @example\n\t *  legend: {\n\t *      show: true,\n\t *      hide: true,\n\t *      //or hide: \"data1\"\n\t *      //or hide: [\"data1\", \"data2\"]\n\t *      contents: {\n\t *          bindto: \"#legend\",   // <ul id='legend'></ul>\n\t *\n\t *          // will be as: <li style='background-color:#1f77b4'>data1</li>\n\t *          template: \"<li style='background-color:{=COLOR}'>{=TITLE}</li>\"\n\t *\n\t *          // or using function\n\t *          template: function(id, color, data) {\n\t *               // if you want omit some legend, return falsy value\n\t *               if (id !== \"data1\") {\n\t *                    return \"<li style='background-color:\"+ color +\">\"+ id +\"</li>\";\n\t *               }\n\t *          }\n\t *      },\n\t *      position: \"bottom\",  // bottom, right, inset\n\t *      inset: {\n\t *          anchor: \"top-right\"  // top-left, top-right, bottom-left, bottom-right\n\t *          x: 20,\n\t *          y: 10,\n\t *          step: 2\n\t *      },\n\t *      equally: false,\n\t *      padding: 10,\n\t *      item: {\n\t *          // will disable default interaction\n\t *          interaction: false,\n\t *\n\t *          // set legend interact on double click\n\t *          // by double clicking, will make focused clicked dataseries only, hiding all others.\n\t *          interaction: {\n\t *            dblclick: true\n\t *          }\n\t *\n\t *          // when set below callback, will disable corresponding default interactions\n\t *          onclick: function(id, visible) {\n\t *           \t// toggle based on the data visibility\n\t *           \tthis[visible ? \"hide\" : \"show\"](id);\n\t *          },\n\t *          onover: function(id, visible) { ... },\n\t *          onout: function(id, visible) { ... },\n\t *\n\t *          // set tile's size\n\t *          tile: {\n\t *              // set tile type\n\t *              type: \"circle\"  // or \"rectangle\" (default)\n\t *\n\t *              // width & height, are only applicable for 'rectangle' legend type\n\t *              width: 15,\n\t *              height: 15\n\t *\n\t *              // radis is only applicable for 'circle' legend type\n\t *              r: 10\n\t *          }\n\t *      },\n\t *      format: function(id, dataId) {\n\t *          // set ellipsis string when length is > 5\n\t *          // to get full legend value, combine with 'legend.tooltip=true'\n\t *          if (id.length > 5) {\n\t *            \tid = id.substr(0, 5) + \"...\";\n\t *          }\n\t *\n\t *          return id;\n\t *      },\n\t *      tooltip: true,\n\t *      usePoint: true\n\t *  }\n\t */\n\tlegend_contents_bindto: <string | HTMLElement | undefined>undefined,\n\tlegend_contents_template: <string | (() => string)\n\t\t| undefined>\"<span style='color:#fff;padding:5px;background-color:{=COLOR}'>{=TITLE}</span>\",\n\tlegend_equally: false,\n\tlegend_hide: false,\n\tlegend_inset_anchor: <\"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\">\"top-left\",\n\tlegend_inset_x: 10,\n\tlegend_inset_y: 0,\n\tlegend_inset_step: <number | undefined>undefined,\n\tlegend_item_interaction: <boolean | {dblclick?: boolean}>true,\n\tlegend_item_dblclick: false,\n\tlegend_item_onclick: <Function | undefined>undefined,\n\tlegend_item_onover: <Function | undefined>undefined,\n\tlegend_item_onout: <Function | undefined>undefined,\n\tlegend_item_tile_width: 10,\n\tlegend_item_tile_height: 10,\n\tlegend_item_tile_r: 5,\n\tlegend_item_tile_type: <\"rectangle\" | \"circle\">\"rectangle\",\n\tlegend_format: <Function | undefined>undefined,\n\tlegend_padding: 0,\n\tlegend_position: <\"bottom\" | \"right\" | \"inset\">\"bottom\",\n\tlegend_show: true,\n\tlegend_tooltip: false,\n\tlegend_usePoint: false\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {RegionOptions} from \"../../../../types/options\";\n\n/**\n * main config options\n */\nexport default {\n\t/**\n\t * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>\n\t * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).\n\t * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.\n\t * @name bindto\n\t * @memberof Options\n\t * @property {string|HTMLElement|d3.selection|object} [bindto=\"#chart\"] Specify the element where chart will be drawn.\n\t * @property {string|HTMLElement|d3.selection} bindto.element=\"#chart\" Specify the element where chart will be drawn.\n\t * @property {string} [bindto.classname=bb] Specify the class name of bind element.<br>\n\t *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.\n\t * @default #chart\n\t * @example\n\t * bindto: \"#myContainer\"\n\t *\n\t * // or HTMLElement\n\t * bindto: document.getElementById(\"myContainer\")\n\t *\n\t * // or D3 selection object\n\t * bindto: d3.select(\"#myContainer\")\n\t *\n\t * // or to change default classname\n\t * bindto: {\n\t *    element: \"#chart\",\n\t *    classname: \"bill-board\"  // ex) <div id='chart' class='bill-board'>\n\t * }\n\t */\n\tbindto: <string | {element: string, classname?: string}>\"#chart\",\n\n\t/**\n\t * Set chart background.\n\t * @name background\n\t * @memberof Options\n\t * @property {object} background background object\n\t * @property {string} background.class Specify the class name for background element.\n\t * @property {string} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.\n\t * @property {string} background.imgUrl Specify the image url string for background.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)\n\t * @example\n\t * background: {\n\t *    class: \"myClass\",\n\t *    color: \"red\",\n\t *\n\t *    // Set image url for background.\n\t *    // If specified, 'color' option will be ignored.\n\t *    imgUrl: \"https://naver.github.io/billboard.js/img/logo/billboard.js.svg\",\n\t * }\n\t */\n\tbackground: <{class?: string, color?: string, imgUrl?: string}>{},\n\n\t/**\n\t * Set 'clip-path' attribute for chart element\n\t * - **NOTE:**\n\t *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.\n\t *  > Is to make chart element positioned over axis element.\n\t * @name clipPath\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)\n\t * @example\n\t * // don't set 'clip-path' attribute\n\t * clipPath: false\n\t */\n\tclipPath: true,\n\n\t/**\n\t * Set svg element's class name\n\t * @name svg\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} [svg] svg object\n\t * @property {string} [svg.classname] class name for svg element\n\t * @example\n\t * svg: {\n\t *   classname: \"test_class\"\n\t * }\n\t */\n\tsvg_classname: <string | undefined>undefined,\n\n\t/**\n\t * The desired size of the chart element.\n\t * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.\n\t * @name size\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} [size] size object\n\t * @property {number} [size.width] width of the chart element\n\t * @property {number} [size.height] height of the chart element\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)\n\t * @example\n\t * size: {\n\t *   width: 640,\n\t *   height: 480\n\t * }\n\t */\n\tsize_width: <number | undefined>undefined,\n\tsize_height: <number | undefined>undefined,\n\n\t/**\n\t * The padding of the chart element.\n\t * - **NOTE:** for more information, see the \"[`Understanding padding`](https://github.com/naver/billboard.js/wiki/Understanding-padding)\"\" wiki documentaion.\n\t * @name padding\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object|boolean} [padding=true] Set padding of chart, and accepts object or boolean type.\n\t * - `Object`: Specify each side's padding.\n\t * - `false`: Remove padding completely and make shape to fully occupy the container element.\n\t *   - In this case, axes and subchart will be hidden.\n\t *   - To adjust some padding from this state, use `axis.[x|y].padding` option.\n\t * @property {string} [padding.mode] padding mode\n\t * - `\"fit\"`: Reduce padding as much as possible to make chart fit to the container element for chart types w/axis.<br>When specified, all padding values will be relative from fitted value.\n\t * @property {number} [padding.top] padding on the top of chart\n\t * @property {number} [padding.right] padding on the right of chart\n\t * @property {number} [padding.bottom] padding on the bottom of chart\n\t * @property {number} [padding.left] padding on the left of chart\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Padding)\n\t * @see [Demo: Fit padding](https://naver.github.io/billboard.js/demo/#ChartOptions.FitPadding)\n\t * @example\n\t * // remove padding completely.\n\t * padding: false,\n\t *\n\t * padding: {\n\t *   // specifying mode value, will reduce padding and make fit to the container element.\n\t *   mode: \"fit\"\n\t *\n\t *   // when mode is \"fit\", all padding values will be relative from fitted value.\n\t *   // so, 0 will be initial fitted value.\n\t *   top: 20,\n\t *   right: 20,\n\t *   bottom: 20,\n\t *   left: 20\n\t * }\n\t *\n\t * // or specify padding value for each side\n\t * padding: {\n\t *   top: 20,\n\t *   right: 20,\n\t *   bottom: 20,\n\t *   left: 20\n\t * }\n\t */\n\tpadding: true,\n\tpadding_mode: <\"fit\" | undefined>undefined,\n\tpadding_left: <number | undefined>undefined,\n\tpadding_right: <number | undefined>undefined,\n\tpadding_top: <number | undefined>undefined,\n\tpadding_bottom: <number | undefined>undefined,\n\n\t/**\n\t * Set chart resize options\n\t * @name resize\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} [resize] resize object\n\t * @property {boolean|string} [resize.auto=true] Set chart resize automatically on viewport changes.\n\t * - **NOTE:** Available options\n\t *   - true: Enables automatic resize.\n\t *   - false: Disables automatic resize.\n\t *   - \"parent\": Enables automatic resize when the parent node is resized.\n\t *   - \"viewBox\": Enables automatic resize, and size will be fixed based on the viewbox.\n\t * @property {boolean|number} [resize.timer=true] Set resize timer option.\n\t * - **NOTE:** Available options\n\t *   - The resize function will be called using:\n\t *     - true: `setTimeout()`\n\t *     - false: `requestIdleCallback()`\n\t *   - Given number(delay in ms) value, resize function will be triggered using `setTimeout()` with given delay.\n\t * @see [Demo: resize \"parent\"](https://naver.github.io/billboard.js/demo/#ChartOptions.resizeParent)\n\t * @see [Demo: resize \"viewBox\"](https://naver.github.io/billboard.js/demo/#ChartOptions.resizeViewBox)\n\t * @example\n\t *  resize: {\n\t *      auto: false,\n\t *\n\t *      // set resize based on parent node width value\n\t *      auto: \"parent\",\n\t *\n\t *      // set resize based on viewBox value\n\t *      auto: \"viewBox\",\n\t *\n\t *      // set resize function will be triggered using `setTimeout()`\n\t *      timer: true,\n\t *\n\t *      // set resize function will be triggered using `requestIdleCallback()`\n\t *      timer: false,\n\t *\n\t *      // set resize function will be triggered using `setTimeout()` with a delay of `100ms`.\n\t *      timer: 100\n\t *  }\n\t */\n\tresize_auto: <boolean | \"parent\" | \"viewBox\">true,\n\tresize_timer: true,\n\n\t/**\n\t * Set a callback to execute when the chart is clicked.\n\t * @name onclick\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onclick: function(event) {\n\t *   this; // chart instance itself\n\t *   event; // native event object\n\t *   ...\n\t * }\n\t */\n\tonclick: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute when mouse/touch enters the chart.\n\t * @name onover\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onover: function(event) {\n\t *   this; // chart instance itself\n\t *   event; // native event object\n\t *   ...\n\t * }\n\t */\n\tonover: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute when mouse/touch leaves the chart.\n\t * @name onout\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onout: function(event) {\n\t *   this; // chart instance itself\n\t *   event; // native event object\n\t *   ...\n\t * }\n\t */\n\tonout: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute when user resizes the screen.\n\t * @name onresize\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onresize: function() {\n\t *   this; // chart instance itself\n\t *   ...\n\t * }\n\t */\n\tonresize: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute when screen resize finished.\n\t * @name onresized\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onresized: function() {\n\t *   this; // chart instance itself\n\t *   ...\n\t * }\n\t */\n\tonresized: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute before the chart is initialized\n\t * @name onbeforeinit\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onbeforeinit: function() {\n\t *   this; // chart instance itself\n\t *   ...\n\t * }\n\t */\n\tonbeforeinit: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute when the chart is initialized.\n\t * @name oninit\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * oninit: function() {\n\t *   this; // chart instance itself\n\t *   ...\n\t * }\n\t */\n\toninit: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback to execute after the chart is initialized\n\t * @name onafterinit\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onafterinit: function() {\n\t *   this; // chart instance itself\n\t *   ...\n\t * }\n\t */\n\tonafterinit: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.\n\t * @name onrendered\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * onrendered: function() {\n\t *   this; // chart instance itself\n\t *   ...\n\t * }\n\t */\n\tonrendered: <(() => void) | undefined>undefined,\n\n\t/**\n\t * Set duration of transition (in milliseconds) for chart animation.<br><br>\n\t * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.\n\t * @name transition\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} [transition] transition object\n\t * @property {number} [transition.duration=350] duration in milliseconds\n\t * @example\n\t * transition: {\n\t *    duration: 500\n\t * }\n\t */\n\ttransition_duration: 250,\n\n\t/**\n\t * Set plugins\n\t * @name plugins\n\t * @memberof Options\n\t * @type {Array}\n\t * @example\n\t *  plugins: [\n\t *    new bb.plugin.stanford({ ... }),\n\t *    new PluginA(),\n\t *    ...\n\t * ]\n\t */\n\tplugins: [],\n\n\t/**\n\t * Control the render timing\n\t * @name render\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} [render] render object\n\t * @property {boolean} [render.lazy=true] Make to not render at initialization.\n\t * - **NOTE**:\n\t *   - Enabled by default when bind element's visibility is hidden.\n\t *   - When set to `false`, will initialize the chart regardless the bind element's visibility state, but in this case chart can't be guaranteed to be rendered properly.\n\t * @property {boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)\n\t * @example\n\t *  render: {\n\t *    lazy: true,\n\t *    observe: true\n\t * }\n\t *\n\t * @example\n\t * \t// <!-- render.lazy will detect visibility defined -->\n\t *  // (a) <div id='chart' class='hide'></div>\n\t *  // (b) <div id='chart' style='display:none'></div>\n\t *\n\t *  // render.lazy enabled by default when element is hidden\n\t *  var chart = bb.generate({ ... });\n\t *\n\t *  // chart will be rendered automatically when element's visibility changes\n\t *  // Note: works only for inlined css property or class attribute changes\n\t *  document.getElementById('chart').classList.remove('hide')  // (a)\n\t *  document.getElementById('chart').style.display = 'block';  // (b)\n\t *\n\t * @example\n\t * \t// chart won't be rendered and not observing bind element's visiblity changes\n\t *  var chart = bb.generate({\n\t *     render: {\n\t *          lazy: true,\n\t *          observe: false\n\t *     }\n\t *  });\n\t *\n\t *  // call at any point when you want to render\n\t *  chart.flush();\n\t */\n\trender: <{lazy?: boolean, observe?: boolean}>{},\n\n\t/**\n\t * Show rectangles inside the chart.<br><br>\n\t * - **NOTE:**<br>\n\t *   - axis must be x, y or y2. start and end should be the value where regions start and end.\n\t *   - If not specified, the edge values will be used.\n\t *   - If timeseries x axis, date string, Date object and unixtime integer can be used.\n\t *   - If category x axis, category name can be used for start and end.\n\t *   - If class is set, the region element will have it as class.\n\t *\n\t * This option accept array of object with below values:\n\t * - `axis {string}`: 'x', 'y', or 'y2'\n\t * - `[start] {number|Date|string}`: Start position of the region. If not set, the start will be the edge of the chart.\n\t * - `[end] {number|Date|string}`: End position of the region. If not set, the end will be the edge of the chart.\n\t * - `[class] {string}`: Class value to apply to the region.\n\t * - `[label] {object}` Lable text option.\n\t *   - `text {string}`: Text value.\n\t *   - `x {number}`: x Position.\n\t *   - `y {number}`: y Position.\n\t *   - `center {string}`: Align label at the center. Allowed values are 'x', 'y', 'xy'.\n\t *   - `color {string}`: Color string.\n\t *   - `rotated (boolean)`: Whether rotate label or not.\n\t * @name regions\n\t * @memberof Options\n\t * @type {Array}\n\t * @default []\n\t * @see [Demo: Regions](https://naver.github.io/billboard.js/demo/#Region.Region)\n\t * @see [Demo: Regions Timeseries](https://naver.github.io/billboard.js/demo/#Region.RegionWithTimeseries)\n\t * @see [Demo: Regions Label](https://naver.github.io/billboard.js/demo/#Region.RegionLabel)\n\t * @example\n\t *  regions: [\n\t *    {\n\t *      axis: \"x\",\n\t *      start: 1,\n\t *      end: 4,\n\t *      class: \"region-1-4\",\n\t *      label: {\n\t *      \ttext: \"Region Text\",\n\t *      \tx: 5,  // position relative of the initial x coordinate\n\t *      \ty: 5,  // position relative of the initial y coordinate\n\t *      \tcenter: \"xy\",  // center text label in both direction.\n\t *      \tcolor: \"red\",  // color string\n\t *      \trotated: true  // make text to show in vertical or horizontal\n\t *      }\n\t *    }\n\t *  ]\n\t */\n\tregions: <RegionOptions[]>[]\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * title config options\n */\nexport default {\n\t/**\n\t * Set title options\n\t * @name title\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} title Title object\n\t * @property {string} [title.text] Title text. If contains `\\n`, it's used as line break allowing multiline title.\n\t * @property {number} [title.padding.top=0] Top padding value.\n\t * @property {number} [title.padding.right=0] Right padding value.\n\t * @property {number} [title.padding.bottom=0] Bottom padding value.\n\t * @property {number} [title.padding.left=0] Left padding value.\n\t * @property {string} [title.position=center] Available values are: 'center', 'right' and 'left'.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)\n\t * @example\n\t *  title: {\n\t *      text: \"Title Text\",\n\t *\n\t *      // or Multiline title text\n\t *      text: \"Main title text\\nSub title text\",\n\t *\n\t *      padding: {\n\t *          top: 10,\n\t *          right: 10,\n\t *          bottom: 10,\n\t *          left: 10\n\t *      },\n\t *      position: \"center\"\n\t *  }\n\t */\n\ttitle_text: <string | undefined>undefined,\n\ttitle_padding: {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: 0,\n\t\tleft: 0\n\t},\n\ttitle_position: <\"center\" | \"right\" | \"left\">\"center\"\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * tooltip config options\n */\nexport default {\n\t/**\n\t * Tooltip options\n\t * @name tooltip\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} tooltip Tooltip object\n\t * @property {boolean} [tooltip.show=true] Show or hide tooltip.\n\t * @property {boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.\n\t * @property {boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.\n\t *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.\n\t * @property {boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.\n\t * @property {string} [tooltip.linked.name=\"\"] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.\n\t * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>\n\t *  Specified function receives x of the data point to show.\n\t * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>\n\t *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.\n\t * @property {Function} [tooltip.format.value] Set format for the value of each data value in tooltip. If undefined returned, the row of that value will be skipped to be called.\n\t *  - Will pass following arguments to the given function:\n\t *    - `value {string}`: Value of the data point. If data row contains multiple or ranged(ex. candlestick, area range, etc.) value, formatter will be called as value length.\n\t *    - `ratio {number}`: Ratio of the data point in the `pie/donut/gauge` and `area/bar` when contains grouped data. Otherwise is `undefined`.\n\t *    - `id {string}`: id of the data point\n\t *    - `index {number}`: Index of the data point\n\t * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>\n\t *  This option can be used to modify the tooltip position by returning object that has top and left.\n\t *  - Will pass following arguments to the given function:\n\t *    - `data {Array}`: Current selected data array object.\n\t *    - `width {number}`: Width of tooltip.\n\t *    - `height {number}`: Height of tooltip.\n\t *    - `element {SVGElement}`: Tooltip event bound element\n\t *    - `pos {object}`: Current position of the tooltip.\n\t * @property {Function|object} [tooltip.contents] Set custom HTML for the tooltip.<br>\n\t *  If tooltip.grouped is true, data includes multiple data points.<br><br>\n\t *  Specified function receives `data` array and `defaultTitleFormat`, `defaultValueFormat` and `color` functions of the data point to show.\n\t *  - **Note:**\n\t *    - defaultTitleFormat:\n\t *      - if `axis.x.tick.format` option will be used if set.\n\t *      - otherwise, will return function based on tick format type(category, timeseries).\n\t *    - defaultValueFormat:\n\t * \t    - for Arc type (except gauge, radar), the function will return value from `(ratio * 100).toFixed(1)`.\n\t * \t    - for Axis based types, will be used `axis.[y|y2].tick.format` option value if is set.\n\t * \t    - otherwise, will parse value and return as number.\n\t * @property {string|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.\n\t *  - **NOTE:** When is specified, will not be updating tooltip's position.\n\t * @property {string} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>\n\t *  Within template, below syntax will be replaced using template-like syntax string:\n\t *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.\n\t *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.\n\t *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)\n\t *    - **{=TITLE}**: title value.\n\t *    - **{=COLOR}**: data color.\n\t *    - **{=NAME}**: data id value.\n\t *    - **{=VALUE}**: data value.\n\t * @property {object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.\n\t *  - **NOTE:** It should contain `{ key: Array, ... }` value\n\t *    - 'key' name is used as substitution within template as '{=KEY}'\n\t *    - The value array length should match with the data length\n\t * @property {boolean} [tooltip.init.show=false] Show tooltip at the initialization.\n\t * @property {number} [tooltip.init.x=0] Set x Axis index(or index for Arc(donut, gauge, pie) types) to be shown at the initialization.\n\t * @property {object} [tooltip.init.position] Set the position of tooltip at the initialization.\n\t * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.\n\t * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.\n\t * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown\n\t * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.\n\t * @property {string|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>\n\t *  **Available Values:**\n\t *  - `desc`: In descending data value order\n\t *  - `asc`: In ascending data value order\n\t *  - `null`: It keeps the data display order<br>\n\t *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>\n\t *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string \"\")\n\t *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)\n\t * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)\n\t * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)\n\t * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)\n\t * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)\n\t * @see [Demo: Tooltip Position](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipPosition)\n\t * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)\n\t * @example\n\t *  tooltip: {\n\t *      show: true,\n\t *      doNotHide: true,\n\t *      grouped: false,\n\t *      format: {\n\t *          title: function(x) { return \"Data \" + x; },\n\t *          name: function(name, ratio, id, index) { return name; },\n\t *\n\t *          // If data row contains multiple or ranged(ex. candlestick, area range, etc.) value,\n\t *          // formatter will be called as value length times.\n\t *          value: function(value, ratio, id, index) { return ratio; }\n\t *      },\n\t *      position: function(data, width, height, element, pos) {\n\t *          // data: [{x, index, id, name, value}, ...]\n\t *          // width: Tooltip width\n\t *          // height: Tooltip height\n\t *          // element: Tooltip event bound element\n\t *          // pos: {\n\t *          //   x: Current mouse event x position,\n\t *          //   y: Current mouse event y position,\n\t *          //   xAxis: Current x Axis position (the value is given for axis based chart type only)\n\t *          //   yAxis: Current y Axis position value or function(the value is given for axis based chart type only)\n\t *          // }\n\t *\n\t *          // yAxis will work differently per data lenghts\n\t *          // - a) Single data: `yAxis` will return `number` value\n\t *          // - b) Multiple data: `yAxis` will return a function with property value\n\t *\n\t *          // a) Single data:\n\t *          // Get y coordinate\n\t *          pos.yAxis; // y axis coordinate value of current data point\n\t *\n\t *          // b) Multiple data:\n\t *          // Get y coordinate of value 500, where 'data1' scales(y or y2).\n\t *          // When 'data.axes' option is used, data can bound to different axes.\n\t *          // - when \"data.axes={data1: 'y'}\", wil return y value from y axis scale.\n\t *          // - when \"data.axes={data1: 'y2'}\", wil return y value from y2 axis scale.\n\t *          pos.yAxis(500, \"data1\"); // will return y coordinate value of data1\n\t *\n\t *          pos.yAxis(500); // get y coordinate with value of 500, using y axis scale\n\t *          pos.yAxis(500, null, \"y2\"); // get y coordinate with value of 500, using y2 axis scale\n\t *\n\t *          return {\n\t *            top: 0,\n\t *            left: 0\n\t *          }\n\t *      },\n\t *\n\t *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {\n\t *          return ... // formatted html as you want\n\t *      },\n\t *\n\t *       // specify tooltip contents using template\n\t *       // - example of HTML returned:\n\t *       // <ul class=\"bb-tooltip\">\n\t *       //   <li class=\"bb-tooltip-name-data1\"><span>250</span><br><span style=\"color:#00c73c\">data1</span></li>\n\t *       //   <li class=\"bb-tooltip-name-data2\"><span>50</span><br><span style=\"color:#fa7171\">data2</span></li>\n\t *       // </ul>\n\t *       contents: {\n\t *      \tbindto: \"#tooltip\",\n\t *      \ttemplate: '<ul class={=CLASS_TOOLTIP}>{{' +\n\t *      \t\t\t'<li class=\"{=CLASS_TOOLTIP_NAME}\"><span>{=VALUE}</span><br>' +\n\t *      \t\t\t'<span style=color:{=COLOR}>{=NAME}</span></li>' +\n\t *      \t\t'}}</ul>'\n\t *      }\n\t *\n\t *       // with additional text value\n\t *       // - example of HTML returned:\n\t *       // <ul class=\"bb-tooltip\">\n\t *       //   <li class=\"bb-tooltip-name-data1\"><span>250</span><br>comment1<span style=\"color:#00c73c\">data1</span>text1</li>\n\t *       //   <li class=\"bb-tooltip-name-data2\"><span>50</span><br>comment2<span style=\"color:#fa7171\">data2</span>text2</li>\n\t *       // </ul>\n\t *       contents: {\n\t *      \tbindto: \"#tooltip\",\n\t *      \ttext: {\n\t *      \t\t// a) 'key' name is used as substitution within template as '{=KEY}'\n\t *      \t\t// b) the length should match with the data length\n\t *      \t\tVAR1: [\"text1\", \"text2\"],\n\t *      \t\tVAR2: [\"comment1\", \"comment2\"],\n\t *      \t},\n\t *      \ttemplate: '<ul class={=CLASS_TOOLTIP}>{{' +\n\t *      \t\t\t'<li class=\"{=CLASS_TOOLTIP_NAME}\"><span>{=VALUE}</span>{=VAR2}<br>' +\n\t *      \t\t\t'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +\n\t *      \t\t'}}</ul>'\n\t *      }\n\t *\n\t *      // sort tooltip data value display in ascending order\n\t *      order: \"asc\",\n\t *\n\t *      // specifying sort function\n\t *      order: function(a, b) {\n\t *         // param data passed format\n\t *         {x: 5, value: 250, id: \"data1\", index: 5, name: \"data1\"}\n\t *           ...\n\t *      },\n\t *\n\t *      // show at the initialization\n\t *      init: {\n\t *          show: true,\n\t *          x: 2, // x Axis index (or index for Arc(donut, gauge, pie) types)\n\t *          position: {\n\t *              top: \"150px\",  // specify as number or as string with 'px' unit string\n\t *              left: 250  // specify as number or as string with 'px' unit string\n\t *          }\n\t *      },\n\t *\n\t *      // fires prior tooltip is shown\n\t *      onshow: function(selectedData) {\n\t *      \t// current dataset selected\n\t *      \t// ==> [{x: 4, value: 150, id: \"data2\", index: 4, name: \"data2\"}, ...]\n\t *      \tselectedData;\n\t *      },\n\t *\n\t *      // fires prior tooltip is hidden\n\t *      onhide: function(selectedData) {\n\t *      \t// current dataset selected\n\t *      \t// ==> [{x: 4, value: 150, id: \"data2\", index: 4, name: \"data2\"}, ...]\n\t *      \tselectedData;\n\t *      },\n\t *\n\t *      // fires after tooltip is shown\n\t *      onshown: function(selectedData) {\n\t *      \t// current dataset selected\n\t *      \t// ==> [{x: 4, value: 150, id: \"data2\", index: 4, name: \"data2\"}, ...]\n\t *      \tselectedData;\n\t *      },\n\t *\n\t *      // fires after tooltip is hidden\n\t *      onhidden: function(selectedData) {\n\t *      \t// current dataset selected\n\t *      \t// ==> [{x: 4, value: 150, id: \"data2\", index: 4, name: \"data2\"}, ...]\n\t *      \tselectedData;\n\t *      },\n\t *\n\t *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available\n\t *      // Useful for timeseries correlation\n\t *      linked: true,\n\t *\n\t *      // Specify name to interact those with the same name only.\n\t *      linked: {\n\t *          name: \"some-group\"\n\t *      }\n\t *  }\n\t */\n\ttooltip_show: true,\n\ttooltip_doNotHide: false,\n\ttooltip_grouped: true,\n\ttooltip_format_title: <(() => string) | undefined>undefined,\n\ttooltip_format_name: <(() => string) | undefined>undefined,\n\ttooltip_format_value: <(() => number) | undefined>undefined,\n\ttooltip_position: <(() => {top: number, left: number}) | undefined>undefined,\n\ttooltip_contents: <(() => string) | {\n\t\tbindto: string,\n\t\ttemplate: string,\n\t\ttext?: {[key: string]: string[]}\n\t}>{},\n\ttooltip_init_show: false,\n\ttooltip_init_x: 0,\n\ttooltip_init_position: undefined,\n\ttooltip_linked: false,\n\ttooltip_linked_name: \"\",\n\ttooltip_onshow: () => {},\n\ttooltip_onhide: () => {},\n\ttooltip_onshown: () => {},\n\ttooltip_onhidden: () => {},\n\ttooltip_order: <string | Function | null>null\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {ChartTypes, d3Selection} from \"../../../../types/types\";\n\n/**\n * data config options\n */\nexport default {\n\t/**\n\t * Specify the key of x values in the data.<br><br>\n\t * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.\n\t * @name data․x\n\t * @memberof Options\n\t * @type {string}\n\t * @default undefined\n\t * @example\n\t * data: {\n\t *   x: \"date\"\n\t * }\n\t */\n\tdata_x: <string | undefined>undefined,\n\n\t/**\n\t * Converts data id value\n\t * @name data․idConverter\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function(id) { return id; }\n\t * @example\n\t * data: {\n\t *    idConverter: function(id) {\n\t *       // when id is 'data1', converts to be 'data2'\n\t *       // 'data2' should be given as the initial data value\n\t *       if (id === \"data1\") {\n\t *          return \"data2\";\n\t *       } else {\n\t *          return id;\n\t *       }\n\t *    }\n\t * }\n\t */\n\tdata_idConverter: id => id,\n\n\t/**\n\t * Set custom data name.\n\t * If a name is set to `null`, the series is omitted from the legend.\n\t * @name data․names\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)\n\t * @example\n\t * data: {\n\t *   names: {\n\t *     data1: \"Data Name 1\",\n\t *     data2: \"Data Name 2\"\n\t *   }\n\t * }\n\t */\n\tdata_names: <{[key: string]: string | null}>{},\n\n\t/**\n\t * Set custom data class.<br><br>\n\t * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).\n\t * @name data․classes\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @example\n\t * data: {\n\t *   classes: {\n\t *     data1: \"additional-data1-class\",\n\t *     data2: \"additional-data2-class\"\n\t *   }\n\t * }\n\t */\n\tdata_classes: <{[key: string]: string}>{},\n\n\t/**\n\t * Set chart type at once.<br><br>\n\t * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>\n\t * **Available Values:**\n\t * - area\n\t * - area-line-range\n\t * - area-spline\n\t * - area-spline-range\n\t * - area-step\n\t * - area-step-range\n\t * - bar\n\t * - bubble\n\t * - candlestick\n\t * - donut\n\t * - funnel\n\t * - gauge\n\t * - line\n\t * - pie\n\t * - polar\n\t * - radar\n\t * - scatter\n\t * - spline\n\t * - step\n\t * - treemap\n\t * @name data․type\n\t * @memberof Options\n\t * @type {string}\n\t * @default \"line\"<br>NOTE: When importing shapes by ESM, `line()` should be specified for type.\n\t * @example\n\t * data: {\n\t *    type: \"bar\"\n\t * }\n\t * @example\n\t * // Generate chart by importing ESM\n\t * // Import types to be used only, where this will make smaller bundle size.\n\t * import bb, {\n\t *   area,\n\t *   areaLineRange,\n\t *   areaSpline,\n\t *   areaSplineRange,\n\t *   areaStep,\n\t *   areaStepRange,\n\t *   bar,\n\t *   bubble,\n\t *   candlestick,\n\t *   donut,\n\t *   funnel,\n\t *   gauge,\n\t *   line,\n\t *   pie,\n\t *   polar,\n\t *   radar,\n\t *   scatter,\n\t *   spline,\n\t *   step,\n\t *   treemap\n\t * }\n\t *\n\t * bb.generate({\n\t *   ...,\n\t *   data: {\n\t *     type: bar()\n\t *   }\n\t * });\n\t */\n\tdata_type: <ChartTypes | undefined>undefined,\n\n\t/**\n\t * Set chart type for each data.<br>\n\t * This setting overwrites data.type setting.\n\t * - **NOTE:** `radar` and `treemap` type can't be combined with other types.\n\t * @name data․types\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @example\n\t * data: {\n\t *   types: {\n\t *     data1: \"bar\",\n\t *     data2: \"spline\"\n\t *   }\n\t * }\n\t * @example\n\t * // Generate chart by importing ESM\n\t * // Import types to be used only, where this will make smaller bundle size.\n\t * import bb, {\n\t *   area,\n\t *   areaLineRange,\n\t *   areaSpline,\n\t *   areaSplineRange,\n\t *   areaStep,\n\t *   areaStepRange,\n\t *   bar,\n\t *   bubble,\n\t *   candlestick,\n\t *   donut,\n\t *   funnel,\n\t *   gauge,\n\t *   line,\n\t *   pie,\n\t *   polar,\n\t *   radar,\n\t *   scatter,\n\t *   spline,\n\t *   step,\n\t *   treemap\n\t * }\n\t *\n\t * bb.generate({\n\t *   ...,\n\t *   data: {\n\t *     types: {\n\t *       data1: bar(),\n\t *       data1: spline()\n\t *     }\n\t *   }\n\t * });\n\t */\n\tdata_types: <{[key: string]: ChartTypes}>{},\n\n\t/**\n\t *  This option changes the order of stacking data and pieces of pie/donut.\n\t *  - If `null` specified, it will be the order the data loaded.\n\t *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>\n\t *\n\t *  **Available Values:**\n\t *  - `desc`: In descending order\n\t *  - `asc`: In ascending order\n\t *  - `null`: It keeps the data load order\n\t *  - `function(data1, data2) { ... }`: Array.sort compareFunction\n\t *\n\t *  **NOTE**: order function, only works for Axis based types & Arc types, except `Radar` type.\n\t * @name data․order\n\t * @memberof Options\n\t * @type {string|Function|null}\n\t * @default desc\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)\n\t * @example\n\t * data: {\n\t *   // in descending order (default)\n\t *   order: \"desc\"\n\t *\n\t *   // in ascending order\n\t *   order: \"asc\"\n\t *\n\t *   // keeps data input order\n\t *   order: null\n\t *\n\t *   // specifying sort function\n\t *   order: function(a, b) {\n\t *       // param data passed format\n\t *       // {\n\t *       //   id: \"data1\", id_org: \"data1\", values: [\n\t *       //      {x: 5, value: 250, id: \"data1\", index: 5, name: \"data1\"},\n\t *       //       ...\n\t *       //   ]\n\t *       // }\n\t *\n\t *       const reducer = (p, c) => p + Math.abs(c.value);\n\t *       const aSum = a.values.reduce(reducer, 0);\n\t *       const bSum = b.values.reduce(reducer, 0);\n\t *\n\t *       // ascending order\n\t *       return aSum - bSum;\n\t *\n\t *       // descending order\n\t *       // return bSum - aSum;\n\t *   }\n\t * }\n\t */\n\tdata_order: <\"desc\" | \"asc\" | Function | null>\"desc\",\n\n\t/**\n\t * Set groups for the data for stacking.\n\t * @name data․groups\n\t * @memberof Options\n\t * @type {Array}\n\t * @default []\n\t * @example\n\t * data: {\n\t *   groups: [\n\t *     [\"data1\", \"data2\"],\n\t *     [\"data3\"]\n\t *   ]\n\t * }\n\t */\n\tdata_groups: <string[][]>[],\n\n\t/**\n\t * Set how zero value will be treated on groups.<br>\n\t * Possible values:\n\t * - `zero`: 0 will be positioned at absolute axis zero point.\n\t * - `positive`: 0 will be positioned at the top of a stack.\n\t * - `negative`: 0 will be positioned at the bottom of a stack.\n\t * @name data․groupsZeroAs\n\t * @memberof Options\n\t * @type {string}\n\t * @default \"positive\"\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.Groups)\n\t * @example\n\t * data: {\n\t *   groupsZeroAs: \"zero\" // \"positive\" or \"negative\"\n\t * }\n\t */\n\tdata_groupsZeroAs: <\"zero\" | \"positive\" | \"negative\">\"positive\",\n\n\t/**\n\t * Set color converter function.<br><br>\n\t * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').\n\t * @name data․color\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)\n\t * @example\n\t * data: {\n\t *   color: function(color, d) { ... }\n\t * }\n\t */\n\tdata_color: <Function | undefined>undefined,\n\n\t/**\n\t * Set color for each data.\n\t * @name data․colors\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @example\n\t * data: {\n\t *   colors: {\n\t *     data1: \"#ff0000\",\n\t *     data2: function(d) {\n\t *        return \"#000\";\n\t *     }\n\t *     ...\n\t *   }\n\t * }\n\t */\n\tdata_colors: <{[key: string]: string | (() => string)}>{},\n\n\t/**\n\t * Set labels options\n\t * @name data․labels\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} data Data object\n\t * @property {boolean} [data.labels=false] Show or hide labels on each data points\n\t * @property {boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)\n\t * @property {Function} [data.labels.format] Set formatter function for data labels.<br>\n\t * The formatter function receives 4 arguments such as `v, id, i, texts` and it **must return a string** (`\\n` character will be used as line break) that will be shown as the label.<br><br>\n\t * The arguments are:<br>\n\t *  - `v` is the value of the data point where the label is shown.\n\t *  - `id` is the id of the data where the label is shown.\n\t *  - `i` is the index of the data series point where the label is shown.\n\t *  - `texts` is the array of whole corresponding data series' text labels.<br><br>\n\t * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))\n\t * @property {string|object|Function} [data.labels.backgroundColors] Set label text background colors.<br><br>\n\t * - **NOTE**: When function is set, background colors can be specified one color per dataset.\n\t *   - Within the function, the last returned color for dataset will be used.\n\t *   - Only can control set or unset background color for each values.\n\t * @property {string|object|Function} [data.labels.colors] Set label text colors.\n\t * @property {object|Function} [data.labels.position] Set each dataset position, relative the original.<br><br>\n\t * When function is specified, will receives 5 arguments such as `type, v, id, i, texts` and it must return a position number.<br><br>\n\t * The arguments are:<br>\n\t *  - `type` coordinate type string, which will be 'x' or 'y'.\n\t *  - `v` is the value of the data point where the label is shown.\n\t *  - `id` is the id of the data where the label is shown.\n\t *  - `i` is the index of the data series point where the label is shown.\n\t *  - `texts` is the array of whole corresponding data series' text labels.<br><br>\n\t * @property {number} [data.labels.position.x=0] x coordinate position, relative the original.\n\t * @property {number} [data.labels.position.y=0] y coordinate position, relative the original.\n\t * @property {object} [data.labels.rotate] Rotate label text. Specify degree value in a range of `0 ~ 360`.\n\t * - **NOTE:** Depend on rotate value, text position need to be adjusted manually(using `data.labels.position` option) to be shown nicely.\n\t * @property {boolean|object} [data.labels.border=false] Add border to data label text. NOTE: When set as `true`, styling aren't applied. Hence, need to set using `.bb-text-border` class.\n\t * @property {number|string|object} [data.labels.border.padding=\"3 5\"] Border padding. Can be a single number, string or object with top, bottom, left, right properties.\n\t * @property {number} [data.labels.border.radius=10] Border radius value.\n\t * @property {number} [data.labels.border.strokeWidth=1] Border stroke width.\n\t * @property {string} [data.labels.border.stroke=\"#000\"] Border stroke color.\n\t * @property {string} [data.labels.border.fill=\"none\"] Border fill color.\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)\n\t * @see [Demo: label border](https://naver.github.io/billboard.js/demo/#Data.DataLabelBorder)\n\t * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)\n\t * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)\n\t * @see [Demo: label multiline](https://naver.github.io/billboard.js/demo/#Data.DataLabelMultiline)\n\t * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)\n\t * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)\n\t * @see [Demo: label rotate](https://naver.github.io/billboard.js/demo/#Data.DataLabelRotate)\n\t * @example\n\t * data: {\n\t *   labels: true,\n\t *\n\t *   // or set specific options\n\t *   labels: {\n\t *     format: function(v, id, i, texts) {\n\t *         ...\n\t *         // to multiline, return with '\\n' character\n\t *         return \"Line1\\nLine2\";\n\t *     },\n\t *\n\t *     // it's possible to set for each data\n\t *     format: {\n\t *         data1: function(v, id, i, texts) { ... },\n\t *         ...\n\t *     },\n\t *\n\t *     // align text to center of the 'bar' shape (works only for 'bar' type)\n\t *     centered: true,\n\t *\n\t *     // apply backgound color for label texts\n\t *     backgroundColors: \"red\",\n\t *\n\t *     // set differenct backround colors per dataset\n\t *     backgroundColors: {\n\t *          data1: \"green\",\n\t *          data2: \"yellow\"\n\t *     },\n\t *\n\t *     // call back for label text background color\n\t *     backgroundColors: function(color, d) {\n\t *         // color: the default data label color string\n\t *         // data: ex) {x: 0, value: 200, id: \"data3\", index: 0}\n\t *         ....\n\t *         return d.value > 200 ? \"cyan\" : \"red\";\n\t *     },\n\t *\n\t *     // apply for all label texts\n\t *     colors: \"red\",\n\t *\n\t *     // set different colors per dataset\n\t *     // for not specified dataset, will have the default color value\n\t *     colors: {\n\t *        data1: \"yellow\",\n\t *        data3: \"green\"\n\t *     },\n\t *\n\t *     // call back for label text color\n\t *     colors: function(color, d) {\n\t *         // color: the default data label color string\n\t *         // data: ex) {x: 0, value: 200, id: \"data3\", index: 0}\n\t *         ....\n\t *         return d.value > 200 ? \"cyan\" : color;\n\t *     },\n\t *\n\t *     // return x, y coordinate position\n\t *     // apt to handle each text position manually\n\t *     position: function(type, v, id, i, texts) {\n\t *         ...\n\t *         return type == \"x\" ? 10 : 20;\n\t *     },\n\t *\n\t *     // set x, y coordinate position\n\t *     position: {\n\t *        x: -10,\n\t *        y: 10\n\t *     },\n\t *\n\t *     // or set x, y coordinate position by each dataset\n\t *     position: {\n\t *        data1: {x: 5, y: 5},\n\t *        data2: {x: 10, y: -20}\n\t *     },\n\t *\n\t * \t   // rotate degree for label text\n\t *     rotate: 90,\n\t *\n\t *     // add border to data label text\n\t *     // NOTE: When set as `true`, styling aren't applied. Hence, need to set using '.bb-text-border' class.\n\t *     // ex. \".bb-text-border { fill: red; stroke: #000; stroke-width: 2px; rx: 10px; ry: 10px; }\"\n\t *     border: true,\n\t *\n\t *     // or set detailed border options\n\t *     border: {\n\t *        padding: 10,  // set all padding to 10\n\t *        padding: \"5 10\",  // set top and bottom padding to 5, left and right padding to 10\n\t *        padding: {  // specify each padding\n\t *           top: 3,\n\t *           bottom: 5,\n\t *           left: 10,\n\t *           right: 13\n\t *        },\n\t *        radius: 10,\n\t *        strokeWidth: 2,\n\t *        stroke: \"#000\",\n\t *        fill: \"red\"\n\t *     },\n\t *\n\t *     // set image URL to be displayed next to the label text\n\t *     imgUrl: \"./sample.svg\",\n\t *\n\t *     // or use function to return image URL dynamically\n\t *     imgUrl: function(v, id, i) {\n\t *        // v is the value of the data point where the label is shown.\n\t *        // id is the id of the data where the label is shown.\n\t *        // i is the index of the data series point where the label is shown.\n\t *        return \"./sample.svg\";\n\t *     }\n\t *   }\n\t * }\n\t */\n\tdata_labels: <boolean | {\n\t\tcentered?: boolean,\n\t\tformat?: (v: number, id: string, i: number, texts: d3Selection) => number,\n\t\tcolors?: string | {[key: string]: string},\n\t\tposition?: (type: \"x\" | \"y\", v: number, id: string, i: number, texts: d3Selection) =>\n\t\t\t| number\n\t\t\t| {[key: string]: number}\n\t\t\t| {[key: string]: {x?: number, y?: number}},\n\t\trotate?: number,\n\t\tborder?: boolean | {\n\t\t\tpadding?: number | string | {\n\t\t\t\ttop?: number,\n\t\t\t\tbottom?: number,\n\t\t\t\tleft?: number,\n\t\t\t\tright?: number\n\t\t\t},\n\t\t\tradius?: number,\n\t\t\tstrokeWidth?: number,\n\t\t\tstroke?: string,\n\t\t\tfill?: string\n\t\t},\n\t\timgUrl?: string | ((v: number, id: string, i: number) => string | null)\n\t}>{},\n\tdata_labels_backgroundColors: <string | {[key: string]: string} | undefined>undefined,\n\tdata_labels_colors: <string | object | Function | undefined>undefined,\n\tdata_labels_position: {},\n\tdata_labels_imgUrl: <string | Function | undefined>undefined,\n\n\t/**\n\t * Hide each data when the chart appears.<br><br>\n\t * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.\n\t * @name data․hide\n\t * @memberof Options\n\t * @type {boolean|Array}\n\t * @default false\n\t * @example\n\t * data: {\n\t *   // all of data will be hidden\n\t *   hide: true\n\t *\n\t *   // specified data will be hidden\n\t *   hide: [\"data1\", ...]\n\t * }\n\t */\n\tdata_hide: <string[] | boolean>false,\n\n\t/**\n\t * Filter values to be shown\n\t * The data value is the same as the returned by `.data()`.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n\t * @name data․filter\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * data: {\n\t *   // filter for id value\n\t *   filter: function(v) {\n\t *      // v: [{id: \"data1\", id_org: \"data1\", values: [\n\t *      //      {x: 0, value: 130, id: \"data2\", index: 0}, ...]\n\t *      //    }, ...]\n\t *      return v.id !== \"data1\";\n\t *   }\n\t */\n\tdata_filter: <(() => boolean) | undefined>undefined,\n\n\t/**\n\t * Set a callback for click event on each data point.<br><br>\n\t * This callback will be called when each data point clicked and will receive `d` and element as the arguments.\n\t * - `d` is the data clicked and element is the element clicked.\n\t * - `element` is the current interacting svg element.\n\t * - In this callback, `this` will be the Chart object.\n\t * @name data․onclick\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function() {}\n\t * @example\n\t * data: {\n\t *     onclick: function(d, element) {\n\t *        // d - ex) {x: 4, value: 150, id: \"data1\", index: 4, name: \"data1\"}\n\t *        // element - <circle>\n\t *        ...\n\t *     }\n\t * }\n\t */\n\tdata_onclick: () => {},\n\n\t/**\n\t * Set a callback for mouse/touch over event on each data point.<br><br>\n\t * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.\n\t * - `d` is the data where mouse cursor moves onto.\n\t * - `element` is the current interacting svg element.\n\t * - In this callback, `this` will be the Chart object.\n\t * @name data․onover\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function() {}\n\t * @example\n\t * data: {\n\t *     onover: function(d, element) {\n\t *        // d - ex) {x: 4, value: 150, id: \"data1\", index: 4}\n\t *        // element - <circle>\n\t *        ...\n\t *     }\n\t * }\n\t */\n\tdata_onover: () => {},\n\n\t/**\n\t * Set a callback for mouse/touch out event on each data point.<br><br>\n\t * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.\n\t * - `d` is the data where mouse cursor moves out.\n\t * - `element` is the current interacting svg element.\n\t * - In this callback, `this` will be the Chart object.\n\t * @name data․onout\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function() {}\n\t * @example\n\t * data: {\n\t *     onout: function(d, element) {\n\t *        // d - ex) {x: 4, value: 150, id: \"data1\", index: 4}\n\t *        // element - <circle>\n\t *        ...\n\t *     }\n\t * }\n\t */\n\tdata_onout: () => {},\n\n\t/**\n\t * Set a callback for when data is shown.<br>\n\t * The callback will receive shown data ids in array.\n\t * @name data․onshown\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t *  data: {\n\t *    onshown: function(ids) {\n\t *      // ids - [\"data1\", \"data2\", ...]\n\t *      ...\n\t *    }\n\t *  }\n\t */\n\tdata_onshown: <Function | undefined>undefined,\n\n\t/**\n\t * Set a callback for when data is hidden.<br>\n\t * The callback will receive hidden data ids in array.\n\t * @name data․onhidden\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t *  data: {\n\t *    onhidden: function(ids) {\n\t *      // ids - [\"data1\", \"data2\", ...]\n\t *      ...\n\t *    }\n\t *  }\n\t */\n\tdata_onhidden: <Function | undefined>undefined,\n\n\t/**\n\t * Set a callback for minimum data\n\t * - **NOTE:** For 'area-line-range', 'area-step-range' and 'area-spline-range', `mid` data will be taken for the comparison\n\t * @name data․onmin\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)\n\t * @example\n\t *  onmin: function(data) {\n\t *    // data - ex) [{x: 3, value: 400, id: \"data1\", index: 3}, ... ]\n\t *    ...\n\t *  }\n\t */\n\tdata_onmin: <Function | undefined>undefined,\n\n\t/**\n\t * Set a callback for maximum data\n\t * - **NOTE:** For 'area-line-range', 'area-step-range' and 'area-spline-range', `mid` data will be taken for the comparison\n\t * @name data․onmax\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)\n\t * @example\n\t *  onmax: function(data) {\n\t *    // data - ex) [{x: 3, value: 400, id: \"data1\", index: 3}, ... ]\n\t *    ...\n\t *  }\n\t */\n\tdata_onmax: <Function | undefined>undefined,\n\n\t/**\n\t * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the \"file://\" protocol as the most browsers will block XMLHTTPRequests.\n\t * @name data․url\n\t * @memberof Options\n\t * @type {string}\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)\n\t * @example\n\t * data: {\n\t *     url: \"/data/test.csv\"\n\t * }\n\t */\n\tdata_url: <string | undefined>undefined,\n\n\t/**\n\t * XHR header value\n\t * - **NOTE:** Should be used with `data.url` option\n\t * @name data․headers\n\t * @memberof Options\n\t * @type {string}\n\t * @default undefined\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n\t * @example\n\t * data: {\n\t *     url: \"/data/test.csv\",\n\t *     headers: {\n\t *        \"Content-Type\": \"text/xml\",\n\t *        ...\n\t *     }\n\t * }\n\t */\n\tdata_headers: <object | undefined>undefined,\n\n\t/**\n\t * Parse a JSON object for data. See also data.keys.\n\t * @name data․json\n\t * @memberof Options\n\t * @type {Array}\n\t * @default undefined\n\t * @see [data․keys](#.data%25E2%2580%25A4keys)\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)\n\t * @example\n\t * data: {\n\t *     json: [\n\t *       {name: \"www.site1.com\", upload: 200, download: 200, total: 400},\n\t *       {name: \"www.site2.com\", upload: 100, download: 300, total: 400},\n\t *       {name: \"www.site3.com\", upload: 300, download: 200, total: 500},\n\t *       {name: \"www.site4.com\", upload: 400, download: 100, total: 500}\n\t *     ],\n\t *     keys: {\n\t *       // case 1: specify 'x' key for category axis\n\t *       x: \"name\", // 'name' key will be used as category x axis values\n\t *       value: [\"upload\", \"download\"]\n\t *\n\t *       // case 2: without 'x' key for non-category axis\n\t *       value: [\"upload\", \"download\"]\n\t *     }\n\t * }\n\t */\n\tdata_json: <object[] | undefined>undefined,\n\n\t/**\n\t * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.\n\t * @name data․rows\n\t * @memberof Options\n\t * @type {Array}\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)\n\t * @example\n\t * data: {\n\t *   rows: [\n\t *     [\"A\", \"B\", \"C\"],\n\t *     [90, 120, 300],\n\t *     [40, 160, 240],\n\t *     [50, 200, 290],\n\t *     [120, 160, 230],\n\t *     [80, 130, 300],\n\t *     [90, 220, 320]\n\t *   ]\n\t * }\n\t *\n\t * // for 'bar' type, data can contain:\n\t * // - an array of [start, end] data following the order\n\t * data: {\n\t *   rows: [\n\t *      [\"data1\", \"data2\"],\n\t *      [[100, 150], 120],\n\t *      [[200, 300], 55],\n\t *      [[-400, 500], 60]\n\t *   ],\n\t *   type: \"bar\"\n\t * }\n\t *\n\t * // for 'range' types('area-line-range' or 'area-step-range' or 'area-spline-range'), data should contain:\n\t * // - an array of [high, mid, low] data following the order\n\t * // - or an object with 'high', 'mid' and 'low' key value\n\t * data: {\n\t *   rows: [\n\t *      [\"data1\", \"data2\"],\n\t *      [\n\t *        // or {high:150, mid: 140, low: 110}, 120\n\t *        [150, 140, 110], 120\n\t *      ],\n\t *      [[155, 130, 115], 55],\n\t *      [[160, 135, 120], 60]\n\t *   ],\n\t *   types: {\n\t *       data1: \"area-line-range\",\n\t *       data2: \"line\"\n\t *   }\n\t * }\n\t *\n\t * // for 'bubble' type, data can contain dimension value:\n\t * // - an array of [y, z] data following the order\n\t * // - or an object with 'y' and 'z' key value\n\t * // 'y' is for y axis coordination and 'z' is the bubble radius value\n\t * data: {\n\t *   rows: [\n\t *      [\"data1\", \"data2\"],\n\t *      [\n\t *        // or {y:10, z: 140}, 120\n\t *        [10, 140], 120\n\t *      ],\n\t *      [[100, 30], 55],\n\t *      [[50, 100], 60]\n\t *   ],\n\t *   types: {\n\t *       data1: \"bubble\",\n\t *       data2: \"line\"\n\t *   }\n\t * }\n\t *\n\t * // for 'canlestick' type, data should contain:\n\t * // - an array of [open, high, low, close, volume(optional)] data following the order\n\t * // - or an object with 'open', 'high', 'low', 'close' and 'value'(optional) key value\n\t * data: {\n\t *   rows: [\n\t *      [\"data1\", \"data2\"],\n\t * \t\t[\n\t * \t\t\t// open, high, low, close, volume (optional)\n\t * \t\t\t{open: 1300, high: 1369, low: 1200, close: 1339, volume: 100},\n\t * \t\t\t[1000, 1100, 850, 870]\n\t * \t\t],\n\t * \t\t[\n\t * \t\t\t{open: 1348, high: 1371, low: 1271, close: 1320},\n\t * \t\t\t[870, 1250, 830, 1200, 50]\n\t * \t\t]\n\t *   ],\n\t *   type: \"candlestick\"\n\t * }\n\t */\n\tdata_rows: <(string | number)[][] | undefined>undefined,\n\n\t/**\n\t * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.\n\t * @name data․columns\n\t * @memberof Options\n\t * @type {Array}\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)\n\t * @example\n\t * data: {\n\t *   columns: [\n\t *      [\"data1\", 30, 20, 50, 40, 60, 50],\n\t *      [\"data2\", 200, 130, 90, 240, 130, 220],\n\t *      [\"data3\", 300, 200, 160, 400, 250, 250]\n\t *   ]\n\t * }\n\t *\n\t * // for 'bar' type, data can contain:\n\t * // - an array of [start, end] data following the order\n\t * data: {\n\t *   columns: [\n\t *     [\"data1\", -100, 50, [100, 200], [200, 300]],\n\t *     [\"data2\", -200, 300, [-100, 100], [-50, -30]],\n\t *   ],\n\t *   type: \"bar\"\n\t * }\n\t *\n\t * // for 'range' types('area-line-range' or 'area-step-range' or 'area-spline-range'), data should contain:\n\t * // - an array of [high, mid, low] data following the order\n\t * // - or an object with 'high', 'mid' and 'low' key value\n\t * data: {\n\t *   columns: [\n\t *      [\"data1\",\n\t *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}\n\t *          [150, 140, 110],\n\t *          [150, 140, 110]\n\t *      ]\n\t *   ],\n\t *   type: \"area-line-range\"\n\t * }\n\t *\n\t * // for 'bubble' type, data can contain dimension value:\n\t * // - an array of [y, z] data following the order\n\t * // - or an object with 'y' and 'z' key value\n\t * // 'y' is for y axis coordination and 'z' is the bubble radius value\n\t * data: {\n\t *   columns: [\n\t *      [\"data1\",\n\t *          [10, 140],  // or {y:10, z: 140}\n\t *          [100, 30],\n\t *          [50, 100]\n\t *      ]\n\t *   ],\n\t *   type: \"bubble\"\n\t * }\n\t *\n\t * // for 'canlestick' type, data should contain:\n\t * // - an array of [open, high, low, close, volume(optional)] data following the order\n\t * // - or an object with 'open', 'high', 'low', 'close' and 'value'(optional) key value\n\t * data: {\n\t *   columns: [\n\t *      [\"data1\",\n\t *          [1000, 1100, 850, 870, 100],  // or {open:1000, high: 1100, low: 870, volume: 100}\n\t *          [870, 1250, 830, 1200]  // 'volume' can be omitted\n\t *      ]\n\t *   ],\n\t *   type: \"candlestick\"\n\t * }\n\t */\n\tdata_columns: <(string | number)[][] | undefined>undefined,\n\n\t/**\n\t * Used if loading JSON via data.url.\n\t * - **Available Values:**\n\t *   - json\n\t *   - csv\n\t *   - tsv\n\t * @name data․mimeType\n\t * @memberof Options\n\t * @type {string}\n\t * @default csv\n\t * @example\n\t * data: {\n\t *     mimeType: \"json\"\n\t * }\n\t */\n\tdata_mimeType: <\"csv\" | \"json\" | \"tsv\">\"csv\",\n\n\t/**\n\t * Choose which JSON object keys correspond to desired data.\n\t * - **NOTE:** Only for JSON object given as array.\n\t * @name data․keys\n\t * @memberof Options\n\t * @type {string}\n\t * @default undefined\n\t * @example\n\t * data: {\n\t *     json: [\n\t *       {name: \"www.site1.com\", upload: 200, download: 200, total: 400},\n\t *       {name: \"www.site2.com\", upload: 100, download: 300, total: 400},\n\t *       {name: \"www.site3.com\", upload: 300, download: 200, total: 500},\n\t *       {name: \"www.site4.com\", upload: 400, download: 100, total: 500}\n\t *     ],\n\t *     keys: {\n\t *       // case 1: specify 'x' key for category axis\n\t *       x: \"name\", // 'name' key will be used as category x axis values\n\t *       value: [\"upload\", \"download\"]\n\t *\n\t *       // case 2: without 'x' key for non-category axis\n\t *       value: [\"upload\", \"download\"]\n\t *     }\n\t * }\n\t */\n\tdata_keys: <{x?: string, value?: string[]} | undefined>undefined,\n\n\t/**\n\t * Set text label to be displayed when there's no data to show.\n\t * - ex. Toggling all visible data to not be shown, unloading all current data, etc.\n\t * @name data․empty․label․text\n\t * @memberof Options\n\t * @type {string}\n\t * @default \"\"\n\t * @example\n\t * data: {\n\t *   empty: {\n\t *     label: {\n\t *       text: \"No Data\"\n\t *     }\n\t *   }\n\t * }\n\t */\n\tdata_empty_label_text: \"\"\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * interaction config options\n */\nexport default {\n\t/**\n\t * Interaction options\n\t * @name interaction\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} interaction Intersection object\n\t * @property {boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>\n\t *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.\n\t * @property {boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)\n\t * @property {boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction\n\t * @property {boolean} [interaction.inputType.touch=true] enable or disable  touch interaction\n\t * @property {boolean|number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.\n\t * @property {boolean} [interaction.onout=true] Enable or disable \"onout\" event.<br>\n\t * \t\tWhen is disabled, defocus(hiding tooltip, focused gridline, etc.) event won't work.\n\t * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)\n\t * @example\n\t * interaction: {\n\t *    enabled: false,\n\t *    brighten: false,\n\t *    inputType: {\n\t *        mouse: true,\n\t *        touch: false\n\t *\n\t *        // or declare preventDefault explicitly.\n\t *        // In this case touch inputType is enabled by default\n\t *        touch: {\n\t *            preventDefault: true\n\t *\n\t *            // or threshold pixel value (pixel moved from touchstart to touchmove)\n\t *            preventDefault: 5\n\t *        }\n\t *    },\n\t *\n\t *    // disable \"onout\" event\n\t *    onout: false\n\t * }\n\t */\n\tinteraction_enabled: true,\n\tinteraction_brighten: true,\n\tinteraction_inputType_mouse: true,\n\tinteraction_inputType_touch: <boolean | {preventDefault?: boolean | number}>{},\n\tinteraction_onout: true\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * Window object\n * @private\n */\n/* eslint-disable no-new-func, no-undef */\n/**\n * Get global object\n * @returns {object} window object\n * @private\n */\nfunction getGlobal() {\n\treturn (typeof globalThis === \"object\" && globalThis !== null && globalThis.Object === Object &&\n\t\tglobalThis) ||\n\t\t(typeof global === \"object\" && global !== null && global.Object === Object && global) ||\n\t\t(typeof self === \"object\" && self !== null && self.Object === Object && self) ||\n\t\tFunction(\"return this\")();\n}\n\n/**\n * Get fallback object\n * @param {object} w global object\n * @returns {Array} fallback object array\n * @private\n */\nexport function getFallback(w?) {\n\tconst hasRAF = typeof w?.requestAnimationFrame === \"function\" &&\n\t\ttypeof w?.cancelAnimationFrame === \"function\";\n\tconst hasRIC = typeof w?.requestIdleCallback === \"function\" &&\n\t\ttypeof w?.cancelIdleCallback === \"function\";\n\tconst request = cb => setTimeout(cb, 1);\n\tconst cancel = id => clearTimeout(id);\n\n\treturn [\n\t\thasRAF ? w.requestAnimationFrame : request,\n\t\thasRAF ? w.cancelAnimationFrame : cancel,\n\t\thasRIC ? w.requestIdleCallback : request,\n\t\thasRIC ? w.cancelIdleCallback : cancel\n\t];\n}\n\nconst win = getGlobal();\nconst doc = win?.document;\n\nconst [\n\trequestAnimationFrame,\n\tcancelAnimationFrame,\n\trequestIdleCallback,\n\tcancelIdleCallback\n] = getFallback(win);\n\nexport {\n\tcancelAnimationFrame,\n\tcancelIdleCallback,\n\tdoc as document,\n\trequestAnimationFrame,\n\trequestIdleCallback,\n\twin as window\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n * @ignore\n */\nimport {brushSelection as d3BrushSelection} from \"d3-brush\";\nimport {pointer as d3Pointer} from \"d3-selection\";\nimport type {d3Selection} from \"../../types/types\";\nimport {document, requestAnimationFrame, window} from \"./browser\";\n\nexport {\n\taddCssRules,\n\tasHalfPixel,\n\tbrushEmpty,\n\tcallFn,\n\tcamelize,\n\tcapitalize,\n\tceil10,\n\tconvertInputType,\n\tdeepClone,\n\tdiffDomain,\n\temulateEvent,\n\tendall,\n\textend,\n\tfindIndex,\n\tgetBBox,\n\tgetBoundingRect,\n\tgetBrushSelection,\n\tgetCssRules,\n\tgetMinMax,\n\tgetOption,\n\tgetPathBox,\n\tgetPointer,\n\tgetRandom,\n\tgetRange,\n\tgetRectSegList,\n\tgetScrollPosition,\n\tgetTransformCTM,\n\tgetTranslation,\n\tgetUnique,\n\thasStyle,\n\thasValue,\n\thasViewBox,\n\tisArray,\n\tisBoolean,\n\tisDefined,\n\tisEmpty,\n\tisFunction,\n\tisNumber,\n\tisObject,\n\tisObjectType,\n\tisString,\n\tisTabVisible,\n\tisUndefined,\n\tisValue,\n\tmergeArray,\n\tmergeObj,\n\tnotEmpty,\n\tparseDate,\n\tparseShorthand,\n\trunUntil,\n\tsanitize,\n\tsetTextValue,\n\tsortValue,\n\ttoArray,\n\ttplProcess\n};\n\nconst isValue = (v: any): boolean => v || v === 0;\nconst isFunction = (v: unknown): v is (...args: any[]) => any => typeof v === \"function\";\nconst isString = (v: unknown): v is string => typeof v === \"string\";\nconst isNumber = (v: unknown): v is number => typeof v === \"number\";\nconst isUndefined = (v: unknown): v is undefined => typeof v === \"undefined\";\nconst isDefined = (v: unknown): boolean => typeof v !== \"undefined\";\nconst isBoolean = (v: unknown): boolean => typeof v === \"boolean\";\nconst ceil10 = (v: number): number => Math.ceil(v / 10) * 10;\nconst asHalfPixel = (n: number): number => Math.ceil(n) + 0.5;\nconst diffDomain = (d: number[]): number => d[1] - d[0];\nconst isObjectType = (v: unknown): v is Record<string | number, any> => typeof v === \"object\";\nconst isEmpty = (o: unknown): boolean => (\n\tisUndefined(o) || o === null ||\n\t(isString(o) && o.length === 0) ||\n\t(isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0) ||\n\t(isNumber(o) && isNaN(o))\n);\nconst notEmpty = (o: unknown): boolean => !isEmpty(o);\n\n/**\n * Check if is array\n * @param {Array} arr Data to be checked\n * @returns {boolean}\n * @private\n */\nconst isArray = (arr: any): arr is any[] => Array.isArray(arr);\n\n/**\n * Check if is object\n * @param {object} obj Data to be checked\n * @returns {boolean}\n * @private\n */\nconst isObject = (obj: any): boolean => obj && !obj?.nodeType && isObjectType(obj) && !isArray(obj);\n\n/**\n * Get specified key value from object\n * If default value is given, will return if given key value not found\n * @param {object} options Source object\n * @param {string} key Key value\n * @param {*} defaultValue Default value\n * @returns {*}\n * @private\n */\nfunction getOption(options: object, key: string, defaultValue): any {\n\treturn isDefined(options[key]) ? options[key] : defaultValue;\n}\n\n/**\n * Check if value exist in the given object\n * @param {object} dict Target object to be checked\n * @param {*} value Value to be checked\n * @returns {boolean}\n * @private\n */\nfunction hasValue(dict: object, value: any): boolean {\n\tlet found = false;\n\n\tObject.keys(dict).forEach(key => (dict[key] === value) && (found = true));\n\n\treturn found;\n}\n\n/**\n * Call function with arguments\n * @param {Function} fn Function to be called\n * @param {*} thisArg \"this\" value for fn\n * @param {*} args Arguments for fn\n * @returns {boolean} true: fn is function, false: fn is not function\n * @private\n */\nfunction callFn(fn: unknown, thisArg: any, ...args: any[]): boolean {\n\tconst isFn = isFunction(fn);\n\n\tisFn && fn.call(thisArg, ...args);\n\treturn isFn;\n}\n\n/**\n * Call function after all transitions ends\n * @param {d3.transition} transition Transition\n * @param {Fucntion} cb Callback function\n * @private\n */\nfunction endall(transition, cb: Function): void {\n\tlet n = 0;\n\n\tconst end = function(...args) {\n\t\t!--n && cb.apply(this, ...args);\n\t};\n\n\t// if is transition selection\n\tif (\"duration\" in transition) {\n\t\ttransition\n\t\t\t.each(() => ++n)\n\t\t\t.on(\"end\", end);\n\t} else {\n\t\t++n;\n\t\ttransition.call(end);\n\t}\n}\n\n/**\n * Replace tag sign to html entity\n * @param {string} str Target string value\n * @returns {string}\n * @private\n */\nfunction sanitize(str: string): string {\n\treturn isString(str) ?\n\t\tstr.replace(/<(script|img)?/ig, \"&lt;\").replace(/(script)?>/ig, \"&gt;\") :\n\t\tstr;\n}\n\n/**\n * Set text value. If there's multiline add nodes.\n * @param {d3Selection} node Text node\n * @param {string} text Text value string\n * @param {Array} dy dy value for multilined text\n * @param {boolean} toMiddle To be alingned vertically middle\n * @private\n */\nfunction setTextValue(\n\tnode: d3Selection,\n\ttext: string,\n\tdy: number[] = [-1, 1],\n\ttoMiddle: boolean = false\n) {\n\tif (!node || !isString(text)) {\n\t\treturn;\n\t}\n\n\tif (text.indexOf(\"\\n\") === -1) {\n\t\tnode.text(text);\n\t} else {\n\t\tconst diff = [node.text(), text].map(v => v.replace(/[\\s\\n]/g, \"\"));\n\n\t\tif (diff[0] !== diff[1]) {\n\t\t\tconst multiline = text.split(\"\\n\");\n\t\t\tconst len = toMiddle ? multiline.length - 1 : 1;\n\n\t\t\t// reset possible text\n\t\t\tnode.html(\"\");\n\n\t\t\tmultiline.forEach((v, i) => {\n\t\t\t\tnode.append(\"tspan\")\n\t\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t\t.attr(\"dy\", `${i === 0 ? dy[0] * len : dy[1]}em`)\n\t\t\t\t\t.text(v);\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * Substitution of SVGPathSeg API polyfill\n * @param {SVGGraphicsElement} path Target svg element\n * @returns {Array}\n * @private\n */\nfunction getRectSegList(path: SVGGraphicsElement): {x: number, y: number}[] {\n\t/*\n\t * seg1 ---------- seg2\n\t *   |               |\n\t *   |               |\n\t *   |               |\n\t * seg0 ---------- seg3\n\t */\n\tconst {x, y, width, height} = path.getBBox();\n\n\treturn [\n\t\t{x, y: y + height}, // seg0\n\t\t{x, y}, // seg1\n\t\t{x: x + width, y}, // seg2\n\t\t{x: x + width, y: y + height} // seg3\n\t];\n}\n\n/**\n * Get svg bounding path box dimension\n * @param {SVGGraphicsElement} path Target svg element\n * @returns {object}\n * @private\n */\nfunction getPathBox(\n\tpath: SVGGraphicsElement\n): {x: number, y: number, width: number, height: number} {\n\tconst {width, height} = getBoundingRect(path);\n\tconst items = getRectSegList(path);\n\tconst x = items[0].x;\n\tconst y = Math.min(items[0].y, items[1].y);\n\n\treturn {\n\t\tx,\n\t\ty,\n\t\twidth,\n\t\theight\n\t};\n}\n\n/**\n * Get event's current position coordinates\n * @param {object} event Event object\n * @param {SVGElement|HTMLElement} element Target element\n * @returns {Array} [x, y] Coordinates x, y array\n * @private\n */\nfunction getPointer(event, element?: SVGElement): number[] {\n\tconst touches = event &&\n\t\t(event.touches || (event.sourceEvent && event.sourceEvent.touches))?.[0];\n\tlet pointer = [0, 0];\n\n\ttry {\n\t\tpointer = d3Pointer(touches || event, element);\n\t} catch {}\n\n\treturn pointer.map(v => (isNaN(v) ? 0 : v));\n}\n\n/**\n * Return brush selection array\n * @param {object} ctx Current instance\n * @returns {d3.brushSelection}\n * @private\n */\nfunction getBrushSelection(ctx) {\n\tconst {event, $el} = ctx;\n\tconst main = $el.subchart.main || $el.main;\n\tlet selection;\n\n\t// check from event\n\tif (event && event.type === \"brush\") {\n\t\tselection = event.selection;\n\t\t// check from brush area selection\n\t} else if (main && (selection = main.select(\".bb-brush\").node())) {\n\t\tselection = d3BrushSelection(selection);\n\t}\n\n\treturn selection;\n}\n\n/**\n * Get boundingClientRect.\n * Cache the evaluated value once it was called.\n * @param {boolean} relativeViewport Relative to viewport - true: will use .getBoundingClientRect(), false: will use .getBBox()\n * @param {SVGElement} node Target element\n * @param {boolean} forceEval Force evaluation\n * @returns {object}\n * @private\n */\nfunction getRect(\n\trelativeViewport: boolean,\n\tnode: SVGElement & Partial<{rect: DOMRect | SVGRect}>,\n\tforceEval = false\n): DOMRect | SVGRect {\n\tconst _ = n => n[relativeViewport ? \"getBoundingClientRect\" : \"getBBox\"]();\n\n\tif (forceEval) {\n\t\treturn _(node);\n\t} else {\n\t\t// will cache the value if the element is not a SVGElement or the width is not set\n\t\tconst needEvaluate = !(\"rect\" in node) || (\n\t\t\t\"rect\" in node && node.hasAttribute(\"width\") &&\n\t\t\tnode.rect!.width !== +(node.getAttribute(\"width\") || 0)\n\t\t);\n\n\t\treturn needEvaluate ? (node.rect = _(node)) : node.rect!;\n\t}\n}\n\n/**\n * Get boundingClientRect.\n * @param {SVGElement} node Target element\n * @param {boolean} forceEval Force evaluation\n * @returns {object}\n * @private\n */\nfunction getBoundingRect(node, forceEval = false) {\n\treturn getRect(true, node, forceEval);\n}\n\n/**\n * Get BBox.\n * @param {SVGElement} node Target element\n * @param {boolean} forceEval Force evaluation\n * @returns {object}\n * @private\n */\nfunction getBBox(node, forceEval = false) {\n\treturn getRect(false, node, forceEval);\n}\n\n/**\n * Retrun random number\n * @param {boolean} asStr Convert returned value as string\n * @param {number} min Minimum value\n * @param {number} max Maximum value\n * @returns {number|string}\n * @private\n */\nfunction getRandom(asStr = true, min = 0, max = 10000) {\n\tconst crpt = window.crypto || window.msCrypto;\n\tconst rand = crpt ?\n\t\tmin + crpt.getRandomValues(new Uint32Array(1))[0] % (max - min + 1) :\n\t\tMath.floor(Math.random() * (max - min) + min);\n\n\treturn asStr ? String(rand) : rand;\n}\n\n/**\n * Find index based on binary search\n * @param {Array} arr Data array\n * @param {number} v Target number to find\n * @param {number} start Start index of data array\n * @param {number} end End index of data arr\n * @param {boolean} isRotated Weather is roted axis\n * @returns {number} Index number\n * @private\n */\nfunction findIndex(arr, v: number, start: number, end: number, isRotated: boolean): number {\n\tif (start > end) {\n\t\treturn -1;\n\t}\n\n\tconst mid = Math.floor((start + end) / 2);\n\tlet {x, w = 0} = arr[mid];\n\n\tif (isRotated) {\n\t\tx = arr[mid].y;\n\t\tw = arr[mid].h;\n\t}\n\n\tif (v >= x && v <= x + w) {\n\t\treturn mid;\n\t}\n\n\treturn v < x ?\n\t\tfindIndex(arr, v, start, mid - 1, isRotated) :\n\t\tfindIndex(arr, v, mid + 1, end, isRotated);\n}\n\n/**\n * Check if brush is empty\n * @param {object} ctx Bursh context\n * @returns {boolean}\n * @private\n */\nfunction brushEmpty(ctx): boolean {\n\tconst selection = getBrushSelection(ctx);\n\n\tif (selection) {\n\t\t// brush selected area\n\t\t// two-dimensional: [[x0, y0], [x1, y1]]\n\t\t// one-dimensional: [x0, x1] or [y0, y1]\n\t\treturn selection[0] === selection[1];\n\t}\n\n\treturn true;\n}\n\n/**\n * Deep copy object\n * @param {object} objectN Source object\n * @returns {object} Cloned object\n * @private\n */\nfunction deepClone(...objectN) {\n\tconst clone = v => {\n\t\tif (isObject(v) && v.constructor) {\n\t\t\tconst r = new v.constructor();\n\n\t\t\tfor (const k in v) {\n\t\t\t\tr[k] = clone(v[k]);\n\t\t\t}\n\n\t\t\treturn r;\n\t\t}\n\n\t\treturn v;\n\t};\n\n\treturn objectN.map(v => clone(v))\n\t\t.reduce((a, c) => (\n\t\t\t{...a, ...c}\n\t\t));\n}\n\n/**\n * Extend target from source object\n * @param {object} target Target object\n * @param {object|Array} source Source object\n * @returns {object}\n * @private\n */\nfunction extend(target = {}, source): object {\n\tif (isArray(source)) {\n\t\tsource.forEach(v => extend(target, v));\n\t}\n\n\t// exclude name with only numbers\n\tfor (const p in source) {\n\t\tif (/^\\d+$/.test(p) || p in target) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttarget[p] = source[p];\n\t}\n\n\treturn target;\n}\n\n/**\n * Return first letter capitalized\n * @param {string} str Target string\n * @returns {string} capitalized string\n * @private\n */\nconst capitalize = (str: string): string => str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * Camelize from kebob style string\n * @param {string} str Target string\n * @param {string} separator Separator string\n * @returns {string} camelized string\n * @private\n */\nfunction camelize(str: string, separator = \"-\"): string {\n\treturn str.split(separator)\n\t\t.map((v, i) => (\n\t\t\ti ? v.charAt(0).toUpperCase() + v.slice(1).toLowerCase() : v.toLowerCase()\n\t\t))\n\t\t.join(\"\");\n}\n\n/**\n * Convert to array\n * @param {object} v Target to be converted\n * @returns {Array}\n * @private\n */\nconst toArray = (v: CSSStyleDeclaration | any): any => [].slice.call(v);\n\n/**\n * Add CSS rules\n * @param {object} style Style object\n * @param {string} selector Selector string\n * @param {Array} prop Prps arrary\n * @returns {number} Newely added rule index\n * @private\n */\nfunction addCssRules(style, selector: string, prop: string[]): number {\n\tconst {rootSelector = \"\", sheet} = style;\n\tconst getSelector = s =>\n\t\ts\n\t\t\t.replace(/\\s?(bb-)/g, \".$1\")\n\t\t\t.replace(/\\.+/g, \".\");\n\n\tconst rule = `${rootSelector} ${getSelector(selector)} {${prop.join(\";\")}}`;\n\n\treturn sheet[sheet.insertRule ? \"insertRule\" : \"addRule\"](\n\t\trule,\n\t\tsheet.cssRules.length\n\t);\n}\n\n/**\n * Get css rules for specified stylesheets\n * @param {Array} styleSheets The stylesheets to get the rules from\n * @returns {Array}\n * @private\n */\nfunction getCssRules(styleSheets: any[]) {\n\tlet rules = [];\n\n\tstyleSheets.forEach(sheet => {\n\t\ttry {\n\t\t\tif (sheet.cssRules && sheet.cssRules.length) {\n\t\t\t\trules = rules.concat(toArray(sheet.cssRules));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\twindow.console?.warn(`Error while reading rules from ${sheet.href}: ${e.toString()}`);\n\t\t}\n\t});\n\n\treturn rules;\n}\n\n/**\n * Get current window and container scroll position\n * @param {HTMLElement} node Target element\n * @returns {object} window scroll position\n * @private\n */\nfunction getScrollPosition(node: HTMLElement) {\n\treturn {\n\t\tx: (window.pageXOffset ?? window.scrollX ?? 0) + (node.scrollLeft ?? 0),\n\t\ty: (window.pageYOffset ?? window.scrollY ?? 0) + (node.scrollTop ?? 0)\n\t};\n}\n\n/**\n * Get translation string from screen <--> svg point\n * @param {SVGGraphicsElement} node graphics element\n * @param {number} x target x point\n * @param {number} y target y point\n * @param {boolean} inverse inverse flag\n * @returns {object}\n */\nfunction getTransformCTM(node: SVGGraphicsElement, x = 0, y = 0, inverse = true): DOMPoint {\n\tconst point = new DOMPoint(x, y);\n\tconst screen = <DOMMatrix>node.getScreenCTM();\n\tconst res = point.matrixTransform(\n\t\tinverse ? screen?.inverse() : screen\n\t);\n\n\tif (inverse === false) {\n\t\tconst rect = getBoundingRect(node);\n\n\t\tres.x -= rect.x;\n\t\tres.y -= rect.y;\n\t}\n\n\treturn res;\n}\n\n/**\n * Gets the SVGMatrix of an SVGGElement\n * @param {SVGElement} node Node element\n * @returns {SVGMatrix} matrix\n * @private\n */\nfunction getTranslation(node) {\n\tconst transform = node ? node.transform : null;\n\tconst baseVal = transform && transform.baseVal;\n\n\treturn baseVal && baseVal.numberOfItems ?\n\t\tbaseVal.getItem(0).matrix :\n\t\t{a: 0, b: 0, c: 0, d: 0, e: 0, f: 0};\n}\n\n/**\n * Get unique value from array\n * @param {Array} data Source data\n * @returns {Array} Unique array value\n * @private\n */\nfunction getUnique(data: any[]): any[] {\n\tconst isDate = data[0] instanceof Date;\n\tconst d = (isDate ? data.map(Number) : data)\n\t\t.filter((v, i, self) => self.indexOf(v) === i);\n\n\treturn isDate ? d.map(v => new Date(v)) : d;\n}\n\n/**\n * Merge array\n * @param {Array} arr Source array\n * @returns {Array}\n * @private\n */\nfunction mergeArray(arr: any[]): any[] {\n\treturn arr && arr.length ? arr.reduce((p, c) => p.concat(c)) : [];\n}\n\n/**\n * Merge object returning new object\n * @param {object} target Target object\n * @param {object} objectN Source object\n * @returns {object} merged target object\n * @private\n */\nfunction mergeObj(target: object, ...objectN): any {\n\tif (!objectN.length || (objectN.length === 1 && !objectN[0])) {\n\t\treturn target;\n\t}\n\n\tconst source = objectN.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (!/^(__proto__|constructor|prototype)$/i.test(key)) {\n\t\t\t\tconst value = source[key];\n\n\t\t\t\tif (isObject(value)) {\n\t\t\t\t\t!target[key] && (target[key] = {});\n\t\t\t\t\ttarget[key] = mergeObj(target[key], value);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = isArray(value) ? value.concat() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn mergeObj(target, ...objectN);\n}\n\n/**\n * Sort value\n * @param {Array} data value to be sorted\n * @param {boolean} isAsc true: asc, false: desc\n * @returns {number|string|Date} sorted date\n * @private\n */\nfunction sortValue(data: any[], isAsc = true): any[] {\n\tlet fn;\n\n\tif (data[0] instanceof Date) {\n\t\tfn = isAsc ? (a, b) => a - b : (a, b) => b - a;\n\t} else {\n\t\tif (isAsc && !data.every(isNaN)) {\n\t\t\tfn = (a, b) => a - b;\n\t\t} else if (!isAsc) {\n\t\t\tfn = (a, b) => (a > b && -1) || (a < b && 1) || (a === b && 0);\n\t\t}\n\t}\n\n\treturn data.concat().sort(fn);\n}\n\n/**\n * Get min/max value\n * @param {string} type 'min' or 'max'\n * @param {Array} data Array data value\n * @returns {number|Date|undefined}\n * @private\n */\nfunction getMinMax(type: \"min\" | \"max\", data: number[] | Date[] | any): number | Date | undefined\n\t| any {\n\tlet res = data.filter(v => notEmpty(v));\n\n\tif (res.length) {\n\t\tif (isNumber(res[0])) {\n\t\t\tres = Math[type](...res);\n\t\t} else if (res[0] instanceof Date) {\n\t\t\tres = sortValue(res, type === \"min\")[0];\n\t\t}\n\t} else {\n\t\tres = undefined;\n\t}\n\n\treturn res;\n}\n\n/**\n * Get range\n * @param {number} start Start number\n * @param {number} end End number\n * @param {number} step Step number\n * @returns {Array}\n * @private\n */\nconst getRange = (start: number, end: number, step = 1): number[] => {\n\tconst res: number[] = [];\n\tconst n = Math.max(0, Math.ceil((end - start) / step)) | 0;\n\n\tfor (let i = start; i < n; i++) {\n\t\tres.push(start + i * step);\n\t}\n\n\treturn res;\n};\n\n// emulate event\nconst emulateEvent = {\n\tmouse: (() => {\n\t\tconst getParams = () => ({\n\t\t\tbubbles: false,\n\t\t\tcancelable: false,\n\t\t\tscreenX: 0,\n\t\t\tscreenY: 0,\n\t\t\tclientX: 0,\n\t\t\tclientY: 0\n\t\t});\n\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new\n\t\t\tnew MouseEvent(\"t\");\n\n\t\t\treturn (el: SVGElement | HTMLElement, eventType: string, params = getParams()) => {\n\t\t\t\tel.dispatchEvent(new MouseEvent(eventType, params));\n\t\t\t};\n\t\t} catch {\n\t\t\t// Polyfills DOM4 MouseEvent\n\t\t\treturn (el: SVGElement | HTMLElement, eventType: string, params = getParams()) => {\n\t\t\t\tconst mouseEvent = document.createEvent(\"MouseEvent\");\n\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent\n\t\t\t\tmouseEvent.initMouseEvent(\n\t\t\t\t\teventType,\n\t\t\t\t\tparams.bubbles,\n\t\t\t\t\tparams.cancelable,\n\t\t\t\t\twindow,\n\t\t\t\t\t0, // the event's mouse click count\n\t\t\t\t\tparams.screenX,\n\t\t\t\t\tparams.screenY,\n\t\t\t\t\tparams.clientX,\n\t\t\t\t\tparams.clientY,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\t0,\n\t\t\t\t\tnull\n\t\t\t\t);\n\n\t\t\t\tel.dispatchEvent(mouseEvent);\n\t\t\t};\n\t\t}\n\t})(),\n\ttouch: (el: SVGElement | HTMLElement, eventType: string, params: any) => {\n\t\tconst touchObj = new Touch(mergeObj({\n\t\t\tidentifier: Date.now(),\n\t\t\ttarget: el,\n\t\t\tradiusX: 2.5,\n\t\t\tradiusY: 2.5,\n\t\t\trotationAngle: 10,\n\t\t\tforce: 0.5\n\t\t}, params));\n\n\t\tel.dispatchEvent(new TouchEvent(eventType, {\n\t\t\tcancelable: true,\n\t\t\tbubbles: true,\n\t\t\tshiftKey: true,\n\t\t\ttouches: [touchObj],\n\t\t\ttargetTouches: [],\n\t\t\tchangedTouches: [touchObj]\n\t\t}));\n\t}\n};\n\n/**\n * Process the template  & return bound string\n * @param {string} tpl Template string\n * @param {object} data Data value to be replaced\n * @returns {string}\n * @private\n */\nfunction tplProcess(tpl: string, data: object): string {\n\tlet res = tpl;\n\n\tfor (const x in data) {\n\t\tres = res.replace(new RegExp(`{=${x}}`, \"g\"), data[x]);\n\t}\n\n\treturn res;\n}\n\n/**\n * Get parsed date value\n * (It must be called in 'ChartInternal' context)\n * @param {Date|string|number} date Value of date to be parsed\n * @returns {Date}\n * @private\n */\nfunction parseDate(date: Date | string | number | any): Date {\n\tlet parsedDate;\n\n\tif (date instanceof Date) {\n\t\tparsedDate = date;\n\t} else if (isString(date)) {\n\t\tconst {config, format} = this;\n\n\t\t// if fails to parse, try by new Date()\n\t\t// https://github.com/naver/billboard.js/issues/1714\n\t\tparsedDate = format.dataTime(config.data_xFormat)(date) ?? new Date(date);\n\t} else if (isNumber(date) && !isNaN(date)) {\n\t\tparsedDate = new Date(+date);\n\t}\n\n\tif (!parsedDate || isNaN(+parsedDate)) {\n\t\tconsole && console.error &&\n\t\t\tconsole.error(`Failed to parse x '${date}' to Date object`);\n\t}\n\n\treturn parsedDate;\n}\n\n/**\n * Check if svg element has viewBox attribute\n * @param {d3Selection} svg Target svg selection\n * @returns {boolean}\n */\nfunction hasViewBox(svg: d3Selection): boolean {\n\tconst attr = svg.attr(\"viewBox\");\n\n\treturn attr ? /(\\d+(\\.\\d+)?){3}/.test(attr) : false;\n}\n\n/**\n * Determine if given node has the specified style\n * @param {d3Selection|SVGElement} node Target node\n * @param {object} condition Conditional style props object\n * @param {boolean} all If true, all condition should be matched\n * @returns {boolean}\n */\nfunction hasStyle(node, condition: {[key: string]: string}, all = false): boolean {\n\tconst isD3Node = !!node.node;\n\tlet has = false;\n\n\tfor (const [key, value] of Object.entries(condition)) {\n\t\thas = isD3Node ? node.style(key) === value : node.style[key] === value;\n\n\t\tif (all === false && has) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn has;\n}\n\n/**\n * Return if the current doc is visible or not\n * @returns {boolean}\n * @private\n */\nfunction isTabVisible(): boolean {\n\treturn document?.hidden === false || document?.visibilityState === \"visible\";\n}\n\n/**\n * Get the current input type\n * @param {boolean} mouse Config value: interaction.inputType.mouse\n * @param {boolean} touch Config value: interaction.inputType.touch\n * @returns {string} \"mouse\" | \"touch\" | null\n * @private\n */\nfunction convertInputType(mouse: boolean, touch: boolean): \"mouse\" | \"touch\" | null {\n\tconst {DocumentTouch, matchMedia, navigator} = window;\n\n\t// https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer#coarse\n\tconst hasPointerCoarse = matchMedia?.(\"(pointer:coarse)\").matches;\n\tlet hasTouch = false;\n\n\tif (touch) {\n\t\t// Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/\n\t\tif (navigator && \"maxTouchPoints\" in navigator) {\n\t\t\thasTouch = navigator.maxTouchPoints > 0;\n\n\t\t\t// Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js\n\t\t\t// On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true\n\t\t} else if (\n\t\t\t\"ontouchmove\" in window || (DocumentTouch && document instanceof DocumentTouch)\n\t\t) {\n\t\t\thasTouch = true;\n\t\t} else {\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#avoiding_user_agent_detection\n\t\t\tif (hasPointerCoarse) {\n\t\t\t\thasTouch = true;\n\t\t\t} else {\n\t\t\t\t// Only as a last resort, fall back to user agent sniffing\n\t\t\t\tconst UA = navigator.userAgent;\n\n\t\t\t\thasTouch = /\\b(BlackBerry|webOS|iPhone|IEMobile)\\b/i.test(UA) ||\n\t\t\t\t\t/\\b(Android|Windows Phone|iPad|iPod)\\b/i.test(UA);\n\t\t\t}\n\t\t}\n\t}\n\n\t// For non-touch device, media feature condition is: '(pointer:coarse) = false' and '(pointer:fine) = true'\n\t// https://github.com/naver/billboard.js/issues/3854#issuecomment-2404183158\n\tconst hasMouse = mouse && !hasPointerCoarse && matchMedia?.(\"(pointer:fine)\").matches;\n\n\t// fallback to 'mouse' if no input type is detected.\n\treturn (hasMouse && \"mouse\") || (hasTouch && \"touch\") || \"mouse\";\n}\n\n/**\n * Run function until given condition function return true\n * @param {Function} fn Function to be executed when condition is true\n * @param {Function} conditionFn Condition function to check if condition is true\n * @private\n */\nfunction runUntil(fn: Function, conditionFn: Function): void {\n\tif (conditionFn() === false) {\n\t\trequestAnimationFrame(() => runUntil(fn, conditionFn));\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * Parse CSS shorthand values (padding, margin, border-radius, etc.)\n * @param {number|string|object} value Shorthand value(s)\n * @returns {object} Parsed object with top, right, bottom, left properties\n * @private\n */\nfunction parseShorthand(\n\tvalue: number | string | object\n): {top: number, right: number, bottom: number, left: number} {\n\tif (isObject(value) && !isString(value)) {\n\t\tconst obj = value as {top?: number, right?: number, bottom?: number, left?: number};\n\t\treturn {\n\t\t\ttop: obj.top || 0,\n\t\t\tright: obj.right || 0,\n\t\t\tbottom: obj.bottom || 0,\n\t\t\tleft: obj.left || 0\n\t\t};\n\t}\n\n\tconst values = (isString(value) ? value.trim().split(/\\s+/) : [value]).map(v => +v || 0);\n\tconst [a, b = a, c = a, d = b] = values;\n\n\treturn {top: a, right: b, bottom: c, left: d};\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n// common\nimport boost from \"./common/boost\";\nimport color from \"./common/color\";\nimport legend from \"./common/legend\";\nimport main from \"./common/main\";\nimport title from \"./common/title\";\nimport tooltip from \"./common/tooltip\";\nimport data from \"./data/data\";\nimport interaction from \"./interaction/interaction\";\n\nimport {deepClone} from \"../../module/util\";\n\n/**\n * Class to set options on generating chart.\n * - It's instantiated internally, not exposed for public.\n * @class Options\n * @see {@link bb.generate} to use these options on generating the chart\n */\nexport default class Options {\n\tstatic data = {};\n\n\tstatic setOptions(options: any[]) {\n\t\tthis.data = options\n\t\t\t.reduce((a, c) => ({...a, ...c}), this.data);\n\t}\n\n\tconstructor() {\n\t\treturn deepClone(\n\t\t\tmain,\n\t\t\tboost,\n\t\t\tdata,\n\t\t\tcolor,\n\t\t\tinteraction,\n\t\t\tlegend,\n\t\t\ttitle,\n\t\t\ttooltip,\n\t\t\tOptions.data\n\t\t);\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {d3Selection} from \"../../../types/types\";\n\ntype T = d3Selection | null;\n\n/**\n * Elements class.\n * @class Elements\n * @ignore\n * @private\n */\nexport default class Element {\n\tconstructor() {\n\t\tconst element: {[key: string]: T | {[key: string]: T}} = {\n\t\t\tchart: null,\n\t\t\tmain: null,\n\t\t\tsvg: null,\n\t\t\taxis: { // axes\n\t\t\t\tx: null,\n\t\t\t\ty: null,\n\t\t\t\ty2: null,\n\t\t\t\tsubX: null\n\t\t\t},\n\t\t\taxisTooltip: {\n\t\t\t\tx: null,\n\t\t\t\ty: null,\n\t\t\t\ty2: null\n\t\t\t},\n\t\t\tdefs: null,\n\t\t\ttooltip: null,\n\t\t\tlegend: null,\n\t\t\ttitle: null,\n\t\t\tsubchart: {\n\t\t\t\tmain: null, // $$.context\n\t\t\t\tbar: null, // $$.contextBar\n\t\t\t\tline: null, // $$.contextLine\n\t\t\t\tarea: null // $$.contextArea\n\t\t\t},\n\n\t\t\tarcs: null,\n\t\t\tbar: null, // mainBar,\n\t\t\tcandlestick: null,\n\t\t\tline: null, // mainLine,\n\t\t\tarea: null, // mainArea,\n\t\t\tcircle: null, // mainCircle,\n\t\t\tradar: null,\n\t\t\ttext: null, // mainText,\n\t\t\tgrid: {\n\t\t\t\tmain: null, // grid (also focus)\n\t\t\t\tx: null, // xgrid,\n\t\t\t\ty: null // ygrid,\n\t\t\t},\n\t\t\tgridLines: {\n\t\t\t\tmain: null, // gridLines\n\t\t\t\tx: null, // xgridLines,\n\t\t\t\ty: null // ygridLines\n\t\t\t},\n\t\t\tregion: {\n\t\t\t\tmain: null, // region\n\t\t\t\tlist: null // mainRegion\n\t\t\t},\n\t\t\teventRect: null,\n\t\t\tzoomResetBtn: null // drag zoom reset button\n\t\t};\n\n\t\treturn element;\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * State class.\n * @class State\n * @ignore\n * @private\n */\nexport default class State {\n\tconstructor() {\n\t\treturn {\n\t\t\t// chart drawn area dimension, excluding axes\n\t\t\twidth: 0,\n\t\t\twidth2: 0,\n\t\t\theight: 0,\n\t\t\theight2: 0,\n\t\t\tmargin: {\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0\n\t\t\t},\n\t\t\tmargin2: {\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0\n\t\t\t},\n\t\t\tmargin3: {\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0\n\t\t\t},\n\t\t\tarcWidth: 0,\n\t\t\tarcHeight: 0,\n\t\t\txAxisHeight: 0,\n\n\t\t\thasAxis: false,\n\t\t\thasFunnel: false,\n\t\t\thasRadar: false,\n\t\t\thasTreemap: false,\n\n\t\t\t// for data CSS rule index (used when boost.useCssRule is true)\n\t\t\tcssRule: {},\n\n\t\t\tcurrent: {\n\t\t\t\t// current domain value. Assigned when is zoom is called\n\t\t\t\tdomain: undefined,\n\n\t\t\t\t// chart whole dimension\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tdataMax: 0,\n\n\t\t\t\tmaxTickSize: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\theight: 0,\n\t\t\t\t\t\tticks: <(number | string)[]>[],\n\t\t\t\t\t\tclipPath: 0,\n\t\t\t\t\t\tdomain: \"\"\n\t\t\t\t\t},\n\t\t\t\t\ty: {width: 0, height: 0, domain: \"\"},\n\t\t\t\t\ty2: {width: 0, height: 0, domain: \"\"}\n\t\t\t\t},\n\n\t\t\t\t// current used chart type list\n\t\t\t\ttypes: <string[]>[],\n\t\t\t\tneedle: undefined, // arc needle current value\n\t\t\t\tzoomDomain: null // zoomed domain value\n\t\t\t},\n\n\t\t\t// legend\n\t\t\tisLegendRight: false,\n\t\t\tisLegendInset: false,\n\t\t\tisLegendTop: false,\n\t\t\tisLegendLeft: false,\n\t\t\tlegendStep: 0,\n\t\t\tlegendItemWidth: 0,\n\t\t\tlegendItemHeight: 0,\n\t\t\tlegendHasRendered: false,\n\n\t\t\teventReceiver: {\n\t\t\t\tcurrentIdx: -1, // current event interaction index\n\t\t\t\trect: {}, // event rect's clientBoundingRect\n\t\t\t\tdata: [], // event data bound of previoous eventRect\n\t\t\t\tcoords: [] // coordination value of previous eventRect\n\t\t\t},\n\n\t\t\taxis: {\n\t\t\t\tx: {\n\t\t\t\t\tpadding: {left: 0, right: 0},\n\t\t\t\t\ttickCount: 0\n\t\t\t\t}\n\t\t\t},\n\n\t\t\trotatedPadding: {\n\t\t\t\tleft: 30,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 5\n\t\t\t},\n\n\t\t\twithoutFadeIn: {},\n\t\t\tinputType: \"\",\n\n\t\t\tdatetimeId: \"\",\n\n\t\t\t// clip id string\n\t\t\tclip: {\n\t\t\t\tid: \"\",\n\t\t\t\tidXAxis: \"\",\n\t\t\t\tidYAxis: \"\",\n\t\t\t\tidXAxisTickTexts: \"\",\n\t\t\t\tidGrid: \"\",\n\t\t\t\tidSubchart: \"\", // clipIdForSubchart\n\t\t\t\tpath: \"\",\n\t\t\t\tpathXAxis: \"\",\n\t\t\t\tpathYAxis: \"\",\n\t\t\t\tpathXAxisTickTexts: \"\",\n\t\t\t\tpathGrid: \"\"\n\t\t\t},\n\n\t\t\t// state\n\t\t\tevent: null, // event object\n\t\t\tdragStart: null,\n\t\t\tdragging: false,\n\t\t\tflowing: false,\n\t\t\tcancelClick: false,\n\t\t\tmouseover: false,\n\t\t\trendered: false,\n\t\t\ttransiting: false,\n\t\t\tredrawing: false, // if redraw() is on process\n\t\t\tresizing: false, // resize event called\n\t\t\ttoggling: false, // legend toggle\n\t\t\tzooming: false,\n\t\t\thasNegativeValue: false,\n\t\t\thasPositiveValue: true,\n\n\t\t\torgAreaOpacity: \"0.2\",\n\t\t\torgConfig: {}, // user original genration config\n\n\t\t\t// ID strings\n\t\t\thiddenTargetIds: <string[]>[],\n\t\t\thiddenLegendIds: <string[]>[],\n\t\t\tfocusedTargetIds: <string[]>[],\n\t\t\tdefocusedTargetIds: <string[]>[],\n\n\t\t\t// value for Arc\n\t\t\tradius: 0,\n\t\t\tinnerRadius: <{[key: string]: number} | number>0,\n\t\t\touterRadius: <{[key: string]: number} | number | undefined>undefined,\n\t\t\tinnerRadiusRatio: 0,\n\t\t\tgaugeArcWidth: 0,\n\t\t\tradiusExpanded: 0,\n\n\t\t\t// xgrid attribute\n\t\t\txgridAttr: {\n\t\t\t\tx1: <number | null>null,\n\t\t\t\tx2: <number | null>null,\n\t\t\t\ty1: <number | null>null,\n\t\t\t\ty2: <number | null>null\n\t\t\t}\n\t\t};\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport Element from \"./Element\";\nimport State from \"./State\";\n\n// mapping\nconst classes = {\n\telement: Element,\n\tstate: State\n};\n\n/**\n * Internal store class.\n * @class Store\n * @ignore\n * @private\n */\nexport default class Store {\n\tconstructor() {\n\t\tObject.keys(classes).forEach(v => {\n\t\t\tthis[v] = new classes[v]();\n\t\t});\n\t}\n\n\tgetStore(name: string): Element | State {\n\t\treturn this[name];\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {DataRow} from \"../../types/types\";\nimport {isString, isValue} from \"./util\";\n\n/**\n * Constant for cache key\n * - NOTE: Prefixed with '$', will be resetted when .load() is called\n * @private\n */\nexport const KEY = {\n\tbubbleBaseLength: \"$baseLength\",\n\tcolorPattern: \"__colorPattern__\",\n\tdataMinMax: \"$dataMinMax\",\n\tdataTotalSum: \"$dataTotalSum\",\n\tdataTotalPerIndex: \"$totalPerIndex\",\n\tlegendItemTextBox: \"legendItemTextBox\",\n\tradarPoints: \"$radarPoints\",\n\tradarTextWidth: \"$radarTextWidth\",\n\tsetOverOut: \"setOverOut\",\n\tcallOverOutForTouch: \"callOverOutForTouch\",\n\ttextRect: \"textRect\"\n};\n\nexport default class Cache {\n\tprivate cache = {};\n\n\t/**\n\t * Add cache\n\t * @param {string} key Cache key\n\t * @param {*} value Value to be stored\n\t * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'\n\t * @returns {*} Added data value\n\t * @private\n\t */\n\tadd(key: string, value, isDataType = false) {\n\t\tthis.cache[key] = isDataType ? this.cloneTarget(value) : value;\n\t\treturn this.cache[key];\n\t}\n\n\t/**\n\t * Remove cache\n\t * @param {string|Array} key Cache key\n\t * @private\n\t */\n\tremove(key: string | string[]) {\n\t\t(isString(key) ? [key] : key)\n\t\t\t.forEach(v => delete this.cache[v]);\n\t}\n\n\t/**\n\t * Get cahce\n\t * @param {string|Array} key Cache key\n\t * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'\n\t * @returns {*}\n\t * @private\n\t */\n\tget(key: string | string[], isDataType = false): any | null {\n\t\t// when is isDataType, key should be string array\n\t\tif (isDataType && Array.isArray(key)) {\n\t\t\tconst targets: any[] = [];\n\n\t\t\tfor (let i = 0, id; (id = key[i]); i++) {\n\t\t\t\tif (id in this.cache) {\n\t\t\t\t\ttargets.push(this.cloneTarget(this.cache[id]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn targets;\n\t\t} else {\n\t\t\tconst value = this.cache[key as string];\n\n\t\t\treturn isValue(value) ? value : null;\n\t\t}\n\t}\n\n\t/**\n\t * Reset cached data\n\t * @param {boolean} all true: reset all data, false: reset only '$' prefixed key data\n\t * @private\n\t */\n\treset(all?: boolean): void {\n\t\tconst $$ = this;\n\n\t\tfor (const x in $$.cache) {\n\t\t\t// reset the prefixed '$' key(which is internal use data) only.\n\t\t\tif (all || /^\\$/.test(x)) {\n\t\t\t\t$$.cache[x] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clone data target object\n\t * @param {object} target Data object\n\t * @returns {object}\n\t * @private\n\t */\n\tcloneTarget(target: DataRow): DataRow {\n\t\treturn {\n\t\t\tid: target.id,\n\t\t\tid_org: target.id_org,\n\t\t\tvalues: target.values.map(d => ({x: d.x, value: d.value, id: d.id}))\n\t\t};\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * Chart type constant\n * @private\n */\nexport const TYPE = {\n\tAREA: \"area\",\n\tAREA_LINE_RANGE: \"area-line-range\",\n\tAREA_SPLINE: \"area-spline\",\n\tAREA_SPLINE_RANGE: \"area-spline-range\",\n\tAREA_STEP: \"area-step\",\n\tAREA_STEP_RANGE: \"area-step-range\",\n\tBAR: \"bar\",\n\tBUBBLE: \"bubble\",\n\tCANDLESTICK: \"candlestick\",\n\tDONUT: \"donut\",\n\tFUNNEL: \"funnel\",\n\tGAUGE: \"gauge\",\n\tLINE: \"line\",\n\tPIE: \"pie\",\n\tPOLAR: \"polar\",\n\tRADAR: \"radar\",\n\tSCATTER: \"scatter\",\n\tSPLINE: \"spline\",\n\tSTEP: \"step\",\n\tTREEMAP: \"treemap\"\n};\n\n/**\n * Chart type module and its method from ChartInternal class, needed to be initialized.\n * @private\n */\nexport const TYPE_METHOD_NEEDED = {\n\tAREA: \"initArea\",\n\tAREA_LINE_RANGE: \"initArea\",\n\tAREA_SPLINE: \"initArea\",\n\tAREA_SPLINE_RANGE: \"initArea\",\n\tAREA_STEP: \"initArea\",\n\tAREA_STEP_RANGE: \"initArea\",\n\tBAR: \"initBar\",\n\tBUBBLE: \"initCircle\",\n\tCANDLESTICK: \"initCandlestick\",\n\tDONUT: \"initArc\",\n\tFUNNEL: \"initFunnel\",\n\tGAUGE: \"initArc\",\n\tLINE: \"initLine\",\n\tPIE: \"initArc\",\n\tPOLAR: \"initPolar\",\n\tRADAR: \"initCircle\",\n\tSCATTER: \"initCircle\",\n\tSPLINE: \"initLine\",\n\tSTEP: \"initLine\",\n\tTREEMAP: \"initTreemap\"\n};\n\n/**\n * chart types by category\n * @private\n */\nexport const TYPE_BY_CATEGORY = {\n\tArea: [\n\t\tTYPE.AREA,\n\t\tTYPE.AREA_SPLINE,\n\t\tTYPE.AREA_SPLINE_RANGE,\n\t\tTYPE.AREA_LINE_RANGE,\n\t\tTYPE.AREA_STEP,\n\t\tTYPE.AREA_STEP_RANGE\n\t],\n\tAreaRange: [\n\t\tTYPE.AREA_SPLINE_RANGE,\n\t\tTYPE.AREA_LINE_RANGE,\n\t\tTYPE.AREA_STEP_RANGE\n\t],\n\tArc: [\n\t\tTYPE.PIE,\n\t\tTYPE.DONUT,\n\t\tTYPE.GAUGE,\n\t\tTYPE.POLAR,\n\t\tTYPE.RADAR\n\t],\n\tLine: [\n\t\tTYPE.LINE,\n\t\tTYPE.SPLINE,\n\t\tTYPE.AREA,\n\t\tTYPE.AREA_SPLINE,\n\t\tTYPE.AREA_SPLINE_RANGE,\n\t\tTYPE.AREA_LINE_RANGE,\n\t\tTYPE.STEP,\n\t\tTYPE.AREA_STEP,\n\t\tTYPE.AREA_STEP_RANGE\n\t],\n\tStep: [\n\t\tTYPE.STEP,\n\t\tTYPE.AREA_STEP,\n\t\tTYPE.AREA_STEP_RANGE\n\t],\n\tSpline: [\n\t\tTYPE.SPLINE,\n\t\tTYPE.AREA_SPLINE,\n\t\tTYPE.AREA_SPLINE_RANGE\n\t]\n};\n","import {TYPE, TYPE_METHOD_NEEDED} from \"../config/const\";\nimport {window} from \"./browser\";\nimport {camelize, isEmpty} from \"./util\";\n\n/**\n * Copyright (c) 2021 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/* eslint no-console: \"off\" */\nexport {checkModuleImport, logError};\n\n/**\n * Check chart type module imports.\n * @param {ChartInternal} ctx Context\n * @private\n */\nfunction checkModuleImport(ctx) {\n\tconst $$ = ctx;\n\tconst {config} = $$;\n\tlet type = \"\";\n\n\tif (isEmpty(config.data_type || config.data_types) && !$$[TYPE_METHOD_NEEDED.LINE]) {\n\t\ttype = \"line\";\n\t} else {\n\t\tfor (const x in TYPE_METHOD_NEEDED) {\n\t\t\tconst t = TYPE[x];\n\n\t\t\tif ($$.hasType(t) && !$$[TYPE_METHOD_NEEDED[x]]) {\n\t\t\t\ttype = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ttype &&\n\t\tlogError(`Please, make sure if %c${camelize(type)}`,\n\t\t\t\"module has been imported and specified correctly.\",\n\t\t\t\"https://github.com/naver/billboard.js/wiki/CHANGELOG-v2#modularization-by-its-functionality\");\n}\n\n/**\n * Log error and throw error\n * @param {string} head Message header\n * @param {string} tail Message tail\n * @param {string} info Info message\n * @private\n */\nfunction logError(head, tail?: string, info?: string) {\n\tconst prefix = \"[billboard.js]\";\n\tconst hasConsole = window.console?.error;\n\n\tif (hasConsole) {\n\t\tconst tailMsg = tail ?\n\t\t\t[\"background:red;color:white;display:block;font-size:15px\", tail] :\n\t\t\t[];\n\n\t\tconsole.error(`❌ ${prefix} ${head}`,\n\t\t\t\"background:red;color:white;display:block;font-size:15px\", ...tailMsg);\n\t\tinfo && console.info(\"%cℹ️\", \"font-size:15px\", info);\n\t}\n\n\tthrow Error(`${prefix} ${head.replace(/\\%c([a-z-]+)/i, \"'$1' \")} ${tail ?? \"\"}`);\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {d3Transition} from \"../../types/types\";\nimport {requestIdleCallback, window} from \"./browser\";\nimport {isArray, isNumber, isTabVisible, runUntil} from \"./util\";\n\nconst {setTimeout, clearTimeout} = window;\n\n/**\n * Generate resize queue function\n * @param {boolean|number} option Resize option\n * @returns {Fucntion}\n * @private\n */\nexport function generateResize(option: boolean | number) {\n\tconst fn: Function[] = [];\n\tlet timeout;\n\n\tconst callResizeFn = function() {\n\t\t// Delay all resize functions call, to prevent unintended excessive call from resize event\n\t\tcallResizeFn.clear();\n\n\t\tif (option === false) {\n\t\t\trequestIdleCallback(() => {\n\t\t\t\tfn.forEach((f: Function) => f());\n\t\t\t}, {timeout: 200});\n\t\t} else {\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tfn.forEach((f: Function) => f());\n\t\t\t}, isNumber(option) ? option : 200);\n\t\t}\n\t};\n\n\tcallResizeFn.clear = () => {\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = null;\n\t\t}\n\t};\n\n\tcallResizeFn.add = f => fn.push(f);\n\tcallResizeFn.remove = f => fn.splice(fn.indexOf(f), 1);\n\n\treturn callResizeFn;\n}\n\ntype Transition = boolean | d3Transition;\n\n/**\n * Generate transition queue function\n * @returns {Function}\n * @private\n */\nexport function generateWait() {\n\tlet transitionsToWait: Transition[] = [];\n\n\t// 'f' is called as selection.call(f, ...);\n\tconst f = function(selection: d3Transition, callback: Function) {\n\t\t/**\n\t\t * Check if transition is complete\n\t\t * @returns {boolean} Whether transition is complete\n\t\t * @private\n\t\t */\n\t\tfunction loop(): boolean {\n\t\t\tlet done = 0;\n\n\t\t\tfor (let i = 0, t; (t = transitionsToWait[i]); i++) {\n\t\t\t\tif (t === true || t.empty?.()) {\n\t\t\t\t\tdone++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// when tab isn't visible exit loop\n\t\t\t\tif (isTabVisible() === false) {\n\t\t\t\t\tdone = transitionsToWait.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tt.transition();\n\t\t\t\t} catch {\n\t\t\t\t\tdone++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn done === transitionsToWait.length;\n\t\t}\n\n\t\trunUntil(() => {\n\t\t\tcallback?.();\n\t\t}, loop);\n\t};\n\n\tf.add = function(t: Transition | Transition[]) {\n\t\tisArray(t) ? (transitionsToWait = transitionsToWait.concat(t)) : transitionsToWait.push(t);\n\t};\n\n\treturn f;\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {window} from \"./browser\";\n\n// Store blob in memory\nconst blob = {};\n\n/**\n * Get Object URL\n * @param {Function} fn Function to be executed in worker\n * @param {Array} depsFn Dependency functions to run given function(fn).\n * @returns {string}\n * @private\n */\nfunction getObjectURL(fn: Function, depsFn?: Function[]): string {\n\tconst fnString = fn.toString();\n\tconst key = fnString.replace(/(function|[\\s\\W\\n])/g, \"\").substring(0, 15);\n\n\tif (!(key in blob)) {\n\t\t// Web Worker body\n\t\tblob[key] = new window.Blob([\n\t\t\t`${depsFn?.map(String).join(\";\") ?? \"\"}\n\n\t\t\tself.onmessage=function({data}) {\n\t\t\t\tconst result = (${fnString}).apply(null, data);\n\t\t\t\tself.postMessage(result);\n\t\t\t};`\n\t\t], {\n\t\t\ttype: \"text/javascript\"\n\t\t});\n\t}\n\n\treturn window.URL.createObjectURL(blob[key]);\n}\n\n/**\n * Get WebWorker instance\n * @param {string} src URL object as string\n * @returns {object} WebWorker instance\n * @private\n */\nexport function getWorker(src) {\n\tconst worker = new window.Worker(src);\n\n\t// handle error\n\tworker.onerror = function(e) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error ? console.error(e) : console.log(e);\n\t};\n\n\treturn worker;\n}\n\n/**\n * Create and run on Web Worker\n * @param {boolean} useWorker Use Web Worker\n * @param {Function} fn Function to be executed in worker\n * @param {Function} callback Callback function to receive result from worker\n * @param {Array} depsFn Dependency functions to run given function(fn).\n * @returns {object}\n * @example\n * \tconst worker = runWorker(function(arg) {\n * \t\t  // do some tasks...\n * \t\t  console.log(\"param:\", A(arg));\n *\n * \t\t  return 1234;\n * \t   }, function(data) {\n * \t\t  // callback after worker is done\n * \t \t  console.log(\"result:\", data);\n * \t   },\n * \t   [function A(){}]\n * \t);\n *\n * \tworker(11111);\n * @private\n */\nexport function runWorker(\n\tuseWorker = true,\n\tfn: Function,\n\tcallback: Function,\n\tdepsFn?: Function[]\n): Function {\n\tlet runFn = function(...args) {\n\t\tconst res = fn(...args);\n\n\t\tcallback(res);\n\t};\n\n\tif (window.Worker && useWorker) {\n\t\tconst src = getObjectURL(fn, depsFn);\n\t\tconst worker = getWorker(src);\n\n\t\trunFn = function(...args) {\n\t\t\t// trigger worker\n\t\t\tworker.postMessage(args);\n\n\t\t\t// listen worker\n\t\t\tworker.onmessage = function(e) {\n\t\t\t\t// release object URL from memory\n\t\t\t\twindow.URL.revokeObjectURL(src);\n\n\t\t\t\treturn callback(e.data);\n\t\t\t};\n\n\t\t\t// return new Promise((resolve, reject) => {\n\t\t\t// \tworker.onmessage = ({data}) => resolve(data);\n\t\t\t// \tworker.onerror = reject;\n\t\t\t// });\n\t\t};\n\t}\n\n\treturn runFn;\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n\n/* eslint-disable */\nimport {\n\tcsvParse as d3CsvParse,\n\tcsvParseRows as d3CsvParseRows,\n\ttsvParse as d3TsvParse,\n\ttsvParseRows as d3TsvParseRows\n} from \"d3-dsv\";\n\nexport {columns, csv, json, rows, tsv, url};\n\n/***** Functions to be executed on Web Worker *****\n * NOTE: Don't allowed to use\n * - arrow function syntax\n * - Utils functions\n */\n/**\n * Convert Columns data\n * @param {object} columns\n * @returns {Array}\n * @private\n */\nfunction columns(columns) {\n\tconst newRows: any[] = [];\n\n\tcolumns.forEach(function(col, i) {\n\t\tconst key = col[0];\n\n\t\tcol.forEach(function(v, j) {\n\t\t\tif (j > 0) {\n\t\t\t\tif (typeof newRows[j - 1] === \"undefined\") {\n\t\t\t\t\tnewRows[j - 1] = {};\n\t\t\t\t}\n\n\t\t\t\tif (typeof v === \"undefined\") {\n\t\t\t\t\tthrow new Error(`Source data is missing a component at (${i}, ${j})!`);\n\t\t\t\t}\n\n\t\t\t\tnewRows[j - 1][key] = v;\n\t\t\t}\n\t\t});\n\t});\n\n\treturn newRows;\n}\n\n/**\n * Convert Rows data\n * @param {object} columns\n * @returns {Array}\n * @private\n */\nfunction rows(rows) {\n\tconst keys = rows[0];\n\tconst newRows: any[] = [];\n\n\trows.forEach(function(row, i) {\n\t\tif (i > 0) {\n\t\t\tconst newRow = {};\n\n\t\t\trow.forEach(function(v, j) {\n\t\t\t\tif (typeof v === \"undefined\") {\n\t\t\t\t\tthrow new Error(`Source data is missing a component at (${i}, ${j})!`);\n\t\t\t\t}\n\n\t\t\t\tnewRow[keys[j]] = v;\n\t\t\t});\n\n\t\t\tnewRows.push(newRow);\n\t\t}\n\t});\n\n\treturn newRows;\n}\n\n/**\n * Convert JSON data\n * @param {object} columns\n * @returns {Array}\n * @private\n */\nfunction json(json, keysParam) {\n\tconst newRows: string[][] = [];\n\tlet targetKeys: string[];\n\tlet data;\n\n\tif (Array.isArray(json)) {\n\t\tconst findValueInJson = function(object, path) {\n\t\t\tif (object[path] !== undefined) {\n\t\t\t\treturn object[path];\n\t\t\t}\n\n\t\t\tconst convertedPath = path.replace(/\\[(\\w+)\\]/g, \".$1\"); // convert indexes to properties (replace [] with .)\n\t\t\tconst pathArray = convertedPath.replace(/^\\./, \"\").split(\".\"); // strip a leading dot\n\t\t\tlet target = object;\n\n\t\t\tpathArray.some(function(k) {\n\t\t\t\treturn !(\n\t\t\t\t\ttarget = target && k in target ? target[k] : undefined\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn target;\n\t\t};\n\n\t\tif (keysParam.x) {\n\t\t\ttargetKeys = keysParam.value.concat(keysParam.x);\n\t\t} else {\n\t\t\ttargetKeys = keysParam.value;\n\t\t}\n\n\t\tnewRows.push(targetKeys);\n\n\t\tjson.forEach(function(o) {\n\t\t\tconst newRow = targetKeys.map(function(key) {\n\t\t\t\t// convert undefined to null because undefined data will be removed in convertDataToTargets()\n\t\t\t\tlet v = findValueInJson(o, key);\n\n\t\t\t\tif (typeof v === \"undefined\") {\n\t\t\t\t\tv = null;\n\t\t\t\t}\n\n\t\t\t\treturn v;\n\t\t\t});\n\n\t\t\tnewRows.push(newRow);\n\t\t});\n\n\t\tdata = rows(newRows);\n\t} else {\n\t\tObject.keys(json).forEach(function(key) {\n\t\t\tconst tmp = json[key].concat();\n\n\t\t\ttmp.unshift?.(key);\n\t\t\tnewRows.push(tmp);\n\t\t});\n\n\t\tdata = columns(newRows);\n\t}\n\n\treturn data;\n}\n\n/***** Functions can't be executed on Web Worker *****/\n/**\n * Convert URL data\n * @param {string} url Remote URL\n * @param {string} mimeType MIME type string: json | csv | tsv\n * @param {object} headers Header object\n * @param {object} keys Key object\n * @param {Function} done Callback function\n * @private\n */\nfunction url(url: string, mimeType = \"csv\", headers: object, keys: object, done: Function): void {\n\tconst req = new XMLHttpRequest();\n\tconst converter = {csv, tsv, json};\n\n\treq.open(\"GET\", url);\n\n\tif (headers) {\n\t\tObject.keys(headers).forEach(function(key) {\n\t\t\treq.setRequestHeader(key, headers[key]);\n\t\t});\n\t}\n\n\treq.onreadystatechange = function() {\n\t\tif (req.readyState === 4) {\n\t\t\tif (req.status === 200) {\n\t\t\t\tconst response = req.responseText;\n\n\t\t\t\tresponse && done.call(this, converter[mimeType](\n\t\t\t\t\tmimeType === \"json\" ? JSON.parse(response) : response,\n\t\t\t\t\tkeys\n\t\t\t\t));\n\t\t\t} else {\n\t\t\t\tthrow new Error(`${url}: Something went wrong loading!`);\n\t\t\t}\n\t\t}\n\t};\n\n\treq.send();\n}\n\n/**\n * Convert CSV/TSV data\n * @param {object} parser Parser object\n * @param {object} xsv Data\n * @returns {object}\n * @private\n */\nfunction convertCsvTsvToData(parser, xsv) {\n\tconst rows = parser.rows(xsv);\n\tlet d;\n\n\tif (rows.length === 1) {\n\t\td = [{}];\n\n\t\trows[0].forEach(id => {\n\t\t\td[0][id] = null;\n\t\t});\n\t} else {\n\t\td = parser.parse(xsv);\n\t}\n\n\treturn d;\n}\n\nfunction csv(xsv) {\n\treturn convertCsvTsvToData({\n\t\trows: d3CsvParseRows,\n\t\tparse: d3CsvParse\n\t}, xsv);\n}\n\nfunction tsv(tsv) {\n\treturn convertCsvTsvToData({\n\t\trows: d3TsvParseRows,\n\t\tparse: d3TsvParse\n\t}, tsv);\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {isArray, isDefined, isObject, isUndefined, isValue, notEmpty} from \"../../module/util\";\nimport {runWorker} from \"../../module/worker\";\nimport type {IData} from \"../data/IData\";\nimport {columns, json, rows, url} from \"./convert.helper\";\n\n/**\n * Get data key for JSON\n * @param {string|object} keysParam Key params\n * @param {object} config Config object\n * @returns {string} Data key\n * @private\n */\nfunction getDataKeyForJson(keysParam, config) {\n\tconst keys = keysParam || config?.data_keys;\n\n\tif (keys?.x) {\n\t\tconfig.data_x = keys.x;\n\t}\n\n\treturn keys;\n}\n\n/**\n * Set `xs` for each id\n * @param {string[]} ids Ids to set xs\n * @param {object[]} data Data to set xs from\n * @param {object} params Parameters for setting xs\n * @param {boolean} params.appendXs Whether to append xs\n * @param {string[]} params.xs X keys to set xs from\n * @param {boolean} params.categorized Whether the axis is categorized\n * @param {boolean} params.timeSeries Whether the axis is time series\n * @param {boolean} params.customX Whether the x is custom\n * @private\n */\nfunction setXS(\n\tids: string[],\n\tdata: {[key: string]: number | null}[],\n\tparams: {appendXs, xs, categorized: boolean, timeSeries: boolean, customX: boolean}\n): void {\n\tconst $$ = this;\n\tconst {config} = $$;\n\tlet xsData;\n\n\tids.forEach(id => {\n\t\tconst xKey = $$.getXKey(id);\n\n\t\tif (params.customX || params.timeSeries) {\n\t\t\t// if included in input data\n\t\t\tif (params.xs.indexOf(xKey) >= 0) {\n\t\t\t\txsData = ((params.appendXs && $$.data.xs[id]) || [])\n\t\t\t\t\t.concat(\n\t\t\t\t\t\tdata.map((d, i) => {\n\t\t\t\t\t\t\tconst rawX = isValue(d[xKey]);\n\t\t\t\t\t\t\treturn rawX ? $$.generateTargetX(rawX, id, i) : false;\n\t\t\t\t\t\t}).filter(v => v !== false)\n\t\t\t\t\t);\n\t\t\t} else if (config.data_x) {\n\t\t\t\t// if not included in input data, find from preloaded data of other id's x\n\t\t\t\txsData = this.getOtherTargetXs();\n\t\t\t} else if (notEmpty(config.data_xs)) {\n\t\t\t\t// if not included in input data, find from preloaded data\n\t\t\t\txsData = $$.getXValuesOfXKey(xKey, $$.data.targets);\n\t\t\t}\n\t\t\t// MEMO: if no x included, use same x of current will be used\n\t\t} else {\n\t\t\txsData = data.map((d, i) => i);\n\t\t}\n\n\t\tif (xsData) {\n\t\t\t$$.data.xs[id] = xsData;\n\t\t} else {\n\t\t\tthrow new Error(`x is not defined for id = \"${id}\".`);\n\t\t}\n\t});\n}\n\n/**\n * Data convert\n * @memberof ChartInternal\n * @private\n */\nexport default {\n\t/**\n\t * Convert data according its type\n\t * @param {object} args data object\n\t * @param {Function} [callback] callback for url(XHR) type loading\n\t * @private\n\t */\n\tconvertData(args, callback: Function): void {\n\t\tconst {config} = this;\n\t\tconst useWorker = config.boost_useWorker;\n\t\tlet data = args;\n\n\t\tif (args.bindto) {\n\t\t\tdata = {};\n\n\t\t\t[\"url\", \"mimeType\", \"headers\", \"keys\", \"json\", \"keys\", \"rows\", \"columns\"]\n\t\t\t\t.forEach(v => {\n\t\t\t\t\tconst key = `data_${v}`;\n\n\t\t\t\t\tif (key in args) {\n\t\t\t\t\t\tdata[v] = args[key];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\n\t\tif (data.url && callback) {\n\t\t\turl(data.url, data.mimeType, data.headers, getDataKeyForJson(data.keys, config),\n\t\t\t\tcallback);\n\t\t} else if (data.json) {\n\t\t\trunWorker(useWorker, json, callback, [columns, rows])(\n\t\t\t\tdata.json,\n\t\t\t\tgetDataKeyForJson(data.keys, config)\n\t\t\t);\n\t\t} else if (data.rows) {\n\t\t\trunWorker(useWorker, rows, callback)(data.rows);\n\t\t} else if (data.columns) {\n\t\t\trunWorker(useWorker, columns, callback)(data.columns);\n\t\t} else if (args.bindto) {\n\t\t\tthrow Error(\"url or json or rows or columns is required.\");\n\t\t}\n\t},\n\n\t/**\n\t * Convert data to targets\n\t * @param {object[]} data Data to convert\n\t * @param {boolean} appendXs Whether to append xs\n\t * @returns {IData[]} Converted targets\n\t * @private\n\t */\n\tconvertDataToTargets(data: {[key: string]: number | null}[], appendXs: boolean): IData[] {\n\t\tconst $$ = this;\n\t\tconst {axis, config, state} = $$;\n\t\tconst chartType = config.data_type;\n\t\tconst dataKeys = Object.keys(data[0] || {});\n\n\t\t// Extract ids and xs from data keys to handle x and non-x values\n\t\tconst {ids, xs} = dataKeys.length ?\n\t\t\tdataKeys.reduce((acc, key) => {\n\t\t\t\tif ($$.isX.call($$, key)) {\n\t\t\t\t\tacc.xs.push(key);\n\t\t\t\t} else if ($$.isNotX.call($$, key)) {\n\t\t\t\t\tacc.ids.push(key);\n\t\t\t\t}\n\n\t\t\t\treturn acc;\n\t\t\t}, {ids: [] as string[], xs: [] as string[]}) :\n\t\t\t{ids: [], xs: []};\n\n\t\tconst params = {\n\t\t\tappendXs,\n\t\t\txs,\n\t\t\tidConverter: config.data_idConverter.bind($$.api),\n\t\t\tcategorized: axis?.isCategorized(),\n\t\t\ttimeSeries: axis?.isTimeSeries(),\n\t\t\tcustomX: axis?.isCustomX()\n\t\t};\n\n\t\t// save x for update data by load when custom x and bb.x API\n\t\tsetXS.bind($$)(ids, data, params);\n\n\t\t// convert to target\n\t\tconst targets = ids.map((id, index) => {\n\t\t\tconst convertedId = config.data_idConverter.bind($$.api)(id);\n\t\t\tconst xKey = $$.getXKey(id);\n\t\t\tconst isCategory = params.customX && params.categorized;\n\t\t\tconst hasCategory = isCategory && (() => {\n\t\t\t\tconst categorySet = new Set(config.axis_x_categories);\n\t\t\t\treturn data.every(v => categorySet.has(v.x));\n\t\t\t})();\n\n\t\t\t// when .load() with 'append' option is used for indexed axis\n\t\t\t// @ts-ignore\n\t\t\tconst isDataAppend = data.__append__;\n\t\t\tconst xIndex = xKey === null && isDataAppend ? $$.api.data.values(id).length : 0;\n\n\t\t\treturn {\n\t\t\t\tid: convertedId,\n\t\t\t\tid_org: id,\n\t\t\t\tvalues: data.map((d, i) => {\n\t\t\t\t\tconst rawX = d[xKey];\n\t\t\t\t\tlet value = d[id];\n\t\t\t\t\tlet x;\n\n\t\t\t\t\tvalue = value !== null && !isNaN(value) && !isObject(value) ?\n\t\t\t\t\t\t+value :\n\t\t\t\t\t\t(isArray(value) || isObject(value) ? value : null);\n\n\t\t\t\t\t// use x as categories if custom x and categorized\n\t\t\t\t\tif ((isCategory || state.hasRadar) && index === 0 && !isUndefined(rawX)) {\n\t\t\t\t\t\tif (!hasCategory && index === 0 && i === 0 && !isDataAppend) {\n\t\t\t\t\t\t\tconfig.axis_x_categories = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx = config.axis_x_categories.indexOf(rawX);\n\n\t\t\t\t\t\tif (x === -1) {\n\t\t\t\t\t\t\tx = config.axis_x_categories.length;\n\t\t\t\t\t\t\tconfig.axis_x_categories.push(rawX);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = $$.generateTargetX(rawX, id, xIndex + i);\n\t\t\t\t\t}\n\n\t\t\t\t\t// mark as x = undefined if value is undefined and filter to remove after mapped\n\t\t\t\t\tif (isUndefined(value) || $$.data.xs[id].length <= i) {\n\t\t\t\t\t\tx = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tid: convertedId,\n\t\t\t\t\t\tindex: -1\n\t\t\t\t\t};\n\t\t\t\t}).filter(v => isDefined(v.x))\n\t\t\t};\n\t\t});\n\n\t\t// finish targets\n\t\ttargets.forEach(t => {\n\t\t\t// sort values by its x\n\t\t\tif (config.data_xSort) {\n\t\t\t\tt.values = t.values.sort((v1, v2) => {\n\t\t\t\t\tconst x1 = v1.x || v1.x === 0 ? v1.x : Infinity;\n\t\t\t\t\tconst x2 = v2.x || v2.x === 0 ? v2.x : Infinity;\n\n\t\t\t\t\treturn x1 - x2;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// indexing each value\n\t\t\tt.values.forEach((v, i) => (v.index = i));\n\n\t\t\t// this needs to be sorted because its index and value.index is identical\n\t\t\t$$.data.xs[t.id]?.sort((v1, v2) => v1 - v2);\n\t\t});\n\n\t\t// cache information about values\n\t\tstate.hasNegativeValue = $$.hasNegativeValueInTargets(targets);\n\t\tstate.hasPositiveValue = $$.hasPositiveValueInTargets(targets);\n\n\t\t// set target types\n\t\tif (chartType && $$.isValidChartType(chartType)) {\n\t\t\tconst targetIds = $$.mapToIds(targets)\n\t\t\t\t.filter(id =>\n\t\t\t\t\t!(id in config.data_types) || !$$.isValidChartType(config.data_types[id])\n\t\t\t\t);\n\n\t\t\t$$.setTargetType(targetIds, chartType);\n\t\t}\n\n\t\t// cache as original id keyed\n\t\ttargets.forEach(d => $$.cache.add(d.id_org, d, true));\n\n\t\treturn targets as IData[];\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$BAR, $CANDLESTICK, $COMMON} from \"../../config/classes\";\nimport {KEY} from \"../../module/Cache\";\nimport {\n\tfindIndex,\n\tgetScrollPosition,\n\tgetTransformCTM,\n\tgetUnique,\n\thasValue,\n\thasViewBox,\n\tisArray,\n\tisBoolean,\n\tisDefined,\n\tisFunction,\n\tisNumber,\n\tisObject,\n\tisObjectType,\n\tisString,\n\tisUndefined,\n\tisValue,\n\tmergeArray,\n\tnotEmpty,\n\tparseDate,\n\tsortValue\n} from \"../../module/util\";\nimport type {IData, IDataPoint, IDataRow} from \"./IData\";\n\nexport default {\n\tisX(key) {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst dataKey = config.data_x && key === config.data_x;\n\t\tconst existValue = notEmpty(config.data_xs) && hasValue(config.data_xs, key);\n\n\t\treturn dataKey || existValue;\n\t},\n\n\tisNotX(key): boolean {\n\t\treturn !this.isX(key);\n\t},\n\n\tisStackNormalized(): boolean {\n\t\tconst {config} = this;\n\n\t\treturn !!(config.data_stack_normalize && config.data_groups.length);\n\t},\n\n\t/**\n\t * Check if given id is grouped data or has grouped data\n\t * @param {string} id Data id value\n\t * @returns {boolean} is grouped data or has grouped data\n\t * @private\n\t */\n\tisGrouped(id?: string): boolean {\n\t\tconst groups = this.config.data_groups;\n\n\t\treturn id ? groups.some(v => v.indexOf(id) >= 0 && v.length > 1) : groups.length > 0;\n\t},\n\n\tgetXKey(id) {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\treturn config.data_x ?\n\t\t\tconfig.data_x :\n\t\t\t(notEmpty(config.data_xs) ? config.data_xs[id] : null);\n\t},\n\n\tgetXValuesOfXKey(key, targets) {\n\t\tconst $$ = this;\n\t\tconst ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];\n\t\tlet xValues;\n\n\t\tids.forEach(id => {\n\t\t\tif ($$.getXKey(id) === key) {\n\t\t\t\txValues = $$.data.xs[id];\n\t\t\t}\n\t\t});\n\n\t\treturn xValues;\n\t},\n\n\t/**\n\t * Get index number based on given x Axis value\n\t * @param {Date|number|string} x x Axis to be compared\n\t * @param {Array} basedX x Axis list to be based on\n\t * @returns {number} index number\n\t * @private\n\t */\n\tgetIndexByX(x: Date | number | string, basedX: (Date | number | string)[]): number {\n\t\tconst $$ = this;\n\n\t\treturn basedX ?\n\t\t\tbasedX.indexOf(isString(x) ? x : +x) :\n\t\t\t($$.filterByX($$.data.targets, x)[0] || {index: null}).index;\n\t},\n\n\tgetXValue(id: string, i: number): number {\n\t\tconst $$ = this;\n\n\t\treturn id in $$.data.xs &&\n\t\t\t\t$$.data.xs[id] &&\n\t\t\t\tisValue($$.data.xs[id][i]) ?\n\t\t\t$$.data.xs[id][i] :\n\t\t\ti;\n\t},\n\n\tgetOtherTargetXs(): string | null {\n\t\tconst $$ = this;\n\t\tconst idsForX = Object.keys($$.data.xs);\n\n\t\treturn idsForX.length ? $$.data.xs[idsForX[0]] : null;\n\t},\n\n\tgetOtherTargetX(index: number): string | null {\n\t\tconst xs = this.getOtherTargetXs();\n\n\t\treturn xs && index < xs.length ? xs[index] : null;\n\t},\n\n\taddXs(xs): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tObject.keys(xs).forEach(id => {\n\t\t\tconfig.data_xs[id] = xs[id];\n\t\t});\n\t},\n\n\t/**\n\t * Determine if x axis is multiple\n\t * @returns {boolean} true: multiple, false: single\n\t * @private\n\t */\n\tisMultipleX(): boolean {\n\t\treturn !this.config.axis_x_forceAsSingle && (\n\t\t\tnotEmpty(this.config.data_xs) ||\n\t\t\tthis.hasType(\"bubble\") ||\n\t\t\tthis.hasType(\"scatter\")\n\t\t);\n\t},\n\n\taddName(data) {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tlet name;\n\n\t\tif (data) {\n\t\t\tname = config.data_names[data.id];\n\t\t\tdata.name = name !== undefined ? name : data.id;\n\t\t}\n\n\t\treturn data;\n\t},\n\n\t/**\n\t * Get all values on given index\n\t * @param {number} index Index\n\t * @param {boolean} filterNull Filter nullish value\n\t * @returns {Array}\n\t * @private\n\t */\n\tgetAllValuesOnIndex(index: number, filterNull = false) {\n\t\tconst $$ = this;\n\n\t\tlet value = $$.filterTargetsToShow($$.data.targets)\n\t\t\t.map(t => $$.addName($$.getValueOnIndex(t.values, index)));\n\n\t\tif (filterNull) {\n\t\t\tvalue = value.filter(v => v && \"value\" in v && isValue(v.value));\n\t\t}\n\n\t\treturn value;\n\t},\n\n\tgetValueOnIndex(values, index: number) {\n\t\tconst valueOnIndex = values.filter(v => v.index === index);\n\n\t\treturn valueOnIndex.length ? valueOnIndex[0] : null;\n\t},\n\n\tupdateTargetX(targets, x) {\n\t\tconst $$ = this;\n\n\t\ttargets.forEach(t => {\n\t\t\tt.values.forEach((v, i) => {\n\t\t\t\tv.x = $$.generateTargetX(x[i], t.id, i);\n\t\t\t});\n\n\t\t\t$$.data.xs[t.id] = x;\n\t\t});\n\t},\n\n\tupdateTargetXs(targets, xs) {\n\t\tconst $$ = this;\n\n\t\ttargets.forEach(t => {\n\t\t\txs[t.id] && $$.updateTargetX([t], xs[t.id]);\n\t\t});\n\t},\n\n\tgenerateTargetX(rawX, id: string, index: number) {\n\t\tconst $$ = this;\n\t\tconst {axis} = $$;\n\t\tlet x = axis?.isCategorized() ? index : (rawX || index);\n\n\t\tif (axis?.isTimeSeries()) {\n\t\t\tconst fn = parseDate.bind($$);\n\n\t\t\tx = rawX ? fn(rawX) : fn($$.getXValue(id, index));\n\t\t} else if (axis?.isCustomX() && !axis?.isCategorized()) {\n\t\t\tx = isValue(rawX) ? +rawX : $$.getXValue(id, index);\n\t\t}\n\n\t\treturn x;\n\t},\n\n\tupdateXs(values): void {\n\t\tif (values.length) {\n\t\t\tthis.axis.xs = values.map(v => v.x);\n\t\t}\n\t},\n\n\tgetPrevX(i: number): number[] | null {\n\t\tconst x = this.axis.xs[i - 1];\n\n\t\treturn isDefined(x) ? x : null;\n\t},\n\n\tgetNextX(i: number): number[] | null {\n\t\tconst x = this.axis.xs[i + 1];\n\n\t\treturn isDefined(x) ? x : null;\n\t},\n\n\t/**\n\t * Get base value isAreaRangeType\n\t * @param {object} data Data object\n\t * @returns {number}\n\t * @private\n\t */\n\tgetBaseValue(data): number {\n\t\tconst $$ = this;\n\t\tconst {hasAxis} = $$.state;\n\t\tlet {value} = data;\n\n\t\t// In case of area-range, data is given as: [low, mid, high] or {low, mid, high}\n\t\t// will take the 'mid' as the base value\n\t\tif (value && hasAxis) {\n\t\t\tif ($$.isAreaRangeType(data)) {\n\t\t\t\tvalue = $$.getRangedData(data, \"mid\");\n\t\t\t} else if ($$.isBubbleZType(data)) {\n\t\t\t\tvalue = $$.getBubbleZData(value, \"y\");\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Get min/max value from the data\n\t * @private\n\t * @param {Array} data array data to be evaluated\n\t * @returns {{min: {number}, max: {number}}}\n\t */\n\tgetMinMaxValue(data): {min: number, max: number} {\n\t\tconst getBaseValue = this.getBaseValue.bind(this);\n\t\tlet min;\n\t\tlet max;\n\n\t\t(data || this.data.targets.map(t => t.values))\n\t\t\t.forEach((v, i) => {\n\t\t\t\tconst value = v.map(getBaseValue).filter(isNumber);\n\n\t\t\t\tmin = Math.min(i ? min : Infinity, ...value);\n\t\t\t\tmax = Math.max(i ? max : -Infinity, ...value);\n\t\t\t});\n\n\t\treturn {min, max};\n\t},\n\n\t/**\n\t * Get the min/max data\n\t * @private\n\t * @returns {{min: Array, max: Array}}\n\t */\n\tgetMinMaxData(): {min: IDataRow[], max: IDataRow[]} {\n\t\tconst $$ = this;\n\t\tconst cacheKey = KEY.dataMinMax;\n\t\tlet minMaxData = $$.cache.get(cacheKey);\n\n\t\tif (!minMaxData) {\n\t\t\tconst data = $$.data.targets.map(t => t.values);\n\t\t\tconst minMax = $$.getMinMaxValue(data);\n\n\t\t\tlet min = [];\n\t\t\tlet max = [];\n\n\t\t\t// Cache the getFilteredDataByValue function calls\n\t\t\tconst {min: minVal, max: maxVal} = minMax;\n\n\t\t\tdata.forEach(v => {\n\t\t\t\tconst minData = $$.getFilteredDataByValue(v, minVal);\n\t\t\t\tconst maxData = $$.getFilteredDataByValue(v, maxVal);\n\n\t\t\t\tif (minData.length) {\n\t\t\t\t\tmin = min.concat(minData);\n\t\t\t\t}\n\n\t\t\t\tif (maxData.length) {\n\t\t\t\t\tmax = max.concat(maxData);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// update the cached data\n\t\t\t$$.cache.add(cacheKey, minMaxData = {min, max});\n\t\t}\n\n\t\treturn minMaxData;\n\t},\n\n\t/**\n\t * Get sum of data per index\n\t * @private\n\t * @returns {Array}\n\t */\n\tgetTotalPerIndex() {\n\t\tconst $$ = this;\n\t\tconst cacheKey = KEY.dataTotalPerIndex;\n\t\tlet sum = $$.cache.get(cacheKey);\n\n\t\tif (($$.config.data_groups.length || $$.isStackNormalized()) && !sum) {\n\t\t\tsum = [];\n\n\t\t\t$$.data.targets.forEach(row => {\n\t\t\t\trow.values.forEach((v, i) => {\n\t\t\t\t\tif (!sum[i]) {\n\t\t\t\t\t\tsum[i] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tsum[i] += ~~v.value;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn sum;\n\t},\n\n\t/**\n\t * Get total data sum\n\t * @param {boolean} subtractHidden Subtract hidden data from total\n\t * @returns {number}\n\t * @private\n\t */\n\tgetTotalDataSum(subtractHidden) {\n\t\tconst $$ = this;\n\t\tconst cacheKey = KEY.dataTotalSum;\n\t\tlet total = $$.cache.get(cacheKey);\n\n\t\tif (!isNumber(total)) {\n\t\t\ttotal = $$.data.targets.reduce((acc, t) => {\n\t\t\t\treturn acc + t.values.reduce((sum, v) => sum + ~~v.value, 0);\n\t\t\t}, 0);\n\n\t\t\t$$.cache.add(cacheKey, total);\n\t\t}\n\n\t\tif (subtractHidden) {\n\t\t\ttotal -= $$.getHiddenTotalDataSum();\n\t\t}\n\n\t\treturn total;\n\t},\n\n\t/**\n\t * Get total hidden data sum\n\t * @returns {number}\n\t * @private\n\t */\n\tgetHiddenTotalDataSum() {\n\t\tconst $$ = this;\n\t\tconst {api, state: {hiddenTargetIds}} = $$;\n\t\tlet total = 0;\n\n\t\tif (hiddenTargetIds.length) {\n\t\t\ttotal = api.data.values.bind(api)(hiddenTargetIds)\n\t\t\t\t.reduce((p, c) => p + c);\n\t\t}\n\n\t\treturn total;\n\t},\n\n\t/**\n\t * Get filtered data by value\n\t * @param {object} data Data\n\t * @param {number} value Value to be filtered\n\t * @returns {Array} filtered array data\n\t * @private\n\t */\n\tgetFilteredDataByValue(data, value) {\n\t\treturn data.filter(t => this.getBaseValue(t) === value);\n\t},\n\n\t/**\n\t * Return the max length of the data\n\t * @returns {number} max data length\n\t * @private\n\t */\n\tgetMaxDataCount(): number {\n\t\treturn Math.max(...this.data.targets.map(t => t.values.length), 0);\n\t},\n\n\tgetMaxDataCountTarget() {\n\t\tlet target = this.filterTargetsToShow() || [];\n\t\tconst length = target.length;\n\t\tconst isInverted = this.config.axis_x_inverted;\n\n\t\tif (length > 1) {\n\t\t\ttarget = target.map(t => t.values)\n\t\t\t\t.reduce((a, b) => a.concat(b))\n\t\t\t\t.map(v => v.x);\n\n\t\t\ttarget = sortValue(getUnique(target))\n\t\t\t\t.map((x, index, array) => ({\n\t\t\t\t\tx,\n\t\t\t\t\tindex: isInverted ? array.length - index - 1 : index\n\t\t\t\t}));\n\t\t} else if (length) {\n\t\t\ttarget = target[0].values.concat();\n\t\t}\n\n\t\treturn target;\n\t},\n\n\tmapToIds(targets): string[] {\n\t\treturn targets.map(d => d.id);\n\t},\n\n\tmapToTargetIds(ids?: string[] | string): string[] {\n\t\tconst $$ = this;\n\n\t\treturn ids ? (isArray(ids) ? ids.concat() : [ids]) : $$.mapToIds($$.data.targets);\n\t},\n\n\thasTarget(targets, id): boolean {\n\t\tconst ids = this.mapToIds(targets);\n\n\t\tfor (let i = 0, val; (val = ids[i]); i++) {\n\t\t\tif (val === id) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tisTargetToShow(targetId): boolean {\n\t\treturn this.state.hiddenTargetIds.indexOf(targetId) < 0;\n\t},\n\n\tisLegendToShow(targetId): boolean {\n\t\treturn this.state.hiddenLegendIds.indexOf(targetId) < 0;\n\t},\n\n\tfilterTargetsToShow(targets?) {\n\t\tconst $$ = this;\n\n\t\treturn (targets || $$.data.targets).filter(t => $$.isTargetToShow(t.id));\n\t},\n\n\tmapTargetsToUniqueXs(targets) {\n\t\tconst $$ = this;\n\t\tconst {axis} = $$;\n\t\tlet xs: any[] = [];\n\n\t\tif (targets?.length) {\n\t\t\txs = getUnique(\n\t\t\t\tmergeArray(targets.map(t => t.values.map(v => +v.x)))\n\t\t\t);\n\n\t\t\txs = axis?.isTimeSeries() ? xs.map(x => new Date(+x)) : xs.map(Number);\n\t\t}\n\n\t\treturn sortValue(xs);\n\t},\n\n\t/**\n\t * Add to the state target Ids\n\t * @param {string} type State's prop name\n\t * @param {Array|string} targetIds Target ids array\n\t * @private\n\t */\n\taddTargetIds(type: string, targetIds: string[] | string): void {\n\t\tconst {state} = this;\n\t\tconst ids = (isArray(targetIds) ? targetIds : [targetIds]) as [];\n\n\t\tids.forEach(v => {\n\t\t\tstate[type].indexOf(v) < 0 &&\n\t\t\t\tstate[type].push(v);\n\t\t});\n\t},\n\n\t/**\n\t * Remove from the state target Ids\n\t * @param {string} type State's prop name\n\t * @param {Array|string} targetIds Target ids array\n\t * @private\n\t */\n\tremoveTargetIds(type: string, targetIds: string[] | string): void {\n\t\tconst {state} = this;\n\t\tconst ids = (isArray(targetIds) ? targetIds : [targetIds]) as [];\n\n\t\tids.forEach(v => {\n\t\t\tconst index = state[type].indexOf(v);\n\n\t\t\tindex >= 0 && state[type].splice(index, 1);\n\t\t});\n\t},\n\n\taddHiddenTargetIds(targetIds: string[]): void {\n\t\tthis.addTargetIds(\"hiddenTargetIds\", targetIds);\n\t},\n\n\tremoveHiddenTargetIds(targetIds: string[]): void {\n\t\tthis.removeTargetIds(\"hiddenTargetIds\", targetIds);\n\t},\n\n\taddHiddenLegendIds(targetIds: string[]): void {\n\t\tthis.addTargetIds(\"hiddenLegendIds\", targetIds);\n\t},\n\n\tremoveHiddenLegendIds(targetIds: string[]): void {\n\t\tthis.removeTargetIds(\"hiddenLegendIds\", targetIds);\n\t},\n\n\tgetValuesAsIdKeyed(targets) {\n\t\tconst $$ = this;\n\t\tconst {hasAxis} = $$.state;\n\t\tconst ys = {};\n\t\tconst isMultipleX = $$.isMultipleX();\n\t\tconst xs = isMultipleX ?\n\t\t\t$$.mapTargetsToUniqueXs(targets)\n\t\t\t\t.map(v => (isString(v) ? v : +v)) :\n\t\t\tnull;\n\n\t\ttargets.forEach(t => {\n\t\t\tconst data: any[] = [];\n\n\t\t\tt.values\n\t\t\t\t.filter(({value}) => isValue(value) || value === null)\n\t\t\t\t.forEach(v => {\n\t\t\t\t\tlet {value} = v;\n\n\t\t\t\t\t// exclude 'volume' value to correct mis domain calculation\n\t\t\t\t\tif (value !== null && $$.isCandlestickType(v)) {\n\t\t\t\t\t\tvalue = isArray(value) ?\n\t\t\t\t\t\t\tvalue.slice(0, 4) :\n\t\t\t\t\t\t\t[value.open, value.high, value.low, value.close];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\tdata.push(...value);\n\t\t\t\t\t} else if (isObject(value) && \"high\" in value) {\n\t\t\t\t\t\tdata.push(...Object.values(value));\n\t\t\t\t\t} else if ($$.isBubbleZType(v)) {\n\t\t\t\t\t\tdata.push(hasAxis && $$.getBubbleZData(value, \"y\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isMultipleX) {\n\t\t\t\t\t\t\tdata[$$.getIndexByX(v.x, xs)] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tys[t.id] = data;\n\t\t});\n\n\t\treturn ys;\n\t},\n\n\tcheckValueInTargets(targets, checker: Function): boolean {\n\t\treturn Object.keys(targets)\n\t\t\t.some(id => targets[id].values.some(v => checker(v.value)));\n\t},\n\n\thasMultiTargets(): boolean {\n\t\treturn this.filterTargetsToShow().length > 1;\n\t},\n\n\thasNegativeValueInTargets(targets): boolean {\n\t\treturn this.checkValueInTargets(targets, v => v < 0);\n\t},\n\n\thasPositiveValueInTargets(targets): boolean {\n\t\treturn this.checkValueInTargets(targets, v => v > 0);\n\t},\n\n\t/**\n\t * Sort targets data\n\t * Note: For stacked bar, will sort from the total sum of data series, not for each stacked bar\n\t * @param {Array} targetsValue Target value\n\t * @returns {Array}\n\t * @private\n\t */\n\torderTargets(targetsValue: IData[]): IData[] {\n\t\tconst $$ = this;\n\t\tconst targets = [...targetsValue];\n\t\tconst fn = $$.getSortCompareFn();\n\n\t\tfn && targets.sort(fn);\n\n\t\treturn targets;\n\t},\n\n\t/**\n\t * Get data.order compare function\n\t * @param {boolean} isReversed for Arc & Treemap type sort order needs to be reversed\n\t * @returns {Function} compare function\n\t * @private\n\t */\n\tgetSortCompareFn(isReversed = false): Function | null {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst order = config.data_order;\n\t\tconst orderAsc = /asc/i.test(order);\n\t\tconst orderDesc = /desc/i.test(order);\n\t\tlet fn;\n\n\t\tif (orderAsc || orderDesc) {\n\t\t\tconst reducer = (p, c) => p + Math.abs(c.value);\n\t\t\tconst sum = v => (isNumber(v) ? v : (\n\t\t\t\t\"values\" in v ? v.values.reduce(reducer, 0) : v.value\n\t\t\t));\n\n\t\t\tfn = (t1: IData | IDataRow, t2: IData | IDataRow) => {\n\t\t\t\tconst t1Sum = sum(t1);\n\t\t\t\tconst t2Sum = sum(t2);\n\n\t\t\t\treturn isReversed ?\n\t\t\t\t\t(orderAsc ? t1Sum - t2Sum : t2Sum - t1Sum) :\n\t\t\t\t\t(orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum);\n\t\t\t};\n\t\t} else if (isFunction(order)) {\n\t\t\tfn = order.bind($$.api);\n\t\t}\n\n\t\treturn fn || null;\n\t},\n\n\tfilterByX(targets, x) {\n\t\treturn mergeArray(targets.map(t => t.values)).filter(v => v.x - x === 0);\n\t},\n\n\tfilterNullish(data) {\n\t\tconst filter = v => isValue(v.value);\n\n\t\treturn data ?\n\t\t\tdata.filter(\n\t\t\t\tv => \"value\" in v ? filter(v) : v.values.some(filter)\n\t\t\t) :\n\t\t\tdata;\n\t},\n\n\tfilterRemoveNull(data) {\n\t\treturn data.filter(d => isValue(this.getBaseValue(d)));\n\t},\n\n\tfilterByXDomain(targets, xDomain) {\n\t\treturn targets.map(t => ({\n\t\t\tid: t.id,\n\t\t\tid_org: t.id_org,\n\t\t\tvalues: t.values.filter(v => xDomain[0] <= v.x && v.x <= xDomain[1])\n\t\t}));\n\t},\n\n\thasDataLabel() {\n\t\tconst dataLabels = this.config.data_labels;\n\n\t\treturn (isBoolean(dataLabels) && dataLabels) ||\n\t\t\t(isObjectType(dataLabels) && notEmpty(dataLabels));\n\t},\n\n\t/**\n\t * Determine if has null value\n\t * @param {Array} targets Data array to be evaluated\n\t * @returns {boolean}\n\t * @private\n\t */\n\thasNullDataValue(targets: IDataRow[]): boolean {\n\t\treturn targets.some(({value}) => value === null);\n\t},\n\n\t/**\n\t * Get data index from the event coodinates\n\t * @param {Event} event Event object\n\t * @returns {number}\n\t * @private\n\t */\n\tgetDataIndexFromEvent(event): number {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\t$el,\n\t\t\tconfig,\n\t\t\tstate: {hasRadar, inputType, eventReceiver: {coords, rect}}\n\t\t} = $$;\n\t\tlet index;\n\n\t\tif (hasRadar) {\n\t\t\tlet target = event.target;\n\n\t\t\t// in case of multilined axis text\n\t\t\tif (/tspan/i.test(target.tagName)) {\n\t\t\t\ttarget = target.parentNode;\n\t\t\t}\n\n\t\t\tconst d: any = d3Select(target).datum();\n\n\t\t\tindex = d && Object.keys(d).length === 1 ? d.index : undefined;\n\t\t} else {\n\t\t\tconst isRotated = config.axis_rotated;\n\t\t\tconst scrollPos = getScrollPosition($el.chart.node());\n\n\t\t\t// get data based on the mouse coords\n\t\t\tconst e = inputType === \"touch\" && event.changedTouches ?\n\t\t\t\tevent.changedTouches[0] :\n\t\t\t\tevent;\n\n\t\t\tlet point = isRotated ? e.clientY + scrollPos.y : e.clientX + scrollPos.x;\n\n\t\t\tif (hasViewBox($el.svg)) {\n\t\t\t\tconst pos = [point, 0];\n\n\t\t\t\tisRotated && pos.reverse();\n\t\t\t\tpoint = getTransformCTM($el.eventRect.node(), ...pos)[isRotated ? \"y\" : \"x\"];\n\t\t\t} else {\n\t\t\t\tpoint -= isRotated ? rect.top : rect.left;\n\t\t\t}\n\n\t\t\tindex = findIndex(\n\t\t\t\tcoords,\n\t\t\t\tpoint,\n\t\t\t\t0,\n\t\t\t\tcoords.length - 1,\n\t\t\t\tisRotated\n\t\t\t);\n\t\t}\n\n\t\treturn index;\n\t},\n\n\tgetDataLabelLength(min: number, max: number, key: \"width\" | \"height\"): number[] {\n\t\tconst $$ = this;\n\t\tconst paddingCoef = 1.3;\n\n\t\treturn $$.getTextRect(\n\t\t\t[min, max].map(v => $$.dataLabelFormat()(v))\n\t\t)?.map((rect: DOMRect) => rect[key] * paddingCoef) || [0, 0];\n\t},\n\n\tisNoneArc(d) {\n\t\treturn this.hasTarget(this.data.targets, d.id);\n\t},\n\n\tisArc(d) {\n\t\treturn \"data\" in d && this.hasTarget(this.data.targets, d.data.id);\n\t},\n\n\tfindSameXOfValues(values, index) {\n\t\tconst targetX = values[index].x;\n\t\tconst sames: any[] = [];\n\t\tlet i;\n\n\t\tfor (i = index - 1; i >= 0; i--) {\n\t\t\tif (targetX !== values[i].x) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsames.push(values[i]);\n\t\t}\n\n\t\tfor (i = index; i < values.length; i++) {\n\t\t\tif (targetX !== values[i].x) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsames.push(values[i]);\n\t\t}\n\n\t\treturn sames;\n\t},\n\n\tfindClosestFromTargets(targets, pos: [number, number]): IDataRow | undefined {\n\t\tconst $$ = this;\n\t\tconst candidates = targets.map(target => $$.findClosest(target.values, pos)); // map to array of closest points of each target\n\n\t\t// decide closest point and return\n\t\treturn $$.findClosest(candidates, pos);\n\t},\n\n\tfindClosest(values, pos: [number, number]): IDataRow | undefined {\n\t\tconst $$ = this;\n\t\tconst {$el: {main}} = $$;\n\t\tconst data = values.filter(v => v && isValue(v.value));\n\n\t\tlet minDist;\n\t\tlet closest;\n\n\t\t// find mouseovering bar/candlestick\n\t\t// https://github.com/naver/billboard.js/issues/2434\n\t\tdata\n\t\t\t.filter(v => $$.isBarType(v.id) || $$.isCandlestickType(v.id))\n\t\t\t.forEach(v => {\n\t\t\t\tconst selector = $$.isBarType(v.id) ?\n\t\t\t\t\t`.${$BAR.chartBar}.${$COMMON.target}${\n\t\t\t\t\t\t$$.getTargetSelectorSuffix(v.id)\n\t\t\t\t\t} .${$BAR.bar}-${v.index}` :\n\t\t\t\t\t`.${$CANDLESTICK.chartCandlestick}.${$COMMON.target}${\n\t\t\t\t\t\t$$.getTargetSelectorSuffix(v.id)\n\t\t\t\t\t} .${$CANDLESTICK.candlestick}-${v.index} path`;\n\n\t\t\t\tif (!closest && $$.isWithinBar(main.select(selector).node())) {\n\t\t\t\t\tclosest = v;\n\t\t\t\t}\n\t\t\t});\n\n\t\t// find closest point from non-bar/candlestick\n\t\tdata\n\t\t\t.filter(v => !$$.isBarType(v.id) && !$$.isCandlestickType(v.id))\n\t\t\t.forEach((v: IDataPoint) => {\n\t\t\t\tconst d = $$.dist(v, pos);\n\n\t\t\t\tminDist = $$.getPointSensitivity(v);\n\n\t\t\t\tif (d < minDist) {\n\t\t\t\t\tminDist = d;\n\t\t\t\t\tclosest = v;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn closest;\n\t},\n\n\tdist(data: IDataPoint, pos: [number, number]) {\n\t\tconst $$ = this;\n\t\tconst {config: {axis_rotated: isRotated}, scale} = $$;\n\t\tconst xIndex = +isRotated; // true: 1, false: 0\n\t\tconst yIndex = +!isRotated; // true: 0, false: 1\n\t\tconst y = $$.circleY(data, data.index);\n\t\tconst x = (scale.zoom || scale.x)(data.x);\n\n\t\treturn Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));\n\t},\n\n\t/**\n\t * Convert data for step type\n\t * @param {Array} values Object data values\n\t * @returns {Array}\n\t * @private\n\t */\n\tconvertValuesToStep(values) {\n\t\tconst $$ = this;\n\t\tconst {axis, config} = $$;\n\t\tconst stepType = config.line_step_type;\n\t\tconst isCategorized = axis ? axis.isCategorized() : false;\n\t\tconst converted = isArray(values) ? values.concat() : [values];\n\n\t\tif (!(isCategorized || /step\\-(after|before)/.test(stepType))) {\n\t\t\treturn values;\n\t\t}\n\n\t\t// when all datas are null, return empty array\n\t\t// https://github.com/naver/billboard.js/issues/3124\n\t\tif (converted.length) {\n\t\t\t// insert & append cloning first/last value to be fully rendered covering on each gap sides\n\t\t\tconst head = converted[0];\n\t\t\tconst tail = converted[converted.length - 1];\n\t\t\tconst {id} = head;\n\t\t\tlet {x} = head;\n\n\t\t\t// insert head\n\t\t\tconverted.unshift({x: --x, value: head.value, id});\n\n\t\t\tisCategorized && stepType === \"step-after\" &&\n\t\t\t\tconverted.unshift({x: --x, value: head.value, id});\n\n\t\t\t// append tail\n\t\t\tx = tail.x;\n\t\t\tconverted.push({x: ++x, value: tail.value, id});\n\n\t\t\tisCategorized && stepType === \"step-before\" &&\n\t\t\t\tconverted.push({x: ++x, value: tail.value, id});\n\t\t}\n\n\t\treturn converted;\n\t},\n\n\tconvertValuesToRange(values) {\n\t\tconst converted = isArray(values) ? values.concat() : [values];\n\t\tconst ranges: {x: string | number, id: string, value: number}[] = [];\n\n\t\tconverted.forEach(range => {\n\t\t\tconst {x, id} = range;\n\n\t\t\tranges.push({\n\t\t\t\tx,\n\t\t\t\tid,\n\t\t\t\tvalue: range.value[0]\n\t\t\t});\n\n\t\t\tranges.push({\n\t\t\t\tx,\n\t\t\t\tid,\n\t\t\t\tvalue: range.value[2]\n\t\t\t});\n\t\t});\n\n\t\treturn ranges;\n\t},\n\n\tupdateDataAttributes(name, attrs) {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst current = config[`data_${name}`];\n\n\t\tif (isUndefined(attrs)) {\n\t\t\treturn current;\n\t\t}\n\n\t\tObject.keys(attrs).forEach(id => {\n\t\t\tcurrent[id] = attrs[id];\n\t\t});\n\n\t\t$$.redraw({withLegend: true});\n\n\t\treturn current;\n\t},\n\n\tgetRangedData(d, key = \"\", type = \"areaRange\"): number | undefined {\n\t\tconst value = d?.value;\n\n\t\tif (isArray(value)) {\n\t\t\tif (type === \"bar\") {\n\t\t\t\treturn value.reduce((a, c) => c - a);\n\t\t\t} else {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst index = {\n\t\t\t\t\tareaRange: [\"high\", \"mid\", \"low\"],\n\t\t\t\t\tcandlestick: [\"open\", \"high\", \"low\", \"close\", \"volume\"]\n\t\t\t\t}[type].indexOf(key);\n\n\t\t\t\treturn index >= 0 && value ? value[index] : undefined;\n\t\t\t}\n\t\t} else if (value && key) {\n\t\t\treturn value[key];\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Set ratio for grouped data\n\t * @param {Array} data Data array\n\t * @private\n\t */\n\tsetRatioForGroupedData(data: (IDataRow | IData)[]): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\t// calculate ratio if grouped data exists\n\t\tif (config.data_groups.length && data.some(d => $$.isGrouped(d.id))) {\n\t\t\tconst setter = (d: IDataRow) => $$.getRatio(\"index\", d, true);\n\n\t\t\tdata.forEach(v => {\n\t\t\t\t\"values\" in v ? v.values.forEach(setter) : setter(v);\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Get ratio value\n\t * @param {string} type Ratio for given type\n\t * @param {object} d Data value object\n\t * @param {boolean} asPercent Convert the return as percent or not\n\t * @returns {number} Ratio value\n\t * @private\n\t */\n\tgetRatio(type: string, d, asPercent = false): number {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst api = $$.api;\n\t\tlet ratio = 0;\n\n\t\tif (d && api.data.shown().length) {\n\t\t\tratio = d.ratio || d.value;\n\n\t\t\tif (type === \"arc\") {\n\t\t\t\t// if has padAngle set, calculate rate based on value\n\t\t\t\tif ($$.pie.padAngle()()) {\n\t\t\t\t\tratio = d.value / $$.getTotalDataSum(true);\n\n\t\t\t\t\t// otherwise, based on the rendered angle value\n\t\t\t\t} else {\n\t\t\t\t\tconst gaugeArcLength = config.gauge_fullCircle ?\n\t\t\t\t\t\t$$.getArcLength() :\n\t\t\t\t\t\t$$.getStartingAngle() * -2;\n\t\t\t\t\tconst arcLength = $$.hasType(\"gauge\") ? gaugeArcLength : Math.PI * 2;\n\n\t\t\t\t\tratio = (d.endAngle - d.startAngle) / arcLength;\n\t\t\t\t}\n\t\t\t} else if (type === \"index\") {\n\t\t\t\tconst dataValues = api.data.values.bind(api);\n\t\t\t\tlet total = this.getTotalPerIndex();\n\n\t\t\t\tif (state.hiddenTargetIds.length) {\n\t\t\t\t\tlet hiddenSum = dataValues(state.hiddenTargetIds, false);\n\n\t\t\t\t\tif (hiddenSum.length) {\n\t\t\t\t\t\thiddenSum = hiddenSum\n\t\t\t\t\t\t\t.reduce((acc, curr) => acc.map((v, i) => ~~v + curr[i]));\n\n\t\t\t\t\t\ttotal = total.map((v, i) => v - hiddenSum[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst divisor = total[d.index];\n\n\t\t\t\td.ratio = isNumber(d.value) && total && divisor ? d.value / divisor : 0;\n\n\t\t\t\tratio = d.ratio;\n\t\t\t} else if (type === \"radar\") {\n\t\t\t\tratio = (\n\t\t\t\t\tparseFloat(String(Math.max(d.value, 0))) / state.current.dataMax\n\t\t\t\t) * config.radar_size_ratio;\n\t\t\t} else if (type === \"bar\") {\n\t\t\t\tconst yScale = $$.getYScaleById.bind($$)(d.id);\n\t\t\t\tconst max = yScale.domain().reduce((a, c) => c - a);\n\n\t\t\t\t// when all data are 0, return 0\n\t\t\t\tratio = max === 0 ? 0 : Math.abs(\n\t\t\t\t\t$$.getRangedData(d, null, type) / max\n\t\t\t\t);\n\t\t\t} else if (type === \"treemap\") {\n\t\t\t\tratio /= $$.getTotalDataSum(true);\n\t\t\t}\n\t\t}\n\n\t\treturn asPercent && ratio ? ratio * 100 : ratio;\n\t},\n\n\t/**\n\t * Sort data index to be aligned with x axis.\n\t * @param {Array} tickValues Tick array values\n\t * @private\n\t */\n\tupdateDataIndexByX(tickValues) {\n\t\tconst $$ = this;\n\n\t\tconst tickValueMap = tickValues.reduce((out, tick, index) => {\n\t\t\tout[Number(tick.x)] = index;\n\t\t\treturn out;\n\t\t}, {});\n\n\t\t$$.data.targets.forEach(t => {\n\t\t\tt.values.forEach((value, valueIndex) => {\n\t\t\t\tlet index = tickValueMap[Number(value.x)];\n\n\t\t\t\tif (index === undefined) {\n\t\t\t\t\tindex = valueIndex;\n\t\t\t\t}\n\t\t\t\tvalue.index = index;\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Determine if bubble has dimension data\n\t * @param {object|Array} d data value\n\t * @returns {boolean}\n\t * @private\n\t */\n\tisBubbleZType(d): boolean {\n\t\tconst $$ = this;\n\n\t\treturn $$.isBubbleType(d) && (\n\t\t\t(isObject(d.value) && (\"z\" in d.value || \"y\" in d.value)) ||\n\t\t\t(isArray(d.value) && d.value.length >= 2)\n\t\t);\n\t},\n\n\t/**\n\t * Determine if bar has ranged data\n\t * @param {Array} d data value\n\t * @returns {boolean}\n\t * @private\n\t */\n\tisBarRangeType(d): boolean {\n\t\tconst $$ = this;\n\t\tconst {value} = d;\n\n\t\treturn $$.isBarType(d) && isArray(value) && value.length >= 2 &&\n\t\t\tvalue.every(isNumber);\n\t},\n\n\t/**\n\t * Get data object by id\n\t * @param {string} id data id\n\t * @returns {object}\n\t * @private\n\t */\n\tgetDataById(id: string) {\n\t\tconst d = this.cache.get(id) || this.api.data(id);\n\n\t\treturn d?.[0] ?? d;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$LEGEND} from \"../../config/classes\";\nimport {endall} from \"../../module/util\";\n\n/**\n * Call done callback with resize after transition\n * @param {Function} fn Callback function\n * @param {boolean} resizeAfter Weather to resize chart after the load\n * @private\n */\nexport function callDone(fn, resizeAfter = false) {\n\tconst $$ = this;\n\tconst {api} = $$;\n\n\tresizeAfter && $$.api.flush(true);\n\tfn?.call(api);\n}\n\nexport default {\n\tload(rawTargets, args): void {\n\t\tconst $$ = this;\n\t\tconst {axis, data, org, scale} = $$;\n\t\tconst {append} = args;\n\t\tconst zoomState = {\n\t\t\tdomain: <any>null,\n\t\t\tcurrentDomain: <any>null,\n\t\t\tx: <any>null\n\t\t};\n\t\tlet targets = rawTargets;\n\n\t\tif (targets) {\n\t\t\t// filter loading targets if needed\n\t\t\tif (args.filter) {\n\t\t\t\ttargets = targets.filter(args.filter);\n\t\t\t}\n\n\t\t\t// set type if args.types || args.type specified\n\t\t\tif (args.type || args.types) {\n\t\t\t\ttargets.forEach(t => {\n\t\t\t\t\tconst type = args.types?.[t.id] || args.type;\n\n\t\t\t\t\t$$.setTargetType(t.id, type);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Update/Add data\n\t\t\tdata.targets.forEach(d => {\n\t\t\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\t\t\tif (d.id === targets[i].id) {\n\t\t\t\t\t\td.values = append ? d.values.concat(targets[i].values) : targets[i].values;\n\n\t\t\t\t\t\ttargets.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tdata.targets = data.targets.concat(targets); // add remained\n\t\t}\n\n\t\t// Set targets\n\t\t$$.updateTargets(data.targets);\n\n\t\tif (scale.zoom) {\n\t\t\tzoomState.x = axis.isCategorized() ?\n\t\t\t\tscale.x.orgScale() :\n\t\t\t\t(org.xScale || scale.x).copy();\n\t\t\tzoomState.domain = $$.getXDomain(data.targets); // get updated xDomain\n\n\t\t\tzoomState.x.domain(zoomState.domain);\n\t\t\tzoomState.currentDomain = $$.zoom.getDomain(); // current zoomed domain\n\n\t\t\t// reset zoom state when new data loaded is out of range\n\t\t\tif (!$$.withinRange(zoomState.currentDomain, undefined, zoomState.domain)) {\n\t\t\t\tscale.x.domain(zoomState.domain);\n\t\t\t\tscale.zoom = null;\n\t\t\t\t$$.$el.eventRect.property(\"__zoom\", null);\n\t\t\t}\n\t\t}\n\n\t\t// Redraw with new targets\n\t\t$$.redraw({\n\t\t\twithUpdateOrgXDomain: true,\n\t\t\twithUpdateXDomain: true,\n\t\t\twithLegend: true\n\t\t});\n\n\t\t// when load happens on zoom state\n\t\tif (scale.zoom) {\n\t\t\t// const x = (axis.isCategorized() ? scale.x.orgScale() : (org.xScale || scale.x)).copy();\n\n\t\t\torg.xDomain = zoomState.domain;\n\t\t\torg.xScale = zoomState.x;\n\n\t\t\tif (axis.isCategorized()) {\n\t\t\t\tzoomState.currentDomain = $$.getZoomDomainValue(zoomState.currentDomain);\n\t\t\t\torg.xDomain = $$.getZoomDomainValue(org.xDomain);\n\t\t\t\torg.xScale = zoomState.x.domain(org.xDomain);\n\t\t\t}\n\n\t\t\t$$.updateCurrentZoomTransform(zoomState.x, zoomState.currentDomain);\n\n\t\t\t// https://github.com/naver/billboard.js/issues/3878\n\t\t} else if (org.xScale) {\n\t\t\torg.xScale.domain(org.xDomain);\n\t\t}\n\n\t\t// Update current state chart type and elements list after redraw\n\t\t$$.updateTypesElements();\n\n\t\tcallDone.call($$, args.done, args.resizeAfter);\n\t},\n\n\tloadFromArgs(args): void {\n\t\tconst $$ = this;\n\n\t\t// prevent load when chart is already destroyed\n\t\tif (!$$.config) {\n\t\t\treturn;\n\t\t}\n\n\t\t// reset internally cached data\n\t\t$$.cache.reset();\n\n\t\t$$.convertData(args, d => {\n\t\t\tconst data = args.data || d;\n\n\t\t\targs.append && (data.__append__ = true);\n\t\t\tdata && $$.load($$.convertDataToTargets(data), args);\n\t\t});\n\t},\n\n\tunload(rawTargetIds, customDoneCb): void {\n\t\tconst $$ = this;\n\t\tconst {state, $el, $T} = $$;\n\t\tconst hasLegendDefsPoint = !!$$.hasLegendDefsPoint?.();\n\t\tlet done = customDoneCb;\n\t\tlet targetIds = rawTargetIds;\n\n\t\t// reset internally cached data\n\t\t$$.cache.reset();\n\n\t\tif (!done) {\n\t\t\tdone = () => {};\n\t\t}\n\n\t\t// filter existing target\n\t\ttargetIds = targetIds.filter(id => $$.hasTarget($$.data.targets, id));\n\n\t\t// If no target, call done and return\n\t\tif (!targetIds || targetIds.length === 0) {\n\t\t\tdone();\n\t\t\treturn;\n\t\t}\n\n\t\tconst targets = $el.svg.selectAll(targetIds.map(id => $$.selectorTarget(id)));\n\n\t\t$T(targets)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove()\n\t\t\t.call(endall, done);\n\n\t\ttargetIds.forEach(id => {\n\t\t\tconst suffixId = $$.getTargetSelectorSuffix(id);\n\n\t\t\t// Reset fadein for future load\n\t\t\tstate.withoutFadeIn[id] = false;\n\n\t\t\t// Remove target's elements\n\t\t\tif ($el.legend) {\n\t\t\t\t$el.legend.selectAll(`.${$LEGEND.legendItem}${suffixId}`).remove();\n\t\t\t}\n\n\t\t\t// Remove target\n\t\t\t$$.data.targets = $$.data.targets.filter(t => t.id !== id);\n\n\t\t\t// Remove custom point def element\n\t\t\thasLegendDefsPoint && $el.defs?.select(`#${$$.getDefsPointId(suffixId)}`).remove();\n\t\t});\n\n\t\t// since treemap uses different data types, it needs to be transformed\n\t\tstate.hasFunnel && $$.updateFunnel($$.data.targets);\n\n\t\t// since treemap uses different data types, it needs to be transformed\n\t\tstate.hasTreemap && $$.updateTargetsForTreemap($$.data.targets);\n\n\t\t// Update current state chart type and elements list after redraw\n\t\t$$.updateTypesElements();\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {drag as d3Drag} from \"d3-drag\";\nimport {select as d3Select} from \"d3-selection\";\nimport {$ARC, $AXIS, $COMMON, $SHAPE} from \"../../config/classes\";\nimport {KEY} from \"../../module/Cache\";\nimport {\n\temulateEvent,\n\tgetBoundingRect,\n\tgetPointer,\n\tgetTransformCTM,\n\thasViewBox,\n\tisNumber,\n\tisObject\n} from \"../../module/util\";\nimport type {IArcDataRow} from \"../data/IData\";\n\nexport default {\n\t/**\n\t * Expand data shape/point\n\t * @param {number} index Index number\n\t * @param {string} id Data id\n\t * @param {boolean} reset Reset expand state\n\t * @private\n\t */\n\tsetExpand(index: number, id?: string, reset?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {circle}} = $$;\n\n\t\tcircle && config.point_focus_expand_enabled &&\n\t\t\t$$.expandCircles(index, id, reset);\n\n\t\t// bar, candlestick\n\t\t$$.expandBarTypeShapes(true, index, id, reset);\n\t},\n\n\t/**\n\t * Expand/Unexpand bar type shapes\n\t * @param {boolean} expand Expand or unexpand\n\t * @param {number} i Shape index\n\t * @param {string} id Data id\n\t * @param {boolean} reset Reset expand style\n\t * @private\n\t */\n\texpandBarTypeShapes(expand = true, i?: number, id?: string, reset?: boolean): void {\n\t\tconst $$ = this;\n\n\t\t[\"bar\", \"candlestick\"]\n\t\t\t.filter(v => $$.$el[v])\n\t\t\t.forEach(v => {\n\t\t\t\treset && $$.$el[v].classed($COMMON.EXPANDED, false);\n\t\t\t\t$$.getShapeByIndex(v, i, id).classed($COMMON.EXPANDED, expand);\n\t\t\t});\n\t},\n\n\t/**\n\t * Handle data.onover/out callback options\n\t * @param {boolean} isOver Over or not\n\t * @param {number|object} d data object\n\t * @private\n\t */\n\tsetOverOut(isOver: boolean, d: number | IArcDataRow): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {hasFunnel, hasRadar, hasTreemap}, $el: {main}} = $$;\n\t\tconst isArcishData = isObject(d);\n\n\t\t// Call event handler\n\t\tif (isArcishData || d !== -1) {\n\t\t\tconst callback = config[isOver ? \"data_onover\" : \"data_onout\"].bind($$.api);\n\n\t\t\tconfig.color_onover && $$.setOverColor(isOver, d, isArcishData);\n\n\t\t\tif (isArcishData) {\n\t\t\t\tconst suffix = $$.getTargetSelectorSuffix((d as IArcDataRow).id);\n\t\t\t\tconst selector = hasFunnel || hasTreemap ?\n\t\t\t\t\t`${$COMMON.target + suffix} .${$SHAPE.shape}` :\n\t\t\t\t\t$ARC.arc + suffix;\n\n\t\t\t\tcallback(d, main.select(`.${selector}`).node());\n\t\t\t} else if (!config.tooltip_grouped) {\n\t\t\t\tconst last = $$.cache.get(KEY.setOverOut) || [];\n\n\t\t\t\t// select based on the index\n\t\t\t\tconst shapesAtIndex = main.selectAll(`.${$SHAPE.shape}-${d}`)\n\t\t\t\t\t.filter(function(d) {\n\t\t\t\t\t\treturn $$.isWithinShape(this, d);\n\t\t\t\t\t});\n\n\t\t\t\t// filter if has new selection\n\t\t\t\tconst shape = shapesAtIndex.filter(function() {\n\t\t\t\t\treturn last.every(v => v !== this);\n\t\t\t\t});\n\n\t\t\t\t// call onout callback\n\t\t\t\tif (\n\t\t\t\t\t!isOver || shapesAtIndex.empty() || (\n\t\t\t\t\t\tlast.length === shape.size() && shape.nodes().every((v, i) => v !== last[i])\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\twhile (last.length) {\n\t\t\t\t\t\tconst target = last.pop();\n\n\t\t\t\t\t\tconfig.data_onout.bind($$.api)(d3Select(target).datum(), target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// call onover callback\n\t\t\t\tshape.each(function() {\n\t\t\t\t\tif (isOver) {\n\t\t\t\t\t\tcallback(d3Select(this).datum(), this);\n\t\t\t\t\t\tlast.push(this);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$$.cache.add(KEY.setOverOut, last);\n\t\t\t} else {\n\t\t\t\tif (isOver) {\n\t\t\t\t\thasRadar && $$.isPointFocusOnly() ?\n\t\t\t\t\t\t$$.showCircleFocus($$.getAllValuesOnIndex(d, true)) :\n\t\t\t\t\t\t$$.setExpand(d, null, true);\n\t\t\t\t}\n\n\t\t\t\t!$$.isMultipleX() && main.selectAll(`.${$SHAPE.shape}-${d}`)\n\t\t\t\t\t.each(function(d) {\n\t\t\t\t\t\tcallback(d, this);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Call data.onover/out callback for touch event\n\t * @param {number|object} d target index or data object for Arc type\n\t * @private\n\t */\n\tcallOverOutForTouch(d): void {\n\t\tconst $$ = this;\n\t\tconst last = $$.cache.get(KEY.callOverOutForTouch);\n\n\t\tif (isObject(d) && last ? d.id !== last.id : (d !== last)) {\n\t\t\t(last || isNumber(last)) && $$.setOverOut(false, last);\n\t\t\t(d || isNumber(d)) && $$.setOverOut(true, d);\n\n\t\t\t$$.cache.add(KEY.callOverOutForTouch, d);\n\t\t}\n\t},\n\n\t/**\n\t * Return draggable selection function\n\t * @returns {Function}\n\t * @private\n\t */\n\tgetDraggableSelection(): Function {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\n\t\treturn config.interaction_enabled && config.data_selection_draggable && $$.drag ?\n\t\t\td3Drag()\n\t\t\t\t.on(\"drag\", function(event) {\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\t$$.drag(getPointer(event, <SVGElement>this));\n\t\t\t\t})\n\t\t\t\t.on(\"start\", function(event) {\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\t$$.dragstart(getPointer(event, <SVGElement>this));\n\t\t\t\t})\n\t\t\t\t.on(\"end\", event => {\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\t$$.dragend();\n\t\t\t\t}) :\n\t\t\t() => {};\n\t},\n\n\t/**\n\t * Dispatch a mouse event.\n\t * @private\n\t * @param {string} type event type\n\t * @param {number} index Index of eventRect\n\t * @param {Array} mouse x and y coordinate value\n\t */\n\tdispatchEvent(type: string, index: number, mouse: [number, number]): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\tconfig,\n\t\t\tstate: {\n\t\t\t\teventReceiver,\n\t\t\t\thasAxis,\n\t\t\t\thasFunnel,\n\t\t\t\thasRadar,\n\t\t\t\thasTreemap\n\t\t\t},\n\t\t\t$el: {eventRect, funnel, radar, svg, treemap}\n\t\t} = $$;\n\t\tlet element = (\n\t\t\t((hasFunnel || hasTreemap) && eventReceiver.rect) ||\n\t\t\t(hasRadar && radar.axes.select(`.${$AXIS.axis}-${index} text`)) || (\n\t\t\t\teventRect || $$.getArcElementByIdOrIndex?.(index)\n\t\t\t)\n\t\t)?.node?.();\n\n\t\tif (element) {\n\t\t\tconst isMultipleX = $$.isMultipleX();\n\t\t\tconst isRotated = config.axis_rotated;\n\t\t\tlet {width, left, top} = getBoundingRect(element);\n\n\t\t\tif (hasAxis && !hasRadar && !isMultipleX) {\n\t\t\t\tconst coords = eventReceiver.coords[index];\n\n\t\t\t\tif (coords) {\n\t\t\t\t\twidth = coords.w;\n\t\t\t\t\tleft += coords.x;\n\t\t\t\t\ttop += coords.y;\n\t\t\t\t} else {\n\t\t\t\t\twidth = 0;\n\t\t\t\t\tleft = 0;\n\t\t\t\t\ttop = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet x = left + (mouse ? mouse[0] : 0) + (\n\t\t\t\tisMultipleX || isRotated ? 0 : (width / 2)\n\t\t\t);\n\n\t\t\t// value 4, is to adjust coordinate value set from: scale.ts - updateScales(): $$.getResettedPadding(1)\n\t\t\tlet y = top + (mouse ? mouse[1] : 0) + (isRotated ? 4 : 0);\n\n\t\t\tif (hasViewBox(svg)) {\n\t\t\t\tconst ctm = getTransformCTM($$.$el.eventRect.node(), x, y, false);\n\n\t\t\t\tx = ctm.x;\n\t\t\t\ty = ctm.y;\n\t\t\t}\n\n\t\t\tconst params = {\n\t\t\t\tscreenX: x,\n\t\t\t\tscreenY: y,\n\t\t\t\tclientX: x,\n\t\t\t\tclientY: y,\n\t\t\t\tbubbles: hasRadar // radar type needs to bubble up event\n\t\t\t};\n\n\t\t\t// for funnel and treemap event bound to <g> node\n\t\t\tif (hasFunnel || hasTreemap) {\n\t\t\t\telement = (funnel ?? treemap).node();\n\t\t\t}\n\n\t\t\temulateEvent[/^(mouse|click)/.test(type) ? \"mouse\" : \"touch\"](\n\t\t\t\telement,\n\t\t\t\ttype,\n\t\t\t\tparams\n\t\t\t);\n\t\t}\n\t},\n\n\tsetDragStatus(isDragging: boolean): void {\n\t\tthis.state.dragging = isDragging;\n\t},\n\n\t/**\n\t * Unbind zoom events\n\t * @private\n\t */\n\tunbindZoomEvent(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {eventRect, zoomResetBtn}} = $$;\n\n\t\teventRect?.on(\".zoom wheel.zoom .drag\", null);\n\n\t\tzoomResetBtn?.on(\"click\", null)\n\t\t\t.style(\"display\", \"none\");\n\t},\n\n\t/**\n\t * Unbind all attached events\n\t * @private\n\t */\n\tunbindAllEvents(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {arcs, eventRect, legend, region, svg, treemap}, brush} = $$;\n\t\tconst list = [\n\t\t\t\"wheel\",\n\t\t\t\"click\",\n\t\t\t\"mouseover\",\n\t\t\t\"mousemove\",\n\t\t\t\"mouseout\",\n\t\t\t\"touchstart\",\n\t\t\t\"touchmove\",\n\t\t\t\"touchend\",\n\t\t\t\"touchstart.eventRect\",\n\t\t\t\"touchmove.eventRect\",\n\t\t\t\"touchend.eventRect\",\n\t\t\t\".brush\",\n\t\t\t\".drag\",\n\t\t\t\".zoom\",\n\t\t\t\"wheel.zoom\",\n\t\t\t\"dblclick.zoom\"\n\t\t].join(\" \");\n\n\t\t// detach all possible event types\n\t\t[\n\t\t\tsvg,\n\t\t\teventRect,\n\t\t\tregion?.list,\n\t\t\tbrush?.getSelection(),\n\t\t\tarcs?.selectAll(\"path\"),\n\t\t\tlegend?.selectAll(\"g\"),\n\t\t\ttreemap\n\t\t]\n\t\t\t.forEach(v => v?.on(list, null));\n\n\t\t$$.unbindZoomEvent?.();\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nexport default {\n\t/**\n\t * Category Name\n\t * @param {number} i Index number\n\t * @returns {string} category Name\n\t * @private\n\t */\n\tcategoryName(i: number): string {\n\t\tconst {axis_x_categories} = this.config;\n\n\t\treturn axis_x_categories?.[i] ?? i;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport CLASS from \"../../config/classes\";\n\nexport default {\n\tgenerateClass(prefix: string, targetId: string): string {\n\t\treturn ` ${prefix} ${prefix + this.getTargetSelectorSuffix(targetId)}`;\n\t},\n\n\t/**\n\t * Get class string\n\t * @param {string} type Shape type\n\t * @param {boolean} withShape Get with shape prefix\n\t * @returns {string} Class string\n\t * @private\n\t */\n\tgetClass(type: string, withShape: boolean): Function {\n\t\tconst isPlural = /s$/.test(type);\n\t\tconst useIdKey = /^(area|arc|line|funnel|treemap)s?$/.test(type);\n\t\tconst key = isPlural ? \"id\" : \"index\";\n\n\t\treturn (d): string => {\n\t\t\tconst data = d.data || d;\n\t\t\tconst result = (\n\t\t\t\twithShape ? this.generateClass(CLASS[isPlural ? \"shapes\" : \"shape\"], data[key]) : \"\"\n\t\t\t) + this.generateClass(CLASS[type], data[useIdKey ? \"id\" : key]);\n\n\t\t\treturn result.trim();\n\t\t};\n\t},\n\n\t/**\n\t * Get chart class string\n\t * @param {string} type Shape type\n\t * @returns {string} Class string\n\t * @private\n\t */\n\tgetChartClass(type: string) {\n\t\treturn (d): string => CLASS[`chart${type}`] + this.classTarget((d.data ? d.data : d).id);\n\t},\n\n\tgenerateExtraLineClass(): Function {\n\t\tconst $$ = this;\n\t\tconst classes = $$.config.line_classes || [];\n\t\tconst ids: string[] = [];\n\n\t\treturn function(d) {\n\t\t\tconst id: string = d.id || d.data?.id || d;\n\n\t\t\tif (ids.indexOf(id) < 0) {\n\t\t\t\tids.push(id);\n\t\t\t}\n\n\t\t\treturn classes[ids.indexOf(id) % classes.length];\n\t\t};\n\t},\n\n\tclassRegion(d, i: number): string {\n\t\treturn `${this.generateClass(CLASS.region, i)} ${\"class\" in d ? d.class : \"\"}`;\n\t},\n\n\tclassTarget(id: string): string {\n\t\tconst additionalClassSuffix = this.config.data_classes[id];\n\t\tlet additionalClass = \"\";\n\n\t\tif (additionalClassSuffix) {\n\t\t\tadditionalClass = ` ${CLASS.target}-${additionalClassSuffix}`;\n\t\t}\n\n\t\treturn this.generateClass(CLASS.target, id) + additionalClass;\n\t},\n\n\tclassFocus(d): string {\n\t\treturn this.classFocused(d) + this.classDefocused(d);\n\t},\n\n\tclassFocused(d): string {\n\t\treturn ` ${this.state.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : \"\"}`;\n\t},\n\n\tclassDefocused(d): string {\n\t\treturn ` ${this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : \"\"}`;\n\t},\n\n\tgetTargetSelectorSuffix(targetId?: string | number): string {\n\t\tconst targetStr = targetId || targetId === 0 ? `-${targetId}` : \"\";\n\n\t\t// replace control ascii(0 ~ 32) and extended ascii(127 ~ 160)\n\t\treturn targetStr\n\t\t\t.replace(/[\\x00-\\x20\\x7F-\\xA0\\s?!@#$%^&*()_=+,.<>'\":;\\[\\]\\/|~`{}\\\\]/g, \"-\"); // eslint-disable-line no-control-regex\n\t},\n\n\tselectorTarget(id: string, prefix = \"\", postfix = \"\"): string {\n\t\tconst target = this.getTargetSelectorSuffix(id);\n\n\t\t// select target & circle\n\t\treturn `${prefix}.${CLASS.target + target} ${postfix}, ${prefix}.${\n\t\t\tCLASS.circles + target\n\t\t} ${postfix}`;\n\t},\n\n\tselectorTargets(idsValue, prefix: string): string[] | null {\n\t\tconst ids = idsValue || [];\n\n\t\treturn ids.length ? ids.map(id => this.selectorTarget(id, prefix)) : null;\n\t},\n\n\tselectorLegend(id: string): string {\n\t\treturn `.${CLASS.legendItem + this.getTargetSelectorSuffix(id)}`;\n\t},\n\n\tselectorLegends(ids): string[] | null {\n\t\treturn ids?.length ? ids.map(id => this.selectorLegend(id)) : null;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {scaleOrdinal as d3ScaleOrdinal} from \"d3-scale\";\nimport {select as d3Select} from \"d3-selection\";\nimport {d3Selection} from \"../../../types\";\nimport {$ARC, $COLOR, $SHAPE} from \"../../config/classes\";\nimport {document} from \"../../module/browser\";\nimport {KEY} from \"../../module/Cache\";\nimport {isFunction, isObject, isString, notEmpty} from \"../../module/util\";\nimport type {IArcData, IDataRow} from \"../data/IData\";\n\n/**\n * Set pattern's background color\n * (it adds a <rect> element to simulate bg-color)\n * @param {SVGPatternElement} pattern SVG pattern element\n * @param {string} color Color string\n * @param {string} id ID to be set\n * @returns {{id: string, node: SVGPatternElement}}\n * @private\n */\nconst colorizePattern = (pattern, color, id: string) => {\n\tconst node = d3Select(pattern.cloneNode(true));\n\n\tnode\n\t\t.attr(\"id\", id)\n\t\t.insert(\"rect\", \":first-child\")\n\t\t.attr(\"width\", node.attr(\"width\"))\n\t\t.attr(\"height\", node.attr(\"height\"))\n\t\t.style(\"fill\", color);\n\n\treturn {\n\t\tid,\n\t\tnode: node.node()\n\t};\n};\n\n/**\n * Get color pattern from CSS file\n * CSS should be defined as: background-image: url(\"#00c73c;#fa7171; ...\");\n * @param {d3Selection} element Chart element\n * @returns {Array}\n * @private\n */\nfunction getColorFromCss(element: d3Selection): string[] {\n\tconst cacheKey = KEY.colorPattern;\n\tconst {body} = document;\n\tlet pattern = body[cacheKey];\n\n\tif (!pattern) {\n\t\tconst delimiter = \";\";\n\t\tconst content = element\n\t\t\t.classed($COLOR.colorPattern, true)\n\t\t\t.style(\"background-image\");\n\n\t\telement.classed($COLOR.colorPattern, false);\n\n\t\tif (content.indexOf(delimiter) > -1) {\n\t\t\tpattern = content\n\t\t\t\t.replace(/url[^#]*|[\"'()]|(\\s|%20)/g, \"\")\n\t\t\t\t.split(delimiter)\n\t\t\t\t.map(v => v.trim().replace(/[\\\"'\\s]/g, \"\"))\n\t\t\t\t.filter(Boolean);\n\n\t\t\tbody[cacheKey] = pattern;\n\t\t}\n\t}\n\n\treturn pattern;\n}\n\n// Replacement of d3.schemeCategory10.\n// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)\nconst schemeCategory10 = [\n\t\"#1f77b4\",\n\t\"#ff7f0e\",\n\t\"#2ca02c\",\n\t\"#d62728\",\n\t\"#9467bd\",\n\t\"#8c564b\",\n\t\"#e377c2\",\n\t\"#7f7f7f\",\n\t\"#bcbd22\",\n\t\"#17becf\"\n];\n\nexport default {\n\tgenerateColor(): Function {\n\t\tconst $$ = this;\n\t\tconst {$el, config} = $$;\n\t\tconst ids: string[] = [];\n\n\t\tlet pattern = notEmpty(config.color_pattern) ?\n\t\t\tconfig.color_pattern :\n\t\t\td3ScaleOrdinal(getColorFromCss($el.chart) || schemeCategory10).range();\n\n\t\tconst originalColorPattern = pattern;\n\n\t\tif (isFunction(config.color_tiles)) {\n\t\t\tconst tiles = config.color_tiles.bind($$.api)();\n\n\t\t\t// Add background color to patterns\n\t\t\tconst colorizedPatterns = pattern.map((p, index) => {\n\t\t\t\tconst color = p.replace(/[#\\(\\)\\s,]/g, \"\");\n\t\t\t\tconst id = `${$$.state.datetimeId}-pattern-${color}-${index}`;\n\n\t\t\t\treturn colorizePattern(tiles[index % tiles.length], p, id);\n\t\t\t});\n\n\t\t\tpattern = colorizedPatterns.map(p => `url(#${p.id})`);\n\t\t\t$$.patterns = colorizedPatterns;\n\t\t}\n\n\t\treturn function(d: IDataRow | IArcData | string): string {\n\t\t\tconst colors = config.data_colors;\n\t\t\tconst callback = config.data_color;\n\t\t\tconst id: string = (d as IDataRow).id ||\n\t\t\t\t(d as IArcData).data?.id ||\n\t\t\t\td as string;\n\n\t\t\tconst isLine = $$.isTypeOf(id, [\"line\", \"spline\", \"step\"]) || !config.data_types[id];\n\t\t\tlet color;\n\n\t\t\t// if callback function is provided\n\t\t\tif (isFunction(colors[id])) {\n\t\t\t\tcolor = colors[id].bind($$.api)(d);\n\n\t\t\t\t// if specified, choose that color\n\t\t\t} else if (colors[id]) {\n\t\t\t\tcolor = colors[id];\n\n\t\t\t\t// if not specified, choose from pattern\n\t\t\t} else {\n\t\t\t\tif (ids.indexOf(id) < 0) {\n\t\t\t\t\tids.push(id);\n\t\t\t\t}\n\n\t\t\t\tcolor = isLine ?\n\t\t\t\t\toriginalColorPattern[ids.indexOf(id) % originalColorPattern.length] :\n\t\t\t\t\tpattern[ids.indexOf(id) % pattern.length];\n\n\t\t\t\tcolors[id] = color;\n\t\t\t}\n\n\t\t\treturn isFunction(callback) ? callback.bind($$.api)(color, d) : color;\n\t\t};\n\t},\n\n\tgenerateLevelColor(): Function | null {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst colors = config.color_pattern;\n\t\tconst threshold = config.color_threshold;\n\t\tconst asValue = threshold.unit === \"value\";\n\t\tconst max = threshold.max || 100;\n\t\tconst values = threshold.values &&\n\t\t\t\tthreshold.values.length ?\n\t\t\tthreshold.values :\n\t\t\t[];\n\n\t\treturn notEmpty(threshold) ?\n\t\t\tfunction(value) {\n\t\t\t\tconst v = asValue ? value : (value * 100 / max);\n\t\t\t\tlet color = colors[colors.length - 1];\n\n\t\t\t\tfor (let i = 0, l = values.length; i < l; i++) {\n\t\t\t\t\tif (v <= values[i]) {\n\t\t\t\t\t\tcolor = colors[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn color;\n\t\t\t} :\n\t\t\tnull;\n\t},\n\n\t/**\n\t * Append data backgound color filter definition\n\t * @param {string|object|Function} color Color string, object, or function\n\t * @param {object} attr filter attribute\n\t * @private\n\t */\n\tgenerateTextBGColorFilter(color: string | {[key: string]: string} | Function, attr = {\n\t\tx: 0,\n\t\ty: 0,\n\t\twidth: 1,\n\t\theight: 1\n\t}): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {defs}, state} = $$;\n\n\t\tif (color) {\n\t\t\tlet ids: string[] = [];\n\n\t\t\tif (isString(color)) {\n\t\t\t\tids.push(\"\");\n\t\t\t} else if (isObject(color)) {\n\t\t\t\tids = Object.keys(color);\n\t\t\t} else if (isFunction(color)) {\n\t\t\t\tids = $$.mapToTargetIds();\n\t\t\t}\n\n\t\t\tids.forEach(v => {\n\t\t\t\tconst id = `${state.datetimeId}-labels-bg${$$.getTargetSelectorSuffix(v)}${\n\t\t\t\t\tisString(color) ? $$.getTargetSelectorSuffix(color) : \"\"\n\t\t\t\t}`;\n\t\t\t\tconst colorValue = v === \"\" ? color : color?.[v] || \"\";\n\n\t\t\t\tif (defs.select(`#${id}`).empty()) {\n\t\t\t\t\tdefs.append(\"filter\")\n\t\t\t\t\t\t.attr(\"x\", attr.x)\n\t\t\t\t\t\t.attr(\"y\", attr.y)\n\t\t\t\t\t\t.attr(\"width\", attr.width)\n\t\t\t\t\t\t.attr(\"height\", attr.height)\n\t\t\t\t\t\t.attr(\"id\", id)\n\t\t\t\t\t\t.html(\n\t\t\t\t\t\t\t`<feFlood flood-color=\"${colorValue}\" />\n\t\t\t\t\t\t\t<feComposite in=\"SourceGraphic\" />`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// Note: For function type, filters will be created dynamically in updateTextBGColor\n\t},\n\n\t/**\n\t * Get data gradient color url\n\t * @param {string} id Data id\n\t * @returns {string}\n\t * @private\n\t */\n\tgetGradienColortUrl(id: string): string {\n\t\treturn `url(#${this.state.datetimeId}-gradient${this.getTargetSelectorSuffix(id)})`;\n\t},\n\n\t/**\n\t * Update linear/radial gradient definition\n\t * - linear: area & bar only\n\t * - radial: type which has data points only\n\t * @private\n\t */\n\tupdateLinearGradient(): void {\n\t\tconst $$ = this;\n\t\tconst {config, data: {targets}, state: {datetimeId}, $el: {defs}} = $$;\n\n\t\ttargets.forEach(d => {\n\t\t\tconst id = `${datetimeId}-gradient${$$.getTargetSelectorSuffix(d.id)}`;\n\t\t\tconst radialGradient = $$.hasPointType() && config.point_radialGradient;\n\t\t\tconst supportedType = ($$.isAreaType(d) && \"area\") || ($$.isBarType(d) && \"bar\");\n\n\t\t\tif ((radialGradient || supportedType) && defs.select(`#${id}`).empty()) {\n\t\t\t\tconst color = $$.color(d);\n\t\t\t\tconst gradient = {\n\t\t\t\t\tdefs: <null | d3Selection>null,\n\t\t\t\t\tstops: <[number, string | Function | null, number][]>[]\n\t\t\t\t};\n\n\t\t\t\tif (radialGradient) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tcx = 0.3,\n\t\t\t\t\t\tcy = 0.3,\n\t\t\t\t\t\tr = 0.7,\n\t\t\t\t\t\tstops = [[0.1, color, 0], [0.9, color, 1]]\n\t\t\t\t\t} = radialGradient;\n\n\t\t\t\t\tgradient.stops = stops;\n\t\t\t\t\tgradient.defs = defs.append(\"radialGradient\")\n\t\t\t\t\t\t.attr(\"id\", `${id}`)\n\t\t\t\t\t\t.attr(\"cx\", cx)\n\t\t\t\t\t\t.attr(\"cy\", cy)\n\t\t\t\t\t\t.attr(\"r\", r);\n\t\t\t\t} else {\n\t\t\t\t\tconst isRotated = config.axis_rotated;\n\t\t\t\t\tconst {\n\t\t\t\t\t\tx = isRotated ? [1, 0] : [0, 0],\n\t\t\t\t\t\ty = isRotated ? [0, 0] : [0, 1],\n\t\t\t\t\t\tstops = [[0, color, 1], [1, color, 0]]\n\t\t\t\t\t} = config[`${supportedType}_linearGradient`];\n\n\t\t\t\t\tgradient.stops = stops;\n\t\t\t\t\tgradient.defs = defs.append(\"linearGradient\")\n\t\t\t\t\t\t.attr(\"id\", `${id}`)\n\t\t\t\t\t\t.attr(\"x1\", x[0])\n\t\t\t\t\t\t.attr(\"x2\", x[1])\n\t\t\t\t\t\t.attr(\"y1\", y[0])\n\t\t\t\t\t\t.attr(\"y2\", y[1]);\n\t\t\t\t}\n\n\t\t\t\tgradient.stops.forEach((v: [number, string | Function | null, number]) => {\n\t\t\t\t\tconst [offset, stopColor, stopOpacity] = v;\n\t\t\t\t\tconst colorValue = isFunction(stopColor) ?\n\t\t\t\t\t\tstopColor.bind($$.api)(d.id) :\n\t\t\t\t\t\tstopColor;\n\n\t\t\t\t\tgradient.defs && gradient.defs.append(\"stop\")\n\t\t\t\t\t\t.attr(\"offset\", offset)\n\t\t\t\t\t\t.attr(\"stop-color\", colorValue || color)\n\t\t\t\t\t\t.attr(\"stop-opacity\", stopOpacity);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Set the data over color.\n\t * When is out, will restate in its previous color value\n\t * @param {boolean} isOver true: set overed color, false: restore\n\t * @param {number|object} d target index or data object for Arc type\n\t * @private\n\t */\n\tsetOverColor(isOver: boolean, d): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {main}} = $$;\n\t\tconst onover = config.color_onover;\n\t\tlet color = isOver ? onover : $$.color;\n\n\t\tif (isObject(color)) {\n\t\t\tcolor = ({id}) => (id in onover ? onover[id] : $$.color(id));\n\t\t} else if (isString(color)) {\n\t\t\tcolor = () => onover;\n\t\t} else if (isFunction(onover)) {\n\t\t\tcolor = color.bind($$.api);\n\t\t}\n\n\t\tmain.selectAll(\n\t\t\tisObject(d) ?\n\t\t\t\t// when is Arc type\n\t\t\t\t`.${$ARC.arc}${$$.getTargetSelectorSuffix(d.id)}` :\n\t\t\t\t`.${$SHAPE.shape}-${d}`\n\t\t).style(\"fill\", color);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {TYPE, TYPE_BY_CATEGORY} from \"../../config/const\";\nimport {\n\tbrushEmpty,\n\tdiffDomain,\n\tgetBrushSelection,\n\tgetMinMax,\n\tisDefined,\n\tisNumber,\n\tisObject,\n\tisValue,\n\tnotEmpty,\n\tparseDate,\n\tsortValue\n} from \"../../module/util\";\nimport type {IData, TDomainRange} from \"../data/IData\";\n\nexport default {\n\tgetYDomainMinMax(targets, type: \"min\" | \"max\"): number | Date | undefined {\n\t\tconst $$ = this;\n\t\tconst {axis, config} = $$;\n\t\tconst isMin = type === \"min\";\n\n\t\tconst dataGroups = config.data_groups;\n\t\tconst ids = $$.mapToIds(targets);\n\t\tconst ys = $$.getValuesAsIdKeyed(targets);\n\n\t\tif (dataGroups.length > 0) {\n\t\t\tconst hasValue = $$[`has${isMin ? \"Negative\" : \"Positive\"}ValueInTargets`](targets);\n\n\t\t\tdataGroups.forEach(groupIds => {\n\t\t\t\t// Determine baseId\n\t\t\t\tconst idsInGroup = groupIds\n\t\t\t\t\t.filter(v => ids.indexOf(v) >= 0);\n\n\t\t\t\tif (idsInGroup.length) {\n\t\t\t\t\tconst baseId = idsInGroup[0];\n\t\t\t\t\tconst baseAxisId = axis.getId(baseId);\n\n\t\t\t\t\t// Initialize base value. Set to 0 if not match with the condition\n\t\t\t\t\tif (hasValue && ys[baseId]) {\n\t\t\t\t\t\tys[baseId] = ys[baseId]\n\t\t\t\t\t\t\t.map(v => ((isMin ? v < 0 : v > 0) ? v : 0));\n\t\t\t\t\t}\n\n\t\t\t\t\tidsInGroup\n\t\t\t\t\t\t.filter((v, i) => i > 0)\n\t\t\t\t\t\t.forEach(id => {\n\t\t\t\t\t\t\tif (ys[id]) {\n\t\t\t\t\t\t\t\tconst axisId = axis.getId(id);\n\n\t\t\t\t\t\t\t\tys[id].forEach((v, i) => {\n\t\t\t\t\t\t\t\t\tconst val = +v;\n\t\t\t\t\t\t\t\t\tconst meetCondition = isMin ? val > 0 : val < 0;\n\n\t\t\t\t\t\t\t\t\tif (axisId === baseAxisId && !(hasValue && meetCondition)) {\n\t\t\t\t\t\t\t\t\t\tys[baseId][i] += val;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn getMinMax(type, Object.keys(ys).map(key => getMinMax(type, ys[key])));\n\t},\n\n\t/**\n\t * Check if hidden targets bound to the given axis id\n\t * @param {string} id ID to be checked\n\t * @returns {boolean}\n\t * @private\n\t */\n\tisHiddenTargetWithYDomain(id): boolean {\n\t\tconst $$ = this;\n\n\t\treturn $$.state.hiddenTargetIds\n\t\t\t.some(v => $$.axis.getId(v) === id);\n\t},\n\n\tgetYDomain(targets: IData[], axisId: \"y\" | \"y2\", xDomain: TDomainRange) {\n\t\tconst $$ = this;\n\t\tconst {axis, config, scale} = $$;\n\t\tconst pfx = `axis_${axisId}`;\n\n\t\tif ($$.isStackNormalized()) {\n\t\t\treturn [0, 100];\n\t\t}\n\n\t\tconst isLog = scale?.[axisId] && scale[axisId].type === \"log\";\n\t\tconst targetsByAxisId = targets.filter(t => axis.getId(t.id) === axisId);\n\t\tconst yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;\n\n\t\tif (yTargets.length === 0) { // use domain of the other axis if target of axisId is none\n\t\t\tif ($$.isHiddenTargetWithYDomain(axisId)) {\n\t\t\t\treturn scale[axisId].domain();\n\t\t\t} else {\n\t\t\t\treturn axisId === \"y2\" ?\n\t\t\t\t\tscale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.\n\t\t\t\t\t// So, it needs to call to get y2 domain here\n\t\t\t\t\t$$.getYDomain(targets, \"y2\", xDomain);\n\t\t\t}\n\t\t}\n\n\t\tconst yMin = config[`${pfx}_min`];\n\t\tconst yMax = config[`${pfx}_max`];\n\t\tconst center = config[`${pfx}_center`];\n\t\tconst isInverted = config[`${pfx}_inverted`];\n\t\tconst showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated;\n\t\tconst showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;\n\n\t\tlet yDomainMin = $$.getYDomainMinMax(yTargets, \"min\");\n\t\tlet yDomainMax = $$.getYDomainMinMax(yTargets, \"max\");\n\n\t\tlet isZeroBased = [TYPE.BAR, TYPE.BUBBLE, TYPE.SCATTER, ...TYPE_BY_CATEGORY.Line]\n\t\t\t.some(v => {\n\t\t\t\tconst type = v.indexOf(\"area\") > -1 ? \"area\" : v;\n\n\t\t\t\treturn $$.hasType(v, yTargets, true) && config[`${type}_zerobased`];\n\t\t\t});\n\n\t\t// MEMO: avoid inverting domain unexpectedly\n\t\tyDomainMin = isValue(yMin) ? yMin : (\n\t\t\tisValue(yMax) ?\n\t\t\t\t(\n\t\t\t\t\tyDomainMin <= yMax ? yDomainMin : yMax - 10\n\t\t\t\t) :\n\t\t\t\tyDomainMin\n\t\t);\n\n\t\tyDomainMax = isValue(yMax) ? yMax : (\n\t\t\tisValue(yMin) ?\n\t\t\t\t(\n\t\t\t\t\tyMin <= yDomainMax ? yDomainMax : yMin + 10\n\t\t\t\t) :\n\t\t\t\tyDomainMax\n\t\t);\n\n\t\tif (isNaN(yDomainMin)) { // set minimum to zero when not number\n\t\t\tyDomainMin = 0;\n\t\t}\n\n\t\tif (isNaN(yDomainMax)) { // set maximum to have same value as yDomainMin\n\t\t\tyDomainMax = yDomainMin;\n\t\t}\n\n\t\tif (yDomainMin === yDomainMax) {\n\t\t\tyDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;\n\t\t}\n\n\t\tconst isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;\n\t\tconst isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;\n\n\t\t// Cancel zerobased if axis_*_min / axis_*_max specified\n\t\tif ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {\n\t\t\tisZeroBased = false;\n\t\t}\n\n\t\t// Bar/Area chart should be 0-based if all positive|negative\n\t\tif (isZeroBased) {\n\t\t\tisAllPositive && (yDomainMin = 0);\n\t\t\tisAllNegative && (yDomainMax = 0);\n\t\t}\n\n\t\tconst domainLength = Math.abs(yDomainMax - yDomainMin);\n\t\tlet padding = {top: domainLength * 0.1, bottom: domainLength * 0.1};\n\n\t\tif (isDefined(center)) {\n\t\t\tconst yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));\n\n\t\t\tyDomainMax = center + yDomainAbs;\n\t\t\tyDomainMin = center - yDomainAbs;\n\t\t}\n\n\t\t// add padding for data label\n\t\tif (showHorizontalDataLabel) {\n\t\t\tconst diff = diffDomain(scale.y.range());\n\t\t\tconst ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, \"width\")\n\t\t\t\t.map(v => {\n\t\t\t\t\tconst result = v / diff;\n\n\t\t\t\t\treturn isFinite(result) ? result : 0;\n\t\t\t\t});\n\n\t\t\t[\"bottom\", \"top\"].forEach((v, i) => {\n\t\t\t\tpadding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));\n\t\t\t});\n\t\t} else if (showVerticalDataLabel) {\n\t\t\tconst lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, \"height\");\n\n\t\t\t[\"bottom\", \"top\"].forEach((v, i) => {\n\t\t\t\tpadding[v] += $$.convertPixelToScale(\"y\", lengths[i], domainLength);\n\t\t\t});\n\t\t}\n\n\t\tpadding = $$.getResettedPadding(padding);\n\n\t\t// if padding is set, the domain will be updated relative the current domain value\n\t\t// ex) $$.height=300, padding.top=150, domainLength=4  --> domain=6\n\t\tconst p = config[`${pfx}_padding`];\n\n\t\tif (notEmpty(p)) {\n\t\t\t[\"bottom\", \"top\"].forEach(v => {\n\t\t\t\tpadding[v] = axis.getPadding(p, v, padding[v], domainLength);\n\t\t\t});\n\t\t}\n\n\t\t// Bar/Area chart should be 0-based if all positive|negative\n\t\tif (isZeroBased) {\n\t\t\tisAllPositive && (padding.bottom = yDomainMin);\n\t\t\tisAllNegative && (padding.top = -yDomainMax);\n\t\t}\n\n\t\tconst domain = isLog ?\n\t\t\t[yDomainMin, yDomainMax].map(v => (v < 0 ? 0 : v)) :\n\t\t\t[yDomainMin - padding.bottom, yDomainMax + padding.top];\n\n\t\treturn isInverted ? domain.reverse() : domain;\n\t},\n\n\tgetXDomainMinMax(targets, type) {\n\t\tconst $$ = this;\n\t\tconst configValue = $$.config[`axis_x_${type}`];\n\t\tconst dataValue = getMinMax(type,\n\t\t\ttargets.map(t => getMinMax(type, t.values.map(v => v.x))));\n\t\tlet value = isObject(configValue) ? configValue.value : configValue;\n\n\t\tvalue = isDefined(value) && $$.axis?.isTimeSeries() ? parseDate.bind(this)(value) : value;\n\n\t\tif (\n\t\t\tisObject(configValue) && configValue.fit && (\n\t\t\t\t(type === \"min\" && value < dataValue) || (type === \"max\" && value > dataValue)\n\t\t\t)\n\t\t) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\treturn isDefined(value) ? value : dataValue;\n\t},\n\n\t/**\n\t * Get x Axis padding\n\t * @param {Array} domain x Axis domain\n\t * @param {number} tickCount Tick count\n\t * @returns {object} Padding object values with 'left' & 'right' key\n\t * @private\n\t */\n\tgetXDomainPadding(domain, tickCount: number): {left: number, right: number} {\n\t\tconst $$ = this;\n\t\tconst {axis, config} = $$;\n\t\tconst padding = config.axis_x_padding;\n\t\tconst isTimeSeriesTickCount = axis.isTimeSeries() && tickCount;\n\t\tconst diff = diffDomain(domain);\n\t\tlet defaultValue;\n\n\t\t// determine default padding value\n\t\tif (axis.isCategorized() || isTimeSeriesTickCount) {\n\t\t\tdefaultValue = 0;\n\t\t} else if ($$.hasType(\"bar\")) {\n\t\t\tconst maxDataCount = $$.getMaxDataCount();\n\n\t\t\tdefaultValue = maxDataCount > 1 ? (diff / (maxDataCount - 1)) / 2 : 0.5;\n\t\t} else {\n\t\t\tdefaultValue = $$.getResettedPadding(diff * 0.01);\n\t\t}\n\n\t\tlet {left = defaultValue, right = defaultValue} = isNumber(padding) ?\n\t\t\t{left: padding, right: padding} :\n\t\t\tpadding;\n\n\t\t// when the unit is pixel, convert pixels to axis scale value\n\t\tif (padding.unit === \"px\") {\n\t\t\tconst domainLength = Math.abs(diff + (diff * 0.2));\n\n\t\t\tleft = axis.getPadding(padding, \"left\", defaultValue, domainLength);\n\t\t\tright = axis.getPadding(padding, \"right\", defaultValue, domainLength);\n\t\t} else {\n\t\t\tconst range = diff + left + right;\n\n\t\t\tif (isTimeSeriesTickCount && range) {\n\t\t\t\tconst relativeTickWidth = (diff / tickCount) / range;\n\n\t\t\t\tleft = left / range / relativeTickWidth;\n\t\t\t\tright = right / range / relativeTickWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn {left, right};\n\t},\n\n\t/**\n\t * Get x Axis domain\n\t * @param {Array} targets targets\n\t * @returns {Array} x Axis domain\n\t * @private\n\t */\n\tgetXDomain(targets: IData[]): (Date | number)[] {\n\t\tconst $$ = this;\n\t\tconst {axis, config, scale: {x}} = $$;\n\t\tconst isInverted = config.axis_x_inverted;\n\t\tconst domain = [\n\t\t\t$$.getXDomainMinMax(targets, \"min\"),\n\t\t\t$$.getXDomainMinMax(targets, \"max\")\n\t\t];\n\t\tlet [min = 0, max = 0] = domain;\n\n\t\tif (x.type !== \"log\") {\n\t\t\tconst isCategorized = axis.isCategorized();\n\t\t\tconst isTimeSeries = axis.isTimeSeries();\n\t\t\tconst padding = $$.getXDomainPadding(domain);\n\t\t\tlet [firstX, lastX] = domain;\n\n\t\t\t// show center of x domain if min and max are the same\n\t\t\tif ((firstX - lastX) === 0 && !isCategorized) {\n\t\t\t\tif (isTimeSeries) {\n\t\t\t\t\tfirstX = new Date(firstX.getTime() * 0.5);\n\t\t\t\t\tlastX = new Date(lastX.getTime() * 1.5);\n\t\t\t\t} else {\n\t\t\t\t\tfirstX = firstX === 0 ? 1 : (firstX * 0.5);\n\t\t\t\t\tlastX = lastX === 0 ? -1 : (lastX * 1.5);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (firstX || firstX === 0) {\n\t\t\t\tmin = isTimeSeries ?\n\t\t\t\t\tnew Date(firstX.getTime() - padding.left) :\n\t\t\t\t\tfirstX - padding.left;\n\t\t\t}\n\n\t\t\tif (lastX || lastX === 0) {\n\t\t\t\tmax = isTimeSeries ?\n\t\t\t\t\tnew Date(lastX.getTime() + padding.right) :\n\t\t\t\t\tlastX + padding.right;\n\t\t\t}\n\t\t}\n\n\t\treturn isInverted ? [max, min] : [min, max];\n\t},\n\n\tupdateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {\n\t\tconst $$ = this;\n\t\tconst {config, org, scale: {x, subX}} = $$;\n\t\tconst zoomEnabled = config.zoom_enabled;\n\n\t\tif (withUpdateOrgXDomain) {\n\t\t\tx.domain(domain || sortValue($$.getXDomain(targets), !config.axis_x_inverted));\n\t\t\torg.xDomain = x.domain();\n\n\t\t\t// zoomEnabled && $$.zoom.updateScaleExtent();\n\n\t\t\tsubX.domain(x.domain());\n\t\t\t$$.brush?.scale(subX);\n\t\t}\n\n\t\tif (withUpdateXDomain) {\n\t\t\tconst domainValue = domain || (!$$.brush || brushEmpty($$)) ?\n\t\t\t\torg.xDomain :\n\t\t\t\tgetBrushSelection($$).map(subX.invert);\n\n\t\t\tx.domain(domainValue);\n\t\t\t// zoomEnabled && $$.zoom.updateScaleExtent();\n\t\t}\n\n\t\tif (withUpdateOrgXDomain || withUpdateXDomain) {\n\t\t\tzoomEnabled && $$.zoom.updateScaleExtent();\n\t\t}\n\n\t\t// Trim domain when too big by zoom mousemove event\n\t\twithTrim && x.domain($$.trimXDomain(x.orgDomain()));\n\n\t\treturn x.domain();\n\t},\n\n\t/**\n\t * Trim x domain when given domain surpasses the range\n\t * @param {Array} domain Domain value\n\t * @returns {Array} Trimed domain if given domain is out of range\n\t * @private\n\t */\n\ttrimXDomain(domain) {\n\t\tconst $$ = this;\n\t\tconst isInverted = $$.config.axis_x_inverted;\n\t\tconst zoomDomain = $$.getZoomDomain();\n\t\tconst [min, max] = zoomDomain;\n\n\t\tif (isInverted ? domain[0] >= min : domain[0] <= min) {\n\t\t\tdomain[1] = +domain[1] + (min - domain[0]);\n\t\t\tdomain[0] = min;\n\t\t}\n\n\t\tif (isInverted ? domain[1] <= max : domain[1] >= max) {\n\t\t\tdomain[0] = +domain[0] - (domain[1] - max);\n\t\t\tdomain[1] = max;\n\t\t}\n\n\t\treturn domain;\n\t},\n\n\t/**\n\t * Get subchart/zoom domain\n\t * @param {string} type \"subX\" or \"zoom\"\n\t * @param {boolean} getCurrent Get current domain if true\n\t * @returns {Array} zoom domain\n\t * @private\n\t */\n\tgetZoomDomain(type: \"subX\" | \"zoom\" = \"zoom\", getCurrent = false): TDomainRange {\n\t\tconst $$ = this;\n\t\tconst {config, scale, org} = $$;\n\t\tlet [min, max] = getCurrent && scale[type] ? scale[type].domain() : org.xDomain;\n\n\t\tif (type === \"zoom\") {\n\t\t\tif (isDefined(config.zoom_x_min)) {\n\t\t\t\tmin = getMinMax(\"min\", [min, config.zoom_x_min]);\n\t\t\t}\n\n\t\t\tif (isDefined(config.zoom_x_max)) {\n\t\t\t\tmax = getMinMax(\"max\", [max, config.zoom_x_max]);\n\t\t\t}\n\t\t}\n\n\t\treturn [min, max];\n\t},\n\n\t/**\n\t * Return zoom domain from given domain\n\t * - 'category' type need to add offset to original value\n\t * @param {Array} domainValue domain value\n\t * @returns {Array} Zoom domain\n\t * @private\n\t */\n\tgetZoomDomainValue<T = TDomainRange>(domainValue: T): T | undefined {\n\t\tconst $$ = this;\n\t\tconst {config, axis} = $$;\n\n\t\tif (axis.isCategorized() && Array.isArray(domainValue)) {\n\t\t\tconst isInverted = config.axis_x_inverted;\n\n\t\t\t// need to add offset to original value for 'category' type\n\t\t\tconst domain = domainValue.map((v, i) =>\n\t\t\t\tNumber(v) + (i === 0 ? +isInverted : +!isInverted)\n\t\t\t);\n\n\t\t\treturn domain as T;\n\t\t}\n\n\t\treturn domainValue;\n\t},\n\n\t/**\n\t * Converts pixels to axis' scale values\n\t * @param {string} type Axis type\n\t * @param {number} pixels Pixels\n\t * @param {number} domainLength Domain length\n\t * @returns {number}\n\t * @private\n\t */\n\tconvertPixelToScale(type: \"x\" | \"y\", pixels: number, domainLength: number): number {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tlet length;\n\n\t\tif (type === \"x\") {\n\t\t\tlength = isRotated ? \"height\" : \"width\";\n\t\t} else {\n\t\t\tlength = isRotated ? \"width\" : \"height\";\n\t\t}\n\n\t\treturn domainLength * (pixels / state[length]);\n\t},\n\n\t/**\n\t * Check if the given domain is within subchart/zoom range\n\t * @param {Array} domain Target domain value\n\t * @param {Array} current Current subchart/zoom domain value\n\t * @param {Array} range subchart/zoom range value\n\t * @returns {boolean}\n\t * @private\n\t */\n\twithinRange<T = TDomainRange>(domain: T, current = [0, 0], range: T): boolean {\n\t\tconst $$ = this;\n\t\tconst isInverted = $$.config.axis_x_inverted;\n\t\tconst [min, max] = range as number[];\n\n\t\tif (Array.isArray(domain)) {\n\t\t\tconst target = [...domain];\n\n\t\t\tisInverted && target.reverse();\n\n\t\t\tif (target[0] < target[1]) {\n\t\t\t\treturn domain.every((v, i) =>\n\t\t\t\t\t(\n\t\t\t\t\t\ti === 0 ?\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tisInverted ? +v <= min : +v >= min\n\t\t\t\t\t\t\t) :\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tisInverted ? +v >= max : +v <= max\n\t\t\t\t\t\t\t)\n\t\t\t\t\t) && !(domain.every((v, i) => v === current[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {AxisType} from \"../../../types/types\";\nimport {isArray, isFunction, isObject, isObjectType, isValue} from \"../../module/util\";\n\n/**\n * Get formatted\n * @param {object} $$ Context\n * @param {string} typeValue Axis type\n * @param {number} v Value to be formatted\n * @returns {number | string}\n * @private\n */\nfunction getFormat($$, typeValue: AxisType, v: number): number | string {\n\tconst {config} = $$;\n\tconst type = `axis_${typeValue}_tick_format`;\n\tconst format = config[type] ? config[type] : $$.defaultValueFormat;\n\n\treturn format.call($$.api, v);\n}\n\nexport default {\n\tyFormat(v: number): number | string {\n\t\treturn getFormat(this, \"y\", v);\n\t},\n\n\ty2Format(v: number): number | string {\n\t\treturn getFormat(this, \"y2\", v);\n\t},\n\n\t/**\n\t * Get default value format function\n\t * @returns {Function} formatter function\n\t * @private\n\t */\n\tgetDefaultValueFormat(): Function {\n\t\tconst $$ = this;\n\t\tconst {defaultArcValueFormat, yFormat, y2Format} = $$;\n\t\tconst hasArc = $$.hasArcType(null, [\"gauge\", \"polar\", \"radar\"]);\n\n\t\treturn function(v, ratio, id) {\n\t\t\tconst format = hasArc ? defaultArcValueFormat : (\n\t\t\t\t$$.axis && $$.axis.getId(id) === \"y2\" ? y2Format : yFormat\n\t\t\t);\n\n\t\t\treturn format.call($$, v, ratio);\n\t\t};\n\t},\n\n\tdefaultValueFormat(v: number | number[]): number | string {\n\t\treturn isArray(v) ? v.join(\"~\") : (isValue(v) ? +v : \"\");\n\t},\n\n\tdefaultArcValueFormat(v, ratio): string {\n\t\treturn `${(ratio * 100).toFixed(1)}%`;\n\t},\n\n\tdefaultPolarValueFormat(v): string {\n\t\treturn `${v}`;\n\t},\n\n\tdataLabelFormat(targetId: string): Function {\n\t\tconst $$ = this;\n\t\tconst dataLabels = $$.config.data_labels;\n\t\tconst defaultFormat = v => {\n\t\t\tconst delimiter = \"~\";\n\t\t\tlet res = v;\n\n\t\t\tif (isArray(v)) {\n\t\t\t\tres = v.join(delimiter);\n\t\t\t} else if (isObject(v)) {\n\t\t\t\tres = Object.values(v).join(delimiter);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t\tlet format = defaultFormat;\n\n\t\t// find format according to axis id\n\t\tif (isFunction(dataLabels.format)) {\n\t\t\tformat = dataLabels.format;\n\t\t} else if (isObjectType(dataLabels.format)) {\n\t\t\tif (dataLabels.format[targetId]) {\n\t\t\t\tformat = dataLabels.format[targetId] === true ?\n\t\t\t\t\tdefaultFormat :\n\t\t\t\t\tdataLabels.format[targetId];\n\t\t\t} else {\n\t\t\t\tformat = () => \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn format.bind($$.api);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {namespaces as d3Namespaces, select as d3Select} from \"d3-selection\";\nimport {$FOCUS, $GAUGE, $LEGEND} from \"../../config/classes\";\nimport {document} from \"../../module/browser\";\nimport {KEY} from \"../../module/Cache\";\nimport {\n\tcallFn,\n\tgetOption,\n\tisDefined,\n\tisEmpty,\n\tisFunction,\n\tnotEmpty,\n\ttplProcess\n} from \"../../module/util\";\n\n/**\n * Get color string for given data id\n * @param {string} id Data id\n * @returns {string} Color string\n * @private\n */\nfunction getLegendColor(id: string): string {\n\tconst $$ = this;\n\tconst data = $$.getDataById(id);\n\tconst color = $$.levelColor ? $$.levelColor(data.values[0].value) : $$.color(data);\n\n\treturn color;\n}\n\n/**\n * Get formatted text value\n * @param {string} id Legend text id\n * @param {boolean} formatted Whether or not to format the text\n * @returns {string} Formatted legend text\n */\nfunction getFormattedText<T = string>(id: T, formatted = true): T {\n\tconst {config} = this;\n\tlet text = config.data_names[id] ?? id;\n\n\tif (formatted && isFunction(config.legend_format)) {\n\t\ttext = config.legend_format(text, id !== text ? id : undefined);\n\t}\n\n\treturn text;\n}\n\nexport default {\n\t/**\n\t * Initialize the legend.\n\t * @private\n\t */\n\tinitLegend(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el} = $$;\n\n\t\t$$.legendItemTextBox = {};\n\t\t$$.state.legendHasRendered = false;\n\n\t\tif (config.legend_show) {\n\t\t\tif (!config.legend_contents_bindto) {\n\t\t\t\t$el.legend = $$.$el.svg.append(\"g\")\n\t\t\t\t\t.classed($LEGEND.legend, true)\n\t\t\t\t\t.attr(\"transform\", $$.getTranslate(\"legend\"));\n\t\t\t}\n\n\t\t\t// MEMO: call here to update legend box and translate for all\n\t\t\t// MEMO: translate will be updated by this, so transform not needed in updateLegend()\n\t\t\t$$.updateLegend();\n\t\t} else {\n\t\t\t$$.state.hiddenLegendIds = $$.mapToIds($$.data.targets);\n\t\t}\n\t},\n\n\t/**\n\t * Update legend element\n\t * @param {Array} targetIds ID's of target\n\t * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.\n\t * @param {object} transitions Return value of the generateTransitions\n\t * @private\n\t */\n\tupdateLegend(targetIds, options, transitions): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, scale, $el} = $$;\n\n\t\tconst optionz = options || {\n\t\t\twithTransform: false,\n\t\t\twithTransitionForTransform: false,\n\t\t\twithTransition: false\n\t\t};\n\n\t\toptionz.withTransition = getOption(optionz, \"withTransition\", true);\n\t\toptionz.withTransitionForTransform = getOption(optionz, \"withTransitionForTransform\", true);\n\n\t\tif (config.legend_contents_bindto && config.legend_contents_template) {\n\t\t\t$$.updateLegendTemplate();\n\t\t} else if (!state.hasTreemap) {\n\t\t\t$$.updateLegendElement(\n\t\t\t\ttargetIds || $$.mapToIds($$.data.targets),\n\t\t\t\toptionz,\n\t\t\t\ttransitions\n\t\t\t);\n\t\t}\n\n\t\t// toggle legend state\n\t\t$el.legend?.selectAll(`.${$LEGEND.legendItem}`)\n\t\t\t.classed($LEGEND.legendItemHidden, function(id) {\n\t\t\t\tconst hide = !$$.isTargetToShow(id);\n\n\t\t\t\tif (hide) {\n\t\t\t\t\tthis.style.opacity = null;\n\t\t\t\t}\n\n\t\t\t\treturn hide;\n\t\t\t});\n\n\t\t// Update size and scale\n\t\t$$.updateScales(false, !scale.zoom);\n\t\t$$.updateSvgSize();\n\n\t\t// Update g positions\n\t\t$$.transformAll(optionz.withTransitionForTransform, transitions);\n\n\t\tstate.legendHasRendered = true;\n\t},\n\n\t/**\n\t * Update legend using template option\n\t * @private\n\t */\n\tupdateLegendTemplate(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el} = $$;\n\t\tconst wrapper = d3Select(config.legend_contents_bindto);\n\t\tconst template = config.legend_contents_template;\n\n\t\tif (!wrapper.empty()) {\n\t\t\tconst targets = $$.mapToIds($$.data.targets);\n\t\t\tconst ids: string[] = [];\n\t\t\tlet html = \"\";\n\n\t\t\ttargets.forEach(v => {\n\t\t\t\tconst content = isFunction(template) ?\n\t\t\t\t\ttemplate.bind($$.api)(v, $$.color(v), $$.api.data(v)[0].values) :\n\t\t\t\t\ttplProcess(template, {\n\t\t\t\t\t\tCOLOR: $$.color(v),\n\t\t\t\t\t\tTITLE: v\n\t\t\t\t\t});\n\n\t\t\t\tif (content) {\n\t\t\t\t\tids.push(v);\n\t\t\t\t\thtml += content;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst legendItem = wrapper.html(html)\n\t\t\t\t.selectAll(function() {\n\t\t\t\t\treturn this.childNodes;\n\t\t\t\t})\n\t\t\t\t.data(ids);\n\n\t\t\t$$.setLegendItem(legendItem);\n\n\t\t\t$el.legend = wrapper;\n\t\t}\n\t},\n\n\t/**\n\t * Update the size of the legend.\n\t * @param {Obejct} size Size object\n\t * @private\n\t */\n\tupdateSizeForLegend(size): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\tconfig,\n\t\t\tstate: {\n\t\t\t\tisLegendTop,\n\t\t\t\tisLegendLeft,\n\t\t\t\tisLegendRight,\n\t\t\t\tisLegendInset,\n\t\t\t\tcurrent\n\t\t\t}\n\t\t} = $$;\n\t\tconst {width, height} = size;\n\n\t\tconst insetLegendPosition = {\n\t\t\ttop: isLegendTop ?\n\t\t\t\t$$.getCurrentPaddingByDirection(\"top\") + config.legend_inset_y + 5.5 :\n\t\t\t\tcurrent.height - height - $$.getCurrentPaddingByDirection(\"bottom\") -\n\t\t\t\tconfig.legend_inset_y,\n\t\t\tleft: isLegendLeft ?\n\t\t\t\t$$.getCurrentPaddingByDirection(\"left\") + config.legend_inset_x + 0.5 :\n\t\t\t\tcurrent.width - width - $$.getCurrentPaddingByDirection(\"right\") -\n\t\t\t\tconfig.legend_inset_x + 0.5\n\t\t};\n\n\t\t$$.state.margin3 = {\n\t\t\ttop: isLegendRight ?\n\t\t\t\t0 :\n\t\t\t\tisLegendInset ?\n\t\t\t\tinsetLegendPosition.top :\n\t\t\t\tcurrent.height - height,\n\t\t\tright: NaN,\n\t\t\tbottom: 0,\n\t\t\tleft: isLegendRight ?\n\t\t\t\tcurrent.width - width :\n\t\t\t\tisLegendInset ?\n\t\t\t\tinsetLegendPosition.left :\n\t\t\t\t0\n\t\t};\n\t},\n\n\t/**\n\t * Transform Legend\n\t * @param {boolean} withTransition whether or not to transition.\n\t * @private\n\t */\n\ttransformLegend(withTransition): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {legend}, $T} = $$;\n\n\t\t$T(legend, withTransition)\n\t\t\t.attr(\"transform\", $$.getTranslate(\"legend\"));\n\t},\n\n\t/**\n\t * Update the legend step\n\t * @param {number} step Step value\n\t * @private\n\t */\n\tupdateLegendStep(step: number): void {\n\t\tthis.state.legendStep = step;\n\t},\n\n\t/**\n\t * Update legend item width\n\t * @param {number} width Width value\n\t * @private\n\t */\n\tupdateLegendItemWidth(width: number): void {\n\t\tthis.state.legendItemWidth = width;\n\t},\n\n\t/**\n\t * Update legend item height\n\t * @param {number} height Height value\n\t * @private\n\t */\n\tupdateLegendItemHeight(height): void {\n\t\tthis.state.legendItemHeight = height;\n\t},\n\n\t/**\n\t * Update legend item color\n\t * @param {string} id Corresponding data ID value\n\t * @param {string} color Color value\n\t * @private\n\t */\n\tupdateLegendItemColor(id: string, color: string): void {\n\t\tconst {legend} = this.$el;\n\n\t\tif (legend) {\n\t\t\tlegend.select(`.${$LEGEND.legendItem}-${id} line`)\n\t\t\t\t.style(\"stroke\", color);\n\t\t}\n\t},\n\n\t/**\n\t * Get the width of the legend\n\t * @returns {number} width\n\t * @private\n\t */\n\tgetLegendWidth(): number {\n\t\tconst $$ = this;\n\t\tconst {current: {width}, isLegendRight, isLegendInset, legendItemWidth, legendStep} =\n\t\t\t$$.state;\n\n\t\treturn $$.config.legend_show ?\n\t\t\t(\n\t\t\t\tisLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : width\n\t\t\t) :\n\t\t\t0;\n\t},\n\n\t/**\n\t * Get the height of the legend\n\t * @returns {number} height\n\t * @private\n\t */\n\tgetLegendHeight(): number {\n\t\tconst $$ = this;\n\t\tconst {current, isLegendRight, legendItemHeight, legendStep} = $$.state;\n\t\tconst isFitPadding = $$.config.padding?.mode === \"fit\";\n\t\tconst height = $$.config.legend_show ?\n\t\t\t(\n\t\t\t\tisLegendRight ? current.height : (\n\t\t\t\t\tMath.max(isFitPadding ? 10 : 20, legendItemHeight)\n\t\t\t\t) * (legendStep + 1)\n\t\t\t) :\n\t\t\t0;\n\n\t\treturn height;\n\t},\n\n\t/**\n\t * Get the opacity of the legend that is unfocused\n\t * @param {d3.selection} legendItem Legend item node\n\t * @returns {string|null} opacity\n\t * @private\n\t */\n\topacityForUnfocusedLegend(legendItem): string | null {\n\t\treturn legendItem.classed($LEGEND.legendItemHidden) ? null : \"0.3\";\n\t},\n\n\t/**\n\t * Toggles the focus of the legend\n\t * @param {Array} targetIds ID's of target\n\t * @param {boolean} focus whether or not to focus.\n\t * @private\n\t */\n\ttoggleFocusLegend(targetIds: string[], focus: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {legend}, $T} = $$;\n\t\tconst targetIdz = $$.mapToTargetIds(targetIds);\n\n\t\tlegend && $T(legend.selectAll(`.${$LEGEND.legendItem}`)\n\t\t\t.filter(id => targetIdz.indexOf(id) >= 0)\n\t\t\t.classed($FOCUS.legendItemFocused, focus))\n\t\t\t.style(\"opacity\", function() {\n\t\t\t\treturn focus ? null : $$.opacityForUnfocusedLegend.call($$, d3Select(this));\n\t\t\t});\n\t},\n\n\t/**\n\t * Revert the legend to its default state\n\t * @private\n\t */\n\trevertLegend(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {legend}, $T} = $$;\n\n\t\tlegend && $T(legend.selectAll(`.${$LEGEND.legendItem}`)\n\t\t\t.classed($FOCUS.legendItemFocused, false))\n\t\t\t.style(\"opacity\", null);\n\t},\n\n\t/**\n\t * Shows the legend\n\t * @param {Array} targetIds ID's of target\n\t * @private\n\t */\n\tshowLegend(targetIds: string[]): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el, $T} = $$;\n\n\t\tif (!config.legend_show) {\n\t\t\tconfig.legend_show = true;\n\n\t\t\t$el.legend ? $el.legend.style(\"visibility\", null) : $$.initLegend();\n\n\t\t\t!$$.state.legendHasRendered && $$.updateLegend();\n\t\t}\n\n\t\t$$.removeHiddenLegendIds(targetIds);\n\n\t\t$T(\n\t\t\t$el.legend.selectAll($$.selectorLegends(targetIds))\n\t\t\t\t.style(\"visibility\", null)\n\t\t).style(\"opacity\", null);\n\t},\n\n\t/**\n\t * Hide the legend\n\t * @param {Array} targetIds ID's of target\n\t * @private\n\t */\n\thideLegend(targetIds: string[]): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {legend}} = $$;\n\n\t\tif (config.legend_show && isEmpty(targetIds)) {\n\t\t\tconfig.legend_show = false;\n\t\t\tlegend.style(\"visibility\", \"hidden\");\n\t\t}\n\n\t\t$$.addHiddenLegendIds(targetIds);\n\t\tlegend.selectAll($$.selectorLegends(targetIds))\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.style(\"visibility\", \"hidden\");\n\t},\n\n\t/**\n\t * Get legend item textbox dimension\n\t * @param {string} id Data ID\n\t * @param {HTMLElement|d3.selection} textElement Text node element\n\t * @returns {object} Bounding rect\n\t * @private\n\t */\n\tgetLegendItemTextBox(id?: string, textElement?) {\n\t\tconst $$ = this;\n\t\tconst {cache, state} = $$;\n\t\tlet data;\n\n\t\t// do not prefix w/'$', to not be resetted cache in .load() call\n\t\tconst cacheKey = KEY.legendItemTextBox;\n\n\t\tif (id) {\n\t\t\tdata = (!state.redrawing && cache.get(cacheKey)) || {};\n\n\t\t\tif (!data[id]) {\n\t\t\t\tdata[id] = $$.getTextRect(textElement, $LEGEND.legendItem);\n\t\t\t\tcache.add(cacheKey, data);\n\t\t\t}\n\n\t\t\tdata = data[id];\n\t\t}\n\n\t\treturn data;\n\t},\n\n\t/**\n\t * Set legend item style & bind events\n\t * @param {d3.selection} item Item node\n\t * @private\n\t */\n\tsetLegendItem(item): void {\n\t\tconst $$ = this;\n\t\tconst {$el, api, config, state} = $$;\n\t\tconst isTouch = state.inputType === \"touch\";\n\t\tconst hasGauge = $$.hasType(\"gauge\");\n\t\tconst useCssRule = config.boost_useCssRule;\n\t\tconst interaction = config.legend_item_interaction;\n\n\t\titem\n\t\t\t.attr(\"class\", function(id) {\n\t\t\t\tconst node = d3Select(this);\n\t\t\t\tconst itemClass = (!node.empty() && node.attr(\"class\")) || \"\";\n\n\t\t\t\treturn itemClass + $$.generateClass($LEGEND.legendItem, id);\n\t\t\t})\n\t\t\t.style(\"visibility\", id => ($$.isLegendToShow(id) ? null : \"hidden\"));\n\n\t\tif (config.interaction_enabled) {\n\t\t\tif (useCssRule) {\n\t\t\t\t[\n\t\t\t\t\t[`.${$LEGEND.legendItem}`, \"cursor:pointer\"],\n\t\t\t\t\t[`.${$LEGEND.legendItem} text`, \"pointer-events:none\"],\n\t\t\t\t\t[`.${$LEGEND.legendItemPoint} text`, \"pointer-events:none\"],\n\t\t\t\t\t[`.${$LEGEND.legendItemTile}`, \"pointer-events:none\"],\n\t\t\t\t\t[`.${$LEGEND.legendItemEvent}`, \"fill-opacity:0\"]\n\t\t\t\t].forEach(v => {\n\t\t\t\t\tconst [selector, props] = v;\n\n\t\t\t\t\t$$.setCssRule(false, selector, [props])($el.legend);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\titem\n\t\t\t\t.on(interaction.dblclick ? \"dblclick\" : \"click\",\n\t\t\t\t\tinteraction || isFunction(config.legend_item_onclick) ?\n\t\t\t\t\t\tfunction(event, id) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!callFn(config.legend_item_onclick, api, id,\n\t\t\t\t\t\t\t\t\t!state.hiddenTargetIds.includes(id))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst {altKey, target, type} = event;\n\n\t\t\t\t\t\t\t\tif (type === \"dblclick\" || altKey) {\n\t\t\t\t\t\t\t\t\t// when focused legend is clicked(with altKey or double clicked), reset all hiding.\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tstate.hiddenTargetIds.length &&\n\t\t\t\t\t\t\t\t\t\ttarget.parentNode.getAttribute(\"class\").indexOf(\n\t\t\t\t\t\t\t\t\t\t\t\t$LEGEND.legendItemHidden\n\t\t\t\t\t\t\t\t\t\t\t) === -1\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tapi.show();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tapi.hide();\n\t\t\t\t\t\t\t\t\t\tapi.show(id);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tapi.toggle(id);\n\n\t\t\t\t\t\t\t\t\td3Select(this)\n\t\t\t\t\t\t\t\t\t\t.classed($FOCUS.legendItemFocused, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tisTouch && $$.hideTooltip();\n\t\t\t\t\t\t} :\n\t\t\t\t\t\tnull);\n\n\t\t\t!isTouch && item\n\t\t\t\t.on(\"mouseout\", interaction || isFunction(config.legend_item_onout) ?\n\t\t\t\t\tfunction(event, id) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!callFn(config.legend_item_onout, api, id,\n\t\t\t\t\t\t\t\t!state.hiddenTargetIds.includes(id))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\td3Select(this).classed($FOCUS.legendItemFocused, false);\n\n\t\t\t\t\t\t\tif (hasGauge) {\n\t\t\t\t\t\t\t\t$$.undoMarkOverlapped($$, `.${$GAUGE.gaugeValue}`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$$.api.revert();\n\t\t\t\t\t\t}\n\t\t\t\t\t} :\n\t\t\t\t\tnull)\n\t\t\t\t.on(\"mouseover\", interaction || isFunction(config.legend_item_onover) ?\n\t\t\t\t\tfunction(event, id) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!callFn(config.legend_item_onover, api, id,\n\t\t\t\t\t\t\t\t!state.hiddenTargetIds.includes(id))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\td3Select(this).classed($FOCUS.legendItemFocused, true);\n\n\t\t\t\t\t\t\tif (hasGauge) {\n\t\t\t\t\t\t\t\t$$.markOverlapped(id, $$, `.${$GAUGE.gaugeValue}`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!state.transiting && $$.isTargetToShow(id)) {\n\t\t\t\t\t\t\t\tapi.focus(id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} :\n\t\t\t\t\tnull);\n\n\t\t\t// set cursor when has some interaction\n\t\t\t!item.empty() && item.on(\"click mouseout mouseover\") &&\n\t\t\t\titem.style(\"cursor\", $$.getStylePropValue(\"pointer\"));\n\t\t}\n\t},\n\n\t/**\n\t * Update the legend\n\t * @param {Array} targetIds ID's of target\n\t * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.\n\t * @private\n\t */\n\tupdateLegendElement(targetIds: string[], options): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {legend}, $T} = $$;\n\t\tconst legendType = config.legend_item_tile_type;\n\t\tconst isRectangle = legendType !== \"circle\";\n\t\tconst legendItemR = config.legend_item_tile_r;\n\n\t\tconst itemTileSize = {\n\t\t\twidth: isRectangle ? config.legend_item_tile_width : legendItemR * 2,\n\t\t\theight: isRectangle ? config.legend_item_tile_height : legendItemR * 2\n\t\t};\n\n\t\tconst dimension = {\n\t\t\tpadding: {\n\t\t\t\ttop: 4,\n\t\t\t\tright: 10\n\t\t\t},\n\t\t\tmax: {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t},\n\t\t\tposMin: 10,\n\t\t\tstep: 0,\n\t\t\ttileWidth: itemTileSize.width + 5,\n\t\t\ttotalLength: 0\n\t\t};\n\n\t\tconst sizes = {\n\t\t\toffsets: {},\n\t\t\twidths: {},\n\t\t\theights: {},\n\t\t\tmargins: [0],\n\t\t\tsteps: {}\n\t\t};\n\n\t\tlet xForLegend;\n\t\tlet yForLegend;\n\t\tlet background;\n\n\t\t// Skip elements when their name is set to null\n\t\tconst targetIdz = targetIds\n\t\t\t.filter(id => !isDefined(config.data_names[id]) || config.data_names[id] !== null);\n\n\t\tconst withTransition = options.withTransition;\n\t\tconst updatePositions = $$.getUpdateLegendPositions(targetIdz, dimension, sizes);\n\n\t\tif (state.isLegendInset) {\n\t\t\tdimension.step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length;\n\t\t\t$$.updateLegendStep(dimension.step);\n\t\t}\n\n\t\tif (state.isLegendRight) {\n\t\t\txForLegend = id => dimension.max.width * sizes.steps[id];\n\t\t\tyForLegend = id => sizes.margins[sizes.steps[id]] + sizes.offsets[id];\n\t\t} else if (state.isLegendInset) {\n\t\t\txForLegend = id => dimension.max.width * sizes.steps[id] + 10;\n\t\t\tyForLegend = id => sizes.margins[sizes.steps[id]] + sizes.offsets[id];\n\t\t} else {\n\t\t\txForLegend = id => sizes.margins[sizes.steps[id]] + sizes.offsets[id];\n\t\t\tyForLegend = id => dimension.max.height * sizes.steps[id];\n\t\t}\n\n\t\tconst posFn = {\n\t\t\txText: (id, i?: number) => xForLegend(id, i) + 4 + itemTileSize.width,\n\t\t\txRect: (id, i?: number) => xForLegend(id, i),\n\t\t\tx1Tile: (id, i?: number) => xForLegend(id, i) - 2,\n\t\t\tx2Tile: (id, i?: number) => xForLegend(id, i) - 2 + itemTileSize.width,\n\t\t\tyText: (id, i?: number) => yForLegend(id, i) + 9,\n\t\t\tyRect: (id, i?: number) => yForLegend(id, i) - 5,\n\t\t\tyTile: (id, i?: number) => yForLegend(id, i) + 4\n\t\t};\n\n\t\t$$.generateLegendItem(targetIdz, itemTileSize, updatePositions, posFn);\n\n\t\t// Set background for inset legend\n\t\tbackground = legend.select(`.${$LEGEND.legendBackground} rect`);\n\n\t\tif (state.isLegendInset && dimension.max.width > 0 && background.size() === 0) {\n\t\t\tbackground = legend.insert(\"g\", `.${$LEGEND.legendItem}`)\n\t\t\t\t.attr(\"class\", $LEGEND.legendBackground)\n\t\t\t\t.append(\"rect\");\n\t\t}\n\n\t\tif (config.legend_tooltip) {\n\t\t\tlegend.selectAll(\"title\")\n\t\t\t\t.data(targetIdz)\n\t\t\t\t.text(id => getFormattedText.bind($$)(id, false));\n\t\t}\n\n\t\tconst texts = legend.selectAll(\"text\")\n\t\t\t.data(targetIdz)\n\t\t\t.text(id => getFormattedText.bind($$)(id)) // MEMO: needed for update\n\t\t\t.each(function(id, i) {\n\t\t\t\tupdatePositions(this, id, i);\n\t\t\t});\n\n\t\t$T(texts, withTransition)\n\t\t\t.attr(\"x\", posFn.xText)\n\t\t\t.attr(\"y\", posFn.yText);\n\n\t\tconst rects = legend.selectAll(`rect.${$LEGEND.legendItemEvent}`)\n\t\t\t.data(targetIdz);\n\n\t\t$T(rects, withTransition)\n\t\t\t.attr(\"width\", id => sizes.widths[id])\n\t\t\t.attr(\"height\", id => sizes.heights[id])\n\t\t\t.attr(\"x\", posFn.xRect)\n\t\t\t.attr(\"y\", posFn.yRect);\n\n\t\t// update legend items position\n\t\t$$.updateLegendItemPos(targetIdz, withTransition, posFn);\n\n\t\tif (background) {\n\t\t\t$T(background, withTransition)\n\t\t\t\t.attr(\"height\", $$.getLegendHeight() - 12)\n\t\t\t\t.attr(\"width\", dimension.max.width * (dimension.step + 1) + 10);\n\t\t}\n\n\t\t// Update all to reflect change of legend\n\t\t$$.updateLegendItemWidth(dimension.max.width);\n\t\t$$.updateLegendItemHeight(dimension.max.height);\n\t\t$$.updateLegendStep(dimension.step);\n\t},\n\n\t/**\n\t * Get position update function\n\t * @param {Array} targetIdz Data ids\n\t * @param {object} dimension Dimension object\n\t * @param {object} sizes Size object\n\t * @returns {Function} Update position function\n\t * @private\n\t */\n\tgetUpdateLegendPositions(targetIdz, dimension, sizes) {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst isLegendRightOrInset = state.isLegendRight || state.isLegendInset;\n\n\t\treturn function(textElement, id, index) {\n\t\t\tconst reset = index === 0;\n\t\t\tconst isLast = index === targetIdz.length - 1;\n\t\t\tconst box = $$.getLegendItemTextBox(id, textElement);\n\n\t\t\tconst itemWidth = box.width + dimension.tileWidth +\n\t\t\t\t(isLast && !isLegendRightOrInset ? 0 : dimension.padding.right) +\n\t\t\t\tconfig.legend_padding;\n\t\t\tconst itemHeight = box.height + dimension.padding.top;\n\t\t\tconst itemLength = isLegendRightOrInset ? itemHeight : itemWidth;\n\t\t\tconst areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth();\n\t\t\tlet margin;\n\n\t\t\t// MEMO: care about condifion of step, totalLength\n\t\t\tconst updateValues = function(id2, withoutStep?: boolean) {\n\t\t\t\tif (!withoutStep) {\n\t\t\t\t\tmargin = (areaLength - dimension.totalLength - itemLength) / 2;\n\n\t\t\t\t\tif (margin < dimension.posMin) {\n\t\t\t\t\t\tmargin = (areaLength - itemLength) / 2;\n\t\t\t\t\t\tdimension.totalLength = 0;\n\t\t\t\t\t\tdimension.step++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsizes.steps[id2] = dimension.step;\n\t\t\t\tsizes.margins[dimension.step] = state.isLegendInset ? 10 : margin;\n\t\t\t\tsizes.offsets[id2] = dimension.totalLength;\n\t\t\t\tdimension.totalLength += itemLength;\n\t\t\t};\n\n\t\t\tif (reset) {\n\t\t\t\tdimension.totalLength = 0;\n\t\t\t\tdimension.step = 0;\n\t\t\t\tdimension.max.width = 0;\n\t\t\t\tdimension.max.height = 0;\n\t\t\t}\n\n\t\t\tif (config.legend_show && !$$.isLegendToShow(id)) {\n\t\t\t\tsizes.widths[id] = 0;\n\t\t\t\tsizes.heights[id] = 0;\n\t\t\t\tsizes.steps[id] = 0;\n\t\t\t\tsizes.offsets[id] = 0;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsizes.widths[id] = itemWidth;\n\t\t\tsizes.heights[id] = itemHeight;\n\n\t\t\tif (!dimension.max.width || itemWidth >= dimension.max.width) {\n\t\t\t\tdimension.max.width = itemWidth;\n\t\t\t}\n\n\t\t\tif (!dimension.max.height || itemHeight >= dimension.max.height) {\n\t\t\t\tdimension.max.height = itemHeight;\n\t\t\t}\n\n\t\t\tconst maxLength = isLegendRightOrInset ? dimension.max.height : dimension.max.width;\n\n\t\t\tif (config.legend_equally) {\n\t\t\t\tObject.keys(sizes.widths).forEach(id2 => (sizes.widths[id2] = dimension.max.width));\n\t\t\t\tObject.keys(sizes.heights).forEach(\n\t\t\t\t\tid2 => (sizes.heights[id2] = dimension.max.height)\n\t\t\t\t);\n\t\t\t\tmargin = (areaLength - maxLength * targetIdz.length) / 2;\n\n\t\t\t\tif (margin < dimension.posMin) {\n\t\t\t\t\tdimension.totalLength = 0;\n\t\t\t\t\tdimension.step = 0;\n\t\t\t\t\ttargetIdz.forEach(id2 => updateValues(id2));\n\t\t\t\t} else {\n\t\t\t\t\tupdateValues(id, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdateValues(id);\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t * Generate legend item elements\n\t * @param {Array} targetIdz Data ids\n\t * @param {object} itemTileSize Item tile size {width, height}\n\t * @param {Function} updatePositions Update position function\n\t * @param {object} posFn Position functions\n\t * @private\n\t */\n\tgenerateLegendItem(targetIdz, itemTileSize, updatePositions, posFn) {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {legend}} = $$;\n\t\tconst usePoint = config.legend_usePoint;\n\t\tconst legendItemR = config.legend_item_tile_r;\n\t\tconst legendType = config.legend_item_tile_type;\n\t\tconst isRectangle = legendType !== \"circle\";\n\t\tconst isLegendRightOrInset = state.isLegendRight || state.isLegendInset;\n\n\t\tconst pos = -200;\n\n\t\t// Define g for legend area\n\t\tconst l = legend.selectAll(`.${$LEGEND.legendItem}`)\n\t\t\t.data(targetIdz)\n\t\t\t.enter()\n\t\t\t.append(\"g\");\n\n\t\t$$.setLegendItem(l);\n\n\t\tif (config.legend_tooltip) {\n\t\t\tl.append(\"title\").text(id => id);\n\t\t}\n\n\t\tl.append(\"text\")\n\t\t\t.text(id => getFormattedText.bind($$)(id))\n\t\t\t.each(function(id, i) {\n\t\t\t\tupdatePositions(this, id, i);\n\t\t\t})\n\t\t\t.style(\"pointer-events\", $$.getStylePropValue(\"none\"))\n\t\t\t.attr(\"x\", isLegendRightOrInset ? posFn.xText : pos)\n\t\t\t.attr(\"y\", isLegendRightOrInset ? pos : posFn.yText);\n\n\t\tl.append(\"rect\")\n\t\t\t.attr(\"class\", $LEGEND.legendItemEvent)\n\t\t\t.style(\"fill-opacity\", $$.getStylePropValue(\"0\"))\n\t\t\t.attr(\"x\", isLegendRightOrInset ? posFn.xRect : pos)\n\t\t\t.attr(\"y\", isLegendRightOrInset ? pos : posFn.yRect);\n\n\t\tif (usePoint) {\n\t\t\tconst ids: string[] = [];\n\n\t\t\tl.append(d => {\n\t\t\t\tconst pattern = notEmpty(config.point_pattern) ?\n\t\t\t\t\tconfig.point_pattern :\n\t\t\t\t\t[config.point_type];\n\n\t\t\t\tids.indexOf(d) === -1 && ids.push(d);\n\n\t\t\t\tlet point = pattern[ids.indexOf(d) % pattern.length];\n\n\t\t\t\tif (point === \"rectangle\") {\n\t\t\t\t\tpoint = \"rect\";\n\t\t\t\t}\n\n\t\t\t\treturn document.createElementNS(d3Namespaces.svg,\n\t\t\t\t\t(\"hasValidPointType\" in $$) && $$.hasValidPointType(point) ? point : \"use\");\n\t\t\t})\n\t\t\t\t.attr(\"class\", $LEGEND.legendItemPoint)\n\t\t\t\t.style(\"fill\", getLegendColor.bind($$))\n\t\t\t\t.style(\"pointer-events\", $$.getStylePropValue(\"none\"))\n\t\t\t\t.attr(\"href\", (data, idx, selection) => {\n\t\t\t\t\tconst node = selection[idx];\n\t\t\t\t\tconst nodeName = node.nodeName.toLowerCase();\n\t\t\t\t\tconst id = $$.getTargetSelectorSuffix(data);\n\n\t\t\t\t\treturn nodeName === \"use\" ? `#${state.datetimeId}-point${id}` : undefined;\n\t\t\t\t});\n\t\t} else {\n\t\t\tl.append(isRectangle ? \"line\" : legendType)\n\t\t\t\t.attr(\"class\", $LEGEND.legendItemTile)\n\t\t\t\t.style(\"stroke\", getLegendColor.bind($$))\n\t\t\t\t.style(\"pointer-events\", $$.getStylePropValue(\"none\"))\n\t\t\t\t.call(selection => {\n\t\t\t\t\tif (legendType === \"circle\") {\n\t\t\t\t\t\tselection\n\t\t\t\t\t\t\t.attr(\"r\", legendItemR)\n\t\t\t\t\t\t\t.style(\"fill\", getLegendColor.bind($$))\n\t\t\t\t\t\t\t.attr(\"cx\", isLegendRightOrInset ? posFn.x2Tile : pos)\n\t\t\t\t\t\t\t.attr(\"cy\", isLegendRightOrInset ? pos : posFn.yTile);\n\t\t\t\t\t} else if (isRectangle) {\n\t\t\t\t\t\tselection\n\t\t\t\t\t\t\t.attr(\"stroke-width\", itemTileSize.height)\n\t\t\t\t\t\t\t.attr(\"x1\", isLegendRightOrInset ? posFn.x1Tile : pos)\n\t\t\t\t\t\t\t.attr(\"y1\", isLegendRightOrInset ? pos : posFn.yTile)\n\t\t\t\t\t\t\t.attr(\"x2\", isLegendRightOrInset ? posFn.x2Tile : pos)\n\t\t\t\t\t\t\t.attr(\"y2\", isLegendRightOrInset ? pos : posFn.yTile);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Update legend item position\n\t * @param {Array} targetIdz Data ids\n\t * @param {boolean} withTransition Whether or not to apply transition\n\t * @param {object} posFn Position functions\n\t * @private\n\t */\n\tupdateLegendItemPos(targetIdz: string[], withTransition: boolean, posFn): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {legend}, $T} = $$;\n\t\tconst usePoint = config.legend_usePoint;\n\t\tconst legendType = config.legend_item_tile_type;\n\t\tconst isRectangle = legendType !== \"circle\";\n\n\t\tif (usePoint) {\n\t\t\tconst tiles = legend.selectAll(`.${$LEGEND.legendItemPoint}`)\n\t\t\t\t.data(targetIdz);\n\n\t\t\t$T(tiles, withTransition)\n\t\t\t\t.each(function() {\n\t\t\t\t\tconst nodeName = this.nodeName.toLowerCase();\n\t\t\t\t\tconst pointR = config.point_r;\n\t\t\t\t\tlet x = \"x\";\n\t\t\t\t\tlet y = \"y\";\n\t\t\t\t\tlet xOffset = 2;\n\t\t\t\t\tlet yOffset = 2.5;\n\t\t\t\t\tlet radius = null;\n\t\t\t\t\tlet width = <number | null>null;\n\t\t\t\t\tlet height = <number | null>null;\n\n\t\t\t\t\tif (nodeName === \"circle\") {\n\t\t\t\t\t\tconst size = pointR * 0.2;\n\n\t\t\t\t\t\tx = \"cx\";\n\t\t\t\t\t\ty = \"cy\";\n\t\t\t\t\t\tradius = pointR + size;\n\t\t\t\t\t\txOffset = pointR * 2;\n\t\t\t\t\t\tyOffset = -size;\n\t\t\t\t\t} else if (nodeName === \"rect\") {\n\t\t\t\t\t\tconst size = pointR * 2.5;\n\n\t\t\t\t\t\twidth = size;\n\t\t\t\t\t\theight = size;\n\t\t\t\t\t\tyOffset = 3;\n\t\t\t\t\t}\n\n\t\t\t\t\td3Select(this)\n\t\t\t\t\t\t.attr(x, d => posFn.x1Tile(d) + xOffset)\n\t\t\t\t\t\t.attr(y, d => posFn.yTile(d) - yOffset)\n\t\t\t\t\t\t.attr(\"r\", radius)\n\t\t\t\t\t\t.attr(\"width\", width)\n\t\t\t\t\t\t.attr(\"height\", height);\n\t\t\t\t});\n\t\t} else {\n\t\t\tconst tiles = legend.selectAll(`.${$LEGEND.legendItemTile}`)\n\t\t\t\t.data(targetIdz);\n\n\t\t\t$T(tiles, withTransition)\n\t\t\t\t.style(\"stroke\", getLegendColor.bind($$))\n\t\t\t\t.call(selection => {\n\t\t\t\t\tif (legendType === \"circle\") {\n\t\t\t\t\t\tselection\n\t\t\t\t\t\t\t.attr(\"cx\", d => {\n\t\t\t\t\t\t\t\tconst x2 = posFn.x2Tile(d);\n\n\t\t\t\t\t\t\t\treturn x2 - ((x2 - posFn.x1Tile(d)) / 2);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.attr(\"cy\", posFn.yTile);\n\t\t\t\t\t} else if (isRectangle) {\n\t\t\t\t\t\tselection\n\t\t\t\t\t\t\t.attr(\"x1\", posFn.x1Tile)\n\t\t\t\t\t\t\t.attr(\"y1\", posFn.yTile)\n\t\t\t\t\t\t\t.attr(\"x2\", posFn.x2Tile)\n\t\t\t\t\t\t\t.attr(\"y2\", posFn.yTile);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {transition as d3Transition} from \"d3-transition\";\nimport {$COMMON, $SELECT, $TEXT} from \"../../config/classes\";\nimport {generateWait} from \"../../module/generator\";\nimport {callFn, capitalize, getOption, isTabVisible, notEmpty} from \"../../module/util\";\n\nexport default {\n\tredraw(options: any = {}): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el} = $$;\n\t\tconst {main, treemap} = $el;\n\n\t\tstate.redrawing = true;\n\n\t\tconst targetsToShow = $$.filterTargetsToShow($$.data.targets);\n\t\tconst {flow, initializing} = options;\n\t\tconst wth = $$.getWithOption(options);\n\t\tconst duration = wth.Transition ? config.transition_duration : 0;\n\t\tconst durationForExit = wth.TransitionForExit ? duration : 0;\n\t\tconst durationForAxis = wth.TransitionForAxis ? duration : 0;\n\t\tconst transitions = $$.axis?.generateTransitions(durationForAxis);\n\n\t\t$$.updateSizes(initializing);\n\n\t\t// update legend and transform each g\n\t\tif (wth.Legend && config.legend_show) {\n\t\t\toptions.withTransition = !!duration;\n\t\t\t!treemap && $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);\n\t\t} else if (wth.Dimension) {\n\t\t\t// need to update dimension (e.g. axis.y.tick.values) because y tick values should change\n\t\t\t// no need to update axis in it because they will be updated in redraw()\n\t\t\t$$.updateDimension(true);\n\t\t}\n\n\t\t// Data empty label positioning and text.\n\t\tconfig.data_empty_label_text && main.select(`text.${$TEXT.text}.${$COMMON.empty}`)\n\t\t\t.attr(\"x\", state.width / 2)\n\t\t\t.attr(\"y\", state.height / 2)\n\t\t\t.text(config.data_empty_label_text)\n\t\t\t.style(\"display\", targetsToShow.length ? \"none\" : null);\n\n\t\t// update axis\n\t\tif (state.hasAxis) {\n\t\t\t// @TODO: Make 'init' state to be accessible everywhere not passing as argument.\n\t\t\t$$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing);\n\n\t\t\t// grid\n\t\t\t$$.hasGrid() && $$.updateGrid();\n\n\t\t\t// rect for regions\n\t\t\tconfig.regions.length && $$.updateRegion();\n\n\t\t\t[\"bar\", \"candlestick\", \"line\", \"area\"].forEach(v => {\n\t\t\t\tconst name = capitalize(v);\n\n\t\t\t\tif ((/^(line|area)$/.test(v) && $$.hasTypeOf(name)) || $$.hasType(v)) {\n\t\t\t\t\t$$[`update${name}`](wth.TransitionForExit);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// circles for select\n\t\t\t$el.text && main.selectAll(`.${$SELECT.selectedCircles}`)\n\t\t\t\t.filter($$.isBarType.bind($$))\n\t\t\t\t.selectAll(\"circle\")\n\t\t\t\t.remove();\n\n\t\t\t// event rects will redrawn when flow called\n\t\t\tif (config.interaction_enabled && !flow && wth.EventRect) {\n\t\t\t\t$$.redrawEventRect();\n\t\t\t\t$$.bindZoomEvent?.();\n\t\t\t}\n\t\t} else {\n\t\t\t// arc\n\t\t\t$el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform);\n\n\t\t\t// radar\n\t\t\t$el.radar && $$.redrawRadar();\n\n\t\t\t// polar\n\t\t\t$el.polar && $$.redrawPolar();\n\n\t\t\t// funnel\n\t\t\t$el.funnel && $$.redrawFunnel();\n\n\t\t\t// treemap\n\t\t\ttreemap && $$.updateTreemap(durationForExit);\n\t\t}\n\n\t\tif (!state.resizing && !treemap && ($$.hasPointType() || state.hasRadar)) {\n\t\t\t$$.updateCircle();\n\t\t} else if ($$.hasLegendDefsPoint?.()) {\n\t\t\t$$.data.targets.forEach($$.point(\"create\", this));\n\t\t}\n\n\t\t// text\n\t\t$$.hasDataLabel() && !$$.hasArcType(null, [\"radar\"]) && $$.updateText();\n\n\t\t// title\n\t\t$$.redrawTitle?.();\n\n\t\tinitializing && $$.updateTypesElements();\n\n\t\t$$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart);\n\t\t$$.updateTooltipOnRedraw();\n\n\t\t$$.callPluginHook(\"$redraw\", options, duration);\n\t},\n\n\t/**\n\t * Generate redraw list\n\t * @param {object} targets targets data to be shown\n\t * @param {object} flow flow object\n\t * @param {number} duration duration value\n\t * @param {boolean} withSubchart whether or not to show subchart\n\t * @private\n\t */\n\tgenerateRedrawList(targets, flow: any, duration: number, withSubchart: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst shape = $$.getDrawShape();\n\n\t\tif (state.hasAxis) {\n\t\t\t// subchart\n\t\t\tconfig.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);\n\t\t}\n\n\t\t// generate flow\n\t\tconst flowFn = flow && $$.generateFlow({\n\t\t\ttargets,\n\t\t\tflow,\n\t\t\tduration: flow.duration,\n\t\t\tshape,\n\t\t\txv: $$.xv.bind($$)\n\t\t});\n\t\tconst withTransition = (duration || flowFn) && isTabVisible();\n\n\t\t// redraw list\n\t\tconst redrawList = $$.getRedrawList(shape, flow, flowFn, withTransition);\n\n\t\t// callback function after redraw ends\n\t\tconst afterRedraw = () => {\n\t\t\tflowFn && flowFn();\n\n\t\t\tstate.redrawing = false;\n\t\t\tcallFn(config.onrendered, $$.api);\n\t\t};\n\n\t\tif (afterRedraw) {\n\t\t\t// Only use transition when current tab is visible.\n\t\t\tif (withTransition && redrawList.length) {\n\t\t\t\t// Wait for end of transitions for callback\n\t\t\t\tconst waitForDraw = generateWait();\n\n\t\t\t\t// transition should be derived from one transition\n\t\t\t\td3Transition().duration(duration)\n\t\t\t\t\t.each(() => {\n\t\t\t\t\t\tredrawList\n\t\t\t\t\t\t\t.reduce((acc, t1) => acc.concat(t1), [])\n\t\t\t\t\t\t\t.forEach(t => waitForDraw.add(t));\n\t\t\t\t\t})\n\t\t\t\t\t.call(waitForDraw, afterRedraw);\n\t\t\t} else if (!state.transiting) {\n\t\t\t\tafterRedraw();\n\t\t\t}\n\t\t}\n\n\t\t// update fadein condition\n\t\t$$.mapToIds($$.data.targets).forEach(id => {\n\t\t\tstate.withoutFadeIn[id] = true;\n\t\t});\n\t},\n\n\tgetRedrawList(shape, flow, flowFn, withTransition: boolean): Function[] {\n\t\tconst $$ = <any>this;\n\t\tconst {config, state: {hasAxis, hasRadar, hasTreemap}, $el: {grid}} = $$;\n\t\tconst {cx, cy, xForText, yForText} = shape.pos;\n\t\tconst list: Function[] = [];\n\n\t\tif (hasAxis) {\n\t\t\tif (config.grid_x_lines.length || config.grid_y_lines.length) {\n\t\t\t\tlist.push($$.redrawGrid(withTransition));\n\t\t\t}\n\n\t\t\tif (config.regions.length) {\n\t\t\t\tlist.push($$.redrawRegion(withTransition));\n\t\t\t}\n\n\t\t\tObject.keys(shape.type).forEach(v => {\n\t\t\t\tconst name = capitalize(v);\n\t\t\t\tconst drawFn = shape.type[v];\n\n\t\t\t\tif ((/^(area|line)$/.test(v) && $$.hasTypeOf(name)) || $$.hasType(v)) {\n\t\t\t\t\tlist.push($$[`redraw${name}`](drawFn, withTransition));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t!flow && grid.main && list.push($$.updateGridFocus());\n\t\t}\n\n\t\tif (!$$.hasArcType() || hasRadar) {\n\t\t\tnotEmpty(config.data_labels) && config.data_labels !== false &&\n\t\t\t\tlist.push($$.redrawText(xForText, yForText, flow, withTransition));\n\t\t}\n\n\t\tif (($$.hasPointType() || hasRadar) && !$$.isPointFocusOnly()) {\n\t\t\t$$.redrawCircle && list.push($$.redrawCircle(cx, cy, withTransition, flowFn));\n\t\t}\n\n\t\tif (hasTreemap) {\n\t\t\tlist.push($$.redrawTreemap(withTransition));\n\t\t}\n\n\t\treturn list;\n\t},\n\n\tupdateAndRedraw(options: any = {}): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tlet transitions;\n\n\t\t// same with redraw\n\t\toptions.withTransition = getOption(options, \"withTransition\", true);\n\t\toptions.withTransform = getOption(options, \"withTransform\", false);\n\t\toptions.withLegend = getOption(options, \"withLegend\", false);\n\n\t\t// NOT same with redraw\n\t\toptions.withUpdateXDomain = true;\n\t\toptions.withUpdateOrgXDomain = true;\n\t\toptions.withTransitionForExit = false;\n\t\toptions.withTransitionForTransform = getOption(options, \"withTransitionForTransform\",\n\t\t\toptions.withTransition);\n\n\t\t// MEMO: called in updateLegend in redraw if withLegend\n\t\tif (!(options.withLegend && config.legend_show)) {\n\t\t\tif (state.hasAxis) {\n\t\t\t\ttransitions = $$.axis.generateTransitions(\n\t\t\t\t\toptions.withTransitionForAxis ? config.transition_duration : 0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Update scales\n\t\t\t$$.updateScales();\n\t\t\t$$.updateSvgSize();\n\n\t\t\t// Update g positions\n\t\t\t$$.transformAll(options.withTransitionForTransform, transitions);\n\t\t}\n\n\t\t// Draw with new sizes & scales\n\t\t$$.redraw(options, transitions);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {\n\tscaleLinear as d3ScaleLinear,\n\tscaleLog as d3ScaleLog,\n\tscaleSymlog as d3ScaleSymlog,\n\tscaleTime as d3ScaleTime,\n\tscaleUtc as d3ScaleUtc\n} from \"d3-scale\";\nimport {isString, isValue, parseDate} from \"../../module/util\";\nimport type {IDataRow, IGridData} from \"../data/IData\";\n\n/**\n * Get scale\n * @param {string} [type='linear'] Scale type\n * @param {number|Date} [min] Min range\n * @param {number|Date} [max] Max range\n * @returns {d3.scaleLinear|d3.scaleTime} scale\n * @private\n */\nexport function getScale<T = IDataRow[\"x\"]>(type = \"linear\", min?: T, max?: T): any {\n\tconst scale = ({\n\t\tlinear: d3ScaleLinear,\n\t\tlog: d3ScaleSymlog,\n\t\t_log: d3ScaleLog,\n\t\ttime: d3ScaleTime,\n\t\tutc: d3ScaleUtc\n\t})[type]();\n\n\tscale.type = type;\n\t/_?log/.test(type) && scale.clamp(true);\n\n\treturn scale.range([min ?? 0, max ?? 1]);\n}\n\nexport default {\n\t/**\n\t * Get x Axis scale function\n\t * @param {number} min Min range value\n\t * @param {number} max Max range value\n\t * @param {Array} domain Domain value\n\t * @param {Function} offset The offset getter to be sum\n\t * @returns {Function} scale\n\t * @private\n\t */\n\tgetXScale(min: number, max: number, domain: number[], offset: Function) {\n\t\tconst $$ = this;\n\t\tconst scale = ($$.state.loading !== \"append\" && $$.scale.zoom) ||\n\t\t\tgetScale($$.axis.getAxisType(\"x\"), min, max);\n\n\t\treturn $$.getCustomizedXScale(\n\t\t\tdomain ? scale.domain(domain) : scale,\n\t\t\toffset\n\t\t);\n\t},\n\n\t/**\n\t * Get y Axis scale function\n\t * @param {string} id Axis id: 'y' or 'y2'\n\t * @param {number} min Min value\n\t * @param {number} max Max value\n\t * @param {Array} domain Domain value\n\t * @returns {Function} Scale function\n\t * @private\n\t */\n\tgetYScale(id: \"y\" | \"y2\", min: number, max: number, domain: number[]): Function {\n\t\tconst $$ = this;\n\t\tconst scale = getScale($$.axis.getAxisType(id), min, max);\n\n\t\tdomain && scale.domain(domain);\n\n\t\treturn scale;\n\t},\n\n\t/**\n\t * Get y Axis scale\n\t * @param {string} id Axis id\n\t * @param {boolean} isSub Weather is sub Axis\n\t * @returns {Function} Scale function\n\t * @private\n\t */\n\tgetYScaleById(id: string, isSub = false): Function {\n\t\tconst isY2 = this.axis?.getId(id) === \"y2\";\n\t\tconst key = isSub ? (isY2 ? \"subY2\" : \"subY\") : (isY2 ? \"y2\" : \"y\");\n\n\t\treturn this.scale[key];\n\t},\n\n\t/**\n\t * Get customized x axis scale\n\t * @param {d3.scaleLinear|d3.scaleTime} scaleValue Scale function\n\t * @param {Function} offsetValue Offset getter to be sum\n\t * @returns {Function} Scale function\n\t * @private\n\t */\n\tgetCustomizedXScale(scaleValue: Function | any, offsetValue): Function {\n\t\tconst $$ = this;\n\t\tconst offset = offsetValue || (() => $$.axis.x.tickOffset());\n\t\tconst isInverted = $$.config.axis_x_inverted;\n\n\t\t/**\n\t\t * Get scaled value\n\t\t * @param {object} d Data object\n\t\t * @returns {number}\n\t\t * @private\n\t\t */\n\t\tconst scale = function(d: IDataRow): number {\n\t\t\treturn scaleValue(d) + offset();\n\t\t};\n\n\t\t// copy original scale methods\n\t\tfor (const key in scaleValue) {\n\t\t\tscale[key] = scaleValue[key];\n\t\t}\n\n\t\tscale.orgDomain = () => scaleValue.domain();\n\t\tscale.orgScale = () => scaleValue;\n\n\t\t// define custom domain() for categorized axis\n\t\tif ($$.axis.isCategorized()) {\n\t\t\tscale.domain = function(domainValue) {\n\t\t\t\tlet domain = domainValue;\n\n\t\t\t\tif (!arguments.length) {\n\t\t\t\t\tdomain = this.orgDomain();\n\n\t\t\t\t\treturn isInverted ? [domain[0] + 1, domain[1]] : [domain[0], domain[1] + 1];\n\t\t\t\t}\n\n\t\t\t\tscaleValue.domain(domain);\n\n\t\t\t\treturn scale;\n\t\t\t};\n\t\t}\n\n\t\treturn scale;\n\t},\n\n\t/**\n\t * Update scale\n\t * @param {boolean} isInit Param is given at the init rendering\n\t * @param {boolean} updateXDomain If update x domain\n\t * @private\n\t */\n\tupdateScales(isInit: boolean, updateXDomain = true): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\taxis,\n\t\t\tconfig,\n\t\t\tformat,\n\t\t\torg,\n\t\t\tscale,\n\t\t\tstate: {current, width, height, width2, height2, hasAxis, hasTreemap}\n\t\t} = $$;\n\n\t\tif (hasAxis) {\n\t\t\tconst isRotated = config.axis_rotated;\n\t\t\tconst resettedPadding = $$.getResettedPadding(1);\n\n\t\t\t// update edges\n\t\t\tconst min = {\n\t\t\t\tx: isRotated ? resettedPadding : 0,\n\t\t\t\ty: isRotated ? 0 : height,\n\t\t\t\tsubX: isRotated ? 1 : 0,\n\t\t\t\tsubY: isRotated ? 0 : height2\n\t\t\t};\n\n\t\t\tconst max = {\n\t\t\t\tx: isRotated ? height : width,\n\t\t\t\ty: isRotated ? width : resettedPadding,\n\t\t\t\tsubX: isRotated ? height : width,\n\t\t\t\tsubY: isRotated ? width2 : 1\n\t\t\t};\n\n\t\t\t// update scales\n\t\t\t// x Axis\n\t\t\tconst xDomain = updateXDomain && scale.x?.orgDomain();\n\t\t\tconst xSubDomain = updateXDomain && org.xDomain;\n\n\t\t\tscale.x = $$.getXScale(min.x, max.x, xDomain, () => axis.x.tickOffset());\n\t\t\tscale.subX = $$.getXScale(min.x, max.x, xSubDomain, d => (\n\t\t\t\td % 1 ? 0 : (axis.subX ?? axis.x).tickOffset()\n\t\t\t));\n\n\t\t\tformat.xAxisTick = axis.getXAxisTickFormat();\n\t\t\tformat.subXAxisTick = axis.getXAxisTickFormat(true);\n\n\t\t\taxis.setAxis(\"x\", scale.x, config.axis_x_tick_outer, isInit);\n\n\t\t\tif (config.subchart_show) {\n\t\t\t\taxis.setAxis(\"subX\", scale.subX, config.axis_x_tick_outer, isInit);\n\t\t\t}\n\n\t\t\t// y Axis\n\t\t\tscale.y = $$.getYScale(\"y\", min.y, max.y,\n\t\t\t\tscale.y ? scale.y.domain() : config.axis_y_default);\n\t\t\tscale.subY = $$.getYScale(\n\t\t\t\t\"y\",\n\t\t\t\tmin.subY,\n\t\t\t\tmax.subY,\n\t\t\t\tscale.subY ? scale.subY.domain() : config.axis_y_default\n\t\t\t);\n\n\t\t\taxis.setAxis(\"y\", scale.y, config.axis_y_tick_outer, isInit);\n\n\t\t\t// y2 Axis\n\t\t\tif (config.axis_y2_show) {\n\t\t\t\tscale.y2 = $$.getYScale(\"y2\", min.y, max.y,\n\t\t\t\t\tscale.y2 ? scale.y2.domain() : config.axis_y2_default);\n\t\t\t\tscale.subY2 = $$.getYScale(\n\t\t\t\t\t\"y2\",\n\t\t\t\t\tmin.subY,\n\t\t\t\t\tmax.subY,\n\t\t\t\t\tscale.subY2 ? scale.subY2.domain() : config.axis_y2_default\n\t\t\t\t);\n\n\t\t\t\taxis.setAxis(\"y2\", scale.y2, config.axis_y2_tick_outer, isInit);\n\t\t\t}\n\t\t} else if (hasTreemap) {\n\t\t\tconst padding = $$.getCurrentPadding();\n\n\t\t\tscale.x = d3ScaleLinear().rangeRound([padding.left, current.width - padding.right]);\n\t\t\tscale.y = d3ScaleLinear().rangeRound([padding.top, current.height - padding.bottom]);\n\t\t} else {\n\t\t\t// update for arc\n\t\t\t$$.updateArc?.();\n\t\t}\n\t},\n\n\t/**\n\t * Get the zoom or unzoomed scaled value\n\t * @param {Date|number|object} d Data value\n\t * @returns {number|null}\n\t * @private\n\t */\n\txx(d: IDataRow): number | null {\n\t\tconst $$ = this;\n\t\tconst {config, scale: {x, zoom}} = $$;\n\t\tconst fn = config.zoom_enabled && zoom ? zoom : x;\n\n\t\treturn d ? fn(isValue(d.x) ? d.x : d) : null;\n\t},\n\n\txv(d: IGridData): number {\n\t\tconst $$ = this;\n\t\tconst {axis, config, scale: {x, zoom}} = $$;\n\t\tconst fn = config.zoom_enabled && zoom ? zoom : x;\n\t\tlet value = $$.getBaseValue(d);\n\n\t\tif (axis.isTimeSeries()) {\n\t\t\tvalue = parseDate.call($$, value);\n\t\t} else if (axis.isCategorized() && isString(value)) {\n\t\t\tvalue = config.axis_x_categories.indexOf(value);\n\t\t}\n\n\t\treturn fn(value);\n\t},\n\n\tyv(d: IGridData): number {\n\t\tconst $$ = this;\n\t\tconst {scale: {y, y2}} = $$;\n\t\tconst yScale = d.axis && d.axis === \"y2\" ? y2 : y;\n\n\t\treturn yScale($$.getBaseValue(d));\n\t},\n\n\tsubxx(d: IDataRow): number | null {\n\t\treturn d ? this.scale.subX(d.x) : null;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$AXIS, $SUBCHART} from \"../../config/classes\";\nimport {document} from \"../../module/browser\";\nimport {KEY} from \"../../module/Cache\";\nimport {\n\tcapitalize,\n\tceil10,\n\tgetBoundingRect,\n\tisEmpty,\n\tisNumber,\n\tisString,\n\tisUndefined\n} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Update container size\n\t * @private\n\t */\n\tsetContainerSize(): void {\n\t\tconst $$ = this;\n\t\tconst {state} = $$;\n\n\t\tstate.current.width = $$.getCurrentWidth();\n\t\tstate.current.height = $$.getCurrentHeight();\n\t},\n\n\tgetCurrentWidth(): number {\n\t\tconst $$ = this;\n\n\t\treturn $$.config.size_width || $$.getParentWidth();\n\t},\n\n\tgetCurrentHeight(): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst h = config.size_height || $$.getParentHeight();\n\n\t\treturn h > 0 ? h : 320 / ($$.hasType(\"gauge\") && !config.gauge_fullCircle ? 2 : 1);\n\t},\n\n\t/**\n\t * Get the parent rect element's size\n\t * @param {string} key property/attribute name\n\t * @returns {number}\n\t * @private\n\t */\n\tgetParentRectValue(key): number {\n\t\tconst offsetName = `offset${capitalize(key)}`;\n\t\tlet parent = this.$el.chart.node();\n\t\tlet v = 0;\n\n\t\twhile (v < 30 && parent && parent.tagName !== \"BODY\") {\n\t\t\ttry {\n\t\t\t\tv = getBoundingRect(parent, true)[key];\n\t\t\t} catch {\n\t\t\t\tif (offsetName in parent) {\n\t\t\t\t\t// In IE in certain cases getBoundingClientRect\n\t\t\t\t\t// will cause an \"unspecified error\"\n\t\t\t\t\tv = parent[offsetName];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\t// Sometimes element's dimension value is incorrect(ex. flex container)\n\t\t// In this case, use body's offset instead.\n\t\tconst bodySize = document.body[offsetName];\n\n\t\tv > bodySize && (v = bodySize);\n\n\t\treturn v;\n\t},\n\n\tgetParentWidth(): number {\n\t\treturn this.getParentRectValue(\"width\");\n\t},\n\n\tgetParentHeight(): number {\n\t\tconst h: string = this.$el.chart.style(\"height\");\n\t\tlet height = 0;\n\n\t\tif (h) {\n\t\t\theight = /px$/.test(h) ? parseInt(h, 10) : this.getParentRectValue(\"height\");\n\t\t}\n\n\t\treturn height;\n\t},\n\n\tgetSvgLeft(withoutRecompute?: boolean): number {\n\t\tconst $$ = this;\n\t\tconst {config, state: {hasAxis}, $el} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst hasLeftAxisRect = isRotated || (!isRotated && !config.axis_y_inner);\n\t\tconst leftAxisClass = isRotated ? $AXIS.axisX : $AXIS.axisY;\n\t\tconst leftAxis = $el.main.select(`.${leftAxisClass}`).node();\n\t\tconst leftLabel = hasAxis && config[`axis_${isRotated ? \"x\" : \"y\"}_label`];\n\t\tlet labelWidth = 0;\n\n\t\t// if axis label position set to inner, exclude from the value\n\t\tif (\n\t\t\thasAxis && (\n\t\t\t\tisString(leftLabel) || isString(leftLabel.text) ||\n\t\t\t\t/^inner-/.test(leftLabel?.position)\n\t\t\t)\n\t\t) {\n\t\t\tconst label = $el.main.select(`.${leftAxisClass}-label`);\n\n\t\t\tif (!label.empty()) {\n\t\t\t\tlabelWidth = getBoundingRect(label.node()).left;\n\t\t\t}\n\t\t}\n\n\t\tconst svgRect = leftAxis && hasLeftAxisRect ?\n\t\t\tgetBoundingRect(leftAxis, !withoutRecompute) :\n\t\t\t{right: 0};\n\t\tconst chartRectLeft = getBoundingRect($el.chart.node(), !withoutRecompute).left +\n\t\t\tlabelWidth;\n\t\tconst hasArc = $$.hasArcType();\n\t\tconst svgLeft = svgRect.right - chartRectLeft -\n\t\t\t(hasArc ? 0 : $$.getCurrentPaddingByDirection(\"left\", withoutRecompute));\n\n\t\treturn svgLeft > 0 ? svgLeft : 0;\n\t},\n\n\tupdateDimension(withoutAxis?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {hasAxis}, $el} = $$;\n\n\t\tif (hasAxis && !withoutAxis && $$.axis.x && config.axis_rotated) {\n\t\t\t$$.axis.subX?.create($el.axis.subX);\n\t\t}\n\n\t\t// pass 'withoutAxis' param to not animate at the init rendering\n\t\t$$.updateScales(withoutAxis);\n\t\t$$.updateSvgSize();\n\t\t$$.transformAll(false);\n\t},\n\n\tupdateSvgSize(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {clip, current, hasAxis, width, height}, $el: {svg}} = $$;\n\n\t\tif (config.resize_auto === \"viewBox\") {\n\t\t\tsvg\n\t\t\t\t.attr(\"viewBox\", `0 0 ${current.width} ${current.height}`);\n\t\t} else {\n\t\t\tsvg\n\t\t\t\t.attr(\"width\", current.width)\n\t\t\t\t.attr(\"height\", current.height);\n\t\t}\n\n\t\tif (hasAxis) {\n\t\t\tconst brush = svg.select(`.${$SUBCHART.brush} .overlay`);\n\t\t\tconst brushSize = {width: 0, height: 0};\n\n\t\t\tif (brush.size()) {\n\t\t\t\tbrushSize.width = +brush.attr(\"width\");\n\t\t\t\tbrushSize.height = +brush.attr(\"height\");\n\t\t\t}\n\n\t\t\tsvg.selectAll([`#${clip.id}`, `#${clip.idGrid}`])\n\t\t\t\t.select(\"rect\")\n\t\t\t\t.attr(\"width\", width)\n\t\t\t\t.attr(\"height\", height);\n\n\t\t\tsvg.select(`#${clip.idXAxis}`)\n\t\t\t\t.select(\"rect\")\n\t\t\t\t.call($$.setXAxisClipPath.bind($$));\n\n\t\t\tsvg.select(`#${clip.idYAxis}`)\n\t\t\t\t.select(\"rect\")\n\t\t\t\t.call($$.setYAxisClipPath.bind($$));\n\n\t\t\tclip.idSubchart && svg.select(`#${clip.idSubchart}`)\n\t\t\t\t.select(\"rect\")\n\t\t\t\t.attr(\"width\", width)\n\t\t\t\t.attr(\"height\", brushSize.height);\n\t\t}\n\t},\n\n\t/**\n\t * Get padding by the direction.\n\t * @param {string} type \"top\" | \"bottom\" | \"left\" | \"right\"\n\t * @param {boolean} [withoutRecompute=false] If set true, do not recompute the padding value.\n\t * @param {boolean} [withXAxisTickTextOverflow=false] If set true, calculate x axis tick text overflow.\n\t * @returns {number} padding value\n\t * @private\n\t */\n\tgetCurrentPaddingByDirection(type: \"top\" | \"bottom\" | \"left\" | \"right\",\n\t\twithoutRecompute = false, withXAxisTickTextOverflow = false): number {\n\t\tconst $$ = this;\n\t\tconst {config, $el, state: {hasAxis}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isFitPadding = config.padding?.mode === \"fit\";\n\t\tconst paddingOption = isNumber(config[`padding_${type}`]) ?\n\t\t\tconfig[`padding_${type}`] :\n\t\t\tundefined;\n\t\tconst axisId = hasAxis ?\n\t\t\t{\n\t\t\t\ttop: isRotated ? \"y2\" : null,\n\t\t\t\tbottom: isRotated ? \"y\" : \"x\",\n\t\t\t\tleft: isRotated ? \"x\" : \"y\",\n\t\t\t\tright: isRotated ? null : \"y2\"\n\t\t\t}[type] :\n\t\t\tnull;\n\n\t\tconst isLeftRight = /^(left|right)$/.test(type);\n\t\tconst isAxisInner = axisId && config[`axis_${axisId}_inner`];\n\t\tconst isAxisShow = axisId && config[`axis_${axisId}_show`];\n\t\tconst axesLen = axisId ? config[`axis_${axisId}_axes`].length : 0;\n\n\t\tlet axisSize = axisId ?\n\t\t\t(\n\t\t\t\tisLeftRight ?\n\t\t\t\t\t$$.getAxisWidthByAxisId(axisId, withoutRecompute) :\n\t\t\t\t\t$$.getHorizontalAxisHeight(axisId)\n\t\t\t) :\n\t\t\t0;\n\t\tconst defaultPadding = 20;\n\t\tlet gap = 0;\n\n\t\tif (!isFitPadding && isLeftRight) {\n\t\t\taxisSize = ceil10(axisSize);\n\t\t}\n\n\t\tlet padding = hasAxis && isLeftRight && (\n\t\t\t\tisAxisInner || (isUndefined(paddingOption) && !isAxisShow)\n\t\t\t) ?\n\t\t\t0 :\n\t\t\t(\n\t\t\t\tisFitPadding ? (isAxisShow ? axisSize : 0) + (paddingOption ?? 0) : (\n\t\t\t\t\tisUndefined(paddingOption) ? axisSize : paddingOption\n\t\t\t\t)\n\t\t\t);\n\n\t\tif (isLeftRight && hasAxis) {\n\t\t\tif (axisId && (isFitPadding || isAxisInner) && config[`axis_${axisId}_label`].text) {\n\t\t\t\tpadding += $$.axis.getAxisLabelPosition(axisId).isOuter ? defaultPadding : 0;\n\t\t\t}\n\n\t\t\tif (type === \"right\") {\n\t\t\t\tpadding += isRotated ?\n\t\t\t\t\t(\n\t\t\t\t\t\t!isFitPadding && isUndefined(paddingOption) ? 10 : 2\n\t\t\t\t\t) :\n\t\t\t\t\t!isAxisShow || isAxisInner ?\n\t\t\t\t\t(isFitPadding ? 2 : 1) :\n\t\t\t\t\t0;\n\n\t\t\t\tpadding += withXAxisTickTextOverflow ?\n\t\t\t\t\t$$.axis.getXAxisTickTextY2Overflow(defaultPadding) :\n\t\t\t\t\t0;\n\t\t\t} else if (type === \"left\" && isRotated && isUndefined(paddingOption)) {\n\t\t\t\tpadding = !config.axis_x_show ?\n\t\t\t\t\t1 :\n\t\t\t\t\t(isFitPadding ? axisSize : Math.max(axisSize, 40));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type === \"top\") {\n\t\t\t\tif ($el.title && $el.title.node()) {\n\t\t\t\t\tpadding += $$.getTitlePadding();\n\t\t\t\t}\n\n\t\t\t\tgap = isRotated && !isAxisInner ? axesLen : 0;\n\t\t\t} else if (type === \"bottom\" && hasAxis && isRotated && !isAxisShow) {\n\t\t\t\tpadding += 1;\n\t\t\t}\n\t\t}\n\t\t// console.log(type, padding + (axisSize * axesLen) - gap)\n\t\treturn padding + (axisSize * axesLen) - gap;\n\t},\n\n\tgetCurrentPadding(\n\t\twithXAxisTickTextOverflow = false\n\t): {top: number, bottom: number, left: number, right: number} {\n\t\tconst $$ = this;\n\t\tconst [top, bottom, left, right] = [\"top\", \"bottom\", \"left\", \"right\"]\n\t\t\t.map(v => $$.getCurrentPaddingByDirection(v, null, withXAxisTickTextOverflow));\n\n\t\treturn {top, bottom, left, right};\n\t},\n\n\t/**\n\t * Get resetted padding values when 'padding=false' option is set\n\t * https://github.com/naver/billboard.js/issues/2367\n\t * @param {number|object} v Padding values to be resetted\n\t * @returns {number|object} Padding value\n\t * @private\n\t */\n\tgetResettedPadding<T = number | {[key: string]: string}>(v: T): T {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst isNum = isNumber(v);\n\t\tlet p: any = isNum ? 0 : {};\n\n\t\tif (config.padding === false) {\n\t\t\t!isNum && Object.keys(v as object).forEach(key => {\n\t\t\t\t// when data.lables=true, do not reset top padding\n\t\t\t\tp[key] = (\n\t\t\t\t\t\t!isEmpty(config.data_labels) &&\n\t\t\t\t\t\tconfig.data_labels !== false &&\n\t\t\t\t\t\tkey === \"top\"\n\t\t\t\t\t) ?\n\t\t\t\t\tv[key] :\n\t\t\t\t\t0;\n\t\t\t});\n\t\t} else {\n\t\t\tp = v;\n\t\t}\n\n\t\treturn p as T;\n\t},\n\n\t/**\n\t * Update size values\n\t * @param {boolean} isInit If is called at initialization\n\t * @private\n\t */\n\tupdateSizes(isInit?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {legend}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isNonAxis = $$.hasArcType() || state.hasFunnel || state.hasTreemap;\n\t\tconst isFitPadding = config.padding?.mode === \"fit\";\n\n\t\t!isInit && $$.setContainerSize();\n\n\t\tconst currLegend = {\n\t\t\twidth: legend ? $$.getLegendWidth() : 0,\n\t\t\theight: legend ? $$.getLegendHeight() : 0\n\t\t};\n\n\t\tif (!isNonAxis && config.axis_x_show && config.axis_x_tick_autorotate) {\n\t\t\t$$.updateXAxisTickClip();\n\t\t}\n\n\t\tconst legendSize = {\n\t\t\tright: config.legend_show && state.isLegendRight ?\n\t\t\t\t$$.getLegendWidth() + (isFitPadding ? 0 : 20) :\n\t\t\t\t0,\n\t\t\tbottom: !config.legend_show || state.isLegendRight || state.isLegendInset ?\n\t\t\t\t0 :\n\t\t\t\tcurrLegend.height\n\t\t};\n\n\t\tconst xAxisHeight = isRotated || isNonAxis ? 0 : $$.getHorizontalAxisHeight(\"x\");\n\n\t\tconst subchartXAxisHeight =\n\t\t\tconfig.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30;\n\t\tconst subchartHeight = config.subchart_show && !isNonAxis ?\n\t\t\t(config.subchart_size_height + subchartXAxisHeight) :\n\t\t\t0;\n\n\t\t// when needle is shown with legend, it need some bottom space to not overlap with legend text\n\t\tconst gaugeHeight = $$.hasType(\"gauge\") && config.arc_needle_show &&\n\t\t\t\t!config.gauge_fullCircle && !config.gauge_label_show ?\n\t\t\t10 :\n\t\t\t0;\n\n\t\tconst padding = $$.getCurrentPadding(true);\n\n\t\t// for main\n\t\tstate.margin = !isNonAxis && isRotated ?\n\t\t\t{\n\t\t\t\ttop: padding.top,\n\t\t\t\tright: isNonAxis ? 0 : padding.right + legendSize.right,\n\t\t\t\tbottom: legendSize.bottom + padding.bottom,\n\t\t\t\tleft: subchartHeight + (isNonAxis ? 0 : padding.left)\n\t\t\t} :\n\t\t\t{\n\t\t\t\ttop: (isFitPadding ? 0 : 4) + padding.top, // for top tick text\n\t\t\t\tright: isNonAxis ? 0 : padding.right + legendSize.right,\n\t\t\t\tbottom: gaugeHeight + subchartHeight + legendSize.bottom + padding.bottom,\n\t\t\t\tleft: isNonAxis ? 0 : padding.left\n\t\t\t};\n\n\t\tstate.margin = $$.getResettedPadding(state.margin);\n\n\t\t// for subchart\n\t\tstate.margin2 = isRotated ?\n\t\t\t{\n\t\t\t\ttop: state.margin.top,\n\t\t\t\tright: NaN,\n\t\t\t\tbottom: 20 + legendSize.bottom,\n\t\t\t\tleft: $$.state.rotatedPadding.left\n\t\t\t} :\n\t\t\t{\n\t\t\t\ttop: state.current.height - subchartHeight - legendSize.bottom,\n\t\t\t\tright: NaN,\n\t\t\t\tbottom: subchartXAxisHeight + legendSize.bottom,\n\t\t\t\tleft: state.margin.left\n\t\t\t};\n\n\t\t// for legend\n\t\tstate.margin3 = {\n\t\t\ttop: 0,\n\t\t\tright: NaN,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t};\n\n\t\t$$.updateSizeForLegend?.(currLegend);\n\n\t\tstate.width = state.current.width - state.margin.left - state.margin.right;\n\t\tstate.height = state.current.height - state.margin.top - state.margin.bottom;\n\n\t\tif (state.width < 0) {\n\t\t\tstate.width = 0;\n\t\t}\n\n\t\tif (state.height < 0) {\n\t\t\tstate.height = 0;\n\t\t}\n\n\t\tstate.width2 = isRotated ?\n\t\t\tstate.margin.left - state.rotatedPadding.left - state.rotatedPadding.right :\n\t\t\tstate.width;\n\n\t\tstate.height2 = isRotated ?\n\t\t\tstate.height :\n\t\t\tstate.current.height - state.margin2.top - state.margin2.bottom;\n\n\t\tif (state.width2 < 0) {\n\t\t\tstate.width2 = 0;\n\t\t}\n\n\t\tif (state.height2 < 0) {\n\t\t\tstate.height2 = 0;\n\t\t}\n\n\t\t// for arc\n\t\tif ($$.hasArcType()) {\n\t\t\tconst hasGauge = $$.hasType(\"gauge\");\n\t\t\tconst isLegendRight = config.legend_show && state.isLegendRight;\n\t\t\tconst textWidth = (state.hasRadar && $$.cache.get(KEY.radarTextWidth)) ?? 0;\n\n\t\t\tstate.arcWidth = state.width - (isLegendRight ? currLegend.width + 10 : 0) - textWidth;\n\t\t\tstate.arcHeight = state.height - (isLegendRight && !hasGauge ? 0 : 10);\n\n\t\t\tif (config.arc_rangeText_values?.length) {\n\t\t\t\tif (hasGauge) {\n\t\t\t\t\tstate.arcWidth -= 25;\n\t\t\t\t\tstate.arcHeight -= 10;\n\t\t\t\t\tstate.margin.left += 10;\n\t\t\t\t} else {\n\t\t\t\t\tstate.arcHeight -= 20;\n\t\t\t\t\tstate.margin.top += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasGauge && !config.gauge_fullCircle) {\n\t\t\t\tstate.arcHeight += state.height - $$.getPaddingBottomForGauge();\n\t\t\t}\n\n\t\t\t$$.updateRadius?.();\n\t\t}\n\n\t\tif (state.isLegendRight && isNonAxis) {\n\t\t\tstate.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1;\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {d3Selection} from \"../../../types/types\";\nimport {$SHAPE} from \"../../config/classes\";\nimport {addCssRules, isFunction, isString} from \"../../module/util\";\nimport type {IDataRow} from \"../data/IData\";\n\nexport default {\n\t/**\n\t * Add props color css rule to given selector\n\t * @param {boolean} withShape Set shpes' prefix class\n\t * @param {string} selector CSS selector\n\t * @param {Array} props CSS props list\n\t * @param {Function} propsFn Function to retrieve value or determine for props\n\t * @returns {Function}\n\t * @private\n\t */\n\tsetCssRule(withShape: boolean, selector: string, props: string[], propsFn: Function): Function {\n\t\tconst $$ = this;\n\t\tconst {config, state: {cssRule, style}} = $$;\n\n\t\treturn config.boost_useCssRule ?\n\t\t\t(selection: d3Selection) => {\n\t\t\t\tselection.each((d: IDataRow) => {\n\t\t\t\t\tconst res = propsFn && propsFn?.call($$, d);\n\t\t\t\t\tconst shapeSelector = `${\n\t\t\t\t\t\twithShape ? `.${$SHAPE.shapes + $$.getTargetSelectorSuffix(d.id)}` : \"\"\n\t\t\t\t\t}${selector}`;\n\n\t\t\t\t\t(selector in cssRule) && style.sheet.deleteRule(cssRule[shapeSelector]);\n\t\t\t\t\t$$.state.cssRule[shapeSelector] = addCssRules(\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tshapeSelector,\n\t\t\t\t\t\tprops.filter(Boolean).map(v => (\n\t\t\t\t\t\t\tisString(res) && v.indexOf(\":\") === -1 ? `${v}: ${res}` : (v || \"\")\n\t\t\t\t\t\t))\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} :\n\t\t\t() => {};\n\t},\n\n\t/**\n\t * Get style prop value\n\t * @param {Function|string} v Value\n\t * @returns {string|null}\n\t * @private\n\t */\n\tgetStylePropValue(v: Function | string): string | null {\n\t\tconst {config: {boost_useCssRule: useCssRule}} = this;\n\n\t\treturn useCssRule ? null : isFunction(v) ? v.bind(this) : v as string;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select, selectAll as d3SelectAll} from \"d3-selection\";\nimport type {AxisType, d3Selection} from \"../../../types/types\";\nimport {$COMMON, $TEXT} from \"../../config/classes\";\nimport {KEY} from \"../../module/Cache\";\nimport {\n\tcapitalize,\n\tgetBBox,\n\tgetBoundingRect,\n\tgetRandom,\n\tgetTranslation,\n\tisFunction,\n\tisNumber,\n\tisObject,\n\tisString,\n\tparseShorthand,\n\tsetTextValue,\n\tnotEmpty\n} from \"../../module/util\";\nimport type {IArcData, IDataRow} from \"../data/IData\";\n\ntype Coord = {x: number, y: number};\ntype Anchor = \"start\" | \"middle\" | \"end\";\n\n/**\n * Get text-anchor according text.labels.rotate angle\n * @param {number} angle Angle value\n * @returns {string} Anchor string value\n * @private\n */\nfunction getRotateAnchor(angle: number): Anchor {\n\tlet anchor: Anchor = \"middle\";\n\n\tif (angle > 0 && angle <= 170) {\n\t\tanchor = \"end\";\n\t} else if (angle > 190 && angle <= 360) {\n\t\tanchor = \"start\";\n\t}\n\n\treturn anchor;\n}\n\n/**\n * Set rotated position coordinate according text.labels.rotate angle\n * @param {object} d Data object\n * @param {object} pos Position object\n * @param {object} pos.x x coordinate\n * @param {object} pos.y y coordinate\n * @param {string} anchor string value\n * @param {boolean} isRotated If axis is rotated\n * @param {boolean} isInverted If axis is inverted\n * @returns {object} x, y coordinate\n * @private\n */\nfunction setRotatePos(\n\td: IDataRow,\n\tpos: Coord,\n\tanchor: Anchor,\n\tisRotated: boolean,\n\tisInverted: boolean\n): Coord {\n\tconst $$ = this;\n\tconst {value} = d;\n\tconst isCandlestickType = $$.isCandlestickType(d);\n\tconst isNegative = (isNumber(value) && value < 0) || (\n\t\tisCandlestickType && !$$.getCandlestickData(d)?._isUp\n\t);\n\n\tlet {x, y} = pos;\n\tconst gap = 4;\n\tconst doubleGap = gap * 2;\n\n\tif (isRotated) {\n\t\tif (anchor === \"start\") {\n\t\t\tx += isNegative ? 0 : doubleGap;\n\t\t\ty += gap;\n\t\t} else if (anchor === \"middle\") {\n\t\t\tx += doubleGap;\n\t\t\ty -= doubleGap;\n\t\t} else if (anchor === \"end\") {\n\t\t\tisNegative && (x -= doubleGap);\n\t\t\ty += gap;\n\t\t}\n\t} else {\n\t\tif (anchor === \"start\") {\n\t\t\tx += gap;\n\t\t\tisNegative && (y += doubleGap * 2);\n\t\t} else if (anchor === \"middle\") {\n\t\t\ty -= doubleGap;\n\t\t} else if (anchor === \"end\") {\n\t\t\tx -= gap;\n\t\t\tisNegative && (y += doubleGap * 2);\n\t\t}\n\n\t\tif (isInverted) {\n\t\t\ty += isNegative ? -17 : (isCandlestickType ? 13 : 7);\n\t\t}\n\t}\n\n\treturn {x, y};\n}\n\n/**\n * Get data.labels.position value\n * @param {object} d Data object\n * @param {string} type x | y\n * @returns {number} Position value\n * @private\n */\nfunction getTextPos(d, type): number {\n\tconst position = this.config.data_labels_position;\n\tconst {id, index, value} = d;\n\n\treturn (\n\t\tisFunction(position) ?\n\t\t\tposition.bind(this.api)(type, value, id, index, this.$el.text) :\n\t\t\t(id in position ? position[id] : position)[type]\n\t) ?? 0;\n}\n\n/**\n * Update text border\n * @param {SVGTextElement} text Text element\n * @param {Coord} pos Position object\n * @param {string} rectClass Class name\n * @private\n */\nfunction updateTextBorder(text: SVGTextElement, pos: Coord, rectClass: string): void {\n\tconst $$ = this;\n\tconst {config, $T} = $$;\n\tconst isRotated = config.axis_rotated;\n\tconst {\n\t\tborder: {\n\t\t\tpadding = \"3 5\",\n\t\t\tradius = 10,\n\t\t\tstroke = \"#000\",\n\t\t\tstrokeWidth = 1,\n\t\t\tfill = \"none\"\n\t\t}\n\t} = config.data_labels;\n\n\tconst borderPadding = parseShorthand(padding);\n\tconst applyStyle = config.data_labels.border !== true;\n\tconst textRect = getBBox(text);\n\tlet borderRect = d3Select(text.previousElementSibling as Element);\n\n\tif (\n\t\tborderRect.empty() ||\n\t\tborderRect.node()?.tagName !== \"rect\" ||\n\t\t!borderRect.attr(\"class\")?.includes(rectClass)\n\t) {\n\t\tborderRect = d3Select(text.parentNode as Element)\n\t\t\t.insert(\"rect\", () => text)\n\t\t\t.attr(\"class\", `${$TEXT.textBorderRect} ${rectClass}`)\n\t\t\t.attr(\"width\",\n\t\t\t\ttextRect.width + (applyStyle ? borderPadding.left + borderPadding.right : 0))\n\t\t\t.attr(\"height\",\n\t\t\t\ttextRect.height + (applyStyle ? borderPadding.top + borderPadding.bottom : 0));\n\n\t\tif (applyStyle) {\n\t\t\tborderRect\n\t\t\t\t.style(\"fill\", fill)\n\t\t\t\t.style(\"stroke\", stroke)\n\t\t\t\t.style(\"stroke-width\", `${strokeWidth}px`)\n\t\t\t\t.attr(\"rx\", radius)\n\t\t\t\t.attr(\"ry\", radius);\n\t\t}\n\t}\n\n\t$T(borderRect)\n\t\t.attr(\"x\",\n\t\t\tpos.x - (applyStyle ? borderPadding.left : 0) - (isRotated ? 0 : textRect.width / 2))\n\t\t.attr(\"y\", pos.y - (applyStyle ? borderPadding.top : 0) - (textRect.height / 4 * 3.2));\n}\n\nexport default {\n\t/**\n\t * Get image URL for data label\n\t * @param {object} d Data object\n\t * @returns {string|null} Image URL\n\t * @private\n\t */\n\tgetDataLabelImgUrl(d): string | null {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst labelsImgUrl = config.data_labels?.imgUrl || config.data_labels_imgUrl;\n\n\t\tif (labelsImgUrl) {\n\t\t\tif (isFunction(labelsImgUrl)) {\n\t\t\t\treturn labelsImgUrl.call($$.api, d.value, d.id, d.index);\n\t\t\t}\n\t\t\treturn labelsImgUrl;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Position data label image relative to text\n\t * @param {d3Selection} image Image element\n\t * @param {d3Selection} textNode Text element\n\t * @param {object} d Data object\n\t * @private\n\t */\n\tpositionDataLabelImage(image, textNode, d): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst labelsCentered = config.data_labels.centered;\n\t\t\n\t\t// Set default image size\n\t\tconst imageSize = 16; // Default size, can be configurable\n\t\t\n\t\tif ($$.isTreemapType(d)) {\n\t\t\tif (labelsCentered) {\n\t\t\t\t// For treemap with centered labels, position image above the text\n\t\t\t\timage\n\t\t\t\t\t.attr(\"x\", -imageSize / 2)\n\t\t\t\t\t.attr(\"y\", -imageSize - 2) // Small gap above text\n\t\t\t\t\t.attr(\"width\", imageSize)\n\t\t\t\t\t.attr(\"height\", imageSize);\n\t\t\t} else {\n\t\t\t\t// For treemap without centered labels, position to the left\n\t\t\t\timage\n\t\t\t\t\t.attr(\"x\", -imageSize - 3)\n\t\t\t\t\t.attr(\"y\", -imageSize / 2)\n\t\t\t\t\t.attr(\"width\", imageSize)\n\t\t\t\t\t.attr(\"height\", imageSize);\n\t\t\t}\n\t\t} else {\n\t\t\t// For other chart types\n\t\t\tconst anchor = textNode.attr(\"text-anchor\");\n\t\t\tlet xPos = -imageSize - 5;\n\t\t\t\n\t\t\tif (anchor === \"middle\") {\n\t\t\t\txPos = -imageSize / 2;\n\t\t\t} else if (anchor === \"end\") {\n\t\t\t\txPos = 5;\n\t\t\t}\n\t\t\t\n\t\t\timage\n\t\t\t\t.attr(\"x\", xPos)\n\t\t\t\t.attr(\"y\", -imageSize / 2)\n\t\t\t\t.attr(\"width\", imageSize)\n\t\t\t\t.attr(\"height\", imageSize);\n\t\t}\n\t},\n\n\topacityForText(d): null | \"0\" {\n\t\tconst $$ = this;\n\n\t\treturn $$.isBarType(d) && !$$.meetsLabelThreshold(\n\t\t\t\tMath.abs($$.getRatio(\"bar\", d)),\n\t\t\t\t\"bar\"\n\t\t\t) ?\n\t\t\t\"0\" :\n\t\t\t($$.hasDataLabel ? null : \"0\");\n\t},\n\n\t/**\n\t * Initializes the text\n\t * @private\n\t */\n\tinitText(): void {\n\t\tconst {$el} = this;\n\n\t\t$el.main.select(`.${$COMMON.chart}`).append(\"g\")\n\t\t\t.attr(\"class\", $TEXT.chartTexts)\n\t\t\t.style(\"pointer-events\", $el.funnel || $el.treemap ? \"none\" : null);\n\t},\n\n\t/**\n\t * Update chartText\n\t * @param {object} targets $$.data.targets\n\t * @private\n\t */\n\tupdateTargetsForText(targets): void {\n\t\tconst $$ = this;\n\t\tconst classChartText = $$.getChartClass(\"Text\");\n\t\tconst classTexts = $$.getClass(\"texts\", \"id\");\n\n\t\tconst classFocus = $$.classFocus.bind($$);\n\t\tconst mainTextUpdate = $$.$el.main.select(`.${$TEXT.chartTexts}`)\n\t\t\t.selectAll(`.${$TEXT.chartText}`)\n\t\t\t.data($$.filterNullish(targets))\n\t\t\t.attr(\"class\", d => `${classChartText(d)}${classFocus(d)}`.trim());\n\n\t\tconst mainTextEnter = mainTextUpdate.enter().append(\"g\")\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.attr(\"class\", classChartText)\n\t\t\t.call(\n\t\t\t\t$$.setCssRule(true, ` .${$TEXT.text}`, [\"fill\", \"pointer-events:none\"],\n\t\t\t\t\t$$.updateTextColor)\n\t\t\t);\n\n\t\tmainTextEnter.append(\"g\")\n\t\t\t.attr(\"class\", classTexts);\n\t},\n\n\t/**\n\t * Update text\n\t * @private\n\t */\n\tupdateText(): void {\n\t\tconst $$ = this;\n\t\tconst {$el, $T, config, axis} = $$;\n\t\tconst classText = $$.getClass(\"text\", \"index\");\n\t\tconst labelsCentered = config.data_labels.centered;\n\n\t\tconst text = $el.main.selectAll(`.${$TEXT.texts}`)\n\t\t\t.selectAll(`.${$TEXT.text}`)\n\t\t\t.data($$.labelishData.bind($$));\n\n\t\t$T(text.exit())\n\t\t\t.style(\"fill-opacity\", \"0\")\n\t\t\t.remove();\n\n\t\t$el.text = text.enter()\n\t\t\t.append(\"text\")\n\t\t\t.merge(text)\n\t\t\t.attr(\"class\", classText)\n\t\t\t.attr(\"text-anchor\", d => {\n\t\t\t\tconst isInverted = config[`axis_${axis?.getId(d.id)}_inverted`];\n\n\t\t\t\t// when value is negative or\n\t\t\t\tlet isEndAnchor = isInverted ? d.value > 0 : d.value < 0;\n\n\t\t\t\tif ($$.isCandlestickType(d)) {\n\t\t\t\t\tconst data = $$.getCandlestickData(d);\n\n\t\t\t\t\tisEndAnchor = !data?._isUp;\n\t\t\t\t} else if ($$.isTreemapType(d)) {\n\t\t\t\t\treturn labelsCentered ? \"middle\" : \"start\";\n\t\t\t\t}\n\n\t\t\t\treturn (config.axis_rotated ? (isEndAnchor ? \"end\" : \"start\") : \"middle\");\n\t\t\t})\n\t\t\t.style(\"fill\", $$.getStylePropValue($$.updateTextColor))\n\t\t\t.style(\"fill-opacity\", \"0\")\n\t\t\t.each(function(d, i, texts) {\n\t\t\t\tconst node = d3Select(this);\n\t\t\t\tlet {value} = d;\n\n\t\t\t\tif ($$.isBubbleZType(d)) {\n\t\t\t\t\tvalue = $$.getBubbleZData(value, \"z\");\n\t\t\t\t} else if ($$.isCandlestickType(d)) {\n\t\t\t\t\tconst data = $$.getCandlestickData(d);\n\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tvalue = data.close;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalue = $$.isTreemapType(d) ?\n\t\t\t\t\t$$.treemapDataLabelFormat(d)(node) :\n\t\t\t\t\t$$.dataLabelFormat(d.id)(value, d.id, d.index, texts);\n\n\t\t\t\tif (isNumber(value)) {\n\t\t\t\t\tthis.textContent = value;\n\t\t\t\t} else {\n\t\t\t\t\tsetTextValue(node, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Add images if imgUrl is specified\n\t\t$el.text.each(function(d, i) {\n\t\t\tconst imgUrl = $$.getDataLabelImgUrl(d);\n\t\t\t\n\t\t\tif (imgUrl) {\n\t\t\t\tconst textNode = d3Select(this);\n\t\t\t\tconst parentNode = d3Select(this.parentNode);\n\t\t\t\t\n\t\t\t\t// Remove existing image if any\n\t\t\t\tparentNode.select(\"image\").remove();\n\t\t\t\t\n\t\t\t\t// Insert image before text\n\t\t\t\tconst image = parentNode.insert(\"image\", \"text\")\n\t\t\t\t\t.attr(\"href\", imgUrl)\n\t\t\t\t\t.attr(\"class\", \"bb-data-label-image\");\n\t\t\t\t\n\t\t\t\t// Position image and text with proper alignment\n\t\t\t\t$$.positionDataLabelImage(image, textNode, d);\n\t\t\t}\n\t\t});\n\t},\n\n\tupdateTextColor(d): null | object | string {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst labelColors = config.data_labels_colors;\n\t\tconst defaultColor =\n\t\t\t($$.isArcType(d) && !$$.isRadarType(d)) || $$.isFunnelType(d) || $$.isTreemapType(d) ?\n\t\t\t\tnull :\n\t\t\t\t$$.color(d);\n\t\tlet color;\n\n\t\tif (isString(labelColors)) {\n\t\t\tcolor = labelColors;\n\t\t} else if (isObject(labelColors)) {\n\t\t\tconst {id} = d.data || d;\n\n\t\t\tcolor = labelColors[id];\n\t\t} else if (isFunction(labelColors)) {\n\t\t\tcolor = labelColors.bind($$.api)(defaultColor, d);\n\t\t}\n\n\t\tif ($$.isCandlestickType(d) && !isFunction(labelColors)) {\n\t\t\tconst value = $$.getCandlestickData(d);\n\n\t\t\tif (!value?._isUp) {\n\t\t\t\tconst downColor = config.candlestick_color_down;\n\n\t\t\t\tcolor = isObject(downColor) ? downColor[d.id] : downColor;\n\t\t\t}\n\t\t}\n\n\t\treturn color || defaultColor;\n\t},\n\n\t/**\n\t * Update data label text background color\n\t * @param {object} d Data object\n\t * @param {object|string|Function} option option object\n\t * @returns {string|null}\n\t * @private\n\t */\n\tupdateTextBGColor(d: IDataRow | IArcData, option): string | null {\n\t\tconst $$ = this;\n\t\tconst {$el: {defs}} = $$;\n\t\tlet color: string = \"\";\n\n\t\tif (option) {\n\t\t\tconst id = isString(option) ?\n\t\t\t\t\"\" :\n\t\t\t\t$$.getTargetSelectorSuffix(\"id\" in d ? d.id : d.data.id);\n\t\t\tconst filter = defs.select([\"filter[id*='labels-bg\", \"']\"].join(id));\n\n\t\t\tif (filter.size()) {\n\t\t\t\tcolor = `url(#${filter.attr(\"id\")})`;\n\t\t\t}\n\n\t\t\tif (isFunction(option)) {\n\t\t\t\t$$.generateTextBGColorFilter(option);\n\n\t\t\t\t// Get default color and call function\n\t\t\t\tconst defaultColor = $$.color(d);\n\t\t\t\tconst bgColor = option.bind($$.api)(defaultColor, d);\n\n\t\t\t\tif (bgColor) {\n\t\t\t\t\tfilter.select(\"feFlood\").attr(\"flood-color\", bgColor);\n\t\t\t\t} else {\n\t\t\t\t\tcolor = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn color || null;\n\t},\n\n\t/**\n\t * Redraw chartText\n\t * @param {Function} getX Positioning function for x\n\t * @param {Function} getY Positioning function for y\n\t * @param {boolean} forFlow Weather is flow\n\t * @param {boolean} withTransition transition is enabled\n\t * @returns {Array}\n\t * @private\n\t */\n\tredrawText(getX, getY, forFlow?: boolean, withTransition?: boolean): true {\n\t\tconst $$ = this;\n\t\tconst {$T, axis, config, state: {hasTreemap}} = $$;\n\t\tconst t = <string>getRandom(true);\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst angle = config.data_labels.rotate;\n\t\tconst anchorString = getRotateAnchor(angle);\n\t\tconst rotateString = angle ? `rotate(${angle})` : \"\";\n\n\t\t$$.$el.text\n\t\t\t.style(\"fill\", $$.getStylePropValue($$.updateTextColor))\n\t\t\t.attr(\"filter\",\n\t\t\t\td => $$.updateTextBGColor.bind($$)(d, config.data_labels_backgroundColors))\n\t\t\t.style(\"fill-opacity\", forFlow ? 0 : $$.opacityForText.bind($$))\n\t\t\t.each(function(d: IDataRow, i: number) {\n\t\t\t\t// do not apply transition for newly added text elements\n\t\t\t\tconst node = $T(hasTreemap && this.childElementCount ? this.parentNode : this,\n\t\t\t\t\t!!(withTransition && this.getAttribute(\"x\")), t);\n\t\t\t\tconst isInverted = config[`axis_${axis?.getId(d.id)}_inverted`];\n\t\t\t\tlet pos = {\n\t\t\t\t\tx: getX.bind(this)(d, i),\n\t\t\t\t\ty: getY.bind(this)(d, i)\n\t\t\t\t};\n\n\t\t\t\tif (angle) {\n\t\t\t\t\tpos = setRotatePos.bind($$)(d, pos, anchorString, isRotated, isInverted);\n\t\t\t\t\tnode.attr(\"text-anchor\", anchorString);\n\t\t\t\t}\n\n\t\t\t\t// when is multiline\n\t\t\t\tif (this.childElementCount || angle) {\n\t\t\t\t\tnode.attr(\"transform\", `translate(${pos.x} ${pos.y}) ${rotateString}`);\n\t\t\t\t} else {\n\t\t\t\t\tnode.attr(\"x\", pos.x).attr(\"y\", pos.y);\n\t\t\t\t}\n\n\t\t\t\tconfig.data_labels.border &&\n\t\t\t\t\tupdateTextBorder.call($$, node.node(), pos, `${$TEXT.textBorderRect}-${i}`);\n\t\t\t});\n\n\t\t// need to return 'true' as of being pushed to the redraw list\n\t\t// ref: getRedrawList()\n\t\treturn true;\n\t},\n\n\t/**\n\t * Gets the getBoundingClientRect value of the element\n\t * @param {HTMLElement|d3.selection|Array} source Target element\n\t * @param {string} className Class name\n\t * @returns {object} value of element.getBoundingClientRect()\n\t * @private\n\t */\n\tgetTextRect(source: d3Selection | SVGElement | number[], className: string): DOMRect[] {\n\t\tconst $$ = this;\n\t\tlet cacheKey;\n\t\tlet base;\n\t\tlet text;\n\n\t\tif (Array.isArray(source)) {\n\t\t\tcacheKey = `${KEY.textRect}-${source.join(\"_\")}`;\n\t\t} else {\n\t\t\tbase = (source as d3Selection).node?.() ?? source as SVGElement;\n\n\t\t\tif (!/text/i.test(base.tagName)) {\n\t\t\t\tbase = base.querySelector(\"text\");\n\t\t\t}\n\n\t\t\ttext = base.textContent;\n\t\t\tcacheKey = `${KEY.textRect}-${text.replace(/\\W/g, \"_\")}`;\n\t\t}\n\n\t\tconst rect = $$.cache.get(cacheKey) || [];\n\n\t\tif (rect.length === 0) {\n\t\t\t($$.$el.svg || $$.$el.chart.select(\"svg\"))\n\t\t\t\t.selectAll(`.${$COMMON.dummy}`)\n\t\t\t\t.data(text ? [text] : source)\n\t\t\t\t.enter()\n\t\t\t\t.append(\"text\")\n\t\t\t\t.style(\"visibility\", \"hidden\")\n\t\t\t\t.style(\"font\", base ? d3Select(base).style(\"font\") : null)\n\t\t\t\t.classed(className || $COMMON.dummy, true)\n\t\t\t\t.text(d => d)\n\t\t\t\t.each(function(v, i) {\n\t\t\t\t\trect[i] = getBoundingRect(this);\n\t\t\t\t})\n\t\t\t\t.remove();\n\n\t\t\t$$.cache.add(cacheKey, rect);\n\t\t}\n\n\t\treturn rect.length > 1 ? rect : rect[0];\n\t},\n\n\t/**\n\t * Gets the x or y coordinate of the text\n\t * @param {object} indices Indices values\n\t * @param {boolean} forX whether or not to x\n\t * @returns {number} coordinates\n\t * @private\n\t */\n\tgenerateXYForText(indices, forX?: boolean): (d, i) => number {\n\t\tconst $$ = this;\n\t\tconst {state: {hasRadar, hasFunnel, hasTreemap}} = $$;\n\t\tconst types = Object.keys(indices);\n\t\tconst points = {};\n\t\tconst getter = forX ? $$.getXForText : $$.getYForText;\n\n\t\thasFunnel && types.push(\"funnel\");\n\t\thasRadar && types.push(\"radar\");\n\t\thasTreemap && types.push(\"treemap\");\n\n\t\ttypes.forEach(v => {\n\t\t\tpoints[v] = $$[`generateGet${capitalize(v)}Points`](indices[v], false);\n\t\t});\n\n\t\treturn function(d, i) {\n\t\t\tconst type = ($$.isAreaType(d) && \"area\") ||\n\t\t\t\t($$.isBarType(d) && \"bar\") ||\n\t\t\t\t($$.isCandlestickType(d) && \"candlestick\") ||\n\t\t\t\t($$.isFunnelType(d) && \"funnel\") ||\n\t\t\t\t($$.isRadarType(d) && \"radar\") ||\n\t\t\t\t($$.isTreemapType(d) && \"treemap\") || \"line\";\n\n\t\t\treturn getter.call($$, points[type](d, i), d, this);\n\t\t};\n\t},\n\n\t/**\n\t * Get centerized text position for bar type data.label.text\n\t * @param {object} d Data object\n\t * @param {Array} points Data points position\n\t * @param {HTMLElement} textElement Data label text element\n\t * @param {string} type 'x' or 'y'\n\t * @returns {number} Position value\n\t * @private\n\t */\n\tgetCenteredTextPos(d, points, textElement, type: \"x\" | \"y\"): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isBarType = $$.isBarType(d);\n\t\tconst isTreemapType = $$.isTreemapType(d);\n\n\t\tif (config.data_labels.centered && (isBarType || isTreemapType)) {\n\t\t\tconst rect = getBoundingRect(textElement);\n\n\t\t\tif (isBarType) {\n\t\t\t\tconst isPositive = $$.getRangedData(d, null, \"bar\") >= 0;\n\n\t\t\t\tif (isRotated) {\n\t\t\t\t\tconst w = (\n\t\t\t\t\t\t\t\tisPositive ?\n\t\t\t\t\t\t\t\t\tpoints[1][1] - points[0][1] :\n\t\t\t\t\t\t\t\t\tpoints[0][1] - points[1][1]\n\t\t\t\t\t\t\t) / 2 + (rect.width / 2);\n\n\t\t\t\t\treturn isPositive ? -w - 3 : w + 2;\n\t\t\t\t} else {\n\t\t\t\t\tconst h = (\n\t\t\t\t\t\t\t\tisPositive ?\n\t\t\t\t\t\t\t\t\tpoints[0][1] - points[1][1] :\n\t\t\t\t\t\t\t\t\tpoints[1][1] - points[0][1]\n\t\t\t\t\t\t\t) / 2 + (rect.height / 2);\n\n\t\t\t\t\treturn isPositive ? h : -h - 2;\n\t\t\t\t}\n\t\t\t} else if (isTreemapType) {\n\t\t\t\treturn type === \"x\" ?\n\t\t\t\t\t(points[1][0] - points[0][0]) / 2 :\n\t\t\t\t\t(points[1][1] - points[0][1]) / 2 + (rect.height / 2);\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t},\n\n\t/**\n\t * Gets the x coordinate of the text\n\t * @param {object} points Data points position\n\t * @param {object} d Data object\n\t * @param {HTMLElement} textElement Data label text element\n\t * @returns {number} x coordinate\n\t * @private\n\t */\n\tgetXForText(points, d: IDataRow, textElement): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isFunnelType = $$.isFunnelType(d);\n\t\tconst isTreemapType = $$.isTreemapType(d);\n\t\tlet xPos = points ? points[0][0] : 0;\n\n\t\tif ($$.isCandlestickType(d)) {\n\t\t\tif (isRotated) {\n\t\t\t\txPos = $$.getCandlestickData(d)?._isUp ? points[2][2] + 4 : points[2][1] - 4;\n\t\t\t} else {\n\t\t\t\txPos += (points[1][0] - xPos) / 2;\n\t\t\t}\n\t\t} else if (isFunnelType) {\n\t\t\txPos += $$.state.current.width / 2;\n\t\t} else if (isTreemapType) {\n\t\t\txPos += config.data_labels.centered ? 0 : 5;\n\t\t} else {\n\t\t\tif (isRotated) {\n\t\t\t\tconst isInverted = config[`axis_${$$.axis.getId(d.id)}_inverted`];\n\t\t\t\tconst padding = $$.isBarType(d) ? 4 : 6;\n\t\t\t\tconst value = d.value as number;\n\n\t\t\t\txPos = points[2][1];\n\n\t\t\t\tif (isInverted) {\n\t\t\t\t\txPos -= padding * (value > 0 ? 1 : -1);\n\t\t\t\t} else {\n\t\t\t\t\txPos += padding * (value < 0 ? -1 : 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txPos = $$.hasType(\"bar\") ? (points[2][0] + points[0][0]) / 2 : xPos;\n\t\t\t}\n\t\t}\n\n\t\tif (isRotated || isTreemapType) {\n\t\t\txPos += $$.getCenteredTextPos(d, points, textElement, \"x\");\n\t\t}\n\n\t\treturn xPos + getTextPos.call(this, d, \"x\");\n\t},\n\n\t/**\n\t * Gets the y coordinate of the text\n\t * @param {object} points Data points position\n\t * @param {object} d Data object\n\t * @param {HTMLElement} textElement Data label text element\n\t * @returns {number} y coordinate\n\t * @private\n\t */\n\tgetYForText(points, d, textElement): number {\n\t\tconst $$ = this;\n\t\tconst {axis, config, state} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isInverted = config[`axis_${axis?.getId(d.id)}_inverted`];\n\t\tconst isBarType = $$.isBarType(d);\n\t\tconst isFunnelType = $$.isFunnelType(d);\n\t\tconst isTreemapType = $$.isTreemapType(d);\n\t\tconst r = config.point_r;\n\t\tconst rect = getBoundingRect(textElement);\n\t\tlet {value} = d;\n\t\tlet baseY = 3;\n\t\tlet yPos;\n\n\t\tif ($$.isCandlestickType(d)) {\n\t\t\tvalue = $$.getCandlestickData(d);\n\n\t\t\tif (isRotated) {\n\t\t\t\tyPos = points[0][0];\n\t\t\t\tyPos += ((points[1][0] - yPos) / 2) + baseY;\n\t\t\t} else {\n\t\t\t\tyPos = value && value._isUp ? points[2][2] - baseY : points[2][1] + (baseY * 4);\n\n\t\t\t\tif (isInverted) {\n\t\t\t\t\tyPos += 15 * (value._isUp ? 1 : -1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isFunnelType) {\n\t\t\tyPos = points ?\n\t\t\t\tpoints[0][1] + ((points[1][1] - points[0][1]) / 2) + rect.height / 2 - 3 :\n\t\t\t\t0;\n\t\t} else if (isTreemapType) {\n\t\t\tyPos = points[0][1] + (config.data_labels.centered ? 0 : rect.height + 5);\n\t\t} else {\n\t\t\tif (isRotated) {\n\t\t\t\tyPos = (points[0][0] + points[2][0] + rect.height * 0.6) / 2;\n\t\t\t} else {\n\t\t\t\tyPos = points[2][1];\n\n\t\t\t\tif (isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d))) {\n\t\t\t\t\tbaseY += config.point_r / 2.3;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tvalue < 0 || (value === 0 && !state.hasPositiveValue && state.hasNegativeValue)\n\t\t\t\t) {\n\t\t\t\t\tyPos += isInverted ? (isBarType ? -3 : -5) : (\n\t\t\t\t\t\trect.height + (isBarType ? -baseY : baseY)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlet diff = -baseY * 2;\n\n\t\t\t\t\tif (isBarType) {\n\t\t\t\t\t\tdiff = -baseY;\n\t\t\t\t\t} else if ($$.isBubbleType(d)) {\n\t\t\t\t\t\tdiff = baseY;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isInverted) {\n\t\t\t\t\t\tdiff = isBarType ? 10 : 15;\n\t\t\t\t\t}\n\n\t\t\t\t\tyPos += diff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isRotated || isTreemapType) {\n\t\t\tyPos += $$.getCenteredTextPos(d, points, textElement, \"y\");\n\t\t}\n\n\t\treturn yPos + getTextPos.call(this, d, \"y\");\n\t},\n\n\t/**\n\t * Calculate if two or more text nodes are overlapping\n\t * Mark overlapping text nodes with \"text-overlapping\" class\n\t * @param {string} id Axis id\n\t * @param {ChartInternal} $$ ChartInternal context\n\t * @param {string} selector Selector string\n\t * @private\n\t */\n\tmarkOverlapped(id: AxisType, $$, selector: string): void {\n\t\tconst textNodes = $$.$el.arcs.selectAll(selector);\n\t\tconst filteredTextNodes = textNodes.filter(node => node.data.id !== id);\n\t\tconst textNode = textNodes.filter(node => node.data.id === id);\n\t\tconst translate = getTranslation(textNode.node());\n\n\t\t// Calculates the length of the hypotenuse\n\t\tconst calcHypo = (x, y) => Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n\n\t\ttextNode.node() && filteredTextNodes.each(function() {\n\t\t\tconst coordinate = getTranslation(this);\n\t\t\tconst filteredTextNode = d3Select(this);\n\t\t\tconst nodeForWidth =\n\t\t\t\tcalcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ?\n\t\t\t\t\ttextNode :\n\t\t\t\t\tfilteredTextNode;\n\n\t\t\tconst overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) <\n\t\t\t\tMath.ceil(nodeForWidth.node().getComputedTextLength());\n\t\t\tconst overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) <\n\t\t\t\tparseInt(textNode.style(\"font-size\"), 10);\n\n\t\t\tfilteredTextNode.classed($TEXT.TextOverlapping, overlapsX && overlapsY);\n\t\t});\n\t},\n\n\t/**\n\t * Calculate if two or more text nodes are overlapping\n\t * Remove \"text-overlapping\" class on selected text nodes\n\t * @param {ChartInternal} $$ ChartInternal context\n\t * @param {string} selector Selector string\n\t * @private\n\t */\n\tundoMarkOverlapped($$, selector): void {\n\t\t$$.$el.arcs.selectAll(selector)\n\t\t\t.each(function() {\n\t\t\t\td3SelectAll([this, this.previousSibling])\n\t\t\t\t\t.classed($TEXT.TextOverlapping, false);\n\t\t\t});\n\t},\n\n\t/**\n\t * Check if meets the ratio to show data label text\n\t * @param {number} ratio ratio to meet\n\t * @param {string} type chart type\n\t * @returns {boolean}\n\t * @private\n\t */\n\tmeetsLabelThreshold(ratio: number = 0,\n\t\ttype: \"bar\" | \"donut\" | \"gauge\" | \"pie\" | \"polar\" | \"treemap\"): boolean {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst threshold = config[`${type}_label_threshold`] || 0;\n\n\t\treturn ratio >= threshold;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$TEXT} from \"../../config/classes\";\nimport {isNumber, setTextValue} from \"../../module/util\";\n\n/**\n * Get the text position\n * @param {string} pos right, left or center\n * @param {number} width chart width\n * @returns {string|number} text-anchor value or position in pixel\n * @private\n */\nfunction getTextXPos(pos = \"left\", width?: number | any): number | \"start\" | \"middle\" | \"end\" {\n\tconst isNum = isNumber(width);\n\tlet position;\n\n\tif (pos.indexOf(\"center\") > -1) {\n\t\tposition = isNum ? width / 2 : \"middle\";\n\t} else if (pos.indexOf(\"right\") > -1) {\n\t\tposition = isNum ? width : \"end\";\n\t} else {\n\t\tposition = isNum ? 0 : \"start\";\n\t}\n\n\treturn position;\n}\n\nexport default {\n\t/**\n\t * Initializes the title\n\t * @private\n\t */\n\tinitTitle(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el} = $$;\n\n\t\tif (config.title_text) {\n\t\t\t$el.title = $el.svg.append(\"g\");\n\n\t\t\tconst text = $el.title\n\t\t\t\t.append(\"text\")\n\t\t\t\t.style(\"text-anchor\", getTextXPos(config.title_position))\n\t\t\t\t.attr(\"class\", $TEXT.title);\n\n\t\t\tsetTextValue(text, config.title_text, [0.3, 1.5]);\n\t\t}\n\t},\n\n\t/**\n\t * Redraw title\n\t * @private\n\t */\n\tredrawTitle(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {current}, $el: {title}} = $$;\n\n\t\tif (title) {\n\t\t\tconst x = getTextXPos(config.title_position, current.width);\n\t\t\tconst y = (config.title_padding.top || 0) +\n\t\t\t\t$$.getTextRect($$.$el.title, $TEXT.title).height;\n\n\t\t\ttitle.attr(\"transform\", `translate(${x}, ${y})`);\n\t\t}\n\t},\n\n\t/**\n\t * Get title padding\n\t * @returns {number} padding value\n\t * @private\n\t */\n\tgetTitlePadding(): number {\n\t\tconst $$ = this;\n\t\tconst {$el: {title}, config} = $$;\n\n\t\treturn (config.title_padding.top || 0) +\n\t\t\t(title ? $$.getTextRect(title, $TEXT.title).height : 0) +\n\t\t\t(config.title_padding.bottom || 0);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$ARC, $TOOLTIP} from \"../../config/classes\";\nimport {document} from \"../../module/browser\";\nimport {\n\tcallFn,\n\tgetBoundingRect,\n\tgetPointer,\n\tgetTransformCTM,\n\thasViewBox,\n\tisEmpty,\n\tisFunction,\n\tisObject,\n\tisString,\n\tisUndefined,\n\tisValue,\n\tparseDate,\n\tsanitize,\n\ttplProcess\n} from \"../../module/util\";\nimport type {IArcData, IDataRow} from \"../data/IData\";\n\nexport default {\n\t/**\n\t * Initializes the tooltip\n\t * @private\n\t */\n\tinitTooltip(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el} = $$;\n\n\t\t$el.tooltip = d3Select(config.tooltip_contents.bindto);\n\n\t\tif ($el.tooltip.empty()) {\n\t\t\t$el.tooltip = $el.chart\n\t\t\t\t.append(\"div\")\n\t\t\t\t.attr(\"class\", $TOOLTIP.tooltipContainer)\n\t\t\t\t.style(\"position\", \"absolute\")\n\t\t\t\t.style(\"pointer-events\", \"none\")\n\t\t\t\t.style(\"display\", \"none\");\n\t\t}\n\n\t\t$$.bindTooltipResizePos();\n\t},\n\n\t/**\n\t * Show tooltip at initialization.\n\t * Is called only when tooltip.init.show=true option is set\n\t * @private\n\t */\n\tinitShowTooltip(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el, state: {hasAxis, hasRadar}} = $$;\n\n\t\t// Show tooltip if needed\n\t\tif (config.tooltip_init_show) {\n\t\t\tconst isArc = !(hasAxis || hasRadar);\n\n\t\t\tif ($$.axis?.isTimeSeries() && isString(config.tooltip_init_x)) {\n\t\t\t\tconfig.tooltip_init_x = parseDate.call($$, config.tooltip_init_x);\n\t\t\t}\n\n\t\t\t$$.api.tooltip.show({\n\t\t\t\tdata: {\n\t\t\t\t\t[isArc ? \"index\" : \"x\"]: config.tooltip_init_x\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst position = config.tooltip_init_position;\n\n\t\t\tif (!config.tooltip_contents.bindto && !isEmpty(position)) {\n\t\t\t\tconst {top = 0, left = 50} = position;\n\n\t\t\t\t$el.tooltip.style(\"top\", isString(top) ? top : `${top}px`)\n\t\t\t\t\t.style(\"left\", isString(left) ? left : `${left}px`)\n\t\t\t\t\t.style(\"display\", null);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get the tooltip HTML string\n\t * @param  {Array} args Arguments\n\t * @returns {string} Formatted HTML string\n\t * @private\n\t */\n\tgetTooltipHTML(...args): string {\n\t\tconst $$ = this;\n\t\tconst {api, config} = $$;\n\n\t\treturn isFunction(config.tooltip_contents) ?\n\t\t\tconfig.tooltip_contents.bind(api)(...args) :\n\t\t\t$$.getTooltipContent(...args);\n\t},\n\n\t/**\n\t * Returns the tooltip content(HTML string)\n\t * @param {object} d data\n\t * @param {Function} defaultTitleFormat Default title format\n\t * @param {Function} defaultValueFormat Default format for each data value in the tooltip.\n\t * @param {Function} color Color function\n\t * @returns {string} html\n\t * @private\n\t */\n\tgetTooltipContent(d, defaultTitleFormat, defaultValueFormat, color): string {\n\t\tconst $$ = this;\n\t\tconst {api, config, state, $el} = $$;\n\n\t\t// get formatter function\n\t\tconst [titleFn, nameFn, valueFn] = [\"title\", \"name\", \"value\"].map(v => {\n\t\t\tconst fn = config[`tooltip_format_${v}`];\n\n\t\t\treturn isFunction(fn) ? fn.bind(api) : fn;\n\t\t});\n\n\t\t// determine fotmatter function with sanitization\n\t\tconst titleFormat = (...arg) => sanitize((titleFn || defaultTitleFormat)(...arg));\n\t\tconst nameFormat = (...arg) => sanitize((nameFn || (name => name))(...arg));\n\t\tconst valueFormat = (...arg) => {\n\t\t\tconst fn = valueFn || (\n\t\t\t\tstate.hasTreemap || $$.isStackNormalized() ?\n\t\t\t\t\t(v, ratio) => `${(ratio * 100).toFixed(2)}%` :\n\t\t\t\t\tdefaultValueFormat\n\t\t\t);\n\n\t\t\treturn sanitize(fn(...arg));\n\t\t};\n\n\t\tconst order = config.tooltip_order;\n\t\tconst getRowValue =\n\t\t\trow => ($$.axis && $$.isBubbleZType(row) ?\n\t\t\t\t$$.getBubbleZData(row.value, \"z\") :\n\t\t\t\t$$.getBaseValue(row));\n\t\tconst getBgColor = $$.levelColor ? row => $$.levelColor(row.value) : row => color(row);\n\t\tconst contents = config.tooltip_contents;\n\t\tconst tplStr = contents.template;\n\t\tconst targetIds = $$.mapToTargetIds();\n\n\t\tif (order === null && config.data_groups.length) {\n\t\t\t// for stacked data, order should aligned with the visually displayed data\n\t\t\tconst ids = $$.orderTargets($$.data.targets)\n\t\t\t\t.map(i2 => i2.id)\n\t\t\t\t.reverse();\n\n\t\t\td.sort((a, b) => {\n\t\t\t\tlet v1 = a ? a.value : null;\n\t\t\t\tlet v2 = b ? b.value : null;\n\n\t\t\t\tif (v1 > 0 && v2 > 0) {\n\t\t\t\t\tv1 = a.id ? ids.indexOf(a.id) : null;\n\t\t\t\t\tv2 = b.id ? ids.indexOf(b.id) : null;\n\t\t\t\t}\n\n\t\t\t\treturn v1 - v2;\n\t\t\t});\n\t\t} else if (/^(asc|desc)$/.test(order)) {\n\t\t\tconst isAscending = order === \"asc\";\n\n\t\t\td.sort((a, b) => {\n\t\t\t\tconst v1 = a ? getRowValue(a) : null;\n\t\t\t\tconst v2 = b ? getRowValue(b) : null;\n\n\t\t\t\treturn isAscending ? v1 - v2 : v2 - v1;\n\t\t\t});\n\t\t} else if (isFunction(order)) {\n\t\t\td.sort(order.bind(api));\n\t\t}\n\n\t\tconst tpl = $$.getTooltipContentTemplate(tplStr);\n\t\tconst len = d.length;\n\t\tlet text;\n\t\tlet row;\n\t\tlet param;\n\t\tlet value;\n\t\tlet i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\trow = d[i];\n\n\t\t\tif (!row || !(getRowValue(row) || getRowValue(row) === 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isUndefined(text)) {\n\t\t\t\tconst title = (state.hasAxis || state.hasRadar) && titleFormat(row.x);\n\n\t\t\t\ttext = tplProcess(tpl[0], {\n\t\t\t\t\tCLASS_TOOLTIP: $TOOLTIP.tooltip,\n\t\t\t\t\tTITLE: isValue(title) ?\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttplStr ? title : `<tr><th colspan=\"2\">${title}</th></tr>`\n\t\t\t\t\t\t) :\n\t\t\t\t\t\t\"\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!row.ratio && $el.arcs) {\n\t\t\t\tparam = [\"arc\", $$.$el.arcs.select(`path.${$ARC.arc}-${row.id}`).data()[0]];\n\t\t\t\trow.ratio = $$.getRatio(...param);\n\t\t\t}\n\n\t\t\t// arrange param to be passed to formatter\n\t\t\tparam = [row.ratio, row.id, row.index];\n\n\t\t\tif ($$.isAreaRangeType(row)) {\n\t\t\t\tconst [high, low] = [\"high\", \"low\"].map(v =>\n\t\t\t\t\tvalueFormat($$.getRangedData(row, v), ...param)\n\t\t\t\t);\n\t\t\t\tconst mid = valueFormat(getRowValue(row), ...param);\n\n\t\t\t\tvalue = `<b>Mid:</b> ${mid} <b>High:</b> ${high} <b>Low:</b> ${low}`;\n\t\t\t} else if ($$.isCandlestickType(row)) {\n\t\t\t\tconst [open, high, low, close, volume] = [\"open\", \"high\", \"low\", \"close\", \"volume\"]\n\t\t\t\t\t.map(v => {\n\t\t\t\t\t\tconst value = $$.getRangedData(row, v, \"candlestick\");\n\n\t\t\t\t\t\treturn value ?\n\t\t\t\t\t\t\tvalueFormat(\n\t\t\t\t\t\t\t\t$$.getRangedData(row, v, \"candlestick\"),\n\t\t\t\t\t\t\t\t...param\n\t\t\t\t\t\t\t) :\n\t\t\t\t\t\t\tundefined;\n\t\t\t\t\t});\n\n\t\t\t\tvalue =\n\t\t\t\t\t`<b>Open:</b> ${open} <b>High:</b> ${high} <b>Low:</b> ${low} <b>Close:</b> ${close}${\n\t\t\t\t\t\tvolume ? ` <b>Volume:</b> ${volume}` : \"\"\n\t\t\t\t\t}`;\n\t\t\t} else if ($$.isBarRangeType(row)) {\n\t\t\t\tconst {value: rangeValue, id, index} = row;\n\n\t\t\t\tvalue = `${valueFormat(rangeValue, undefined, id, index)}`;\n\t\t\t} else {\n\t\t\t\tvalue = valueFormat(getRowValue(row), ...param);\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\t// Skip elements when their name is set to null\n\t\t\t\tif (row.name === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst name = nameFormat(row.name ?? row.id, ...param);\n\t\t\t\tconst color = getBgColor(row);\n\t\t\t\tconst contentValue = {\n\t\t\t\t\tCLASS_TOOLTIP_NAME: $TOOLTIP.tooltipName + $$.getTargetSelectorSuffix(row.id),\n\t\t\t\t\tCOLOR: (tplStr || !$$.patterns) ?\n\t\t\t\t\t\tcolor :\n\t\t\t\t\t\t`<svg><rect style=\"fill:${color}\" width=\"10\" height=\"10\"></rect></svg>`,\n\t\t\t\t\tNAME: name,\n\t\t\t\t\tVALUE: value\n\t\t\t\t};\n\n\t\t\t\tif (tplStr && isObject(contents.text)) {\n\t\t\t\t\tconst index = targetIds.indexOf(row.id);\n\n\t\t\t\t\tObject.keys(contents.text).forEach(key => {\n\t\t\t\t\t\tcontentValue[key] = contents.text[key][index];\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\ttext += tplProcess(tpl[1], contentValue);\n\t\t\t}\n\t\t}\n\n\t\treturn `${text}</table>`;\n\t},\n\n\t/**\n\t * Get the content template string\n\t * @param {string} tplStr Tempalte string\n\t * @returns {Array} Template string\n\t * @private\n\t */\n\tgetTooltipContentTemplate(tplStr?: string): string[] {\n\t\treturn (tplStr || `<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">${\n\t\t\tthis.patterns ? `{=COLOR}` : `<span style=\"background-color:{=COLOR}\"></span>`\n\t\t}{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>`)\n\t\t\t.replace(/(\\r?\\n|\\t)/g, \"\")\n\t\t\t.split(/{{(.*)}}/);\n\t},\n\n\t/**\n\t * Update tooltip position coordinate\n\t * @param {object} dataToShow Data object\n\t * @param {SVGElement} eventTarget Event element\n\t * @private\n\t */\n\tsetTooltipPosition(dataToShow: IDataRow[], eventTarget: SVGElement): void {\n\t\tconst $$ = this;\n\t\tconst {config, scale, state, $el: {eventRect, tooltip, svg}} = $$;\n\t\tconst {bindto} = config.tooltip_contents;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst datum = tooltip?.datum();\n\n\t\tif (!bindto && datum) {\n\t\t\tconst data = dataToShow ?? JSON.parse(datum.current);\n\t\t\tconst [x, y] = getPointer(state.event, eventTarget ?? eventRect?.node()); // get mouse event position\n\t\t\tconst currPos: {\n\t\t\t\tx: number,\n\t\t\t\ty: number,\n\t\t\t\txAxis?: number,\n\t\t\t\tyAxis?: number | (\n\t\t\t\t\t(value: number, id?: string, axisId?: string) => number\n\t\t\t\t)\n\t\t\t} = {x, y};\n\n\t\t\tif (state.hasAxis && scale.x && datum && \"x\" in datum) {\n\t\t\t\tconst getYPos = (value = 0, id?: string, axisId = \"y\"): number => {\n\t\t\t\t\tconst scaleFn = scale[id ? $$.axis?.getId(id) : axisId];\n\n\t\t\t\t\treturn scaleFn ?\n\t\t\t\t\t\tscaleFn(value) + (isRotated ? state.margin.left : state.margin.top) :\n\t\t\t\t\t\t0;\n\t\t\t\t};\n\n\t\t\t\tcurrPos.xAxis = scale.x(datum.x) + (\n\t\t\t\t\t// add margin only when user specified tooltip.position function\n\t\t\t\t\tconfig.tooltip_position ? (isRotated ? state.margin.top : state.margin.left) : 0\n\t\t\t\t);\n\n\t\t\t\tif (data.length === 1) {\n\t\t\t\t\tcurrPos.yAxis = getYPos(data[0].value as number, data[0].id);\n\t\t\t\t} else {\n\t\t\t\t\tcurrPos.yAxis = getYPos;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst {width = 0, height = 0} = datum;\n\n\t\t\t// Get tooltip position\n\t\t\tconst pos = config.tooltip_position?.bind($$.api)(\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\teventRect?.node(),\n\t\t\t\tcurrPos\n\t\t\t) ?? (\n\t\t\t\thasViewBox(svg) ?\n\t\t\t\t\t$$.getTooltipPositionViewBox.bind($$)(width, height, currPos) :\n\t\t\t\t\t$$.getTooltipPosition.bind($$)(width, height, currPos)\n\t\t\t);\n\n\t\t\t[\"top\", \"left\"].forEach(v => {\n\t\t\t\tconst value = pos[v];\n\n\t\t\t\ttooltip.style(v, `${value}px`);\n\n\t\t\t\t// Remember left pos in percentage to be used on resize call\n\t\t\t\tif (v === \"left\" && !datum.xPosInPercent) {\n\t\t\t\t\tdatum.xPosInPercent = value / state.current.width * 100;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Get tooltip position when svg has vieBox attribute\n\t * @param {number} tWidth Tooltip width value\n\t * @param {number} tHeight Tooltip height value\n\t * @param {object} currPos Current event position value from SVG coordinate\n\t * @returns {object} top, left value\n\t */\n\tgetTooltipPositionViewBox(tWidth: number, tHeight: number,\n\t\tcurrPos: {[key: string]: number}): {top: number, left: number} {\n\t\tconst $$ = this;\n\t\tconst {$el: {eventRect, svg}, config, state} = $$;\n\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst hasArcType = $$.hasArcType() || state.hasFunnel || state.hasTreemap;\n\t\tconst target = (hasArcType ? svg : eventRect)?.node() ?? state.event.target;\n\n\t\tlet {x, y} = currPos;\n\n\t\tif (state.hasAxis) {\n\t\t\tx = isRotated ? x : currPos.xAxis;\n\t\t\ty = isRotated ? currPos.xAxis : y;\n\t\t}\n\n\t\t// currPos value based on SVG coordinate\n\t\tconst ctm = getTransformCTM(target, x, y, false);\n\t\tconst rect = getBoundingRect(target);\n\t\tconst size = getTransformCTM(target, 20, 0, false).x;\n\n\t\tlet top = ctm.y;\n\t\tlet left = ctm.x + (tWidth / 2) + size;\n\n\t\tif (hasArcType) {\n\t\t\tif (state.hasFunnel || state.hasTreemap || state.hasRadar) {\n\t\t\t\tleft -= (tWidth / 2) + size;\n\t\t\t\ttop += tHeight;\n\t\t\t} else {\n\t\t\t\ttop += rect.height / 2;\n\t\t\t\tleft += (rect.width / 2) - (tWidth - size);\n\t\t\t}\n\t\t}\n\n\t\tif (left + tWidth > rect.width) {\n\t\t\tleft = rect.width - tWidth - size;\n\t\t}\n\n\t\tif (top + tHeight > rect.height) {\n\t\t\ttop -= tHeight * 2;\n\t\t}\n\n\t\treturn {\n\t\t\ttop,\n\t\t\tleft\n\t\t};\n\t},\n\n\t/**\n\t * Returns the position of the tooltip\n\t * @param {string} tWidth Width value of tooltip element\n\t * @param {string} tHeight Height value of tooltip element\n\t * @param {object} currPos Current mouse position\n\t * @returns {object} top, left value\n\t * @private\n\t */\n\tgetTooltipPosition(tWidth: number, tHeight: number,\n\t\tcurrPos: {[key: string]: number}): {top: number, left: number} {\n\t\tconst $$ = this;\n\t\tconst {config, scale, state} = $$;\n\t\tconst {width, height, current, hasFunnel, hasRadar, hasTreemap, isLegendRight, inputType} =\n\t\t\tstate;\n\t\tconst hasGauge = $$.hasType(\"gauge\") && !config.gauge_fullCircle;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst hasArcType = $$.hasArcType();\n\t\tconst svgLeft = $$.getSvgLeft(true);\n\t\tlet chartRight = svgLeft + current.width - $$.getCurrentPaddingByDirection(\"right\");\n\n\t\tconst size = 20;\n\t\tlet {x, y} = currPos;\n\n\t\t// Determine tooltip position\n\t\tif (hasRadar) {\n\t\t\tx += x >= (width / 2) ? 15 : -(tWidth + 15);\n\t\t\ty += 15;\n\t\t} else if (hasArcType) {\n\t\t\tconst notTouch = inputType !== \"touch\";\n\n\t\t\tif (notTouch) {\n\t\t\t\tlet titlePadding = $$.getTitlePadding?.() ?? 0;\n\n\t\t\t\tif (titlePadding && hasGauge && config.arc_rangeText_values?.length) {\n\t\t\t\t\ttitlePadding += 10;\n\t\t\t\t}\n\n\t\t\t\tx += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2;\n\t\t\t\ty += (hasGauge ? height : (height / 2) + tHeight) + titlePadding;\n\t\t\t}\n\t\t} else if (hasFunnel || hasTreemap) {\n\t\t\ty += tHeight;\n\t\t} else {\n\t\t\tconst padding = {\n\t\t\t\ttop: $$.getCurrentPaddingByDirection(\"top\", true),\n\t\t\t\tleft: $$.getCurrentPaddingByDirection(\"left\", true)\n\t\t\t};\n\n\t\t\tif (isRotated) {\n\t\t\t\tx += svgLeft + padding.left + size;\n\t\t\t\ty = padding.top + currPos.xAxis + size;\n\t\t\t\tchartRight -= svgLeft;\n\t\t\t} else {\n\t\t\t\tx = svgLeft + padding.left + size + (scale.zoom ? x : currPos.xAxis);\n\t\t\t\ty += padding.top - 5;\n\t\t\t}\n\t\t}\n\n\t\t// when tooltip left + tWidth > chart's width\n\t\tif ((x + tWidth + 15) > chartRight) {\n\t\t\tx -= tWidth + (hasFunnel || hasTreemap || hasArcType ? 0 : (isRotated ? size * 2 : 38));\n\t\t}\n\n\t\tif (y + tHeight > current.height) {\n\t\t\tconst gap = hasTreemap ? tHeight + 10 : 30;\n\n\t\t\ty -= hasGauge ? tHeight * 1.5 : tHeight + gap;\n\t\t}\n\n\t\tconst pos = {top: y, left: x};\n\n\t\t// make sure to not be positioned out of viewport\n\t\tObject.keys(pos).forEach(v => {\n\t\t\tif (pos[v] < 0) {\n\t\t\t\tpos[v] = 0;\n\t\t\t}\n\t\t});\n\n\t\treturn pos;\n\t},\n\n\t/**\n\t * Show the tooltip\n\t * @param {object} selectedData Data object\n\t * @param {SVGElement} eventTarget Event element\n\t * @private\n\t */\n\tshowTooltip(selectedData: IDataRow[], eventTarget: SVGElement): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {tooltip}} = $$;\n\t\tconst dataToShow = selectedData.filter(d => d && isValue($$.getBaseValue(d)));\n\n\t\tif (!tooltip || dataToShow.length === 0 || !config.tooltip_show) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet datum = tooltip.datum();\n\t\tconst dataStr = JSON.stringify(selectedData);\n\n\t\tif (!datum || datum.current !== dataStr) {\n\t\t\tconst {index, x} = selectedData.concat().sort()[0];\n\n\t\t\tcallFn(config.tooltip_onshow, $$.api, selectedData);\n\n\t\t\t// set tooltip content\n\t\t\ttooltip\n\t\t\t\t.html($$.getTooltipHTML(\n\t\t\t\t\tselectedData, // data\n\t\t\t\t\t$$.axis ? $$.axis.getXAxisTickFormat() : $$.categoryName.bind($$), // defaultTitleFormat\n\t\t\t\t\t$$.getDefaultValueFormat(), // defaultValueFormat\n\t\t\t\t\t$$.color // color\n\t\t\t\t))\n\t\t\t\t.style(\"display\", null)\n\t\t\t\t.style(\"visibility\", null) // for IE9\n\t\t\t\t.datum(datum = {\n\t\t\t\t\tindex,\n\t\t\t\t\tx,\n\t\t\t\t\tcurrent: dataStr,\n\t\t\t\t\twidth: tooltip.property(\"offsetWidth\"),\n\t\t\t\t\theight: tooltip.property(\"offsetHeight\")\n\t\t\t\t});\n\n\t\t\tcallFn(config.tooltip_onshown, $$.api, selectedData);\n\t\t\t$$._handleLinkedCharts(true, index);\n\t\t}\n\n\t\t$$.setTooltipPosition(dataToShow, eventTarget);\n\t},\n\n\t/**\n\t * Adjust tooltip position on resize event\n\t * @private\n\t */\n\tbindTooltipResizePos(): void {\n\t\tconst $$ = this;\n\t\tconst {resizeFunction, state, $el: {tooltip}} = $$;\n\n\t\tresizeFunction.add(() => {\n\t\t\tif (tooltip.style(\"display\") === \"block\") {\n\t\t\t\tconst {current} = state;\n\t\t\t\tconst {width, xPosInPercent} = tooltip.datum();\n\t\t\t\tlet value = current.width / 100 * xPosInPercent;\n\t\t\t\tconst diff = current.width - (value + width);\n\n\t\t\t\t// if tooltip size overs current viewport size\n\t\t\t\tif (diff < 0) {\n\t\t\t\t\tvalue += diff;\n\t\t\t\t}\n\n\t\t\t\ttooltip.style(\"left\", `${value}px`);\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Hide the tooltip\n\t * @param {boolean} force Force to hide\n\t * @private\n\t */\n\thideTooltip(force?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {api, config, $el: {tooltip}} = $$;\n\n\t\tif (\n\t\t\ttooltip && tooltip.style(\"display\") !== \"none\" && (!config.tooltip_doNotHide || force)\n\t\t) {\n\t\t\tconst selectedData = JSON.parse(tooltip.datum().current ?? {});\n\n\t\t\tcallFn(config.tooltip_onhide, api, selectedData);\n\n\t\t\t// hide tooltip\n\t\t\ttooltip\n\t\t\t\t.style(\"display\", \"none\")\n\t\t\t\t.style(\"visibility\", \"hidden\") // for IE9\n\t\t\t\t.datum(null);\n\n\t\t\tcallFn(config.tooltip_onhidden, api, selectedData);\n\t\t}\n\t},\n\n\t/**\n\t * Toggle display for linked chart instances\n\t * @param {boolean} show true: show, false: hide\n\t * @param {number} index x Axis index\n\t * @private\n\t */\n\t_handleLinkedCharts(show: boolean, index: number): void {\n\t\tconst $$ = this;\n\t\tconst {charts, config, state: {event}} = $$;\n\n\t\t// Prevent propagation among instances if isn't instantiated from the user's event\n\t\t// https://github.com/naver/billboard.js/issues/1979\n\t\tif (event?.isTrusted && config.tooltip_linked && charts.length > 1) {\n\t\t\tconst linkedName = config.tooltip_linked_name;\n\n\t\t\tcharts\n\t\t\t\t.filter(c => c !== $$.api)\n\t\t\t\t.forEach(c => {\n\t\t\t\t\tconst {config, $el} = c.internal;\n\t\t\t\t\tconst isLinked = config.tooltip_linked;\n\t\t\t\t\tconst name = config.tooltip_linked_name;\n\t\t\t\t\tconst isInDom = document.body.contains($el.chart.node());\n\n\t\t\t\t\tif (isLinked && linkedName === name && isInDom) {\n\t\t\t\t\t\tconst data = $el.tooltip.data()[0];\n\t\t\t\t\t\tconst isNotSameIndex = index !== data?.index;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tc.tooltip[\n\t\t\t\t\t\t\t\tshow && isNotSameIndex ? \"show\" : \"hide\"\n\t\t\t\t\t\t\t]({index});\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Update tooltip content on redraw\n\t * - In a situation where tooltip is displayed and data load happens, it should reflect loaded data to tooltip\n\t * @param {d3Selection} context Event rect element\n\t * @param {number} index Data index\n\t * @private\n\t */\n\tupdateTooltipOnRedraw(context?: SVGRectElement, index?: number): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\tconfig,\n\t\t\t$el: {eventRect, svg, tooltip},\n\t\t\tstate: {event, hasAxis, hasRadar, hasTreemap}\n\t\t} = $$;\n\n\t\t// Update tooltip, when tooltip is in shown state\n\t\tif (tooltip?.style(\"display\") === \"block\" && event) {\n\t\t\tconst rect = context ?? (hasRadar ? svg : eventRect)?.node();\n\n\t\t\t// for Axis based & Radar\n\t\t\tif (hasAxis || hasRadar) {\n\t\t\t\tif ($$.isMultipleX()) {\n\t\t\t\t\t$$.selectRectForMultipleXs(rect, false);\n\t\t\t\t} else {\n\t\t\t\t\tconst idx = index ?? $$.getDataIndexFromEvent(event);\n\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\t$$.api.tooltip.hide();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$.selectRectForSingle(rect, idx);\n\t\t\t\t\t\t$$.setExpand(idx, null, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // for Arc & Treemap\n\t\t\t\tconst {clientX, clientY} = event;\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tlet target = [clientX, clientY].every(Number.isFinite) &&\n\t\t\t\t\t\tdocument.elementFromPoint(clientX, clientY);\n\t\t\t\t\tconst data = target && d3Select(target).datum() as IArcData;\n\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tconst d = $$.hasArcType() ?\n\t\t\t\t\t\t\t$$.convertToArcData($$.updateAngle(data)) :\n\t\t\t\t\t\t\tdata?.data;\n\n\t\t\t\t\t\thasTreemap && (target = svg.node());\n\t\t\t\t\t\td && $$.showTooltip([d], target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$.api.tooltip.hide();\n\t\t\t\t\t}\n\t\t\t\t}, config.transition_duration);\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$ARC, $AXIS} from \"../../config/classes\";\nimport {asHalfPixel} from \"../../module/util\";\n\ntype TranslateParam = \"main\" | \"context\" | \"legend\" | \"x\" | \"y\" | \"y2\" | \"subX\" | \"arc\" | \"radar\"\n\t| \"polar\";\n\nexport default {\n\tgetTranslate(target: TranslateParam, index = 0): string {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tlet padding = 0;\n\t\tlet x;\n\t\tlet y;\n\n\t\tif (index && /^(x|y2?)$/.test(target)) {\n\t\t\tpadding = $$.getAxisSize(target) * index;\n\t\t}\n\n\t\tif (target === \"main\") {\n\t\t\tx = asHalfPixel(state.margin.left);\n\t\t\ty = asHalfPixel(state.margin.top);\n\t\t} else if (target === \"context\") {\n\t\t\tx = asHalfPixel(state.margin2.left);\n\t\t\ty = asHalfPixel(state.margin2.top);\n\t\t} else if (target === \"legend\") {\n\t\t\tx = state.margin3.left;\n\t\t\ty = state.margin3.top;\n\t\t} else if (target === \"x\") {\n\t\t\tx = isRotated ? -padding : 0;\n\t\t\ty = isRotated ? 0 : state.height + padding;\n\t\t} else if (target === \"y\") {\n\t\t\tx = isRotated ? 0 : -padding;\n\t\t\ty = isRotated ? state.height + padding : 0;\n\t\t} else if (target === \"y2\") {\n\t\t\tx = isRotated ? 0 : state.width + padding;\n\t\t\ty = isRotated ? -padding - 1 : 0;\n\t\t} else if (target === \"subX\") {\n\t\t\tx = 0;\n\t\t\ty = isRotated ? 0 : state.height2;\n\t\t} else if (target === \"arc\") {\n\t\t\tx = state.arcWidth / 2;\n\t\t\ty = state.arcHeight / 2;\n\n\t\t\tif (config.arc_rangeText_values?.length) {\n\t\t\t\ty += 5 + ($$.hasType(\"gauge\") && config.title_text ? 10 : 0);\n\t\t\t}\n\t\t} else if (target === \"polar\") {\n\t\t\tx = state.arcWidth / 2;\n\t\t\ty = state.arcHeight / 2;\n\t\t} else if (target === \"radar\") {\n\t\t\tconst [width, height] = $$.getRadarSize();\n\n\t\t\tx = state.width / 2 - width;\n\t\t\ty = state.height / 2 - height;\n\t\t}\n\n\t\treturn `translate(${x}, ${y})`;\n\t},\n\n\ttransformMain(withTransition: boolean, transitions): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {main}, $T} = $$;\n\n\t\tconst xAxis = transitions?.axisX ?\n\t\t\ttransitions.axisX :\n\t\t\t$T(main.select(`.${$AXIS.axisX}`), withTransition);\n\n\t\tconst yAxis = transitions?.axisY ?\n\t\t\ttransitions.axisY :\n\t\t\t$T(main.select(`.${$AXIS.axisY}`), withTransition);\n\n\t\tconst y2Axis = transitions?.axisY2 ?\n\t\t\ttransitions.axisY2 :\n\t\t\t$T(main.select(`.${$AXIS.axisY2}`), withTransition);\n\n\t\t$T(main, withTransition)\n\t\t\t.attr(\"transform\", $$.getTranslate(\"main\"));\n\n\t\txAxis.attr(\"transform\", $$.getTranslate(\"x\"));\n\t\tyAxis.attr(\"transform\", $$.getTranslate(\"y\"));\n\t\ty2Axis.attr(\"transform\", $$.getTranslate(\"y2\"));\n\n\t\tmain.select(`.${$ARC.chartArcs}`)\n\t\t\t.attr(\"transform\", $$.getTranslate(\"arc\"));\n\t},\n\n\ttransformAll(withTransition: boolean, transitions): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {hasAxis, hasFunnel, hasTreemap}, $el} = $$;\n\n\t\t!hasFunnel && !hasTreemap && $$.transformMain(withTransition, transitions);\n\n\t\thasAxis && config.subchart_show &&\n\t\t\t$$.transformContext(withTransition, transitions);\n\n\t\t$el.legend && $$.transformLegend(withTransition);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {TYPE, TYPE_BY_CATEGORY} from \"../../config/const\";\nimport {isArray, isNumber, isString} from \"../../module/util\";\nimport type {IData} from \"../data/IData\";\n\nexport default {\n\t/**\n\t * Check if the given chart type is valid\n\t * @param {string} type Chart type string\n\t * @returns {boolean}\n\t * @private\n\t */\n\tisValidChartType(type: string): boolean {\n\t\treturn !!(type && Object.values(TYPE).indexOf(type) > -1);\n\t},\n\n\tsetTargetType(targetIds: string[], type: string): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {withoutFadeIn}} = $$;\n\n\t\t$$.mapToTargetIds(targetIds).forEach(id => {\n\t\t\twithoutFadeIn[id] = type === config.data_types[id];\n\t\t\tconfig.data_types[id] = type;\n\t\t});\n\n\t\tif (!targetIds) {\n\t\t\tconfig.data_type = type;\n\t\t}\n\t},\n\n\t/**\n\t * Updte current used chart types\n\t * @private\n\t */\n\tupdateTypesElements(): void {\n\t\tconst $$ = this;\n\t\tconst {state: {current}} = $$;\n\n\t\tObject.keys(TYPE).forEach(v => {\n\t\t\tconst t = TYPE[v];\n\t\t\tconst has = $$.hasType(t, null, true);\n\t\t\tconst idx = current.types.indexOf(t);\n\n\t\t\tif (idx === -1 && has) {\n\t\t\t\tcurrent.types.push(t);\n\t\t\t} else if (idx > -1 && !has) {\n\t\t\t\tcurrent.types.splice(idx, 1);\n\t\t\t}\n\t\t});\n\n\t\t// Update current chart elements reference\n\t\t$$.setChartElements();\n\t},\n\n\t/**\n\t * Check if given chart types exists\n\t * @param {string} type Chart type\n\t * @param {Array} targetsValue Data array\n\t * @param {boolean} checkFromData Force to check type cotains from data targets\n\t * @returns {boolean}\n\t * @private\n\t */\n\thasType(type: string, targetsValue?, checkFromData = false): boolean {\n\t\tconst $$ = this;\n\t\tconst {config, state: {current}} = $$;\n\t\tconst types = config.data_types;\n\t\tconst targets = targetsValue || $$.data.targets;\n\t\tlet has = false;\n\n\t\tif (!checkFromData && current.types?.indexOf(type) > -1) {\n\t\t\thas = true;\n\t\t} else if (targets?.length) {\n\t\t\ttargets.forEach(target => {\n\t\t\t\tconst t = types[target.id];\n\n\t\t\t\tif (t === type || (!t && type === \"line\")) {\n\t\t\t\t\thas = true;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (Object.keys(types).length) {\n\t\t\tObject.keys(types).forEach(id => {\n\t\t\t\tif (types[id] === type) {\n\t\t\t\t\thas = true;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\thas = config.data_type === type;\n\t\t}\n\n\t\treturn has;\n\t},\n\n\t/**\n\t * Check if contains given chart types\n\t * @param {string} type Type key\n\t * @param {object} targets Target data\n\t * @param {Array} exclude Excluded types\n\t * @returns {boolean}\n\t * @private\n\t */\n\thasTypeOf(type, targets, exclude: string[] = []): boolean {\n\t\tif (type in TYPE_BY_CATEGORY) {\n\t\t\treturn !TYPE_BY_CATEGORY[type]\n\t\t\t\t.filter((v: string) => exclude.indexOf(v) === -1)\n\t\t\t\t.every((v: string) => !this.hasType(v, targets));\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t/**\n\t * Check if given data is certain chart type\n\t * @param {object} d Data object\n\t * @param {string|Array} type chart type\n\t * @returns {boolean}\n\t * @private\n\t */\n\tisTypeOf(d, type): boolean {\n\t\tconst id = isString(d) ? d : d.id;\n\t\tconst dataType = this.config && (this.config.data_types?.[id] || this.config.data_type);\n\n\t\treturn isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;\n\t},\n\n\thasPointType(): boolean {\n\t\tconst $$ = this;\n\n\t\treturn $$.hasTypeOf(\"Line\") || $$.hasType(\"bubble\") || $$.hasType(\"scatter\");\n\t},\n\n\t/**\n\t * Check if contains arc types chart\n\t * @param {object} targets Target data\n\t * @param {Array} exclude Excluded types\n\t * @returns {boolean}\n\t * @private\n\t */\n\thasArcType(targets?: IData, exclude?: string[]): boolean {\n\t\treturn this.hasTypeOf(\"Arc\", targets, exclude);\n\t},\n\n\thasMultiArcGauge(): boolean {\n\t\treturn this.hasType(\"gauge\") && this.config.gauge_type === \"multi\";\n\t},\n\n\tisLineType(d): boolean {\n\t\tconst id = isString(d) ? d : d.id;\n\n\t\treturn !this.config.data_types[id] ||\n\t\t\tthis.isTypeOf(id, TYPE_BY_CATEGORY.Line);\n\t},\n\n\tisStepType(d): boolean {\n\t\treturn this.isTypeOf(d, TYPE_BY_CATEGORY.Step);\n\t},\n\n\tisSplineType(d): boolean {\n\t\treturn this.isTypeOf(d, TYPE_BY_CATEGORY.Spline);\n\t},\n\n\tisAreaType(d): boolean {\n\t\treturn this.isTypeOf(d, TYPE_BY_CATEGORY.Area);\n\t},\n\n\tisAreaRangeType(d): boolean {\n\t\treturn this.isTypeOf(d, TYPE_BY_CATEGORY.AreaRange);\n\t},\n\n\tisBarType(d): boolean {\n\t\treturn this.isTypeOf(d, \"bar\");\n\t},\n\n\tisBubbleType(d): boolean {\n\t\treturn this.isTypeOf(d, \"bubble\");\n\t},\n\n\tisCandlestickType(d): boolean {\n\t\treturn this.isTypeOf(d, \"candlestick\");\n\t},\n\n\tisScatterType(d): boolean {\n\t\treturn this.isTypeOf(d, \"scatter\");\n\t},\n\n\tisTreemapType(d): boolean {\n\t\treturn this.isTypeOf(d, \"treemap\");\n\t},\n\n\tisPieType(d): boolean {\n\t\treturn this.isTypeOf(d, \"pie\");\n\t},\n\n\tisFunnelType(d): boolean {\n\t\treturn this.isTypeOf(d, \"funnel\");\n\t},\n\n\tisGaugeType(d): boolean {\n\t\treturn this.isTypeOf(d, \"gauge\");\n\t},\n\n\tisDonutType(d): boolean {\n\t\treturn this.isTypeOf(d, \"donut\");\n\t},\n\n\tisPolarType(d): boolean {\n\t\treturn this.isTypeOf(d, \"polar\");\n\t},\n\n\tisRadarType(d): boolean {\n\t\treturn this.isTypeOf(d, \"radar\");\n\t},\n\n\tisArcType(d): boolean {\n\t\treturn this.isPieType(d) ||\n\t\t\tthis.isDonutType(d) ||\n\t\t\tthis.isGaugeType(d) ||\n\t\t\tthis.isPolarType(d) ||\n\t\t\tthis.isRadarType(d);\n\t},\n\n\t// determine if is 'circle' data point\n\tisCirclePoint(node?): boolean {\n\t\tconst {config} = this;\n\t\tconst pattern = config.point_pattern;\n\t\tlet isCircle = false;\n\n\t\tif (node?.tagName === \"circle\") {\n\t\t\tisCircle = true;\n\t\t} else {\n\t\t\tisCircle = config.point_type === \"circle\" &&\n\t\t\t\t(!pattern || (\n\t\t\t\t\tisArray(pattern) && pattern.length === 0\n\t\t\t\t));\n\t\t}\n\n\t\treturn isCircle;\n\t},\n\n\tlineData(d) {\n\t\treturn this.isLineType(d) ? [d] : [];\n\t},\n\n\tarcData(d) {\n\t\treturn this.isArcType(d.data) ? [d] : [];\n\t},\n\n\t/**\n\t * Get data adapt for data label showing\n\t * @param {object} d Data object\n\t * @returns {Array}\n\t * @private\n\t */\n\tlabelishData(d) {\n\t\treturn this.isBarType(d) ||\n\t\t\t\tthis.isLineType(d) ||\n\t\t\t\tthis.isScatterType(d) ||\n\t\t\t\tthis.isBubbleType(d) ||\n\t\t\t\tthis.isCandlestickType(d) ||\n\t\t\t\tthis.isFunnelType(d) ||\n\t\t\t\tthis.isRadarType(d) ||\n\t\t\t\tthis.isTreemapType(d) ?\n\t\t\td.values.filter(v => isNumber(v.value) || Boolean(v.value)) :\n\t\t\t[];\n\t},\n\n\tbarLineBubbleData(d) {\n\t\treturn this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];\n\t},\n\n\t// https://github.com/d3/d3-shape#curves\n\tisInterpolationType(type: string): boolean {\n\t\treturn [\n\t\t\t\"basis\",\n\t\t\t\"basis-closed\",\n\t\t\t\"basis-open\",\n\t\t\t\"bundle\",\n\t\t\t\"cardinal\",\n\t\t\t\"cardinal-closed\",\n\t\t\t\"cardinal-open\",\n\t\t\t\"catmull-rom\",\n\t\t\t\"catmull-rom-closed\",\n\t\t\t\"catmull-rom-open\",\n\t\t\t\"linear\",\n\t\t\t\"linear-closed\",\n\t\t\t\"monotone-x\",\n\t\t\t\"monotone-y\",\n\t\t\t\"natural\"\n\t\t].indexOf(type) >= 0;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {\n\tcurveBasis as d3CurveBasis,\n\tcurveBasisClosed as d3CurveBasisClosed,\n\tcurveBasisOpen as d3CurveBasisOpen,\n\tcurveBundle as d3CurveBundle,\n\tcurveCardinal as d3CurveCardinal,\n\tcurveCardinalClosed as d3CurveCardinalClosed,\n\tcurveCardinalOpen as d3CurveCardinalOpen,\n\tcurveCatmullRom as d3CurveCatmullRom,\n\tcurveCatmullRomClosed as d3CurveCatmullRomClosed,\n\tcurveCatmullRomOpen as d3CurveCatmullRomOpen,\n\tcurveLinear as d3CurveLinear,\n\tcurveLinearClosed as d3CurveLinearClosed,\n\tcurveMonotoneX as d3CurveMonotoneX,\n\tcurveMonotoneY as d3CurveMonotoneY,\n\tcurveNatural as d3CurveNatural,\n\tcurveStep as d3CurveStep,\n\tcurveStepAfter as d3CurveStepAfter,\n\tcurveStepBefore as d3CurveStepBefore\n} from \"d3-shape\";\nimport type {d3Selection} from \"../../../types/types\";\nimport CLASS from \"../../config/classes\";\nimport {\n\tcapitalize,\n\tgetBBox,\n\tgetPointer,\n\tgetRectSegList,\n\tgetUnique,\n\tisFunction,\n\tisNumber,\n\tisObjectType,\n\tisUndefined,\n\tisValue,\n\tnotEmpty,\n\tparseDate\n} from \"../../module/util\";\nimport type {IDataIndice, IDataRow, TIndices} from \"../data/IData\";\n\n/**\n * Get grouped data point function for y coordinate\n * - Note: Grouped(stacking) works only for line and bar types\n * @param {object} d data vlaue\n * @returns {Function|undefined}\n * @private\n */\nfunction getGroupedDataPointsFn(d) {\n\tconst $$ = this;\n\tlet fn;\n\n\tif ($$.isLineType(d)) {\n\t\tfn = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType));\n\t} else if ($$.isBarType(d)) {\n\t\tfn = $$.generateGetBarPoints($$.getShapeIndices($$.isBarType));\n\t}\n\n\treturn fn;\n}\n\nexport interface IOffset {\n\t_$width: number;\n\t_$total: number[];\n}\n\nexport default {\n\t/**\n\t * Get the shape draw function\n\t * @returns {object}\n\t * @private\n\t */\n\tgetDrawShape() {\n\t\ttype TShape = {area?: any, bar?: any, line?: any};\n\n\t\tconst $$ = this;\n\t\tconst isRotated = $$.config.axis_rotated;\n\t\tconst {hasRadar, hasTreemap} = $$.state;\n\t\tconst shape = {type: <TShape>{}, indices: <TShape>{}, pos: {}};\n\n\t\t!hasTreemap && [\"bar\", \"candlestick\", \"line\", \"area\"].forEach(v => {\n\t\t\tconst name = capitalize(/^(bubble|scatter)$/.test(v) ? \"line\" : v);\n\n\t\t\tif (\n\t\t\t\t$$.hasType(v) || $$.hasTypeOf(name) || (\n\t\t\t\t\tv === \"line\" &&\n\t\t\t\t\t($$.hasType(\"bubble\") || $$.hasType(\"scatter\"))\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tconst indices = $$.getShapeIndices($$[`is${name}Type`]);\n\t\t\t\tconst drawFn = $$[`generateDraw${name}`];\n\n\t\t\t\tshape.indices[v] = indices;\n\t\t\t\tshape.type[v] = drawFn ? drawFn.bind($$)(indices, false) : undefined;\n\t\t\t}\n\t\t});\n\n\t\tif (!$$.hasArcType() || hasRadar || hasTreemap) {\n\t\t\tlet cx;\n\t\t\tlet cy;\n\n\t\t\t// generate circle x/y functions depending on updated params\n\t\t\tif (!hasTreemap) {\n\t\t\t\tcx = hasRadar ? $$.radarCircleX : (isRotated ? $$.circleY : $$.circleX);\n\t\t\t\tcy = hasRadar ? $$.radarCircleY : (isRotated ? $$.circleX : $$.circleY);\n\t\t\t}\n\n\t\t\tshape.pos = {\n\t\t\t\txForText: $$.generateXYForText(shape.indices, true),\n\t\t\t\tyForText: $$.generateXYForText(shape.indices, false),\n\t\t\t\tcx: (cx || function() {}).bind($$),\n\t\t\t\tcy: (cy || function() {}).bind($$)\n\t\t\t};\n\t\t}\n\n\t\treturn shape;\n\t},\n\n\t/**\n\t * Get shape's indices according it's position within each axis tick.\n\t *\n\t * From the below example, indices will be:\n\t * ==> {data1: 0, data2: 0, data3: 1, data4: 1, __max__: 1}\n\t *\n\t * \tdata1 data3   data1 data3\n\t * \tdata2 data4   data2 data4\n\t * \t-------------------------\n\t * \t\t 0             1\n\t * @param {Function} typeFilter Chart type filter function\n\t * @returns {object} Indices object with its position\n\t */\n\tgetShapeIndices(typeFilter): TIndices {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst xs = config.data_xs;\n\t\tconst hasXs = notEmpty(xs);\n\t\tconst indices: TIndices = {};\n\t\tlet i: any = hasXs ? {} : 0;\n\n\t\tif (hasXs) {\n\t\t\tgetUnique(Object.keys(xs).map(v => xs[v]))\n\t\t\t\t.forEach(v => {\n\t\t\t\t\ti[v] = 0;\n\t\t\t\t\tindices[v] = {};\n\t\t\t\t});\n\t\t}\n\n\t\t$$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))\n\t\t\t.forEach(d => {\n\t\t\t\tconst xKey = d.id in xs ? xs[d.id] : \"\";\n\t\t\t\tconst ind = xKey ? indices[xKey] : indices;\n\n\t\t\t\tfor (let j = 0, groups; (groups = config.data_groups[j]); j++) {\n\t\t\t\t\tif (groups.indexOf(d.id) < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let k = 0, key; (key = groups[k]); k++) {\n\t\t\t\t\t\tif (key in ind) {\n\t\t\t\t\t\t\tind[d.id] = ind[key];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for same grouped data, add other data to same indices\n\t\t\t\t\t\tif (d.id !== key && xKey) {\n\t\t\t\t\t\t\tind[key] = ind[d.id] ?? i[xKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isUndefined(ind[d.id])) {\n\t\t\t\t\tind[d.id] = xKey ? i[xKey]++ : i++;\n\t\t\t\t\tind.__max__ = (xKey ? i[xKey] : i) - 1;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn indices;\n\t},\n\n\t/**\n\t * Get indices value based on data ID value\n\t * @param {object} indices Indices object\n\t * @param {object} d Data row\n\t * @param {string} caller Caller function name (Used only for 'sparkline' plugin)\n\t * @returns {object} Indices object\n\t * @private\n\t */\n\tgetIndices(indices: TIndices, d: IDataRow, caller?: string): IDataIndice { // eslint-disable-line\n\t\tconst $$ = this;\n\t\tconst {data_xs: xs, bar_indices_removeNull: removeNull} = $$.config;\n\t\tconst {id, index} = d;\n\n\t\tif ($$.isBarType(id) && removeNull) {\n\t\t\tconst ind = {} as IDataIndice;\n\n\t\t\t// redefine bar indices order\n\t\t\t$$.getAllValuesOnIndex(index, true)\n\t\t\t\t.forEach((v, i) => {\n\t\t\t\t\tind[v.id] = i;\n\t\t\t\t\tind.__max__ = i;\n\t\t\t\t});\n\n\t\t\treturn ind;\n\t\t}\n\n\t\treturn notEmpty(xs) ? indices[xs[id]] : indices as IDataIndice;\n\t},\n\n\t/**\n\t * Get indices max number\n\t * @param {object} indices Indices object\n\t * @returns {number} Max number\n\t * @private\n\t */\n\tgetIndicesMax(indices: TIndices | IDataIndice): number {\n\t\treturn notEmpty(this.config.data_xs) ?\n\t\t\t// if is multiple xs, return total sum of xs' __max__ value\n\t\t\tObject.keys(indices)\n\t\t\t\t.map(v => indices[v].__max__ || 0)\n\t\t\t\t.reduce((acc, curr) => acc + curr) :\n\t\t\t(indices as IDataIndice).__max__;\n\t},\n\n\tgetShapeX(offset: IOffset, indices, isSub?: boolean): (d) => number {\n\t\tconst $$ = this;\n\t\tconst {config, scale} = $$;\n\t\tconst currScale = isSub ? scale.subX : (scale.zoom || scale.x);\n\t\tconst barOverlap = config.bar_overlap;\n\t\tconst barPadding = config.bar_padding;\n\t\tconst sum = (p, c) => p + c;\n\n\t\t// total shapes half width\n\t\tconst halfWidth = isObjectType(offset) && (\n\t\t\toffset._$total.length ? offset._$total.reduce(sum) / 2 : 0\n\t\t);\n\n\t\treturn d => {\n\t\t\tconst ind = $$.getIndices(indices, d, \"getShapeX\");\n\t\t\tconst index = d.id in ind ? ind[d.id] : 0;\n\t\t\tconst targetsNum = (ind.__max__ || 0) + 1;\n\t\t\tlet x = 0;\n\n\t\t\tif (notEmpty(d.x)) {\n\t\t\t\tconst xPos = currScale(d.x, true);\n\n\t\t\t\tif (halfWidth) {\n\t\t\t\t\tconst offsetWidth = offset[d.id] || offset._$width;\n\n\t\t\t\t\tx = barOverlap ? xPos - offsetWidth / 2 : xPos - offsetWidth +\n\t\t\t\t\t\toffset._$total.slice(0, index + 1).reduce(sum) -\n\t\t\t\t\t\thalfWidth;\n\t\t\t\t} else {\n\t\t\t\t\tx = xPos - (isNumber(offset) ? offset : offset._$width) *\n\t\t\t\t\t\t\t(targetsNum / 2 - (\n\t\t\t\t\t\t\t\tbarOverlap ? 1 : index\n\t\t\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// adjust x position for bar.padding option\n\t\t\tif (offset && x && targetsNum > 1 && barPadding) {\n\t\t\t\tif (index) {\n\t\t\t\t\tx += barPadding * index;\n\t\t\t\t}\n\n\t\t\t\tif (targetsNum > 2) {\n\t\t\t\t\tx -= (targetsNum - 1) * barPadding / 2;\n\t\t\t\t} else if (targetsNum === 2) {\n\t\t\t\t\tx -= barPadding / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn x;\n\t\t};\n\t},\n\n\tgetShapeY(isSub?: boolean): Function {\n\t\tconst $$ = this;\n\t\tconst isStackNormalized = $$.isStackNormalized();\n\n\t\treturn d => {\n\t\t\tlet {value} = d;\n\n\t\t\tif (isNumber(d)) {\n\t\t\t\tvalue = d;\n\t\t\t} else if ($$.isAreaRangeType(d)) {\n\t\t\t\tvalue = $$.getBaseValue(d, \"mid\");\n\t\t\t} else if (isStackNormalized) {\n\t\t\t\tvalue = $$.getRatio(\"index\", d, true);\n\t\t\t} else if ($$.isBubbleZType(d)) {\n\t\t\t\tvalue = $$.getBubbleZData(d.value, \"y\");\n\t\t\t} else if ($$.isBarRangeType(d)) {\n\t\t\t\t// TODO use range.getEnd() like method\n\t\t\t\tvalue = value[1];\n\t\t\t}\n\n\t\t\treturn $$.getYScaleById(d.id, isSub)(value);\n\t\t};\n\t},\n\n\t/**\n\t * Get shape based y Axis min value\n\t * @param {string} id Data id\n\t * @returns {number}\n\t * @private\n\t */\n\tgetShapeYMin(id: string): number {\n\t\tconst $$ = this;\n\t\tconst axisId = $$.axis.getId(id);\n\t\tconst scale = $$.scale[axisId];\n\t\tconst [yMin] = scale.domain();\n\t\tconst inverted = $$.config[`axis_${axisId}_inverted`];\n\n\t\treturn !$$.isGrouped(id) && !inverted && yMin > 0 ? yMin : 0;\n\t},\n\n\t/**\n\t * Get Shape's offset data\n\t * @param {Function} typeFilter Type filter function\n\t * @returns {object}\n\t * @private\n\t */\n\tgetShapeOffsetData(typeFilter) {\n\t\tconst $$ = this;\n\t\tconst targets = $$.orderTargets(\n\t\t\t$$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))\n\t\t);\n\t\tconst isStackNormalized = $$.isStackNormalized();\n\n\t\tconst shapeOffsetTargets = targets.map(target => {\n\t\t\tlet rowValues = target.values;\n\t\t\tconst values = {};\n\n\t\t\tif ($$.isStepType(target)) {\n\t\t\t\trowValues = $$.convertValuesToStep(rowValues);\n\t\t\t}\n\n\t\t\tconst rowValueMapByXValue = rowValues.reduce((out, d) => {\n\t\t\t\tconst key = Number(d.x);\n\n\t\t\t\tout[key] = d;\n\t\t\t\tvalues[key] = isStackNormalized ? $$.getRatio(\"index\", d, true) : d.value;\n\n\t\t\t\treturn out;\n\t\t\t}, {});\n\n\t\t\treturn {\n\t\t\t\tid: target.id,\n\t\t\t\trowValues,\n\t\t\t\trowValueMapByXValue,\n\t\t\t\tvalues\n\t\t\t};\n\t\t});\n\t\tconst indexMapByTargetId = targets.reduce((out, {id}, index) => {\n\t\t\tout[id] = index;\n\t\t\treturn out;\n\t\t}, {});\n\n\t\treturn {indexMapByTargetId, shapeOffsetTargets};\n\t},\n\n\tgetShapeOffset(typeFilter, indices, isSub?: boolean): Function {\n\t\tconst $$ = this;\n\t\tconst {shapeOffsetTargets, indexMapByTargetId} = $$.getShapeOffsetData(\n\t\t\ttypeFilter\n\t\t);\n\t\tconst groupsZeroAs = $$.config.data_groupsZeroAs;\n\n\t\treturn (d, idx) => {\n\t\t\tconst {id, value, x} = d;\n\t\t\tconst ind = $$.getIndices(indices, d);\n\t\t\tconst scale = $$.getYScaleById(id, isSub);\n\n\t\t\tif ($$.isBarRangeType(d)) {\n\t\t\t\t// TODO use range.getStart()\n\t\t\t\treturn scale(value[0]);\n\t\t\t}\n\n\t\t\tconst dataXAsNumber = Number(x);\n\t\t\tconst y0 = scale(groupsZeroAs === \"zero\" ? 0 : $$.getShapeYMin(id));\n\t\t\tlet offset = y0;\n\n\t\t\tshapeOffsetTargets\n\t\t\t\t.filter(t => t.id !== id && ind[t.id] === ind[id])\n\t\t\t\t.forEach(t => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tid: tid,\n\t\t\t\t\t\trowValueMapByXValue,\n\t\t\t\t\t\trowValues,\n\t\t\t\t\t\tvalues: tvalues\n\t\t\t\t\t} = t;\n\n\t\t\t\t\t// for same stacked group (ind[tid] === ind[id])\n\t\t\t\t\tif (indexMapByTargetId[tid] < indexMapByTargetId[id]) {\n\t\t\t\t\t\tconst rValue = tvalues[dataXAsNumber];\n\t\t\t\t\t\tlet row = rowValues[idx];\n\n\t\t\t\t\t\t// check if the x values line up\n\t\t\t\t\t\tif (!row || Number(row.x) !== dataXAsNumber) {\n\t\t\t\t\t\t\trow = rowValueMapByXValue[dataXAsNumber];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (row?.value * value >= 0 && isNumber(rValue)) {\n\t\t\t\t\t\t\tconst addOffset = value === 0 ?\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t(groupsZeroAs === \"positive\" &&\n\t\t\t\t\t\t\t\t\t\trValue > 0) ||\n\t\t\t\t\t\t\t\t\t(groupsZeroAs === \"negative\" && rValue < 0)\n\t\t\t\t\t\t\t\t) :\n\t\t\t\t\t\t\t\ttrue;\n\n\t\t\t\t\t\t\tif (addOffset) {\n\t\t\t\t\t\t\t\toffset += scale(rValue) - y0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\treturn offset;\n\t\t};\n\t},\n\n\t/**\n\t * Get data's y coordinate\n\t * @param {object} d Target data\n\t * @param {number} i Index number\n\t * @returns {number} y coordinate\n\t * @private\n\t */\n\tcircleY(d: IDataRow, i: number): number {\n\t\tconst $$ = this;\n\t\tconst id = d.id;\n\t\tlet points;\n\n\t\tif ($$.isGrouped(id)) {\n\t\t\tpoints = getGroupedDataPointsFn.bind($$)(d);\n\t\t}\n\n\t\treturn points ? points(d, i)[0][1] : $$.getYScaleById(id)($$.getBaseValue(d));\n\t},\n\n\tgetBarW(type, axis, targetsNum: number): number | IOffset {\n\t\tconst $$ = this;\n\t\tconst {config, org, scale, state} = $$;\n\t\tconst maxDataCount = $$.getMaxDataCount();\n\t\tconst isGrouped = type === \"bar\" && config.data_groups?.length;\n\t\tconst configName = `${type}_width`;\n\t\tconst {k} = $$.getZoomTransform?.() ?? {k: 1};\n\t\tconst xMinMax = <[number, number]>[\n\t\t\tconfig.axis_x_min ?? org.xDomain[0],\n\t\t\tconfig.axis_x_max ?? org.xDomain[1]\n\t\t].map($$.axis.isTimeSeries() ? parseDate.bind($$) : Number);\n\n\t\tlet tickInterval = axis.tickInterval(maxDataCount);\n\n\t\tif (scale.zoom && !$$.axis.isCategorized() && k > 1) {\n\t\t\tconst isSameMinMax = xMinMax.every((v, i) => v === org.xDomain[i]);\n\n\t\t\ttickInterval = org.xDomain.map((v, i) => {\n\t\t\t\tconst value = isSameMinMax ? v : v - Math.abs(xMinMax[i]);\n\n\t\t\t\treturn scale.zoom(value);\n\t\t\t}).reduce((a, c) => Math.abs(a) + c) / maxDataCount;\n\t\t}\n\n\t\tconst getWidth = (id?: string) => {\n\t\t\tconst width = id ? config[configName][id] : config[configName];\n\t\t\tconst ratio = id ? width.ratio : config[`${configName}_ratio`];\n\t\t\tconst max = id ? width.max : config[`${configName}_max`];\n\t\t\tconst w = isNumber(width) ? width : (\n\t\t\t\tisFunction(width) ?\n\t\t\t\t\twidth.call($$, state.width, targetsNum, maxDataCount) :\n\t\t\t\t\t(targetsNum ? (tickInterval * ratio) / targetsNum : 0)\n\t\t\t);\n\n\t\t\treturn max && w > max ? max : w;\n\t\t};\n\n\t\tlet result = getWidth();\n\n\t\tif (!isGrouped && isObjectType(config[configName])) {\n\t\t\tresult = {_$width: result, _$total: []};\n\n\t\t\t$$.filterTargetsToShow($$.data.targets).forEach(v => {\n\t\t\t\tif (config[configName][v.id]) {\n\t\t\t\t\tresult[v.id] = getWidth(v.id);\n\t\t\t\t\tresult._$total.push(result[v.id] || result._$width);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Get shape element\n\t * @param {string} shapeName Shape string\n\t * @param {number} i Index number\n\t * @param {string} id Data series id\n\t * @returns {d3Selection}\n\t * @private\n\t */\n\tgetShapeByIndex(shapeName: string, i: number, id?: string): d3Selection {\n\t\tconst $$ = this;\n\t\tconst {$el} = $$;\n\t\tconst suffix = isValue(i) ? `-${i}` : ``;\n\t\tlet shape = $el[shapeName];\n\n\t\t// filter from shape reference if has\n\t\tif (shape && !shape.empty()) {\n\t\t\tshape = shape\n\t\t\t\t.filter(d => (id ? d.id === id : true))\n\t\t\t\t.filter(d => (isValue(i) ? d.index === i : true));\n\t\t} else {\n\t\t\tshape = (id ?\n\t\t\t\t$el.main\n\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t`.${CLASS[`${shapeName}s`]}${$$.getTargetSelectorSuffix(id)}`\n\t\t\t\t\t) :\n\t\t\t\t$el.main)\n\t\t\t\t.selectAll(`.${CLASS[shapeName]}${suffix}`);\n\t\t}\n\n\t\treturn shape;\n\t},\n\n\tisWithinShape(that, d): boolean {\n\t\tconst $$ = this;\n\t\tconst shape = d3Select(that);\n\t\tlet isWithin;\n\n\t\tif (!$$.isTargetToShow(d.id)) {\n\t\t\tisWithin = false;\n\t\t} else if ($$.hasValidPointType?.(that.nodeName)) {\n\t\t\tisWithin = $$.isStepType(d) ?\n\t\t\t\t$$.isWithinStep(that, $$.getYScaleById(d.id)($$.getBaseValue(d))) :\n\t\t\t\t$$.isWithinCircle(\n\t\t\t\t\tthat,\n\t\t\t\t\t$$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0\n\t\t\t\t);\n\t\t} else if (that.nodeName === \"path\") {\n\t\t\tisWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;\n\t\t}\n\n\t\treturn isWithin;\n\t},\n\n\tgetInterpolate(d) {\n\t\tconst $$ = this;\n\t\tconst interpolation = $$.getInterpolateType(d);\n\n\t\treturn {\n\t\t\tbasis: d3CurveBasis,\n\t\t\t\"basis-closed\": d3CurveBasisClosed,\n\t\t\t\"basis-open\": d3CurveBasisOpen,\n\t\t\tbundle: d3CurveBundle,\n\t\t\tcardinal: d3CurveCardinal,\n\t\t\t\"cardinal-closed\": d3CurveCardinalClosed,\n\t\t\t\"cardinal-open\": d3CurveCardinalOpen,\n\t\t\t\"catmull-rom\": d3CurveCatmullRom,\n\t\t\t\"catmull-rom-closed\": d3CurveCatmullRomClosed,\n\t\t\t\"catmull-rom-open\": d3CurveCatmullRomOpen,\n\t\t\t\"monotone-x\": d3CurveMonotoneX,\n\t\t\t\"monotone-y\": d3CurveMonotoneY,\n\t\t\tnatural: d3CurveNatural,\n\t\t\t\"linear-closed\": d3CurveLinearClosed,\n\t\t\tlinear: d3CurveLinear,\n\t\t\tstep: d3CurveStep,\n\t\t\t\"step-after\": d3CurveStepAfter,\n\t\t\t\"step-before\": d3CurveStepBefore\n\t\t}[interpolation];\n\t},\n\n\tgetInterpolateType(d) {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst type = config.spline_interpolation_type;\n\t\tconst interpolation = $$.isInterpolationType(type) ? type : \"cardinal\";\n\n\t\treturn $$.isSplineType(d) ? interpolation : (\n\t\t\t$$.isStepType(d) ? config.line_step_type : \"linear\"\n\t\t);\n\t},\n\n\tisWithinBar(that): boolean {\n\t\tconst mouse = getPointer(this.state.event, that);\n\t\tconst list = getRectSegList(that);\n\t\tconst [seg0, seg1] = list;\n\t\tconst x = Math.min(seg0.x, seg1.x);\n\t\tconst y = Math.min(seg0.y, seg1.y);\n\t\tconst offset = this.config.bar_sensitivity;\n\t\tconst {width, height} = getBBox(that, true);\n\t\tconst sx = x - offset;\n\t\tconst ex = x + width + offset;\n\t\tconst sy = y + height + offset;\n\t\tconst ey = y - offset;\n\n\t\tconst isWithin = sx < mouse[0] &&\n\t\t\tmouse[0] < ex &&\n\t\t\tey < mouse[1] &&\n\t\t\tmouse[1] < sy;\n\n\t\treturn isWithin;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n * @ignore\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {\n\ttimeFormat as d3TimeFormat,\n\ttimeParse as d3TimeParse,\n\tutcFormat as d3UtcFormat,\n\tutcParse as d3UtcParse\n} from \"d3-time-format\";\nimport type {d3Selection, d3Transition} from \"../../types/types\";\nimport {$CIRCLE, $COMMON, $TEXT} from \"../config/classes\";\nimport Options from \"../config/Options/Options\";\nimport Store from \"../config/Store/Store\";\nimport {document, window} from \"../module/browser\";\nimport Cache from \"../module/Cache\";\nimport {checkModuleImport} from \"../module/error\";\nimport {generateResize} from \"../module/generator\";\nimport {\n\tcallFn,\n\tcapitalize,\n\tconvertInputType,\n\textend,\n\tgetOption,\n\tgetRandom,\n\thasStyle,\n\tisFunction,\n\tisObject,\n\tisString,\n\tnotEmpty,\n\tsortValue\n} from \"../module/util\";\n\n// data\nimport dataConvert from \"./data/convert\";\nimport data from \"./data/data\";\nimport dataLoad from \"./data/load\";\n\n// interactions\nimport interaction from \"./interactions/interaction\";\n\n// internals\nimport category from \"./internals/category\"; // used to retrieve radar Axis name\nimport classModule from \"./internals/class\";\nimport color from \"./internals/color\";\nimport domain from \"./internals/domain\";\nimport format from \"./internals/format\";\nimport legend from \"./internals/legend\";\nimport redraw from \"./internals/redraw\";\nimport scale from \"./internals/scale\";\nimport size from \"./internals/size\";\nimport style from \"./internals/style\";\nimport text from \"./internals/text\";\nimport title from \"./internals/title\";\nimport tooltip from \"./internals/tooltip\";\nimport transform from \"./internals/transform\";\nimport typeInternals from \"./internals/type\";\nimport shape from \"./shape/shape\";\n\n/**\n * Internal chart class.\n * - Note: Instantiated internally, not exposed for public.\n * @class ChartInternal\n * @ignore\n * @private\n */\nexport default class ChartInternal {\n\tpublic api; // API interface\n\tpublic config; // config object\n\tpublic cache; // cache instance\n\tpublic $el; // elements\n\tpublic state; // state variables\n\tpublic charts; // all Chart instances array within page (equivalent of 'bb.instances')\n\n\t// data object\n\tpublic data = {\n\t\txs: {},\n\t\ttargets: []\n\t};\n\n\t// Axis\n\tpublic axis; // Axis\n\n\t// scales\n\tpublic scale = {\n\t\tx: null,\n\t\ty: null,\n\t\ty2: null,\n\t\tsubX: null,\n\t\tsubY: null,\n\t\tsubY2: null,\n\t\tzoom: null\n\t};\n\n\t// original values\n\tpublic org = {\n\t\txScale: null,\n\t\txDomain: null\n\t};\n\n\t// formatter function\n\tpublic color;\n\tpublic patterns;\n\tpublic levelColor;\n\tpublic point;\n\tpublic brush;\n\n\t// format function\n\tpublic format = {\n\t\textraLineClasses: null,\n\t\txAxisTick: null,\n\t\tdataTime: null, // dataTimeFormat\n\t\tdefaultAxisTime: null, // defaultAxisTimeFormat\n\t\taxisTime: null // axisTimeFormat\n\t};\n\n\tconstructor(api) {\n\t\tconst $$ = this;\n\n\t\t$$.api = api; // Chart class instance alias\n\t\t$$.config = new Options();\n\t\t$$.cache = new Cache();\n\n\t\tconst store = new Store();\n\n\t\t$$.$el = store.getStore(\"element\");\n\t\t$$.state = store.getStore(\"state\");\n\n\t\t$$.$T = $$.$T.bind($$);\n\t}\n\n\t/**\n\t * Get the selection based on transition config\n\t * @param {SVGElement|d3Selection} selection Target selection\n\t * @param {boolean} force Force transition\n\t * @param {string} name Transition name\n\t * @returns {d3Selection}\n\t * @private\n\t */\n\t$T(selection: SVGElement | d3Selection | d3Transition, force?: boolean,\n\t\tname?: string): d3Selection {\n\t\tconst {config, state} = this;\n\t\tconst duration = config.transition_duration;\n\t\tconst subchart = config.subchart_show;\n\t\tlet t = selection;\n\n\t\tif (t) {\n\t\t\t// in case of non d3 selection, wrap with d3 selection\n\t\t\tif (\"tagName\" in t) {\n\t\t\t\tt = d3Select(t);\n\t\t\t}\n\n\t\t\t// do not transit on:\n\t\t\t// - wheel zoom (state.zooming = true)\n\t\t\t// - when has no subchart\n\t\t\t// - initialization\n\t\t\t// - resizing\n\t\t\tconst transit = ((force !== false && duration) || force) &&\n\t\t\t\t(!state.zooming || state.dragging) &&\n\t\t\t\t!state.resizing &&\n\t\t\t\tstate.rendered &&\n\t\t\t\t!subchart;\n\n\t\t\t// @ts-ignore\n\t\t\tt = (transit ? t.transition(name).duration(duration) : t) as d3Selection;\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tbeforeInit(): void {\n\t\tconst $$ = this;\n\n\t\t$$.callPluginHook(\"$beforeInit\");\n\n\t\t// can do something\n\t\tcallFn($$.config.onbeforeinit, $$.api);\n\t}\n\n\tafterInit(): void {\n\t\tconst $$ = this;\n\n\t\t$$.callPluginHook(\"$afterInit\");\n\n\t\t// can do something\n\t\tcallFn($$.config.onafterinit, $$.api);\n\t}\n\n\tinit(): void {\n\t\tconst $$ = <any>this;\n\t\tconst {config, state, $el} = $$;\n\t\tconst {boost_useCssRule, bindto} = config;\n\n\t\tcheckModuleImport($$);\n\n\t\tconst hasArcType = $$.hasArcType();\n\t\tstate.hasRadar = !state.hasAxis && $$.hasType(\"radar\");\n\t\tstate.hasFunnel = !state.hasAxis && $$.hasType(\"funnel\");\n\t\tstate.hasTreemap = !state.hasAxis && $$.hasType(\"treemap\");\n\t\tstate.hasAxis = !hasArcType && !state.hasFunnel && !state.hasTreemap;\n\n\t\t// datetime to be used for uniqueness\n\t\tstate.datetimeId = `bb-${+new Date() * (getRandom() as number)}`;\n\n\t\tif (boost_useCssRule) {\n\t\t\t// append style element\n\t\t\tconst styleEl = document.createElement(\"style\");\n\n\t\t\t// styleEl.id = styleId;\n\t\t\tstyleEl.type = \"text/css\";\n\t\t\tdocument.head.appendChild(styleEl);\n\n\t\t\tstate.style = {\n\t\t\t\trootSelctor: `.${state.datetimeId}`,\n\t\t\t\tsheet: styleEl.sheet\n\t\t\t};\n\n\t\t\t// used on .destroy()\n\t\t\t$el.style = styleEl;\n\t\t}\n\n\t\tconst bindConfig = {\n\t\t\telement: bindto,\n\t\t\tclassname: \"bb\"\n\t\t};\n\n\t\tif (isObject(bindto)) {\n\t\t\tbindConfig.element = bindto.element || \"#chart\";\n\t\t\tbindConfig.classname = bindto.classname || bindConfig.classname;\n\t\t}\n\n\t\t// select bind element\n\t\t$el.chart = isFunction(bindConfig.element.node) ?\n\t\t\tbindto.element :\n\t\t\td3Select(bindConfig.element || []);\n\n\t\tif ($el.chart.empty()) {\n\t\t\t$el.chart = d3Select(document.body.appendChild(document.createElement(\"div\")));\n\t\t}\n\n\t\t$el.chart.html(\"\")\n\t\t\t.classed(bindConfig.classname, true)\n\t\t\t.classed(state.datetimeId, boost_useCssRule)\n\t\t\t.style(\"position\", \"relative\");\n\n\t\t$$.initParams();\n\t\t$$.initToRender();\n\t}\n\n\t/**\n\t * Initialize the rendering process\n\t * @param {boolean} forced Force to render process\n\t * @private\n\t */\n\tinitToRender(forced?: boolean): void {\n\t\tconst $$ = <any>this;\n\t\tconst {config, state, $el: {chart}} = $$;\n\t\tconst isHidden = () => hasStyle(chart, {display: \"none\", visibility: \"hidden\"});\n\n\t\tconst isLazy = config.render.lazy === false ? false : config.render.lazy || isHidden();\n\t\tconst MutationObserver = window.MutationObserver;\n\n\t\tif (isLazy && MutationObserver && config.render.observe !== false && !forced) {\n\t\t\tnew MutationObserver((mutation, observer) => {\n\t\t\t\tif (!isHidden()) {\n\t\t\t\t\tobserver.disconnect();\n\t\t\t\t\t!state.rendered && $$.initToRender(true);\n\t\t\t\t}\n\t\t\t}).observe(chart.node(), {\n\t\t\t\tattributes: true,\n\t\t\t\tattributeFilter: [\"class\", \"style\"]\n\t\t\t});\n\t\t}\n\n\t\tif (!isLazy || forced) {\n\t\t\t$$.convertData(config, res => {\n\t\t\t\t$$.initWithData(res);\n\t\t\t\t$$.afterInit();\n\t\t\t});\n\t\t}\n\t}\n\n\tinitParams(): void {\n\t\tconst $$ = <any>this;\n\t\tconst {config, format, state} = $$;\n\n\t\t// color settings\n\t\t$$.color = $$.generateColor();\n\t\t$$.levelColor = $$.generateLevelColor();\n\n\t\t// when 'padding=false' is set, disable axes and subchart. Because they are useless.\n\t\tif (config.padding === false) {\n\t\t\tconfig.axis_x_show = false;\n\t\t\tconfig.axis_y_show = false;\n\t\t\tconfig.axis_y2_show = false;\n\t\t\tconfig.subchart_show = false;\n\t\t}\n\n\t\tif ($$.hasPointType() || $$.hasLegendDefsPoint?.()) {\n\t\t\t$$.point = $$.generatePoint();\n\t\t}\n\n\t\tif (state.hasAxis) {\n\t\t\t$$.initClip();\n\n\t\t\tformat.extraLineClasses = $$.generateExtraLineClass();\n\t\t\tformat.dataTime = config.data_xLocaltime ? d3TimeParse : d3UtcParse;\n\t\t\tformat.axisTime = config.axis_x_localtime ? d3TimeFormat : d3UtcFormat;\n\n\t\t\tconst isDragZoom = config.zoom_enabled && config.zoom_type === \"drag\";\n\n\t\t\tformat.defaultAxisTime = d => {\n\t\t\t\tconst {x, zoom} = $$.scale;\n\t\t\t\tconst isZoomed = isDragZoom ?\n\t\t\t\t\tzoom :\n\t\t\t\t\tzoom && x.orgDomain().toString() !== zoom.domain().toString();\n\n\t\t\t\tconst specifier: string = (d.getMilliseconds() && \".%L\") ||\n\t\t\t\t\t(d.getSeconds() && \".:%S\") ||\n\t\t\t\t\t(d.getMinutes() && \"%I:%M\") ||\n\t\t\t\t\t(d.getHours() && \"%I %p\") ||\n\t\t\t\t\t(d.getDate() !== 1 && \"%b %d\") ||\n\t\t\t\t\t(isZoomed && d.getDate() === 1 && \"%b'%y\") ||\n\t\t\t\t\t(d.getMonth() && \"%-m/%-d\") || \"%Y\";\n\n\t\t\t\treturn format.axisTime(specifier)(d);\n\t\t\t};\n\t\t}\n\n\t\tconst {legend_position, legend_inset_anchor, axis_rotated} = config;\n\n\t\tstate.isLegendRight = legend_position === \"right\";\n\t\tstate.isLegendInset = legend_position === \"inset\";\n\t\tstate.isLegendTop = legend_inset_anchor === \"top-left\" ||\n\t\t\tlegend_inset_anchor === \"top-right\";\n\t\tstate.isLegendLeft = legend_inset_anchor === \"top-left\" ||\n\t\t\tlegend_inset_anchor === \"bottom-left\";\n\n\t\tstate.rotatedPadding.top = $$.getResettedPadding(state.rotatedPadding.top);\n\t\tstate.rotatedPadding.right = axis_rotated && !config.axis_x_show ? 0 : 30;\n\n\t\tstate.inputType = convertInputType(\n\t\t\tconfig.interaction_inputType_mouse,\n\t\t\tconfig.interaction_inputType_touch\n\t\t);\n\t}\n\n\tinitWithData(data): void {\n\t\tconst $$ = <any>this;\n\t\tconst {config, scale, state, $el, org} = $$;\n\t\tconst {hasAxis, hasFunnel, hasTreemap} = state;\n\t\tconst hasInteraction = config.interaction_enabled;\n\t\tconst hasPolar = $$.hasType(\"polar\");\n\t\tconst labelsBGColor = config.data_labels_backgroundColors;\n\n\t\t// for arc type, set axes to not be shown\n\t\t// $$.hasArcType() && [\"x\", \"y\", \"y2\"].forEach(id => (config[`axis_${id}_show`] = false));\n\n\t\tif (hasAxis) {\n\t\t\t$$.axis = $$.getAxisInstance();\n\t\t\tconfig.zoom_enabled && $$.initZoom();\n\t\t}\n\n\t\t// Init data as targets\n\t\t$$.data.xs = {};\n\t\t$$.data.targets = $$.convertDataToTargets(data);\n\n\t\tif (config.data_filter) {\n\t\t\t$$.data.targets = $$.data.targets.filter(config.data_filter.bind($$.api));\n\t\t}\n\n\t\t// Set targets to hide if needed\n\t\tif (config.data_hide) {\n\t\t\t$$.addHiddenTargetIds(\n\t\t\t\tconfig.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide\n\t\t\t);\n\t\t}\n\n\t\tif (config.legend_hide) {\n\t\t\t$$.addHiddenLegendIds(\n\t\t\t\tconfig.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide\n\t\t\t);\n\t\t}\n\n\t\t// Init sizes and scales\n\t\t$$.updateSizes();\n\t\t$$.updateScales(true);\n\n\t\t// retrieve scale after the 'updateScales()' is called\n\t\tif (hasAxis) {\n\t\t\tconst {x, y, y2, subX, subY, subY2} = scale;\n\n\t\t\t// Set domains for each scale\n\t\t\tif (x) {\n\t\t\t\tx.domain(sortValue($$.getXDomain($$.data.targets), !config.axis_x_inverted));\n\t\t\t\tsubX.domain(x.domain());\n\n\t\t\t\t// Save original x domain for zoom update\n\t\t\t\torg.xDomain = x.domain();\n\t\t\t}\n\n\t\t\tif (y) {\n\t\t\t\ty.domain($$.getYDomain($$.data.targets, \"y\"));\n\t\t\t\tsubY.domain(y.domain());\n\t\t\t}\n\n\t\t\tif (y2) {\n\t\t\t\ty2.domain($$.getYDomain($$.data.targets, \"y2\"));\n\t\t\t\tsubY2 && subY2.domain(y2.domain());\n\t\t\t}\n\t\t}\n\n\t\t// -- Basic Elements --\n\t\t$el.svg = $el.chart.append(\"svg\")\n\t\t\t.style(\"overflow\", \"hidden\")\n\t\t\t.style(\"display\", \"block\");\n\n\t\tif (hasInteraction && state.inputType) {\n\t\t\tconst isTouch = state.inputType === \"touch\";\n\t\t\tconst {onclick, onover, onout} = config;\n\n\t\t\t$el.svg\n\t\t\t\t.on(\"click\", onclick?.bind($$.api) || null)\n\t\t\t\t.on(isTouch ? \"touchstart\" : \"mouseenter\", onover?.bind($$.api) || null)\n\t\t\t\t.on(isTouch ? \"touchend\" : \"mouseleave\", onout?.bind($$.api) || null);\n\t\t}\n\n\t\tconfig.svg_classname && $el.svg.attr(\"class\", config.svg_classname);\n\n\t\t// Define defs\n\t\tconst hasColorPatterns = isFunction(config.color_tiles) && $$.patterns;\n\n\t\tif (\n\t\t\thasAxis || hasColorPatterns || hasPolar || hasTreemap ||\n\t\t\tlabelsBGColor || $$.hasLegendDefsPoint?.()\n\t\t) {\n\t\t\t$el.defs = $el.svg.append(\"defs\");\n\n\t\t\tif (hasAxis) {\n\t\t\t\t[\"id\", \"idXAxis\", \"idYAxis\", \"idGrid\"].forEach(v => {\n\t\t\t\t\t$$.appendClip($el.defs, state.clip[v]);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Append data background color filter definition\n\t\t\t$$.generateTextBGColorFilter(labelsBGColor);\n\n\t\t\t// set color patterns\n\t\t\tif (hasColorPatterns) {\n\t\t\t\t$$.patterns.forEach(p => $el.defs.append(() => p.node));\n\t\t\t}\n\t\t}\n\n\t\t$$.updateSvgSize();\n\n\t\t// Bind resize event\n\t\t$$.bindResize();\n\n\t\t// Define regions\n\t\tconst main = $el.svg.append(\"g\")\n\t\t\t.classed($COMMON.main, true)\n\t\t\t.attr(\"transform\", hasFunnel || hasTreemap ? null : $$.getTranslate(\"main\"));\n\n\t\t$el.main = main;\n\n\t\t// initialize subchart when subchart show option is set\n\t\tconfig.subchart_show && $$.initSubchart();\n\n\t\tconfig.tooltip_show && $$.initTooltip();\n\n\t\tconfig.title_text && $$.initTitle();\n\t\t!hasTreemap && config.legend_show && $$.initLegend();\n\n\t\t// -- Main Region --\n\n\t\t// text when empty\n\t\tif (config.data_empty_label_text) {\n\t\t\tmain.append(\"text\")\n\t\t\t\t.attr(\"class\", `${$TEXT.text} ${$COMMON.empty}`)\n\t\t\t\t.attr(\"text-anchor\", \"middle\") // horizontal centering of text at x position in all browsers.\n\t\t\t\t.attr(\"dominant-baseline\", \"middle\"); // vertical centering of text at y position in all browsers, except IE.\n\t\t}\n\n\t\tif (hasAxis) {\n\t\t\t// Regions\n\t\t\tconfig.regions.length && $$.initRegion();\n\n\t\t\t// Add Axis here, when clipPath is 'false'\n\t\t\t!config.clipPath && $$.axis.init();\n\t\t}\n\n\t\t// Define g for chart area\n\t\tmain.append(\"g\")\n\t\t\t.classed($COMMON.chart, true)\n\t\t\t.attr(\"clip-path\", hasAxis ? state.clip.path : null);\n\n\t\t$$.callPluginHook(\"$init\");\n\n\t\t$$.initChartElements();\n\n\t\tif (hasAxis) {\n\t\t\t// Cover whole with rects for events\n\t\t\thasInteraction && $$.initEventRect?.();\n\n\t\t\t// Grids\n\t\t\t$$.initGrid();\n\n\t\t\t// Add Axis here, when clipPath is 'true'\n\t\t\tconfig.clipPath && $$.axis?.init();\n\t\t}\n\n\t\t// Set targets\n\t\t$$.updateTargets($$.data.targets);\n\n\t\t// Draw with targets\n\t\t$$.updateDimension();\n\n\t\t// oninit callback\n\t\tcallFn(config.oninit, $$.api);\n\n\t\t// Set background\n\t\t$$.setBackground();\n\n\t\t$$.redraw({\n\t\t\twithTransition: false,\n\t\t\twithTransform: true,\n\t\t\twithUpdateXDomain: true,\n\t\t\twithUpdateOrgXDomain: true,\n\t\t\twithTransitionForAxis: false,\n\t\t\tinitializing: true\n\t\t});\n\n\t\t// data.onmin/max callback\n\t\tif (config.data_onmin || config.data_onmax) {\n\t\t\tconst minMax = $$.getMinMaxData();\n\n\t\t\tcallFn(config.data_onmin, $$.api, minMax.min);\n\t\t\tcallFn(config.data_onmax, $$.api, minMax.max);\n\t\t}\n\n\t\tconfig.tooltip_show && $$.initShowTooltip();\n\t\tstate.rendered = true;\n\t}\n\n\t/**\n\t * Initialize chart elements\n\t * @private\n\t */\n\tinitChartElements(): void {\n\t\tconst $$ = <any>this;\n\t\tconst {hasAxis, hasRadar, hasTreemap} = $$.state;\n\t\tconst types: string[] = [];\n\n\t\tif (hasAxis) {\n\t\t\tconst shapes = [\"bar\", \"bubble\", \"candlestick\", \"line\"];\n\n\t\t\tif ($$.config.bar_front) {\n\t\t\t\tshapes.push(shapes.shift() as string);\n\t\t\t}\n\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst name = capitalize(shape);\n\t\t\t\tif ((shape === \"line\" && $$.hasTypeOf(name)) || $$.hasType(shape)) {\n\t\t\t\t\ttypes.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hasTreemap) {\n\t\t\ttypes.push(\"Treemap\");\n\t\t} else if ($$.hasType(\"funnel\")) {\n\t\t\ttypes.push(\"Funnel\");\n\t\t} else {\n\t\t\tconst hasPolar = $$.hasType(\"polar\");\n\t\t\tconst hasGauge = $$.hasType(\"gauge\");\n\n\t\t\tif (!hasRadar) {\n\t\t\t\ttypes.push(\"Arc\", \"Pie\");\n\t\t\t}\n\n\t\t\tif (hasGauge) {\n\t\t\t\ttypes.push(\"Gauge\");\n\t\t\t} else if (hasRadar) {\n\t\t\t\ttypes.push(\"Radar\");\n\t\t\t} else if (hasPolar) {\n\t\t\t\ttypes.push(\"Polar\");\n\t\t\t}\n\t\t}\n\n\t\tfor (const type of types) {\n\t\t\t$$[`init${type}`]();\n\t\t}\n\n\t\tif (notEmpty($$.config.data_labels) && !$$.hasArcType(null, [\"radar\"])) {\n\t\t\t$$.initText();\n\t\t}\n\t}\n\n\t/**\n\t * Set chart elements\n\t * @private\n\t */\n\tsetChartElements(): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\t$el: {\n\t\t\t\tchart,\n\t\t\t\tsvg,\n\t\t\t\tdefs,\n\t\t\t\tmain,\n\t\t\t\ttooltip,\n\t\t\t\tlegend,\n\t\t\t\ttitle,\n\t\t\t\tgrid,\n\t\t\t\tneedle,\n\t\t\t\tarcs: arc,\n\t\t\t\tcircle: circles,\n\t\t\t\tbar: bars,\n\t\t\t\tcandlestick,\n\t\t\t\tline: lines,\n\t\t\t\tarea: areas,\n\t\t\t\ttext: texts\n\t\t\t}\n\t\t} = $$;\n\n\t\t// public\n\t\t$$.api.$ = {\n\t\t\tchart,\n\t\t\tsvg,\n\t\t\tdefs,\n\t\t\tmain,\n\t\t\ttooltip,\n\t\t\tlegend,\n\t\t\ttitle,\n\t\t\tgrid,\n\t\t\tarc,\n\t\t\tcircles,\n\t\t\tbar: {bars},\n\t\t\tcandlestick,\n\t\t\tline: {lines, areas},\n\t\t\tneedle,\n\t\t\ttext: {texts}\n\t\t};\n\t}\n\n\t/**\n\t * Set background element/image\n\t * @private\n\t */\n\tsetBackground(): void {\n\t\tconst $$ = this;\n\t\tconst {config: {background: bg}, state, $el: {svg}} = $$;\n\n\t\tif (notEmpty(bg)) {\n\t\t\tconst element = svg.select(\"g\")\n\t\t\t\t.insert(bg.imgUrl ? \"image\" : \"rect\", \":first-child\");\n\n\t\t\tif (bg.imgUrl) {\n\t\t\t\telement.attr(\"href\", bg.imgUrl);\n\t\t\t} else if (bg.color) {\n\t\t\t\telement\n\t\t\t\t\t.style(\"fill\", bg.color)\n\t\t\t\t\t.attr(\"clip-path\", state.clip.path);\n\t\t\t}\n\n\t\t\telement\n\t\t\t\t.attr(\"class\", bg.class || null)\n\t\t\t\t.attr(\"width\", \"100%\")\n\t\t\t\t.attr(\"height\", \"100%\");\n\t\t}\n\t}\n\n\t/**\n\t * Update targeted element with given data\n\t * @param {object} targets Data object formatted as 'target'\n\t * @private\n\t */\n\tupdateTargets(targets): void {\n\t\tconst $$ = <any>this;\n\t\tconst {hasAxis, hasFunnel, hasRadar, hasTreemap} = $$.state;\n\t\tconst helper = type =>\n\t\t\t$$[`updateTargetsFor${type}`](\n\t\t\t\ttargets.filter($$[`is${type}Type`].bind($$))\n\t\t\t);\n\n\t\t// Text\n\t\t$$.updateTargetsForText(targets);\n\n\t\tif (hasAxis) {\n\t\t\tconst shapes = [\"bar\", \"candlestick\", \"line\"];\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst name = capitalize(shape);\n\t\t\t\tif ((shape === \"line\" && $$.hasTypeOf(name)) || $$.hasType(shape)) {\n\t\t\t\t\thelper(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sub Chart\n\t\t\t$$.updateTargetsForSubchart?.(targets);\n\n\t\t\t// Arc, Polar, Radar\n\t\t} else if ($$.hasArcType(targets)) {\n\t\t\tlet type = \"Arc\";\n\n\t\t\tif (hasRadar) {\n\t\t\t\ttype = \"Radar\";\n\t\t\t} else if ($$.hasType(\"polar\")) {\n\t\t\t\ttype = \"Polar\";\n\t\t\t}\n\n\t\t\thelper(type);\n\t\t} else if (hasFunnel) {\n\t\t\thelper(\"Funnel\");\n\t\t} else if (hasTreemap) {\n\t\t\thelper(\"Treemap\");\n\t\t}\n\n\t\t// Point types\n\t\tconst hasPointType = $$.hasType(\"bubble\") || $$.hasType(\"scatter\");\n\n\t\tif (hasPointType) {\n\t\t\t$$.updateTargetForCircle?.();\n\t\t}\n\n\t\t// Fade-in each chart\n\t\t$$.filterTargetsToShowAtInit(hasPointType);\n\t}\n\n\t/**\n\t * Display targeted elements at initialization\n\t * @param {boolean} hasPointType whether has point type(bubble, scatter) or not\n\t * @private\n\t */\n\tfilterTargetsToShowAtInit(hasPointType: boolean = false): void {\n\t\tconst $$ = <any>this;\n\t\tconst {$el: {svg}, $T} = $$;\n\t\tlet selector = `.${$COMMON.target}`;\n\n\t\tif (hasPointType) {\n\t\t\tselector += `, .${$CIRCLE.chartCircles} > .${$CIRCLE.circles}`;\n\t\t}\n\n\t\t$T(svg.selectAll(selector)\n\t\t\t.filter(d => $$.isTargetToShow(d.id))).style(\"opacity\", null);\n\t}\n\n\tgetWithOption(options) {\n\t\tconst withOptions = {\n\t\t\tDimension: true,\n\t\t\tEventRect: true,\n\t\t\tLegend: false,\n\t\t\tSubchart: true,\n\t\t\tTransform: false,\n\t\t\tTransition: true,\n\t\t\tTrimXDomain: true,\n\t\t\tUpdateXAxis: \"UpdateXDomain\",\n\t\t\tUpdateXDomain: false,\n\t\t\tUpdateOrgXDomain: false,\n\t\t\tTransitionForExit: \"Transition\",\n\t\t\tTransitionForAxis: \"Transition\",\n\t\t\tY: true\n\t\t};\n\n\t\tfor (const [key, defVal] of Object.entries(withOptions)) {\n\t\t\tconst value = isString(defVal) ? withOptions[defVal] : defVal;\n\t\t\twithOptions[key] = getOption(options, `with${key}`, value);\n\t\t}\n\n\t\treturn withOptions;\n\t}\n\n\tinitialOpacity(d): null | \"0\" {\n\t\tconst $$ = <any>this;\n\t\tconst {withoutFadeIn} = $$.state;\n\n\t\treturn $$.getBaseValue(d) !== null && withoutFadeIn[d.id] ? null : \"0\";\n\t}\n\n\tbindResize(): void {\n\t\tconst $$ = <any>this;\n\t\tconst {$el, config, state} = $$;\n\t\tconst resizeFunction = generateResize(config.resize_timer);\n\t\tconst {resize_auto} = config;\n\t\tconst list: (() => void)[] = [];\n\n\t\tlist.push(() => callFn(config.onresize, $$.api));\n\n\t\tif (/^(true|parent)$/.test(resize_auto)) {\n\t\t\tlist.push(() => {\n\t\t\t\tstate.resizing = true;\n\n\t\t\t\t// https://github.com/naver/billboard.js/issues/2650\n\t\t\t\tif (config.legend_show) {\n\t\t\t\t\t$$.updateSizes();\n\t\t\t\t\t$$.updateLegend();\n\t\t\t\t}\n\n\t\t\t\t$$.api.flush(false);\n\t\t\t});\n\t\t}\n\n\t\tlist.push(() => {\n\t\t\tcallFn(config.onresized, $$.api);\n\t\t\tstate.resizing = false;\n\t\t});\n\n\t\t// add resize functions\n\t\tlist.forEach(v => resizeFunction.add(v));\n\t\t$$.resizeFunction = resizeFunction;\n\n\t\t// attach resize event\n\t\tif (resize_auto === \"parent\") {\n\t\t\t($$.resizeFunction.resizeObserver = new ResizeObserver($$.resizeFunction.bind($$)))\n\t\t\t\t.observe($el.chart.node().parentNode);\n\t\t} else {\n\t\t\twindow.addEventListener(\"resize\", $$.resizeFunction);\n\t\t}\n\t}\n\n\t/**\n\t * Call plugin hook\n\t * @param {string} phase The lifecycle phase\n\t * @param {Array} args Arguments\n\t * @private\n\t */\n\tcallPluginHook(phase, ...args): void {\n\t\tthis.config.plugins.forEach(v => {\n\t\t\tif (phase === \"$beforeInit\") {\n\t\t\t\tv.$$ = this;\n\t\t\t\tthis.api.plugins.push(v);\n\t\t\t}\n\n\t\t\tv[phase](...args);\n\t\t});\n\t}\n}\n\nextend(ChartInternal.prototype, [\n\t// common\n\tdataConvert,\n\tdata,\n\tdataLoad,\n\tcategory,\n\tclassModule,\n\tcolor,\n\tdomain,\n\tinteraction,\n\tformat,\n\tlegend,\n\tredraw,\n\tscale,\n\tshape,\n\tsize,\n\tstyle,\n\ttext,\n\ttitle,\n\ttooltip,\n\ttransform,\n\ttypeInternals\n]);\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {ChartOptions} from \"../../types/options\";\nimport {isDefined, isObjectType} from \"../module/util\";\nimport Options from \"./Options/Options\";\n\n/**\n * Load configuration option\n * @param {object} config User's generation config value\n * @private\n */\nexport function loadConfig(config: ChartOptions): void {\n\tconst thisConfig: Options = this.config;\n\tlet target;\n\tlet keys;\n\tlet read;\n\n\tconst find = () => {\n\t\tconst key = keys.shift();\n\n\t\tif (key && target && isObjectType(target) && key in target) {\n\t\t\ttarget = target[key];\n\t\t\treturn find();\n\t\t} else if (!key) {\n\t\t\treturn target;\n\t\t}\n\n\t\treturn undefined;\n\t};\n\n\tObject.keys(thisConfig).forEach(key => {\n\t\ttarget = config;\n\t\tkeys = key.split(\"_\");\n\t\tread = find();\n\n\t\tif (isDefined(read)) {\n\t\t\tthisConfig[key] = read;\n\t\t}\n\t});\n\n\t// only should run in the ChartInternal context\n\tif (this.api) {\n\t\tthis.state.orgConfig = config;\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {window} from \"../../module/browser\";\nimport {isDefined, isEmpty, notEmpty} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Resize the chart.\n\t * @function resize\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} size This argument should include width and height in pixels.\n\t * @param {number} [size.width] width value\n\t * @param {number} [size.height] height value\n\t * @example\n\t * // Resize to 640x480\n\t * chart.resize({\n\t *    width: 640,\n\t *    height: 480\n\t * });\n\t */\n\tresize(size?: {width?: number, height?: number}): void {\n\t\tconst $$ = this.internal;\n\t\tconst {config, state} = $$;\n\n\t\tif (state.rendered) {\n\t\t\tconfig.size_width = size ? size.width : null;\n\t\t\tconfig.size_height = size ? size.height : null;\n\n\t\t\tstate.resizing = true;\n\n\t\t\tthis.flush(false);\n\t\t\t$$.resizeFunction();\n\t\t}\n\t},\n\n\t/**\n\t * Force to redraw.\n\t * - **NOTE:** When zoom/subchart is used, the zoomed state will be resetted.\n\t * @function flush\n\t * @instance\n\t * @memberof Chart\n\t * @param {boolean} [soft] For soft redraw.\n\t * @example\n\t * chart.flush();\n\t *\n\t * // for soft redraw\n\t * chart.flush(true);\n\t */\n\tflush(soft?: boolean): void {\n\t\tconst $$ = this.internal;\n\t\tconst {state, $el: {zoomResetBtn}} = $$;\n\n\t\tif (state.rendered) {\n\t\t\t// reset possible zoom scale when is called from resize event\n\t\t\tif (state.resizing) { // arguments[1] is given when is called from resize\n\t\t\t\t$$.brush?.updateResize();\n\t\t\t} else {\n\t\t\t\t// re-update config info\n\t\t\t\t$$.axis?.setOrient();\n\t\t\t}\n\n\t\t\t// hide possible reset zoom button\n\t\t\t// https://github.com/naver/billboard.js/issues/2201\n\t\t\tzoomResetBtn?.style(\"display\", \"none\");\n\n\t\t\t// keep current zoom domain\n\t\t\tif ($$.scale.zoom) {\n\t\t\t\tstate.current.zoomDomain = $$.scale.zoom.domain();\n\t\t\t}\n\n\t\t\t$$.scale.zoom = null;\n\n\t\t\tsoft ?\n\t\t\t\t$$.redraw({\n\t\t\t\t\twithTransform: true,\n\t\t\t\t\twithUpdateXDomain: true,\n\t\t\t\t\twithUpdateOrgXDomain: true,\n\t\t\t\t\twithLegend: true\n\t\t\t\t}) :\n\t\t\t\t$$.updateAndRedraw({\n\t\t\t\t\twithLegend: true,\n\t\t\t\t\twithTransition: false,\n\t\t\t\t\twithTransitionForTransform: false\n\t\t\t\t});\n\n\t\t\t// reset subchart selection & selection state\n\t\t\tif (!state.resizing && $$.brush) {\n\t\t\t\t$$.brush.getSelection().call($$.brush.move);\n\t\t\t\t$$.unselectRect();\n\t\t\t}\n\n\t\t\t// restore zoom domain\n\t\t\tif (state.current.zoomDomain) {\n\t\t\t\t$$.api.zoom(state.current.zoomDomain);\n\t\t\t\tstate.current.zoomDomain = null;\n\t\t\t}\n\t\t} else {\n\t\t\t$$.initToRender(true);\n\t\t}\n\t},\n\n\t/**\n\t * Reset the chart object and remove element and events completely.\n\t * @function destroy\n\t * @instance\n\t * @memberof Chart\n\t * @returns {null}\n\t * @example\n\t * chart.destroy();\n\t */\n\tdestroy(): null {\n\t\tconst $$ = this.internal;\n\t\tconst {$el: {chart, style, svg}} = $$;\n\n\t\tif (notEmpty($$)) {\n\t\t\t$$.callPluginHook(\"$willDestroy\");\n\n\t\t\t$$.charts.splice($$.charts.indexOf(this), 1);\n\n\t\t\t// detach events\n\t\t\t$$.unbindAllEvents();\n\n\t\t\t// clear timers && pending transition\n\t\t\tsvg.select(\"*\").interrupt();\n\t\t\t$$.resizeFunction.clear();\n\n\t\t\t$$.resizeFunction.resizeObserver?.disconnect();\n\t\t\twindow.removeEventListener(\"resize\", $$.resizeFunction);\n\t\t\tchart.classed(\"bb\", false)\n\t\t\t\t.style(\"position\", null)\n\t\t\t\t.selectChildren()\n\t\t\t\t.remove();\n\n\t\t\t// remove <style> element added by boost.useCssRule option\n\t\t\tstyle && style.parentNode.removeChild(style);\n\n\t\t\t// releasing own references\n\t\t\tObject.keys(this).forEach(key => {\n\t\t\t\tkey === \"internal\" && Object.keys($$).forEach(k => {\n\t\t\t\t\t$$[k] = null;\n\t\t\t\t});\n\n\t\t\t\tthis[key] = null;\n\t\t\t\tdelete this[key];\n\t\t\t});\n\n\t\t\t// release prototype chains\n\t\t\tfor (const key in this) {\n\t\t\t\tthis[key] = () => {};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Get or set config option value.\n\t * - **NOTE**\n\t *  - The option key name must be specified as the last level.\n\t *  - when no argument is given, will return all specified generation options object only. (will exclude any other options not specified at the initialization)\n\t * @function config\n\t * @instance\n\t * @memberof Chart\n\t * @param {string} name The option key name.\n\t * @param {*} [value] The value accepted for indicated option.\n\t * @param {boolean} [redraw] Set to redraw with the new option changes.\n\t * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.\n\t * @returns {*}\n\t * @example\n\t *\n\t * // Getter\n\t * chart.config(\"gauge.max\");\n\t *\n\t * // Getter specified with top level key name will not work.\n\t * // The option key name must be specified as the last level.\n\t * // chart.config(\"gauge\"); // will not work\n\t *\n\t * // without any arguments, it returns generation config object\n\t * chart.config();  // {data: { ... }, axis: { ... }, ...}\n\t *\n\t * // Setter\n\t * chart.config(\"gauge.max\", 100);\n\t *\n\t * // Setter specified with top level key name will not work.\n\t * // The option key name must be specified as the last level.\n\t * // chart.config(\"gauge\", {min: 10, max: 20}); // will not work\n\t *\n\t * // Setter & redraw with the new option\n\t * chart.config(\"gauge.max\", 100, true);\n\t */\n\tconfig(name: string, value?: any, redraw?: boolean): any {\n\t\tconst $$ = this.internal;\n\t\tconst {config, state} = $$;\n\t\tconst key = name?.replace(/\\./g, \"_\");\n\t\tlet res;\n\n\t\tif (name && key in config) {\n\t\t\tif (isDefined(value)) {\n\t\t\t\tconfig[key] = value;\n\t\t\t\tres = value;\n\n\t\t\t\tredraw && this.flush();\n\t\t\t} else {\n\t\t\t\tres = config[key];\n\t\t\t}\n\t\t} else if (arguments.length === 0 || isEmpty(name)) {\n\t\t\tres = state.orgConfig;\n\t\t}\n\n\t\treturn res;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nexport default {\n\t/**\n\t * Get the color\n\t * @function color\n\t * @instance\n\t * @memberof Chart\n\t * @param {string} id id to get the color\n\t * @returns {string}\n\t * @example\n\t * chart.color(\"data1\");\n\t */\n\tcolor(id: string): string {\n\t\treturn this.internal.color(id); // more patterns\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {DataItem} from \"../../../types/types\";\nimport type {IDataRow} from \"../../ChartInternal/data/IData\";\nimport {extend, isArray, isUndefined} from \"../../module/util\";\n\n/**\n * Get data loaded in the chart.\n * @function data\n * @instance\n * @memberof Chart\n * @param {string|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.\n * @returns {Array} Data objects\n * @example\n * // Get only data1 data\n * chart.data(\"data1\");\n * // --> [{id: \"data1\", id_org: \"data1\", values: Array(6)}, ...]\n *\n * // Get data1 and data2 data\n * chart.data([\"data1\", \"data2\"]);\n *\n * // Get all data\n * chart.data();\n */\nconst data = function(targetIds: string | string[]): DataItem[] {\n\tconst {targets} = this.internal.data;\n\n\tif (!isUndefined(targetIds)) {\n\t\tconst ids: any = isArray(targetIds) ? targetIds : [targetIds];\n\n\t\treturn targets.filter(t => ids.some(v => v === t.id));\n\t}\n\n\treturn targets;\n};\n\nextend(data, {\n\t/**\n\t * Get data shown in the chart.\n\t * @function data․shown\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.\n\t * @returns {Array} Data objects\n\t * @example\n\t * // Get shown data by filtering to include only data1 data\n\t * chart.data.shown(\"data1\");\n\t * // --> [{id: \"data1\", id_org: \"data1\", values: Array(6)}, ...]\n\t *\n\t * // Get shown data by filtering to include data1 and data2 data\n\t * chart.data.shown([\"data1\", \"data2\"]);\n\t *\n\t * // Get all shown data\n\t * chart.data.shown();\n\t */\n\tshown: function(targetIds: string | string[]): DataItem[] {\n\t\treturn this.internal.filterTargetsToShow(this.data(targetIds));\n\t},\n\n\t/**\n\t * Get values of the data loaded in the chart.\n\t * @function data․values\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array|null} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned\n\t * @param {boolean} [flat=true] Get flatten values\n\t * @returns {Array} Data values\n\t * @example\n\t * // Get data1 values\n\t * chart.data.values(\"data1\");\n\t * // --> [10, 20, 30, 40]\n\t */\n\tvalues: function(targetIds?: string | string[], flat: boolean = true): number[] | number[][]\n\t\t| null {\n\t\tlet values: any = null;\n\n\t\tif (targetIds) {\n\t\t\tconst targets = this.data(targetIds);\n\n\t\t\tif (isArray(targets)) {\n\t\t\t\tvalues = [];\n\n\t\t\t\ttargets.forEach(v => {\n\t\t\t\t\tconst dataValue = v.values.map(d => d.value);\n\n\t\t\t\t\tflat ? (values = values.concat(dataValue)) : values.push(dataValue);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn values;\n\t},\n\n\t/**\n\t * Get and set names of the data loaded in the chart.\n\t * @function data․names\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as [data.names](./Options.html#.data%25E2%2580%25A4names).\n\t * @returns {object} Corresponding names according its key value, if specified names values.\n\t * @example\n\t * // Get current names\n\t * chart.data.names();\n\t * // --> {data1: \"test1\", data2: \"test2\"}\n\t *\n\t * // Update names\n\t * chart.data.names({\n\t *  data1: \"New Name 1\",\n\t *  data2: \"New Name 2\"\n\t * });\n\t */\n\tnames: function(names?: Array<{[key: string]: string | null}>): {[key: string]: string | null} {\n\t\tconst $$ = this.internal;\n\n\t\treturn $$.updateDataAttributes(\"names\", names);\n\t},\n\n\t/**\n\t * Get and set colors of the data loaded in the chart.\n\t * @function data․colors\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).\n\t * @returns {object} Corresponding data color value according its key value.\n\t * @example\n\t * // Get current colors\n\t * chart.data.colors();\n\t * // --> {data1: \"#00c73c\", data2: \"#fa7171\"}\n\t *\n\t * // Update colors\n\t * chart.data.colors({\n\t *  data1: \"#FFFFFF\",\n\t *  data2: \"#000000\"\n\t * });\n\t */\n\tcolors: function(colors?: Array<{[key: string]: string}>): {[key: string]: string} {\n\t\treturn this.internal.updateDataAttributes(\"colors\", colors);\n\t},\n\n\t/**\n\t * Get and set axes of the data loaded in the chart.\n\t * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data\n\t * @function data․axes\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as\n\t * @returns {object} Corresponding axes value for data, if specified axes value.\n\t * @example\n\t * // Get current axes\n\t * chart.data.axes();\n\t * // --> {data1: \"y\"}\n\t *\n\t * // Update axes\n\t * chart.data.axes({\n\t *  data1: \"y\",\n\t *  data2: \"y2\"\n\t * });\n\t */\n\taxes: function(axes?: Array<{[key: string]: string}>): {[key: string]: string} {\n\t\treturn this.internal.updateDataAttributes(\"axes\", axes);\n\t},\n\n\t/**\n\t * Get the minimum data value bound to the chart\n\t * @function data․min\n\t * @instance\n\t * @memberof Chart\n\t * @returns {Array} Data objects\n\t * @example\n\t * // Get current axes\n\t * chart.data.min();\n\t * // --> [{x: 0, value: 30, id: \"data1\", index: 0}, ...]\n\t */\n\tmin: function(): IDataRow[] {\n\t\treturn this.internal.getMinMaxData().min;\n\t},\n\n\t/**\n\t * Get the maximum data value bound to the chart\n\t * @function data․max\n\t * @instance\n\t * @memberof Chart\n\t * @returns {Array} Data objects\n\t * @example\n\t * // Get current axes\n\t * chart.data.max();\n\t * // --> [{x: 3, value: 400, id: \"data1\", index: 3}, ...]\n\t */\n\tmax: function(): IDataRow[] {\n\t\treturn this.internal.getMinMaxData().max;\n\t}\n});\n\nexport default {data};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {namespaces as d3Namespaces} from \"d3-selection\";\nimport {document, window} from \"../../module/browser\";\nimport {\n\tgetBBox,\n\tgetBoundingRect,\n\tgetCssRules,\n\tisFunction,\n\tmergeObj,\n\ttoArray\n} from \"../../module/util\";\n\ntype TExportOption = TSize & {\n\tpreserveAspectRatio: boolean,\n\tpreserveFontStyle: boolean,\n\tmimeType: string\n};\n\ntype TSize = {x?: number, y?: number, width: number, height: number};\n\ntype TTextGlyph = {\n\t[key: string]: TSize & {\n\t\tfill: string,\n\t\tfontFamily: string,\n\t\tfontSize: string,\n\t\ttextAnchor: string,\n\t\ttransform: string\n\t}\n};\n\n/**\n * Encode to base64\n * @param {string} str string to be encoded\n * @returns {string}\n * @private\n * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\n */\nconst b64EncodeUnicode = (str: string): string =>\n\twindow.btoa?.(\n\t\tencodeURIComponent(str)\n\t\t\t.replace(/%([0-9A-F]{2})/g,\n\t\t\t\t(match, p: number | string): string => String.fromCharCode(Number(`0x${p}`)))\n\t);\n\n/**\n * Convert svg node to data url\n * @param {HTMLElement} node target node\n * @param {object} option object containing {width, height, preserveAspectRatio}\n * @param {object} orgSize object containing {width, height}\n * @returns {string}\n * @private\n */\nfunction nodeToSvgDataUrl(node, option: TExportOption, orgSize: TSize) {\n\tconst {width, height} = option || orgSize;\n\tconst serializer = new XMLSerializer();\n\tconst clone = node.cloneNode(true);\n\tconst cssText = getCssRules(toArray(document.styleSheets))\n\t\t.filter((r: CSSStyleRule) => r.cssText)\n\t\t.map((r: CSSStyleRule) => r.cssText);\n\n\tclone.setAttribute(\"xmlns\", d3Namespaces.xhtml);\n\n\t// remove padding & margin\n\tclone.style.margin = \"0\";\n\tclone.style.padding = \"0\";\n\n\t// remove text nodes\n\tif (option.preserveFontStyle) {\n\t\tclone.querySelectorAll(\"text\").forEach(t => {\n\t\t\tt.innerHTML = \"\";\n\t\t});\n\t}\n\n\tconst nodeXml = serializer.serializeToString(clone);\n\n\t// escape css for XML\n\tconst style = document.createElement(\"style\");\n\n\tstyle.appendChild(document.createTextNode(cssText.join(\"\\n\")));\n\n\tconst styleXml = serializer.serializeToString(style);\n\n\t// foreignObject not supported in IE11 and below\n\t// https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx\n\tconst dataStr = `<svg xmlns=\"${d3Namespaces.svg}\" width=\"${width}\" height=\"${height}\" \n\t\tviewBox=\"0 0 ${orgSize.width} ${orgSize.height}\" \n\t\tpreserveAspectRatio=\"${option?.preserveAspectRatio === false ? \"none\" : \"xMinYMid meet\"}\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t${styleXml}\n\t\t\t\t${nodeXml.replace(/(url\\()[^#]+/g, \"$1\")}\n\t\t\t</foreignObject></svg>`;\n\n\treturn `data:image/svg+xml;base64,${b64EncodeUnicode(dataStr)}`;\n}\n\n/**\n * Get coordinate of the element\n * @param {SVGElement} elem Target element\n * @param {object} svgOffset SVG offset\n * @returns {object}\n * @private\n */\nfunction getCoords(elem, svgOffset): TSize {\n\tconst {top, left} = svgOffset;\n\tconst {x, y} = getBBox(elem, true);\n\tconst {a, b, c, d, e, f} = elem.getScreenCTM();\n\tconst {width, height} = getBoundingRect(elem, true);\n\n\treturn {\n\t\tx: (a * x) + (c * y) + e - left,\n\t\ty: (b * x) + (d * y) + f - top + (height - Math.round(height / 4)),\n\t\twidth,\n\t\theight\n\t};\n}\n\n/**\n * Get text glyph\n * @param {SVGTextElement} svg Target svg node\n * @returns {Array}\n * @private\n */\nfunction getGlyph(svg: SVGElement): TTextGlyph[] {\n\tconst {left, top} = getBoundingRect(svg);\n\tconst filterFn = t => t.textContent || t.childElementCount;\n\tconst glyph: TTextGlyph[] = [];\n\n\ttoArray(svg.querySelectorAll(\"text\"))\n\t\t.filter(filterFn)\n\t\t.forEach((t: SVGTextElement) => { // eslint-disable-line\n\t\t\tconst getStyleFn = (ts: SVGTextElement): TTextGlyph => {\n\t\t\t\tconst {fill, fontFamily, fontSize, textAnchor, transform} = window.getComputedStyle(\n\t\t\t\t\tts\n\t\t\t\t);\n\t\t\t\tconst {x, y, width, height} = getCoords(ts, {left, top});\n\n\t\t\t\treturn {\n\t\t\t\t\t[ts.textContent as string]: {\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tfill,\n\t\t\t\t\t\tfontFamily,\n\t\t\t\t\t\tfontSize,\n\t\t\t\t\t\ttextAnchor,\n\t\t\t\t\t\ttransform\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tif (t.childElementCount > 1) {\n\t\t\t\tconst text: TTextGlyph[] = [];\n\n\t\t\t\ttoArray(t.querySelectorAll(\"tspan\"))\n\t\t\t\t\t.filter(filterFn)\n\t\t\t\t\t.forEach((ts: SVGTSpanElement) => {\n\t\t\t\t\t\tglyph.push(getStyleFn(ts));\n\t\t\t\t\t});\n\n\t\t\t\treturn text;\n\t\t\t} else {\n\t\t\t\tglyph.push(getStyleFn(t));\n\t\t\t}\n\t\t});\n\n\treturn glyph;\n}\n\n/**\n * Render text glyph\n * - NOTE: Called when the 'preserveFontStyle' option is true\n * @param {CanvasRenderingContext2D} ctx Canvas context\n * @param {Array} glyph Text glyph array\n * @private\n */\nfunction renderText(ctx, glyph): void {\n\tglyph.forEach(g => {\n\t\tObject.keys(g).forEach(key => {\n\t\t\tconst {x, y, width, height, fill, fontFamily, fontSize, transform} = g[key];\n\n\t\t\tctx.save();\n\n\t\t\tctx.font = `${fontSize} ${fontFamily}`;\n\t\t\tctx.fillStyle = fill;\n\n\t\t\tif (transform === \"none\") {\n\t\t\t\tctx.fillText(key, x, y);\n\t\t\t} else {\n\t\t\t\tconst args = transform\n\t\t\t\t\t.replace(/(matrix|\\(|\\))/g, \"\")\n\t\t\t\t\t.split(\",\");\n\n\t\t\t\tif (args.splice(4).every(v => +v === 0)) {\n\t\t\t\t\targs.push(x + width - (width / 4));\n\t\t\t\t\targs.push(y - height + (height / 3));\n\t\t\t\t} else {\n\t\t\t\t\targs.push(x);\n\t\t\t\t\targs.push(y);\n\t\t\t\t}\n\n\t\t\t\tctx.transform(...args);\n\t\t\t\tctx.fillText(key, 0, 0);\n\t\t\t}\n\n\t\t\tctx.restore();\n\t\t});\n\t});\n}\n\nexport default {\n\t/**\n\t * Export chart as an image.\n\t * - **NOTE:**\n\t *   - IE11 and below not work properly due to the lack of the feature(<a href=\"https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx\">foreignObject</a>) support\n\t *   - Every style applied to the chart & the basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.\n\t * @function export\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} option Export option\n\t * @param {string} [option.mimeType=\"image/png\"] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)\n\t * @param {number} [option.width={currentWidth}] width\n\t * @param {number} [option.height={currentHeigth}] height\n\t * @param {boolean} [option.preserveAspectRatio=true] Preserve aspect ratio on given size\n\t * @param {boolean} [option.preserveFontStyle=false] Preserve font style(font-family).<br>\n\t * **NOTE:**\n\t *   - This option is useful when outlink web font style's `font-family` are applied to chart's text element.\n\t *   - Text element's position(especially \"transformed\") can't be preserved correctly according the page's layout condition.\n\t *   - If need to preserve accurate text position, embed the web font data within to the page and set `preserveFontStyle=false`.\n\t *     - Checkout the embed example: <a href=\"https://stackblitz.com/edit/zfbya9-8nf9nn?file=index.html\">https://stackblitz.com/edit/zfbya9-8nf9nn?file=index.html</a>\n\t * @param {Function} [callback] The callback to be invoked when export is ready.\n\t * @returns {string} dataURI\n\t * @example\n\t *  chart.export();\n\t *  // --> \"data:image/svg+xml;base64,PHN...\"\n\t *\n\t *  // Initialize the download automatically\n\t *  chart.export({mimeType: \"image/png\"}, dataUrl => {\n\t *     const link = document.createElement(\"a\");\n\t *\n\t *     link.download = `${Date.now()}.png`;\n\t *     link.href = dataUrl;\n\t *     link.innerHTML = \"Download chart as image\";\n\t *\n\t *     document.body.appendChild(link);\n\t *  });\n\t *\n\t *  // Resize the exported image\n\t *  chart.export(\n\t *    {\n\t *      width: 800,\n\t *      height: 600,\n\t *      preserveAspectRatio: false,\n\t *      preserveFontStyle: false,\n\t *      mimeType: \"image/png\"\n\t *    },\n\t *    dataUrl => { ... }\n\t *  );\n\t */\n\texport(option?: TExportOption, callback?: (dataUrl: string) => void): string {\n\t\tconst $$ = this.internal;\n\t\tconst {state, $el: {chart, svg}} = $$;\n\t\tconst {width, height} = state.current;\n\t\tconst opt = mergeObj(Object.create(null), {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tpreserveAspectRatio: true,\n\t\t\tpreserveFontStyle: false,\n\t\t\tmimeType: \"image/png\"\n\t\t}, option) as TExportOption;\n\n\t\tconst svgDataUrl = nodeToSvgDataUrl(chart.node(), opt, {width, height});\n\t\tconst glyph = opt.preserveFontStyle ? getGlyph(svg.node()) : [];\n\n\t\tif (callback && isFunction(callback)) {\n\t\t\tconst img = new Image();\n\n\t\t\timg.crossOrigin = \"Anonymous\";\n\t\t\timg.onload = () => {\n\t\t\t\tconst canvas = document.createElement(\"canvas\");\n\t\t\t\tconst ctx = canvas.getContext(\"2d\");\n\n\t\t\t\tcanvas.width = opt.width || width;\n\t\t\t\tcanvas.height = opt.height || height;\n\t\t\t\tctx.drawImage(img, 0, 0);\n\n\t\t\t\tif (glyph.length) {\n\t\t\t\t\trenderText(ctx, glyph);\n\n\t\t\t\t\t// release glyph array\n\t\t\t\t\tglyph.length = 0;\n\t\t\t\t}\n\n\t\t\t\tcallback.bind(this)(canvas.toDataURL(opt.mimeType));\n\t\t\t};\n\n\t\t\timg.src = svgDataUrl;\n\t\t}\n\n\t\treturn svgDataUrl;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$FOCUS, $GAUGE} from \"../../config/classes\";\n\ntype FocusParam = string | string[];\n\nexport default {\n\t/**\n\t * This API highlights specified targets and fade out the others.<br><br>\n\t * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.\n\t * @function focus\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} targetIdsValue Target ids to be highlighted.\n\t * @example\n\t *  // data1 will be highlighted and the others will be faded out\n\t *  chart.focus(\"data1\");\n\t *\n\t * // data1 and data2 will be highlighted and the others will be faded out\n\t * chart.focus([\"data1\", \"data2\"]);\n\t *\n\t * // all targets will be highlighted\n\t * chart.focus();\n\t */\n\tfocus(targetIdsValue?: FocusParam): void {\n\t\tconst $$ = this.internal;\n\t\tconst {state} = $$;\n\t\tconst targetIds = $$.mapToTargetIds(targetIdsValue);\n\t\tconst candidates = $$.$el.svg.selectAll(\n\t\t\t$$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))\n\t\t);\n\n\t\tthis.revert();\n\t\tthis.defocus();\n\n\t\tcandidates.classed($FOCUS.focused, true).classed($FOCUS.defocused, false);\n\n\t\tif ($$.hasArcType() && !state.hasRadar) {\n\t\t\t$$.expandArc(targetIds);\n\n\t\t\t$$.hasType(\"gauge\") &&\n\t\t\t\t$$.markOverlapped(targetIdsValue, $$, `.${$GAUGE.gaugeValue}`);\n\t\t}\n\n\t\t$$.toggleFocusLegend(targetIds, true);\n\n\t\tstate.focusedTargetIds = targetIds;\n\t\tstate.defocusedTargetIds = state.defocusedTargetIds.filter(id => targetIds.indexOf(id) < 0);\n\t},\n\n\t/**\n\t * This API fades out specified targets and reverts the others.<br><br>\n\t * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.\n\t * @function defocus\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} targetIdsValue Target ids to be faded out.\n\t * @example\n\t * // data1 will be faded out and the others will be reverted.\n\t * chart.defocus(\"data1\");\n\t *\n\t * // data1 and data2 will be faded out and the others will be reverted.\n\t * chart.defocus([\"data1\", \"data2\"]);\n\t *\n\t * // all targets will be faded out.\n\t * chart.defocus();\n\t */\n\tdefocus(targetIdsValue?: FocusParam): void {\n\t\tconst $$ = this.internal;\n\t\tconst {state} = $$;\n\t\tconst targetIds = $$.mapToTargetIds(targetIdsValue);\n\t\tconst candidates = $$.$el.svg.selectAll(\n\t\t\t$$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))\n\t\t);\n\n\t\tcandidates.classed($FOCUS.focused, false).classed($FOCUS.defocused, true);\n\n\t\tif ($$.hasArcType(null, [\"polar\"])) {\n\t\t\t$$.unexpandArc(targetIds);\n\n\t\t\t$$.hasType(\"gauge\") &&\n\t\t\t\t$$.undoMarkOverlapped($$, `.${$GAUGE.gaugeValue}`);\n\t\t}\n\n\t\t$$.toggleFocusLegend(targetIds, false);\n\n\t\tstate.focusedTargetIds = state.focusedTargetIds.filter(id => targetIds.indexOf(id) < 0);\n\t\tstate.defocusedTargetIds = targetIds;\n\t},\n\n\t/**\n\t * Revert focused or defocused state to initial state.<br><br>\n\t * You can specify multiple targets by giving an array that includes id as string. If no argument is given, all of targets will be reverted.\n\t * @function revert\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} targetIdsValue Target ids to be reverted\n\t * @example\n\t * // 'data1' will be reverted.\n\t * chart.revert(\"data1\");\n\t *\n\t * // 'data1' and 'data2' will be reverted.\n\t * chart.revert([\"data1\", \"data2\"]);\n\t *\n\t * // all targets will be reverted.\n\t * chart.revert();\n\t */\n\trevert(targetIdsValue?: FocusParam): void {\n\t\tconst $$ = this.internal;\n\t\tconst {config, state, $el} = $$;\n\t\tconst targetIds = $$.mapToTargetIds(targetIdsValue);\n\t\tconst candidates = $el.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets\n\n\t\tcandidates.classed($FOCUS.focused, false).classed($FOCUS.defocused, false);\n\n\t\t$$.hasArcType(null, [\"polar\"]) && $$.unexpandArc(targetIds);\n\n\t\tif (config.legend_show) {\n\t\t\t$$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));\n\t\t\t$el.legend.selectAll($$.selectorLegends(targetIds))\n\t\t\t\t.filter(function() {\n\t\t\t\t\treturn d3Select(this).classed($FOCUS.legendItemFocused);\n\t\t\t\t})\n\t\t\t\t.classed($FOCUS.legendItemFocused, false);\n\t\t}\n\n\t\tstate.focusedTargetIds = [];\n\t\tstate.defocusedTargetIds = [];\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * Define legend\n * @ignore\n */\nconst legend = {\n\t/**\n\t * Show legend for each target.\n\t * - **NOTE:** Legend APIs aren't supported for `treemap` type.\n\t * @function legend․show\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} targetIds\n\t * - If targetIds is given, specified target's legend will be shown.\n\t * - If only one target is the candidate, String can be passed.\n\t * - If no argument is given, all of target's legend will be shown.\n\t * @example\n\t * // Show legend for data1.\n\t * chart.legend.show(\"data1\");\n\t *\n\t * // Show legend for data1 and data2.\n\t * chart.legend.show([\"data1\", \"data2\"]);\n\t *\n\t * // Show all legend.\n\t * chart.legend.show();\n\t */\n\tshow: function(targetIds?: string | string[]): void {\n\t\tconst $$ = this.internal;\n\n\t\t$$.showLegend($$.mapToTargetIds(targetIds));\n\t\t$$.updateAndRedraw({withLegend: true});\n\t},\n\n\t/**\n\t * Hide legend for each target.\n\t * @function legend․hide\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} targetIds\n\t * - If targetIds is given, specified target's legend will be hidden.\n\t * - If only one target is the candidate, String can be passed.\n\t * - If no argument is given, all of target's legend will be hidden.\n\t * @example\n\t * // Hide legend for data1.\n\t * chart.legend.hide(\"data1\");\n\t *\n\t * // Hide legend for data1 and data2.\n\t * chart.legend.hide([\"data1\", \"data2\"]);\n\t *\n\t * // Hide all legend.\n\t * chart.legend.hide();\n\t */\n\thide: function(targetIds?: string | string[]): void {\n\t\tconst $$ = this.internal;\n\n\t\t$$.hideLegend($$.mapToTargetIds(targetIds));\n\t\t$$.updateAndRedraw({withLegend: true});\n\t}\n};\n\nexport default {legend};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {callDone} from \"../../ChartInternal/data/load\";\nimport {requestIdleCallback} from \"../../module/browser\";\nimport {isArray, isEmpty, isString} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Load data to the chart.<br><br>\n\t * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.\n\t * - <b>Note:</b>\n\t *   - unload should be used if some data needs to be unloaded simultaneously.\n\t *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>\n\t *   - done will be called after data loaded, but it's not after rendering.\n\t *     It's because rendering will finish after some transition and there is some time lag between loading and rendering\n\t * @function load\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} args The object can consist with following members:<br>\n\t *\n\t *    | Key | Type | Description |\n\t *    | --- | --- | --- |\n\t *    | columns | Array | The `columns` data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |\n\t *    | json | Array | The `json` data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |\n\t *    | rows | Array | The `rows` data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |\n\t *    | url | string | The data from `url` will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |\n\t *    | &nbsp; | | |\n\t *    | append | boolean | Load data appending it to the current dataseries.<br>If the existing chart has`x` value, should provide with corresponding `x` value for newly loaded data.  |\n\t *    | axes | Object | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |\n\t *    | categories | Array | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |\n\t *    | classes | Object | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |\n\t *    | colors | Object | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |\n\t *    | data | Obejct | Data objects to be loaded. Checkout the example. |\n\t *    | done | Function | The specified function will be called after data loaded.|\n\t *    | headers | string |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |\n\t *    | keys | Object |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |\n\t *    | mimeType | string |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |\n\t *    | names | Object | Same as data.names() |\n\t *    | resizeAfter | boolean | Resize after the load. Default value is `false`.<br>- This option won't call `onresize` neither `onresized`.<br>- When set to 'true', will call `.flush(true)` at the end of load. |\n\t *    | type | string | The type of targets will be updated. |\n\t *    | types | Object | The types of targets will be updated. |\n\t *    | unload | Array | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |\n\t *    | xs | string | Same as data.xs option  |\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)\n\t * @example\n\t * // Load data1 and unload data2 and data3\n\t * chart.load({\n\t *     columns: [\n\t *        [\"data1\", 100, 200, 150, ...],\n\t *        ...\n\t *    ],\n\t *    unload: [\"data2\", \"data3\"],\n\t *    url: \"...\",\n\t *    done: function() { ... }\n\t *    resizeAfter: true  // will resize after load\n\t * });\n\t * @example\n\t * const chart = bb.generate({\n\t *   data: {\n\t *     columns: [\n\t *       [\"data1\", 20, 30, 40]\n\t *     ]\n\t *   }\n\t * });\n\t *\n\t * chart.load({\n\t *    columns: [\n\t *        // with 'append' option, the 'data1' will have `[20,30,40,50,60]`.\n\t *        [\"data1\", 50, 60]\n\t *    ],\n\t *    append: true\n\t * });\n\t * @example\n\t * const chart = bb.generate({\n\t *   data: {\n\t *     x: \"x\",\n\t *     xFormat: \"%Y-%m-%dT%H:%M:%S\",\n\t *     columns: [\n\t *       [\"x\", \"2021-01-03T03:00:00\", \"2021-01-04T12:00:00\", \"2021-01-05T21:00:00\"],\n\t *       [\"data1\", 36, 30, 24]\n\t *     ]\n\t *   },\n\t *   axis: {\n\t *     x: {\n\t *       type: \"timeseries\"\n\t *     }\n\t *   }\n\t * };\n\t *\n\t * chart.load({\n\t *   columns: [\n\t *     // when existing chart has `x` value, should provide correponding 'x' value.\n\t *     // with 'append' option, the 'data1' will have `[36,30,24,37]`.\n\t *     [\"x\", \"2021-02-01T08:00:00\"],\n\t *     [\"data1\", 37]\n\t *   ],\n\t *   append: true\n\t * });\n\t * @example\n\t * // myAPI.json\n\t * // {\n\t * //   \"data1\": [220, 240, 270, 250, 280],\n\t * //   \"data2\": [180, 150, 300, 70, 120]\n\t * // }\n\t *\n\t * chart.load({\n\t *     url: './data/myAPI.json',\n\t *     mimeType: \"json\",\n\t *\n\t *     // set request header if is needed\n\t *     headers: {\n\t *       \"Content-Type\": \"text/json\"\n\t *     }\n\t * });\n\t * @example\n\t * chart.load({\n\t *     data: [\n\t *       // equivalent as: columns: [[\"data1\", 30, 200, 100]]\n\t *       {\"data1\": 30}, {\"data1\": 200}, {\"data1\": 100}\n\t *\n\t *       // or\n\t *       // equivalent as: columns: [[\"data1\", 10, 20], [\"data2\", 13, 30]]\n\t *       // {\"data1\": 10, \"data2\": 13}, {\"data1\": 20, \"data2\": 30}}\n\t *     ]\n\t * });\n\t * @example\n\t * chart.load({\n\t *     json: [\n\t *          {name: \"www.site1.com\", upload: 800, download: 500, total: 400},\n\t *     ],\n\t *     keys: {\n\t *         x: \"name\",\n\t *         value: [\"upload\", \"download\"]\n\t *     }\n\t * });\n\t * @example\n\t * chart.load({\n\t *   json: {\n\t *       data1:[30, 20, 50, 40, 60, 50],\n\t *       data2:[200, 130, 90, 240, 130, 220],\n\t *   }\n\t * });\n\t */\n\tload(args): void {\n\t\tconst $$ = this.internal;\n\t\tconst {config} = $$;\n\n\t\t// update xs if specified\n\t\targs.xs && $$.addXs(args.xs);\n\n\t\t// update names if exists\n\t\t\"names\" in args && this.data.names(args.names);\n\n\t\t// update classes if exists\n\t\t\"classes\" in args && Object.keys(args.classes).forEach(id => {\n\t\t\tconfig.data_classes[id] = args.classes[id];\n\t\t});\n\n\t\t// update categories if exists\n\t\tif (\"categories\" in args && $$.axis.isCategorized()) {\n\t\t\tconfig.axis_x_categories = args.categories;\n\t\t}\n\n\t\t// update axes if exists\n\t\t\"axes\" in args && Object.keys(args.axes).forEach(id => {\n\t\t\tconfig.data_axes[id] = args.axes[id];\n\t\t});\n\n\t\t// update colors if exists\n\t\t\"colors\" in args && Object.keys(args.colors).forEach(id => {\n\t\t\tconfig.data_colors[id] = args.colors[id];\n\t\t});\n\n\t\t// unload if needed\n\t\tif (\"unload\" in args && args.unload !== false) {\n\t\t\t// TODO: do not unload if target will load (included in url/rows/columns)\n\t\t\t$$.unload($$.mapToTargetIds(args.unload === true ? null : args.unload), () => {\n\t\t\t\t// to mitigate improper rendering for multiple consecutive calls\n\t\t\t\t// https://github.com/naver/billboard.js/issues/2121\n\t\t\t\trequestIdleCallback(() => $$.loadFromArgs(args));\n\t\t\t});\n\t\t} else {\n\t\t\t$$.loadFromArgs(args);\n\t\t}\n\t},\n\n\t/**\n\t * Unload data to the chart.<br><br>\n\t * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.\n\t * - <b>Note:</b>\n\t * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>\n\t * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.\n\t * @function unload\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} argsValue\n\t *  | key | Type | Description |\n\t *  | --- | --- | --- |\n\t *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |\n\t *  | done | Fuction | Callback after data is unloaded. |\n\t *  | resizeAfter | boolean | Resize after the unload. Default value is `false`.<br>- This option won't call `onresize` neither `onresized`.<br>- When set to 'true', will call `.flush(true)` at the end of unload. |\n\t * @example\n\t *  // Unload data2 and data3\n\t *  chart.unload({\n\t *    ids: [\"data2\", \"data3\"],\n\t *    done: function() {\n\t *       // called after the unloaded\n\t *    },\n\t *    resizeAfter: true  // will resize after unload\n\t *  });\n\t */\n\tunload(argsValue): void {\n\t\tconst $$ = this.internal;\n\t\tlet args = argsValue || {};\n\n\t\t// hide possible tooltip display when data is completely unloaded\n\t\tisEmpty(args) && this.tooltip.hide();\n\n\t\tif (isArray(args)) {\n\t\t\targs = {ids: args};\n\t\t} else if (isString(args)) {\n\t\t\targs = {ids: [args]};\n\t\t}\n\n\t\tconst ids = $$.mapToTargetIds(args.ids);\n\n\t\t$$.unload(ids, () => {\n\t\t\t$$.redraw({\n\t\t\t\twithUpdateOrgXDomain: true,\n\t\t\t\twithUpdateXDomain: true,\n\t\t\t\twithLegend: true\n\t\t\t});\n\n\t\t\t$$.cache.remove(ids);\n\t\t\tcallDone.call($$, args.done, args.resizeAfter);\n\t\t});\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {callFn, endall} from \"../../module/util\";\n\n/**\n * Show/Hide data series\n * @param {boolean} show Show or hide\n * @param {Array} targetIdsValue Target id values\n * @param {object} options Options\n * @private\n */\nfunction showHide(show: boolean, targetIdsValue: string[], options: any): void {\n\tconst $$ = this.internal;\n\tconst targetIds = $$.mapToTargetIds(targetIdsValue);\n\tconst hiddenIds = $$.state.hiddenTargetIds\n\t\t.map(v => targetIds.indexOf(v) > -1 && v)\n\t\t.filter(Boolean);\n\n\t$$.state.toggling = true;\n\n\t$$[`${show ? \"remove\" : \"add\"}HiddenTargetIds`](targetIds);\n\n\tconst targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds));\n\tconst opacity = show ? null : \"0\";\n\n\tif (show && hiddenIds.length) {\n\t\ttargets.style(\"display\", null);\n\t\tcallFn($$.config.data_onshown, this, hiddenIds);\n\t}\n\n\t$$.$T(targets)\n\t\t.style(\"opacity\", opacity, \"important\")\n\t\t.call(endall, () => {\n\t\t\t// https://github.com/naver/billboard.js/issues/1758\n\t\t\tif (!show && hiddenIds.length === 0) {\n\t\t\t\ttargets.style(\"display\", \"none\");\n\t\t\t\tcallFn($$.config?.data_onhidden, this, targetIds);\n\t\t\t}\n\n\t\t\ttargets.style(\"opacity\", opacity);\n\t\t});\n\n\toptions.withLegend && $$[`${show ? \"show\" : \"hide\"}Legend`](targetIds);\n\n\t$$.redraw({\n\t\twithUpdateOrgXDomain: true,\n\t\twithUpdateXDomain: true,\n\t\twithLegend: true\n\t});\n\n\t$$.state.toggling = false;\n}\n\nexport default {\n\t/**\n\t * Show data series on chart\n\t * @function show\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} [targetIdsValue] The target id value.\n\t * @param {object} [options] The object can consist with following members:<br>\n\t *\n\t *    | Key | Type | default | Description |\n\t *    | --- | --- | --- | --- |\n\t *    | withLegend | boolean | false | whether or not display legend |\n\t *\n\t * @example\n\t * // show 'data1'\n\t * chart.show(\"data1\");\n\t *\n\t * // show 'data1' and 'data3'\n\t * chart.show([\"data1\", \"data3\"]);\n\t */\n\tshow(targetIdsValue?: string[] | string, options = {}): void {\n\t\tshowHide.call(this, true, targetIdsValue, options);\n\t},\n\n\t/**\n\t * Hide data series from chart\n\t * @function hide\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} [targetIdsValue] The target id value.\n\t * @param {object} [options] The object can consist with following members:<br>\n\t *\n\t *    | Key | Type | default | Description |\n\t *    | --- | --- | --- | --- |\n\t *    | withLegend | boolean | false | whether or not display legend |\n\t *\n\t * @example\n\t * // hide 'data1'\n\t * chart.hide(\"data1\");\n\t *\n\t * // hide 'data1' and 'data3'\n\t * chart.hide([\"data1\", \"data3\"]);\n\t */\n\thide(targetIdsValue?: string[], options = {}): void {\n\t\tshowHide.call(this, false, targetIdsValue, options);\n\t},\n\n\t/**\n\t * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.\n\t * @function toggle\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} [targetIds] The target id value.\n\t * @param {object} [options] The object can consist with following members:<br>\n\t *\n\t *    | Key | Type | default | Description |\n\t *    | --- | --- | --- | --- |\n\t *    | withLegend | boolean | false | whether or not display legend |\n\t *\n\t * @example\n\t * // toggle 'data1'\n\t * chart.toggle(\"data1\");\n\t *\n\t * // toggle 'data1' and 'data3'\n\t * chart.toggle([\"data1\", \"data3\"]);\n\t */\n\ttoggle(targetIds: string | string[], options = {}): void {\n\t\tconst $$ = this.internal;\n\t\tconst targets = {show: <string[]>[], hide: <string[]>[]};\n\n\t\t// sort show & hide target ids\n\t\t$$.mapToTargetIds(targetIds)\n\t\t\t.forEach((id: string) => targets[$$.isTargetToShow(id) ? \"hide\" : \"show\"].push(id));\n\n\t\t// perform show & hide task separately\n\t\t// https://github.com/naver/billboard.js/issues/454\n\t\ttargets.show.length && this.show(targets.show, options);\n\t\ttargets.hide.length && setTimeout(() => this.hide(targets.hide, options), 0);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$SHAPE} from \"../../config/classes\";\nimport {isDefined} from \"../../module/util\";\n\n/**\n * Define tooltip\n * @ignore\n */\nconst tooltip = {\n\t/**\n\t * Show tooltip\n\t * @function tooltip․show\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} args The object can consist with following members:<br>\n\t *\n\t *    | Key | Type | Description |\n\t *    | --- | --- | --- |\n\t *    | index | Number | Determine focus by index |\n\t *    | x | Number &vert; Date | Determine focus by x Axis index |\n\t *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |\n\t *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {number &verbar; Date}: x Axis value<br>- index {number}: x Axis index (useless for data.xs)<br>- id {string}: data id<br>- value {number}: The corresponding value for tooltip. |\n\t *\n\t * @example\n\t *  // show the 2nd x Axis coordinate tooltip\n\t *  // for Arc(gauge, donut & pie) and radar type, approch showing tooltip by using \"index\" number.\n\t *  chart.tooltip.show({\n\t *    index: 1\n\t *  });\n\t *\n\t *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.\n\t *  chart.tooltip.show({\n\t *    x: 2,\n\t *    mouse: [50, 100]\n\t *  });\n\t *\n\t *  // show tooltip for timeseries x axis\n\t *  chart.tooltip.show({\n\t *    x: new Date(\"2018-01-02 00:00\")\n\t *  });\n\t *\n\t *  // treemap type can be shown by using \"id\" only.\n\t *  chart.tooltip.show({\n\t *    data: {\n\t *        id: \"data1\"  // data id\n\t *    }\n\t *  });\n\t *\n\t *  // for Arc types, specify 'id' or 'index'\n\t *  chart.tooltip.show({ data: { id: \"data2\" }});\n\t *  chart.tooltip.show({ data: { index: 2 }});\n\t *\n\t *  // when data.xs is used\n\t *  chart.tooltip.show({\n\t *    data: {\n\t *        x: 3,  // x Axis value\n\t *        id: \"data1\",  // data id\n\t *        value: 500  // data value\n\t *    }\n\t *  });\n\t *\n\t *  // when data.xs isn't used, but tooltip.grouped=false is set\n\t *  chart.tooltip.show({\n\t *    data: {\n\t *        index: 3,  // or 'x' key value\n\t *        id: \"data1\",  // data id\n\t *        value: 500  // data value\n\t *    }\n\t *  });\n\t */\n\tshow: function(args): void {\n\t\tconst $$ = this.internal;\n\t\tconst {$el, config, state: {eventReceiver, hasFunnel, hasTreemap, inputType}} = $$;\n\t\tlet index;\n\t\tlet mouse;\n\n\t\t// determine mouse position on the chart\n\t\tif (args.mouse) {\n\t\t\tmouse = args.mouse;\n\t\t}\n\n\t\t// determine focus data\n\t\tif (args.data) {\n\t\t\tconst {data} = args;\n\t\t\tconst y = $$.getYScaleById(data.id)?.(data.value);\n\n\t\t\tif ((hasFunnel || hasTreemap) && data.id) {\n\t\t\t\tconst selector = $$.selectorTarget(data.id, undefined, `.${$SHAPE.shape}`);\n\n\t\t\t\teventReceiver.rect = $el.main.select(selector);\n\t\t\t} else if ($$.isMultipleX()) {\n\t\t\t\t// if multiple xs, target point will be determined by mouse\n\t\t\t\tmouse = [$$.xx(data), y];\n\t\t\t} else {\n\t\t\t\tif (!config.tooltip_grouped) {\n\t\t\t\t\tmouse = [0, y];\n\t\t\t\t}\n\n\t\t\t\tindex = data.index ?? (\n\t\t\t\t\t$$.hasArcType() && data.id ?\n\t\t\t\t\t\t$$.getArcElementByIdOrIndex(data.id)?.datum().index :\n\t\t\t\t\t\t$$.getIndexByX(data.x)\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (isDefined(args.x)) {\n\t\t\tindex = $$.getIndexByX(args.x);\n\t\t} else if (isDefined(args.index)) {\n\t\t\tindex = args.index;\n\t\t}\n\n\t\t(inputType === \"mouse\" ? [\"mouseover\", \"mousemove\"] : [\"touchstart\"]).forEach(eventName => {\n\t\t\t$$.dispatchEvent(eventName, index, mouse);\n\t\t});\n\t},\n\n\t/**\n\t * Hide tooltip\n\t * @function tooltip․hide\n\t * @instance\n\t * @memberof Chart\n\t */\n\thide: function(): void {\n\t\tconst $$ = this.internal;\n\t\tconst {state: {inputType}, $el: {tooltip}} = $$;\n\t\tconst data = tooltip?.datum();\n\n\t\tif (data) {\n\t\t\tconst {index} = JSON.parse(data.current)[0];\n\n\t\t\t// make to finalize, possible pending event flow set from '.tooltip.show()' call\n\t\t\t(inputType === \"mouse\" ? [\"mouseout\"] : [\"touchend\"]).forEach(eventName => {\n\t\t\t\t$$.dispatchEvent(eventName, index);\n\t\t\t});\n\t\t}\n\n\t\t// reset last touch point index\n\t\tinputType === \"touch\" && $$.callOverOutForTouch();\n\n\t\t$$.hideTooltip(true);\n\t\t$$.hideGridFocus?.();\n\n\t\t$$.unexpandCircles?.();\n\t\t$$.expandBarTypeShapes?.(false);\n\t}\n};\n\nexport default {tooltip};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport ChartInternal from \"../ChartInternal/ChartInternal\";\nimport {loadConfig} from \"../config/config\";\nimport {extend, isFunction, notEmpty} from \"../module/util\";\n\nimport apiChart from \"./api/chart\";\nimport apiColor from \"./api/color\";\nimport apiData from \"./api/data\";\nimport apiExport from \"./api/export\";\nimport apiFocus from \"./api/focus\";\nimport apiLegend from \"./api/legend\";\nimport apiLoad from \"./api/load\";\nimport apiShow from \"./api/show\";\nimport apiTooltip from \"./api/tooltip\";\n\n/**\n * Main chart class.\n * - Note: Instantiated via `bb.generate()`.\n * @class Chart\n * @example\n * var chart = bb.generate({\n *  data: {\n *    columns: [\n *        [\"x\", \"2015-11-02\", \"2015-12-01\", \"2016-01-01\", \"2016-02-01\", \"2016-03-01\"],\n *        [\"count1\", 11, 8, 7, 6, 5 ],\n *        [\"count2\", 9, 3, 6, 2, 8 ]\n *   ]}\n * }\n * @see {@link bb.generate} for the initialization.\n */\n/**\n * Access instance's primary node elements\n * @member {object} $\n * @property {object} $ Access instance's primary node elements\n * @property {d3.selection} $.chart Wrapper element\n * @property {d3.selection} $.svg Main svg element\n * @property {d3.selection} $.defs Definition element\n * @property {d3.selection} $.main Main grouping element\n * @property {d3.selection} $.needle Needle element\n *  - **NOTE:**\n *    - The element will have `bb-needle` as class name.\n *    - Will provide speical helper `.updateHelper(value: number, updateConfig: boolean)` method to facilitate needle position update.\n * @property {d3.selection} $.tooltip Tooltip element\n * @property {d3.selection} $.legend Legend element\n * @property {d3.selection} $.title Title element\n * @property {d3.selection} $.grid Grid element\n * @property {d3.selection} $.arc Arc element\n * @property {d3.selection} $.circles Data point circle elements\n * @property {object} $.bar Bar element object\n * @property {d3.selection} $.bar.bars Bar elements\n * @property {d3.selection} $.candlestick Candlestick elements\n * @property {object} $.line Line element object\n * @property {d3.selection} $.line.lines Line elements\n * @property {d3.selection} $.line.areas Areas elements\n * @property {object} $.text Text element object\n * @property {d3.selection} $.text.texts Data label text elements\n * @memberof Chart\n * @example\n * const chart = bb.generate({ ... });\n *\n * chart.$.chart; // wrapper element\n * chart.$.line.circles;  // all data point circle elements\n * @example\n * // Update arc needle position\n * const chart = bb.generate({\n *   data: {\n *     type: \"donut\"\n *   },\n *   arc: {\n *     needle: {\n *       show: true,\n *       ...\n *     }\n *   }\n * });\n *\n * chart.$.needle.updateHelper(70);  // update needle position to point value 70.\n *\n * // update needle position to point value 70 and the config value.\n * // NOTE: updating config value, will update needle pointer initial value too.\n * chart.$.needle.updateHelper(70, true);\n *\n * // update needle point position every 1 second\n * let i = 0;\n * setInterval(() => {\n *   chart.$.needle.updateHelper(i += 10);\n * }, 1000)\n */\n/**\n * Plugin instance array\n * @member {Array} plugins\n * @memberof Chart\n * @example\n *  var chart = bb.generate({\n *     ...\n *     plugins: [\n *        new bb.plugin.stanford({ ... }),\n *        new PluginA()\n *     ]\n *  });\n *\n *  chart.plugins; // [Stanford, PluginA] - instance array\n */\nexport default class Chart {\n\tpublic plugins = [];\n\tpublic internal: ChartInternal;\n\n\tconstructor(options) {\n\t\tconst $$ = new ChartInternal(this);\n\t\t// let hook = () => {};\n\n\t\tthis.internal = $$;\n\n\t\t// bind to namespaced APIs\n\t\t(function bindThis(fn, target, argThis) {\n\t\t\tObject.keys(fn).forEach(key => {\n\t\t\t\tconst isFunc = isFunction(fn[key]);\n\t\t\t\tconst isChild = target !== argThis;\n\t\t\t\tconst isNotNil = notEmpty(fn[key]);\n\t\t\t\tconst hasChild = isNotNil && Object.keys(fn[key]).length > 0;\n\t\t\t\t// const hookFn = function(...params) {\n\t\t\t\t// \thook();\n\t\t\t\t// \treturn fn[key].bind(argThis)(...params);\n\t\t\t\t// }\n\n\t\t\t\tif (isFunc && ((!isChild && hasChild) || isChild)) {\n\t\t\t\t\ttarget[key] = fn[key].bind(argThis);\n\t\t\t\t} else if (isNotNil && !isFunc) {\n\t\t\t\t\ttarget[key] = {};\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = fn[key];\n\t\t\t\t}\n\n\t\t\t\thasChild && bindThis(fn[key], target[key], argThis);\n\t\t\t});\n\t\t})(Chart.prototype, this, this);\n\n\t\tloadConfig.call($$, options);\n\n\t\t$$.beforeInit();\n\t\t$$.init();\n\n\t\t// if ($$.config.render.lazy !== false && hasStyle($$.$el.chart, {\"display\": \"none\", \"visibility\": \"hidden\"})) {\n\t\t// \thook = () => {\n\t\t// \t\tlogError(`The call of APIs won't work. Please, make sure if chart element is %cvisible.`);\n\t\t// \t};\n\t\t// }\n\t}\n}\n\n// extend common APIs as part of Chart class\nextend(Chart.prototype, [\n\tapiChart,\n\tapiColor,\n\tapiData,\n\tapiExport,\n\tapiFocus,\n\tapiLegend,\n\tapiLoad,\n\tapiShow,\n\tapiTooltip\n]);\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport type {DataItem} from \"../../../types/types\";\nimport {$AREA, $LINE, $SELECT, $SHAPE} from \"../../config/classes\";\nimport {isDefined} from \"../../module/util\";\n\n/**\n * Toggler function to select or unselect\n * @param {boolean} isSelection Weather select or unselect\n * @param {Array} ids Target ids\n * @param {Array} indices Indices number\n * @param {boolean} resetOther Weather reset other selected points (only for selection)\n * @private\n */\nfunction setSelection(\n\tisSelection = false,\n\tids?: string | string[],\n\tindices?: number[],\n\tresetOther?: boolean\n): void {\n\tconst $$ = this;\n\tconst {config, $el: {main}} = $$;\n\tconst selectionGrouped = config.data_selection_grouped;\n\tconst isSelectable = config.data_selection_isselectable.bind($$.api);\n\n\tif (!config.data_selection_enabled) {\n\t\treturn;\n\t}\n\n\tmain.selectAll(`.${$SHAPE.shapes}`)\n\t\t.selectAll(`.${$SHAPE.shape}`)\n\t\t.each(function(d) {\n\t\t\tconst shape = d3Select(this);\n\t\t\tconst {id, index} = d.data ? d.data : d;\n\t\t\tconst toggle = $$.getToggle(this, d).bind($$);\n\t\t\tconst isTargetId = selectionGrouped || !ids || ids.indexOf(id) >= 0;\n\t\t\tconst isTargetIndex = !indices || indices.indexOf(index) >= 0;\n\t\t\tconst isSelected = shape.classed($SELECT.SELECTED);\n\n\t\t\t// line/area selection not supported yet\n\t\t\tif (shape.classed($LINE.line) || shape.classed($AREA.area)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isSelection) {\n\t\t\t\tif (isTargetId && isTargetIndex && isSelectable(d) && !isSelected) {\n\t\t\t\t\ttoggle(true, shape.classed($SELECT.SELECTED, true), d, index);\n\t\t\t\t} else if (isDefined(resetOther) && resetOther && isSelected) {\n\t\t\t\t\ttoggle(false, shape.classed($SELECT.SELECTED, false), d, index);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isTargetId && isTargetIndex && isSelectable(d) && isSelected) {\n\t\t\t\t\ttoggle(false, shape.classed($SELECT.SELECTED, false), d, index);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n\nexport default {\n\t/**\n\t * Get selected data points.<br><br>\n\t * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.\n\t * @function selected\n\t * @instance\n\t * @memberof Chart\n\t * @param {string} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.\n\t * @returns {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: \"data1\", index: 1, name: \"data1\"}, ...]`\n\t * @example\n\t *  // all selected data points will be returned.\n\t *  chart.selected();\n\t *  // --> ex.) [{x: 1, value: 200, id: \"data1\", index: 1, name: \"data1\"}, ... ]\n\t *\n\t *  // all selected data points of data1 will be returned.\n\t *  chart.selected(\"data1\");\n\t */\n\tselected(targetId?: string): DataItem[] {\n\t\tconst $$ = this.internal;\n\t\tconst dataPoint: DataItem[] = [];\n\n\t\t$$.$el.main.selectAll(`.${$SHAPE.shapes + $$.getTargetSelectorSuffix(targetId)}`)\n\t\t\t.selectAll(`.${$SHAPE.shape}`)\n\t\t\t.filter(function() {\n\t\t\t\treturn d3Select(this).classed($SELECT.SELECTED);\n\t\t\t})\n\t\t\t.each(d => dataPoint.push(d));\n\n\t\treturn dataPoint;\n\t},\n\n\t/**\n\t * Set data points to be selected. ([`data.selection.enabled`](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)\n\t * @function select\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} [ids] id value to get selected.\n\t * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.\n\t * @param {boolean} [resetOther] Unselect already selected.\n\t * @example\n\t *  // select all data points\n\t *  chart.select();\n\t *\n\t *  // select all from 'data2'\n\t *  chart.select(\"data2\");\n\t *\n\t *  // select all from 'data1' and 'data2'\n\t *  chart.select([\"data1\", \"data2\"]);\n\t *\n\t *  // select from 'data1', indices 2 and unselect others selected\n\t *  chart.select(\"data1\", [2], true);\n\t *\n\t *  // select from 'data1', indices 0, 3 and 5\n\t *  chart.select(\"data1\", [0, 3, 5]);\n\t */\n\tselect(ids?: string[] | string, indices?: number[], resetOther?: boolean): void {\n\t\tconst $$ = this.internal;\n\n\t\tsetSelection.bind($$)(true, ids, indices, resetOther);\n\t},\n\n\t/**\n\t * Set data points to be un-selected.\n\t * @function unselect\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|Array} [ids] id value to be unselected.\n\t * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.\n\t * @example\n\t *  // unselect all data points\n\t *  chart.unselect();\n\t *\n\t *  // unselect all from 'data1'\n\t *  chart.unselect(\"data1\");\n\t *\n\t *  // unselect from 'data1', indices 2\n\t *  chart.unselect(\"data1\", [2]);\n\t */\n\tunselect(ids?: string | string[], indices?: number[]): void {\n\t\tconst $$ = this.internal;\n\n\t\tsetSelection.bind($$)(false, ids, indices);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {TDomain} from \"../../ChartInternal/data/IData\";\nimport {$COMMON} from \"../../config/classes\";\nimport {extend, parseDate} from \"../../module/util\";\n\n/**\n * Select subchart by giving x domain range.\n * - **ℹ️ NOTE:**\n *  - Due to the limitations of floating point precision, domain value may not be exact returning approximately values.\n * @function subchart\n * @instance\n * @memberof Chart\n * @param {Array} domainValue If domain range is given, the subchart will be seleted to the given domain. If no argument is given, the current subchart selection domain will be returned.\n * @returns {Array} domain value in array\n * @example\n *  // Specify domain for subchart selection\n *  chart.subchart([1, 2]);\n *\n *  // Get the current subchart selection domain range\n *  // Domain value may not be exact returning approximately values.\n *  chart.subchart();\n */\n// NOTE: declared funciton assigning to variable to prevent duplicated method generation in JSDoc.\nconst subchart = function<T = TDomain[]>(domainValue?: T): T | undefined {\n\tconst $$ = this.internal;\n\tconst {axis, brush, config, scale: {x, subX}, state} = $$;\n\tlet domain;\n\n\tif (config.subchart_show) {\n\t\tdomain = domainValue;\n\n\t\tif (Array.isArray(domain)) {\n\t\t\tif (axis.isTimeSeries()) {\n\t\t\t\tdomain = domain.map(x => parseDate.bind($$)(x));\n\t\t\t}\n\n\t\t\tconst isWithinRange = $$.withinRange(\n\t\t\t\tdomain,\n\t\t\t\t$$.getZoomDomain(\"subX\", true),\n\t\t\t\t$$.getZoomDomain(\"subX\")\n\t\t\t);\n\n\t\t\tif (isWithinRange) {\n\t\t\t\tstate.domain = domain;\n\n\t\t\t\tbrush.move(\n\t\t\t\t\tbrush.getSelection(),\n\t\t\t\t\tdomain.map(subX)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tdomain = state.domain ?? x.orgDomain();\n\t\t}\n\t}\n\n\treturn domain as T;\n};\n\nextend(subchart, {\n\t/**\n\t * Show subchart\n\t * - **NOTE:** for ESM imports, needs to import 'subchart' exports and instantiate it by calling `subchart()`.\n\t * @function subchart․show\n\t * @instance\n\t * @memberof Chart\n\t * @example\n\t * // for ESM imports, needs to import 'subchart' and must be instantiated first to enable subchart's API.\n\t * import {subchart} from \"billboard.js\";\n\t *\n\t * const chart = bb.generate({\n\t *   ...\n\t *   subchart: {\n\t *      // need to be instantiated by calling 'subchart()'\n\t *      enabled: subchart()\n\t *\n\t *      // in case don't want subchart to be shown at initialization, instantiate with '!subchart()'\n\t *      enabled: !subchart()\n\t *   }\n\t * });\n\t *\n\t * chart.subchart.show();\n\t */\n\tshow(): void {\n\t\tconst $$ = this.internal;\n\t\tconst {$el: {subchart}, config} = $$;\n\t\tconst show = config.subchart_show;\n\n\t\tif (!show) {\n\t\t\t// unbind zoom event bound to chart rect area\n\t\t\t$$.unbindZoomEvent();\n\n\t\t\tconfig.subchart_show = !show;\n\t\t\t!subchart.main && $$.initSubchart();\n\n\t\t\tlet $target = subchart.main.selectAll(`.${$COMMON.target}`);\n\n\t\t\t// need to cover when new data has been loaded\n\t\t\tif ($$.data.targets.length !== $target.size()) {\n\t\t\t\t$$.updateSizes();\n\t\t\t\t$$.updateTargetsForSubchart($$.data.targets);\n\n\t\t\t\t$target = subchart.main?.selectAll(`.${$COMMON.target}`);\n\t\t\t}\n\n\t\t\t$target?.style(\"opacity\", null);\n\t\t\tsubchart.main?.style(\"display\", null);\n\n\t\t\tthis.resize();\n\t\t}\n\t},\n\n\t/**\n\t * Hide generated subchart\n\t * - **NOTE:** for ESM imports, needs to import 'subchart' exports and instantiate it by calling `subchart()`.\n\t * @function subchart․hide\n\t * @instance\n\t * @memberof Chart\n\t * @example\n\t *  chart.subchart.hide();\n\t */\n\thide(): void {\n\t\tconst $$ = this.internal;\n\t\tconst {$el: {subchart: {main}}, config} = $$;\n\n\t\tif (config.subchart_show && main?.style(\"display\") !== \"none\") {\n\t\t\tconfig.subchart_show = false;\n\t\t\tmain.style(\"display\", \"none\");\n\n\t\t\tthis.resize();\n\t\t}\n\t},\n\n\t/**\n\t * Toggle the visiblity of subchart\n\t * - **NOTE:** for ESM imports, needs to import 'subchart' exports and instantiate it by calling `subchart()`.\n\t * @function subchart․toggle\n\t * @instance\n\t * @memberof Chart\n\t * @example\n\t * // When subchart is hidden, will be shown\n\t * // When subchart is shown, will be hidden\n\t * chart.subchart.toggle();\n\t */\n\ttoggle(): void {\n\t\tconst $$ = this.internal;\n\t\tconst {config} = $$;\n\n\t\tthis.subchart[config.subchart_show ? \"hide\" : \"show\"]();\n\t},\n\n\t/**\n\t * Reset subchart selection\n\t * @function subchart․reset\n\t * @instance\n\t * @memberof Chart\n\t * @example\n\t * // Reset subchart selection\n\t * chart.subchart.reset();\n\t */\n\treset(): void {\n\t\tconst $$ = this.internal;\n\t\tconst {brush} = $$;\n\n\t\tbrush.clear(brush.getSelection());\n\t}\n});\n\nexport default {\n\tsubchart\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {zoomIdentity as d3ZoomIdentity, zoomTransform as d3ZoomTransform} from \"d3-zoom\";\nimport type {TDomainRange} from \"../../ChartInternal/data/IData\";\nimport {extend, getMinMax, isDefined, isObject, parseDate} from \"../../module/util\";\n\n/**\n * Zoom by giving x domain range.\n * - **ℹ️ NOTE:**\n *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain range. To get the initial state, [.unzoom()](#unzoom) should be called.\n *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.\n *  - When x axis type is `category`, domain range should be specified as index numbers.\n *  - Due to the limitations of floating point precision, domain value may not be exact returning approximately values.\n * @function zoom\n * @instance\n * @memberof Chart\n * @param {Array} domainValue If domain range is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.\n * @returns {Array} domain value in array\n * @example\n *  // Zoom to specified domain range\n *  chart.zoom([10, 20]);\n *\n *  // For timeseries x axis, the domain value can be string, but the format should match with the 'data.xFormat' option.\n *  chart.zoom([\"2021-02-03\", \"2021-02-08\"]);\n *\n *  // For category x axis, the domain value should be index number.\n *  chart.zoom([0, 3]);\n *\n *  // Get the current zoomed domain range\n *  // Domain value may not be exact returning approximately values.\n *  chart.zoom();\n */\n// NOTE: declared funciton assigning to variable to prevent duplicated method generation in JSDoc.\nconst zoom = function<T = TDomainRange>(domainValue?: T): T | undefined {\n\tconst $$ = this.internal;\n\tconst {axis, config, org, scale, state} = $$;\n\tconst isCategorized = axis.isCategorized();\n\tlet domain;\n\n\tif (config.zoom_enabled) {\n\t\tdomain = domainValue;\n\n\t\tif (Array.isArray(domain)) {\n\t\t\tif (axis.isTimeSeries()) {\n\t\t\t\tdomain = domain.map(x => parseDate.bind($$)(x));\n\t\t\t}\n\n\t\t\tconst isWithinRange = $$.withinRange(\n\t\t\t\tdomain,\n\t\t\t\t$$.getZoomDomain(\"zoom\", true),\n\t\t\t\t$$.getZoomDomain(\"zoom\")\n\t\t\t);\n\n\t\t\tif (isWithinRange) {\n\t\t\t\tstate.domain = domain;\n\n\t\t\t\tdomain = $$.getZoomDomainValue(domain);\n\n\t\t\t\t// hide any possible tooltip show before the zoom\n\t\t\t\t$$.api.tooltip.hide();\n\n\t\t\t\tif (config.subchart_show) {\n\t\t\t\t\tconst x = scale.zoom || scale.x;\n\n\t\t\t\t\t$$.brush.getSelection().call($$.brush.move, domain.map(x));\n\t\t\t\t\t// resultDomain = domain;\n\t\t\t\t} else {\n\t\t\t\t\t// in case of 'config.zoom_rescale=true', use org.xScale\n\t\t\t\t\tconst x = isCategorized ? scale.x.orgScale() : (org.xScale || scale.x);\n\n\t\t\t\t\t$$.updateCurrentZoomTransform(x, domain);\n\t\t\t\t}\n\n\t\t\t\t$$.setZoomResetButton();\n\t\t\t}\n\t\t} else {\n\t\t\tdomain = $$.zoom.getDomain();\n\t\t}\n\t}\n\n\treturn state.domain ?? domain;\n};\n\nextend(zoom, {\n\t/**\n\t * Enable and disable zooming.\n\t * @function zoom․enable\n\t * @instance\n\t * @memberof Chart\n\t * @param {string|boolean} enabled Possible string values are \"wheel\" or \"drag\". If enabled is true, \"wheel\" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.\n\t * @example\n\t *  // Enable zooming using the mouse wheel\n\t *  chart.zoom.enable(true);\n\t *  // Or\n\t *  chart.zoom.enable(\"wheel\");\n\t *\n\t *  // Enable zooming by dragging\n\t *  chart.zoom.enable(\"drag\");\n\t *\n\t *  // Disable zooming\n\t *  chart.zoom.enable(false);\n\t */\n\tenable(enabled: boolean | \"wheel\" | \"drag\" | any): void {\n\t\tconst $$ = this.internal;\n\t\tconst {config} = $$;\n\n\t\tif (/^(drag|wheel)$/.test(enabled)) {\n\t\t\tconfig.zoom_type = enabled;\n\t\t}\n\n\t\tconfig.zoom_enabled = !!enabled;\n\n\t\tif (!$$.zoom) {\n\t\t\t$$.initZoom();\n\t\t\t$$.bindZoomEvent();\n\t\t} else if (enabled === false) {\n\t\t\t$$.bindZoomEvent(false);\n\t\t}\n\n\t\t$$.updateAndRedraw();\n\t},\n\n\t/**\n\t * Set or get x Axis maximum zoom range value\n\t * @function zoom․max\n\t * @instance\n\t * @memberof Chart\n\t * @param {number} [max] maximum value to set for zoom\n\t * @returns {number} zoom max value\n\t * @example\n\t *  // Set maximum range value\n\t *  chart.zoom.max(20);\n\t */\n\tmax(max?: number): number {\n\t\tconst $$ = this.internal;\n\t\tconst {config, org: {xDomain}} = $$;\n\n\t\tif (max === 0 || max) {\n\t\t\tconfig.zoom_x_max = getMinMax(\"max\", [xDomain[1], max]);\n\t\t}\n\n\t\treturn config.zoom_x_max;\n\t},\n\n\t/**\n\t * Set or get x Axis minimum zoom range value\n\t * @function zoom․min\n\t * @instance\n\t * @memberof Chart\n\t * @param {number} [min] minimum value to set for zoom\n\t * @returns {number} zoom min value\n\t * @example\n\t *  // Set minimum range value\n\t *  chart.zoom.min(-1);\n\t */\n\tmin(min?: number): number {\n\t\tconst $$ = this.internal;\n\t\tconst {config, org: {xDomain}} = $$;\n\n\t\tif (min === 0 || min) {\n\t\t\tconfig.zoom_x_min = getMinMax(\"min\", [xDomain[0], min]);\n\t\t}\n\n\t\treturn config.zoom_x_min;\n\t},\n\n\t/**\n\t * Set zoom range\n\t * @function zoom․range\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} [range] zoom range\n\t * @returns {object} zoom range value\n\t * {\n\t *   min: 0,\n\t *   max: 100\n\t * }\n\t * @example\n\t *  chart.zoom.range({\n\t *      min: 10,\n\t *      max: 100\n\t *  });\n\t */\n\trange(range): {min: (number | undefined)[], max: (number | undefined)[]} {\n\t\tconst zoom = this.zoom;\n\n\t\tif (isObject(range)) {\n\t\t\tconst {min, max} = range;\n\n\t\t\tisDefined(min) && zoom.min(min);\n\t\t\tisDefined(max) && zoom.max(max);\n\t\t}\n\n\t\treturn {\n\t\t\tmin: zoom.min(),\n\t\t\tmax: zoom.max()\n\t\t};\n\t}\n});\n\nexport default {\n\tzoom,\n\n\t/**\n\t * Unzoom zoomed area\n\t * - **NOTE:** Calling .unzoom() will not trigger zoom events.\n\t * @function unzoom\n\t * @instance\n\t * @memberof Chart\n\t * @example\n\t *  chart.unzoom();\n\t */\n\tunzoom(): void {\n\t\tconst $$ = this.internal;\n\t\tconst {config, $el: {eventRect, zoomResetBtn}, scale: {zoom}, state} = $$;\n\n\t\tif (zoom) {\n\t\t\tconfig.subchart_show ?\n\t\t\t\t$$.brush.getSelection().call($$.brush.move, null) :\n\t\t\t\t$$.zoom.updateTransformScale(d3ZoomIdentity);\n\n\t\t\t$$.updateZoom(true);\n\t\t\tzoomResetBtn?.style(\"display\", \"none\");\n\n\t\t\t// reset transform\n\t\t\tif (d3ZoomTransform(eventRect.node()) !== d3ZoomIdentity) {\n\t\t\t\t$$.zoom.transform(eventRect, d3ZoomIdentity);\n\t\t\t}\n\n\t\t\tstate.domain = undefined;\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {brushSelection as d3BrushSelection, brushX as d3BrushX, brushY as d3BrushY} from \"d3-brush\";\nimport {select as d3Select} from \"d3-selection\";\nimport CLASS from \"../../config/classes\";\nimport {brushEmpty, capitalize, isArray} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Initialize the brush.\n\t * @private\n\t */\n\tinitBrush(): void {\n\t\tconst $$ = this;\n\t\tconst {config, scale, $el: {subchart}, state} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst height = config.subchart_size_height;\n\t\tlet lastDomain;\n\t\tlet lastSelection;\n\t\tlet timeout;\n\n\t\t// set the brush\n\t\t$$.brush = (\n\t\t\tisRotated ? d3BrushY() : d3BrushX()\n\t\t).handleSize(5);\n\n\t\t// bind brush event\n\t\t$$.brush.on(\"start brush end\", event => {\n\t\t\tconst {selection, sourceEvent, target, type} = event;\n\n\t\t\tif (type === \"start\") {\n\t\t\t\t$$.state.inputType === \"touch\" && $$.hideTooltip();\n\t\t\t\tlastSelection = sourceEvent ? selection : null;\n\t\t\t\t// sourceEvent && (state.domain = null);\n\t\t\t}\n\n\t\t\t// if (type === \"brush\") {\n\t\t\tif (/(start|brush)/.test(type)) {\n\t\t\t\t// when brush selection updates happens on one edge, update only chainging edge and\n\t\t\t\t// is only for adjustment of given domain range to be used to return current domain range.\n\t\t\t\ttype === \"brush\" && sourceEvent && state.domain &&\n\t\t\t\t\tlastSelection?.forEach((v, i) => {\n\t\t\t\t\t\tif (v !== selection[i]) {\n\t\t\t\t\t\t\tstate.domain[i] = scale.x.orgDomain()[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t$$.redrawForBrush(type !== \"start\");\n\t\t\t}\n\n\t\t\tif (type === \"end\") {\n\t\t\t\tlastDomain = scale.x.orgDomain();\n\t\t\t}\n\n\t\t\t// handle brush's handle position & visibility\n\t\t\tif (target?.handle) {\n\t\t\t\tif (selection === null) {\n\t\t\t\t\t$$.brush.handle.attr(\"display\", \"none\");\n\t\t\t\t} else {\n\t\t\t\t\t$$.brush.handle.attr(\"display\", null)\n\t\t\t\t\t\t.attr(\"transform\", (d, i) => {\n\t\t\t\t\t\t\tconst pos = [selection[i], height / 2];\n\n\t\t\t\t\t\t\treturn `translate(${isRotated ? pos.reverse() : pos})`;\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$$.brush.updateResize = function() {\n\t\t\ttimeout && clearTimeout(timeout);\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tconst selection = this.getSelection();\n\n\t\t\t\tlastDomain && d3BrushSelection(selection.node()) &&\n\t\t\t\t\tthis.move(selection, lastDomain.map(scale.subX.orgScale()));\n\t\t\t}, 0);\n\t\t};\n\n\t\t$$.brush.update = function() {\n\t\t\tconst extent = this.extent()();\n\n\t\t\tif (extent[1].filter(v => isNaN(v)).length === 0) {\n\t\t\t\tsubchart.main?.select(`.${CLASS.brush}`).call(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t// set the brush extent\n\t\t$$.brush.scale = function(scale) {\n\t\t\tconst h = config.subchart_size_height;\n\t\t\tlet extent = $$.axis.getExtent();\n\n\t\t\tif (!extent && scale.range) {\n\t\t\t\textent = [[0, 0], [scale.range()[1], h]];\n\t\t\t} else if (isArray(extent)) {\n\t\t\t\textent = extent.map((v, i) => [v, i > 0 ? h : i]);\n\t\t\t}\n\n\t\t\t// [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner\n\t\t\tisRotated && extent[1].reverse();\n\t\t\tthis.extent(extent);\n\n\t\t\t// when extent updates, brush selection also be re-applied\n\t\t\t// https://github.com/d3/d3/issues/2918\n\t\t\tthis.update();\n\t\t};\n\n\t\t$$.brush.getSelection = () => (\n\t\t\t// @ts-ignore\n\t\t\tsubchart.main ? subchart.main.select(`.${CLASS.brush}`) : d3Select([])\n\t\t);\n\t},\n\n\t/**\n\t * Initialize the subchart.\n\t * @private\n\t */\n\tinitSubchart(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {clip, hasAxis}, $el: {defs, svg, subchart, axis}} = $$;\n\n\t\tif (!hasAxis) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst visibility = config.subchart_show ? null : \"hidden\";\n\t\tconst clipId = `${clip.id}-subchart`;\n\t\tconst clipPath = $$.getClipPath(clipId);\n\n\t\tclip.idSubchart = clipId;\n\t\t$$.appendClip(defs, clipId);\n\t\t$$.initBrush();\n\n\t\tsubchart.main = svg.append(\"g\")\n\t\t\t.classed(CLASS.subchart, true)\n\t\t\t.attr(\"transform\", $$.getTranslate(\"context\"));\n\n\t\tconst {main} = subchart;\n\n\t\tmain.style(\"visibility\", visibility);\n\n\t\t// Define g for chart area\n\t\tmain.append(\"g\")\n\t\t\t.attr(\"clip-path\", clipPath)\n\t\t\t.attr(\"class\", CLASS.chart);\n\n\t\t// Define g for chart types area\n\t\t[\"bar\", \"line\", \"bubble\", \"candlestick\", \"scatter\"].forEach(v => {\n\t\t\tconst type = capitalize(/^(bubble|scatter)$/.test(v) ? \"circle\" : v);\n\n\t\t\tif ($$.hasType(v) || $$.hasTypeOf(type)) {\n\t\t\t\tconst chart = main.select(`.${CLASS.chart}`);\n\t\t\t\tconst chartClassName = CLASS[`chart${type}s`];\n\n\t\t\t\tif (chart.select(`.${chartClassName}`).empty()) {\n\t\t\t\t\tchart\n\t\t\t\t\t\t.append(\"g\")\n\t\t\t\t\t\t.attr(\"class\", chartClassName);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Add extent rect for Brush\n\t\tconst brush = main.append(\"g\")\n\t\t\t.attr(\"clip-path\", clipPath)\n\t\t\t.attr(\"class\", CLASS.brush)\n\t\t\t.call($$.brush);\n\n\t\tconfig.subchart_showHandle && $$.addBrushHandle(brush);\n\n\t\t// ATTENTION: This must be called AFTER chart added\n\t\t// Add Axis\n\t\taxis.subX = main.append(\"g\")\n\t\t\t.attr(\"class\", CLASS.axisX)\n\t\t\t.attr(\"transform\", $$.getTranslate(\"subX\"))\n\t\t\t.attr(\"clip-path\", config.axis_rotated ? \"\" : clip.pathXAxis)\n\t\t\t.style(\"visibility\", config.subchart_axis_x_show ? visibility : \"hidden\");\n\t},\n\n\t/**\n\t * Add brush handle\n\t * Enabled when: subchart.showHandle=true\n\t * @param {d3Selection} brush Brush selection\n\t * @private\n\t */\n\taddBrushHandle(brush): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst initRange = config.subchart_init_range;\n\t\tconst customHandleClass = \"handle--custom\";\n\n\t\t// brush handle shape's path\n\t\tconst path = isRotated ?\n\t\t\t[\n\t\t\t\t\"M8.5 0 a6 6 0 0 0 -6 -6.5 H-2.5 a 6 6 0 0 0 -6 6.5 z m-5 -2 H-3.5 m7 -2 H-3.5z\",\n\t\t\t\t\"M8.5 0 a6 -6 0 0 1 -6 6.5 H-2.5 a 6 -6 0 0 1 -6 -6.5z m-5 2 H-3.5 m7 2 H-3.5z\"\n\t\t\t] :\n\t\t\t[\n\t\t\t\t\"M0 -8.5 A6 6 0 0 0 -6.5 -3.5 V2.5 A6 6 0 0 0 0 8.5 Z M-2 -3.5 V3.5 M-4 -3.5 V3.5z\",\n\t\t\t\t\"M0 -8.5 A6 6 0 0 1 6.5 -3.5 V2.5 A6 6 0 0 1 0 8.5 Z M2 -3.5 V3.5 M4 -3.5 V3.5z\"\n\t\t\t];\n\n\t\t$$.brush.handle = brush.selectAll(`.${customHandleClass}`)\n\t\t\t.data(isRotated ? [{type: \"n\"}, {type: \"s\"}] : [{type: \"w\"}, {type: \"e\"}])\n\t\t\t.enter()\n\t\t\t.append(\"path\")\n\t\t\t.attr(\"class\", customHandleClass)\n\t\t\t.attr(\"cursor\", `${isRotated ? \"ns\" : \"ew\"}-resize`)\n\t\t\t.attr(\"d\", d => path[+/[se]/.test(d.type)])\n\t\t\t.attr(\"display\", initRange ? null : \"none\");\n\t},\n\n\t/**\n\t * Update sub chart\n\t * @param {object} targets $$.data.targets\n\t * @private\n\t */\n\tupdateTargetsForSubchart(targets): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {subchart: {main}}} = $$;\n\n\t\tif (config.subchart_show) {\n\t\t\t[\"bar\", \"line\", \"bubble\", \"candlestick\", \"scatter\"]\n\t\t\t\t.filter(v => $$.hasType(v) || $$.hasTypeOf(capitalize(v)))\n\t\t\t\t.forEach(v => {\n\t\t\t\t\tconst isPointType = /^(bubble|scatter)$/.test(v);\n\t\t\t\t\tconst name = capitalize(isPointType ? \"circle\" : v);\n\t\t\t\t\tconst chartClass = $$.getChartClass(name, true);\n\t\t\t\t\tconst shapeClass = $$.getClass(isPointType ? \"circles\" : `${v}s`, true);\n\n\t\t\t\t\tconst shapeChart = main.select(`.${CLASS[`chart${`${name}s`}`]}`);\n\n\t\t\t\t\tif (isPointType) {\n\t\t\t\t\t\tconst circle = shapeChart\n\t\t\t\t\t\t\t.selectAll(`.${CLASS.circles}`)\n\t\t\t\t\t\t\t.data(targets.filter($$[`is${capitalize(v)}Type`].bind($$)))\n\t\t\t\t\t\t\t.attr(\"class\", shapeClass);\n\n\t\t\t\t\t\tcircle.exit().remove();\n\t\t\t\t\t\tcircle.enter().append(\"g\")\n\t\t\t\t\t\t\t.attr(\"class\", shapeClass);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst shapeUpdate = shapeChart\n\t\t\t\t\t\t\t.selectAll(`.${CLASS[`chart${name}`]}`)\n\t\t\t\t\t\t\t.attr(\"class\", chartClass)\n\t\t\t\t\t\t\t.data(targets.filter($$[`is${name}Type`].bind($$)));\n\n\t\t\t\t\t\tconst shapeEnter = shapeUpdate.enter()\n\t\t\t\t\t\t\t.append(\"g\")\n\t\t\t\t\t\t\t.style(\"opacity\", \"0\")\n\t\t\t\t\t\t\t.attr(\"class\", chartClass)\n\t\t\t\t\t\t\t.append(\"g\")\n\t\t\t\t\t\t\t.attr(\"class\", shapeClass);\n\n\t\t\t\t\t\tshapeUpdate.exit().remove();\n\n\t\t\t\t\t\t// Area\n\t\t\t\t\t\tv === \"line\" && $$.hasTypeOf(\"Area\") &&\n\t\t\t\t\t\t\tshapeEnter.append(\"g\").attr(\"class\", $$.getClass(\"areas\", true));\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t// -- Brush --//\n\t\t\tmain.selectAll(`.${CLASS.brush} rect`)\n\t\t\t\t.attr(config.axis_rotated ? \"width\" : \"height\",\n\t\t\t\t\tconfig.axis_rotated ? state.width2 : state.height2);\n\t\t}\n\t},\n\n\t/**\n\t * Redraw subchart.\n\t * @private\n\t * @param {boolean} withSubchart whether or not to show subchart\n\t * @param {number} duration duration\n\t * @param {object} shape Shape's info\n\t */\n\tredrawSubchart(withSubchart: boolean, duration: number, shape): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {subchart: {main}}, state} = $$;\n\t\tconst withTransition = !!duration;\n\n\t\tmain.style(\"visibility\", config.subchart_show ? null : \"hidden\");\n\n\t\t// subchart\n\t\tif (config.subchart_show) {\n\t\t\t// reflect main chart to extent on subchart if zoomed\n\t\t\tif (state.event?.type === \"zoom\") {\n\t\t\t\t$$.brush.update();\n\t\t\t}\n\n\t\t\t// update subchart elements if needed\n\t\t\tif (withSubchart) {\n\t\t\t\tconst initRange = config.subchart_init_range;\n\n\t\t\t\t// extent rect\n\t\t\t\t!brushEmpty($$) && $$.brush.update();\n\n\t\t\t\tObject.keys(shape.type).forEach(v => {\n\t\t\t\t\tconst name = capitalize(v);\n\t\t\t\t\tconst drawFn = $$[`generateDraw${name}`](shape.indices[v], true);\n\n\t\t\t\t\t// call shape's update & redraw method\n\t\t\t\t\t$$[`update${name}`](withTransition, true);\n\t\t\t\t\t$$[`redraw${name}`](drawFn, withTransition, true);\n\t\t\t\t});\n\n\t\t\t\tif ($$.hasType(\"bubble\") || $$.hasType(\"scatter\")) {\n\t\t\t\t\tconst {cx} = shape.pos;\n\t\t\t\t\tconst cy = $$.updateCircleY(true);\n\n\t\t\t\t\t$$.updateCircle(true);\n\t\t\t\t\t$$.redrawCircle(cx, cy, withTransition, undefined, true);\n\t\t\t\t}\n\n\t\t\t\tif (!state.rendered && initRange) {\n\t\t\t\t\tstate.domain = initRange;\n\n\t\t\t\t\t$$.brush.move(\n\t\t\t\t\t\t$$.brush.getSelection(),\n\t\t\t\t\t\tinitRange.map($$.scale.x)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Redraw the brush.\n\t * @param {boolean} [callCallbck=true] Call 'onbrush' callback or not.\n\t * @private\n\t */\n\tredrawForBrush(callCallbck = true): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\tconfig: {\n\t\t\t\tsubchart_onbrush: onBrush,\n\t\t\t\tzoom_rescale: withY\n\t\t\t},\n\t\t\tscale,\n\t\t\tstate\n\t\t} = $$;\n\n\t\t$$.redraw({\n\t\t\twithTransition: false,\n\t\t\twithY,\n\t\t\twithSubchart: false,\n\t\t\twithUpdateXDomain: true,\n\t\t\twithDimension: false\n\t\t});\n\n\t\tcallCallbck && state.rendered &&\n\t\t\tonBrush.bind($$.api)(state.domain ?? scale.x.orgDomain());\n\t},\n\n\t/**\n\t * Transform context\n\t * @param {boolean} withTransition indicates transition is enabled\n\t * @param {object} transitions The return value of the generateTransitions method of Axis.\n\t * @private\n\t */\n\ttransformContext(withTransition, transitions): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {subchart}, $T} = $$;\n\n\t\tconst subXAxis = transitions?.axisSubX ?\n\t\t\ttransitions.axisSubX :\n\t\t\t$T(subchart.main.select(`.${CLASS.axisX}`), withTransition);\n\n\t\tsubchart.main.attr(\"transform\", $$.getTranslate(\"context\"));\n\t\tsubXAxis.attr(\"transform\", $$.getTranslate(\"subX\"));\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {drag as d3Drag} from \"d3-drag\";\nimport {\n\tzoom as d3Zoom,\n\tzoomIdentity as d3ZoomIdentity,\n\tzoomTransform as d3ZoomTransform\n} from \"d3-zoom\";\nimport {$COMMON, $ZOOM} from \"../../config/classes\";\nimport {window} from \"../../module/browser\";\nimport {callFn, diffDomain, getPointer, isFunction} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Initialize zoom.\n\t * @private\n\t */\n\tinitZoom(): void {\n\t\tconst $$ = this;\n\n\t\t$$.scale.zoom = null;\n\n\t\t$$.generateZoom();\n\n\t\t$$.config.zoom_type === \"drag\" &&\n\t\t\t$$.initZoomBehaviour();\n\t},\n\n\t/**\n\t * Bind zoom event\n\t * @param {boolean} bind Weather bind or unbound\n\t * @private\n\t */\n\tbindZoomEvent(bind = true): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst zoomEnabled = config.zoom_enabled;\n\n\t\tif (zoomEnabled && bind) {\n\t\t\t// Do not bind zoom event when subchart is shown\n\t\t\t!config.subchart_show &&\n\t\t\t\t$$.bindZoomOnEventRect();\n\t\t} else if (bind === false) {\n\t\t\t$$.api.unzoom();\n\t\t\t$$.unbindZoomEvent();\n\t\t}\n\t},\n\n\t/**\n\t * Generate zoom\n\t * @private\n\t */\n\tgenerateZoom(): void {\n\t\tconst $$ = this;\n\t\tconst {config, org, scale} = $$;\n\n\t\tconst zoom = d3Zoom().duration(0)\n\t\t\t.on(\"start\", $$.onZoomStart.bind($$))\n\t\t\t.on(\"zoom\", $$.onZoom.bind($$))\n\t\t\t.on(\"end\", $$.onZoomEnd.bind($$));\n\n\t\t// get zoom extent\n\t\t// @ts-ignore\n\t\tzoom.orgScaleExtent = (): [number, number] => {\n\t\t\tconst extent = config.zoom_extent || [1, 10];\n\n\t\t\treturn [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];\n\t\t};\n\n\t\t// @ts-ignore\n\t\tzoom.updateScaleExtent = function() {\n\t\t\tconst ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain());\n\t\t\tconst extent = this.orgScaleExtent();\n\n\t\t\t// https://d3js.org/d3-zoom#zoom_scaleExtent\n\t\t\tthis.scaleExtent([extent[0] * ratio, extent[1] * ratio]);\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t * Update scale according zoom transform value\n\t\t * @param {object} transform transform object\n\t\t * @param {boolean} correctTransform if the d3 transform should be updated after rescaling\n\t\t * @private\n\t\t */\n\t\t// @ts-ignore\n\t\tzoom.updateTransformScale = (transform: d3ZoomTransform,\n\t\t\tcorrectTransform: boolean): void => {\n\t\t\tconst isRotated = config.axis_rotated;\n\n\t\t\t// in case of resize, update range of orgXScale\n\t\t\torg.xScale?.range(scale.x.range());\n\n\t\t\t// rescale from the original scale\n\t\t\tconst newScale = transform[\n\t\t\t\tisRotated ? \"rescaleY\" : \"rescaleX\"\n\t\t\t](org.xScale || scale.x);\n\n\t\t\t// prevent drag zoom to be out of range\n\t\t\tif (newScale.domain().some(v => /(Invalid Date|NaN)/.test(v.toString()))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst domain = $$.trimXDomain(newScale.domain());\n\t\t\tconst rescale = config.zoom_rescale;\n\n\t\t\tnewScale.domain(domain, org.xDomain);\n\n\t\t\t// prevent chart from panning off the edge and feeling \"stuck\"\n\t\t\t// https://github.com/naver/billboard.js/issues/2588\n\t\t\tif (correctTransform) {\n\t\t\t\tconst t = newScale(scale.x.domain()[0]);\n\t\t\t\tconst tX = isRotated ? transform.x : t;\n\t\t\t\tconst tY = isRotated ? t : transform.y;\n\n\t\t\t\t$$.$el.eventRect.property(\"__zoom\",\n\t\t\t\t\td3ZoomIdentity.translate(tX, tY).scale(transform.k));\n\t\t\t}\n\n\t\t\tif (!$$.state.xTickOffset) {\n\t\t\t\t$$.state.xTickOffset = $$.axis.x.tickOffset();\n\t\t\t}\n\n\t\t\tscale.zoom = $$.getCustomizedXScale(newScale);\n\t\t\t$$.axis.x.scale(scale.zoom);\n\n\t\t\tif (rescale) {\n\t\t\t\t// copy current initial x scale in case of rescale option is used\n\t\t\t\t!org.xScale && (org.xScale = scale.x.copy());\n\t\t\t\tscale.x.domain(domain);\n\t\t\t} else if (org.xScale) {\n\t\t\t\tscale.x.domain(org.xScale.domain());\n\t\t\t\torg.xScale = null;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Get zoom domain\n\t\t * @returns {Array} zoom domain\n\t\t * @private\n\t\t */\n\t\t// @ts-ignore\n\t\tzoom.getDomain = (): (number | Date)[] => {\n\t\t\tconst domain = scale[scale.zoom ? \"zoom\" : \"subX\"].domain();\n\t\t\tconst isCategorized = $$.axis.isCategorized();\n\n\t\t\tif (isCategorized) {\n\t\t\t\tdomain[1] -= 2;\n\t\t\t}\n\n\t\t\treturn domain;\n\t\t};\n\n\t\t$$.zoom = zoom;\n\t},\n\n\t/**\n\t * 'start' event listener\n\t * @param {object} event Event object\n\t * @private\n\t */\n\tonZoomStart(event): void {\n\t\tconst $$ = this;\n\t\tconst {sourceEvent} = event;\n\n\t\tif (sourceEvent) {\n\t\t\t$$.zoom.startEvent = sourceEvent;\n\t\t\t$$.state.zooming = true;\n\t\t\tcallFn($$.config.zoom_onzoomstart, $$.api, event);\n\t\t}\n\t},\n\n\t/**\n\t * 'zoom' event listener\n\t * @param {object} event Event object\n\t * @private\n\t */\n\tonZoom(event): void {\n\t\tconst $$ = this;\n\t\tconst {config, scale, state, org} = $$;\n\t\tconst {sourceEvent} = event;\n\t\tconst isUnZoom = event?.transform === d3ZoomIdentity;\n\n\t\tif (\n\t\t\t!config.zoom_enabled ||\n\t\t\t$$.filterTargetsToShow($$.data.targets).length === 0 ||\n\t\t\t(!scale.zoom && sourceEvent?.type.indexOf(\"touch\") > -1 &&\n\t\t\t\tsourceEvent?.touches.length === 1)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (event.sourceEvent) {\n\t\t\tstate.zooming = true;\n\t\t\tstate.domain = undefined;\n\t\t}\n\n\t\tconst isMousemove = sourceEvent?.type === \"mousemove\";\n\t\tconst isZoomOut = sourceEvent?.wheelDelta < 0;\n\t\tconst {transform} = event;\n\n\t\tif (!isMousemove && isZoomOut && scale.x.domain().every((v, i) => v !== org.xDomain[i])) {\n\t\t\tscale.x.domain(org.xDomain);\n\t\t}\n\n\t\t$$.zoom.updateTransformScale(transform, config.zoom_type === \"wheel\" && sourceEvent);\n\n\t\t// do zoom transiton when:\n\t\t// - zoom type 'drag'\n\t\t// - when .unzoom() is called (event.transform === d3ZoomIdentity)\n\t\tconst doTransition = config.transition_duration > 0 &&\n\t\t\t!config.subchart_show && (\n\t\t\t\tstate.dragging || isUnZoom || !event.sourceEvent\n\t\t\t);\n\n\t\t$$.redraw({\n\t\t\twithTransition: doTransition,\n\t\t\twithY: config.zoom_rescale,\n\t\t\twithSubchart: false,\n\t\t\twithEventRect: false,\n\t\t\twithDimension: false\n\t\t});\n\n\t\t$$.state.cancelClick = isMousemove;\n\n\t\t// do not call event cb when is .unzoom() is called\n\t\t!isUnZoom && callFn(\n\t\t\tconfig.zoom_onzoom,\n\t\t\t$$.api,\n\t\t\t$$.state.domain ?? $$.zoom.getDomain()\n\t\t);\n\t},\n\n\t/**\n\t * 'end' event listener\n\t * @param {object} event Event object\n\t * @private\n\t */\n\tonZoomEnd(event): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tlet {startEvent} = $$.zoom;\n\t\tlet e = event?.sourceEvent;\n\t\tconst isUnZoom = event?.transform === d3ZoomIdentity;\n\n\t\tif (startEvent?.type.indexOf(\"touch\") > -1) {\n\t\t\tstartEvent = startEvent.changedTouches[0];\n\t\t\te = e?.changedTouches?.[0];\n\t\t}\n\n\t\t// if click, do nothing. otherwise, click interaction will be canceled.\n\t\tif (\n\t\t\tconfig.zoom_type === \"drag\" && (\n\t\t\t\te && startEvent.clientX === e.clientX && startEvent.clientY === e.clientY\n\t\t\t)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tstate.zooming = false;\n\t\t$$.redrawEventRect();\n\t\t$$.updateZoom();\n\n\t\t// do not call event cb when is .unzoom() is called\n\t\t!isUnZoom && (e || state.dragging) && callFn(\n\t\t\tconfig.zoom_onzoomend,\n\t\t\t$$.api,\n\t\t\t$$.state.domain ?? $$.zoom.getDomain()\n\t\t);\n\t},\n\n\t/**\n\t * Update zoom\n\t * @param {boolean} force Force unzoom\n\t * @private\n\t */\n\tupdateZoom(force: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {subX, x, zoom} = $$.scale;\n\n\t\tif (zoom) {\n\t\t\tconst zoomDomain = zoom.domain();\n\t\t\tconst xDomain = subX.domain();\n\t\t\tconst delta = 0.015; // arbitrary value\n\n\t\t\tconst isfullyShown = $$.config.axis_x_inverted ?\n\t\t\t\t(\n\t\t\t\t\tzoomDomain[0] >= xDomain[0] || (zoomDomain[0] + delta) >= xDomain[0]\n\t\t\t\t) && (\n\t\t\t\t\txDomain[1] >= zoomDomain[1] || xDomain[1] >= (zoomDomain[1] + delta)\n\t\t\t\t) :\n\t\t\t\t(\n\t\t\t\t\tzoomDomain[0] <= xDomain[0] || (zoomDomain[0] - delta) <= xDomain[0]\n\t\t\t\t) && (\n\t\t\t\t\txDomain[1] <= zoomDomain[1] || xDomain[1] <= (zoomDomain[1] - delta)\n\t\t\t\t);\n\n\t\t\t// check if the zoomed chart is fully shown, then reset scale when zoom is out as initial\n\t\t\tif (force || isfullyShown) {\n\t\t\t\t$$.axis.x.scale(subX);\n\t\t\t\tx.domain(subX.orgDomain());\n\t\t\t\t$$.scale.zoom = null;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Set zoom transform to event rect\n\t * @param {Function} x x Axis scale function\n\t * @param {Array} domain Domain value to be set\n\t * @private\n\t */\n\tupdateCurrentZoomTransform(x, domain: [number, number]): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {eventRect}, config} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\t// Get transform from given domain value\n\t\t// https://github.com/d3/d3-zoom/issues/57#issuecomment-246434951\n\t\tconst translate = [-x(domain[0]), 0];\n\t\tconst transform = d3ZoomIdentity\n\t\t\t.scale(x.range()[1] / (\n\t\t\t\tx(domain[1]) - x(domain[0])\n\t\t\t))\n\t\t\t.translate(\n\t\t\t\t...(isRotated ? translate.reverse() : translate) as [number, number]\n\t\t\t);\n\n\t\teventRect.call($$.zoom.transform, transform);\n\t},\n\n\t/**\n\t * Attach zoom event on <rect>\n\t * @private\n\t */\n\tbindZoomOnEventRect(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {eventRect, svg}} = $$;\n\t\tconst behaviour = config.zoom_type === \"drag\" ? $$.zoomBehaviour : $$.zoom;\n\n\t\t// On Safari, event can't be built inside the svg content\n\t\t// for workaround, register wheel event on <svg> element first\n\t\t// https://bugs.webkit.org/show_bug.cgi?id=226683#c3\n\t\t// https://stackoverflow.com/questions/67836886/wheel-event-is-not-fired-on-a-svg-group-element-in-safari\n\t\tif (\n\t\t\twindow.GestureEvent &&\n\t\t\t/^((?!chrome|android|mobile).)*safari/i.test(window.navigator?.userAgent)\n\t\t) {\n\t\t\tsvg.on(\"wheel\", () => {});\n\t\t}\n\n\t\teventRect?.call(behaviour)\n\t\t\t.on(\"dblclick.zoom\", null);\n\t},\n\n\t/**\n\t * Initialize the drag behaviour used for zooming.\n\t * @private\n\t */\n\tinitZoomBehaviour(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tlet start = 0;\n\t\tlet end = 0;\n\t\tlet zoomRect;\n\t\tlet extent;\n\n\t\tconst prop = {\n\t\t\taxis: isRotated ? \"y\" : \"x\",\n\t\t\tattr: isRotated ? \"height\" : \"width\",\n\t\t\tindex: isRotated ? 1 : 0\n\t\t};\n\n\t\t$$.zoomBehaviour = d3Drag()\n\t\t\t.clickDistance(4)\n\t\t\t.on(\"start\", function(event) {\n\t\t\t\t// get extent at first zooming, when is zoomed do not consider\n\t\t\t\textent = $$.scale.zoom ? null : $$.axis.getExtent();\n\n\t\t\t\tstate.event = event;\n\t\t\t\t$$.setDragStatus(true);\n\t\t\t\t$$.unselectRect();\n\n\t\t\t\tif (!zoomRect) {\n\t\t\t\t\tzoomRect = $$.$el.main.append(\"rect\")\n\t\t\t\t\t\t.attr(\"clip-path\", state.clip.path)\n\t\t\t\t\t\t.attr(\"class\", $ZOOM.zoomBrush)\n\t\t\t\t\t\t.attr(\"width\", isRotated ? state.width : 0)\n\t\t\t\t\t\t.attr(\"height\", isRotated ? 0 : state.height);\n\t\t\t\t}\n\n\t\t\t\tstart = getPointer(event, this as SVGAElement)[prop.index];\n\n\t\t\t\tif (extent) {\n\t\t\t\t\tif (start < extent[0]) {\n\t\t\t\t\t\tstart = extent[0];\n\t\t\t\t\t} else if (start > extent[1]) {\n\t\t\t\t\t\tstart = extent[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tend = start;\n\n\t\t\t\tzoomRect\n\t\t\t\t\t.attr(prop.axis, start)\n\t\t\t\t\t.attr(prop.attr, 0);\n\n\t\t\t\t$$.onZoomStart(event);\n\t\t\t})\n\t\t\t.on(\"drag\", function(event) {\n\t\t\t\tend = getPointer(event, this as SVGAElement)[prop.index];\n\n\t\t\t\tif (extent) {\n\t\t\t\t\tif (end > extent[1]) {\n\t\t\t\t\t\tend = extent[1];\n\t\t\t\t\t} else if (end < extent[0]) {\n\t\t\t\t\t\tend = extent[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tzoomRect\n\t\t\t\t\t.attr(prop.axis, Math.min(start, end))\n\t\t\t\t\t.attr(prop.attr, Math.abs(end - start));\n\t\t\t})\n\t\t\t.on(\"end\", event => {\n\t\t\t\tconst scale = $$.scale.zoom || $$.scale.x;\n\n\t\t\t\tstate.event = event;\n\n\t\t\t\tzoomRect\n\t\t\t\t\t.attr(prop.axis, 0)\n\t\t\t\t\t.attr(prop.attr, 0);\n\n\t\t\t\tif (start > end) {\n\t\t\t\t\t[start, end] = [end, start];\n\t\t\t\t}\n\n\t\t\t\tif (start < 0) {\n\t\t\t\t\tend += Math.abs(start);\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\n\t\t\t\tif (start !== end) {\n\t\t\t\t\t$$.api.zoom([start, end].map(v => scale.invert(v)));\n\t\t\t\t}\n\n\t\t\t\t$$.setDragStatus(false);\n\t\t\t});\n\t},\n\n\tsetZoomResetButton(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el} = $$;\n\t\tconst resetButton = config.zoom_resetButton;\n\n\t\tif (resetButton && config.zoom_type === \"drag\") {\n\t\t\tif (!$el.zoomResetBtn) {\n\t\t\t\t$el.zoomResetBtn = $$.$el.chart.append(\"div\")\n\t\t\t\t\t.classed($COMMON.button, true)\n\t\t\t\t\t.append(\"span\")\n\t\t\t\t\t.on(\"click\", function() {\n\t\t\t\t\t\tisFunction(resetButton.onclick) && resetButton.onclick.bind($$.api)(this);\n\t\t\t\t\t\t$$.api.unzoom();\n\t\t\t\t\t})\n\t\t\t\t\t.classed($ZOOM.buttonZoomReset, true)\n\t\t\t\t\t.text(resetButton.text || \"Reset Zoom\");\n\t\t\t} else {\n\t\t\t\t$el.zoomResetBtn.style(\"display\", null);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetZoomTransform() {\n\t\tconst $$ = this;\n\t\tconst {$el: {eventRect}} = $$;\n\n\t\treturn eventRect?.node() ? d3ZoomTransform(eventRect.node()) : {k: 1};\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport type {d3Selection} from \"../../../types/types\";\nimport {$BAR, $CIRCLE, $COMMON, $DRAG, $SELECT, $SHAPE} from \"../../config/classes\";\nimport {getPathBox} from \"../../module/util\";\n\n/**\n * Module used for data.selection.draggable option\n */\nexport default {\n\t/**\n\t * Called when dragging.\n\t * Data points can be selected.\n\t * @private\n\t * @param {object} mouse Object\n\t */\n\tdrag(mouse): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {main}} = $$;\n\t\tconst isSelectionGrouped = config.data_selection_grouped;\n\t\tconst isSelectable = config.interaction_enabled && config.data_selection_isselectable;\n\n\t\tif (\n\t\t\t$$.hasArcType() ||\n\t\t\t!config.data_selection_enabled || // do nothing if not selectable\n\t\t\t(config.zoom_enabled && !$$.zoom.altDomain) || // skip if zoomable because of conflict drag behavior\n\t\t\t!config.data_selection_multiple // skip when single selection because drag is used for multiple selection\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [sx, sy] = state.dragStart || [0, 0];\n\t\tconst [mx, my] = mouse;\n\n\t\tconst minX = Math.min(sx, mx);\n\t\tconst maxX = Math.max(sx, mx);\n\t\tconst minY = isSelectionGrouped ? state.margin.top : Math.min(sy, my);\n\t\tconst maxY = isSelectionGrouped ? state.height : Math.max(sy, my);\n\n\t\tmain.select(`.${$DRAG.dragarea}`)\n\t\t\t.attr(\"x\", minX)\n\t\t\t.attr(\"y\", minY)\n\t\t\t.attr(\"width\", maxX - minX)\n\t\t\t.attr(\"height\", maxY - minY);\n\n\t\t// TODO: binary search when multiple xs\n\t\tmain.selectAll(`.${$SHAPE.shapes}`)\n\t\t\t.selectAll(`.${$SHAPE.shape}`)\n\t\t\t.filter(d => isSelectable?.bind($$.api)(d))\n\t\t\t.each(function(d, i) {\n\t\t\t\tconst shape: d3Selection = d3Select(this);\n\t\t\t\tconst isSelected = shape.classed($SELECT.SELECTED);\n\t\t\t\tconst isIncluded = shape.classed($DRAG.INCLUDED);\n\t\t\t\tlet isWithin: any = false;\n\t\t\t\tlet toggle;\n\n\t\t\t\tif (shape.classed($CIRCLE.circle)) {\n\t\t\t\t\tconst x: number = +shape.attr(\"cx\") * 1;\n\t\t\t\t\tconst y: number = +shape.attr(\"cy\") * 1;\n\n\t\t\t\t\ttoggle = $$.togglePoint;\n\t\t\t\t\tisWithin = minX < x && x < maxX && minY < y && y < maxY;\n\t\t\t\t} else if (shape.classed($BAR.bar)) {\n\t\t\t\t\tconst {x, y, width, height} = getPathBox(this);\n\n\t\t\t\t\ttoggle = $$.togglePath;\n\t\t\t\t\tisWithin = !(maxX < x || x + width < minX) && !(maxY < y || y + height < minY);\n\t\t\t\t} else {\n\t\t\t\t\t// line/area selection not supported yet\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (isWithin ^ isIncluded) {\n\t\t\t\t\tshape.classed($DRAG.INCLUDED, !isIncluded);\n\t\t\t\t\t// TODO: included/unincluded callback here\n\t\t\t\t\tshape.classed($SELECT.SELECTED, !isSelected);\n\t\t\t\t\ttoggle.call($$, !isSelected, shape, d, i);\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\t/**\n\t * Called when the drag starts.\n\t * Adds and Shows the drag area.\n\t * @private\n\t * @param {object} mouse Object\n\t */\n\tdragstart(mouse): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {main}} = $$;\n\n\t\tif ($$.hasArcType() || !config.data_selection_enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tstate.dragStart = mouse;\n\n\t\tmain.select(`.${$COMMON.chart}`)\n\t\t\t.append(\"rect\")\n\t\t\t.attr(\"class\", $DRAG.dragarea)\n\t\t\t.style(\"opacity\", \"0.1\");\n\n\t\t$$.setDragStatus(true);\n\t},\n\n\t/**\n\t * Called when the drag finishes.\n\t * Removes the drag area.\n\t * @private\n\t */\n\tdragend(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {main}, $T} = $$;\n\n\t\tif ($$.hasArcType() || !config.data_selection_enabled) { // do nothing if not selectable\n\t\t\treturn;\n\t\t}\n\n\t\t$T(main.select(`.${$DRAG.dragarea}`))\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\tmain.selectAll(`.${$SHAPE.shape}`)\n\t\t\t.classed($DRAG.INCLUDED, false);\n\n\t\t$$.setDragStatus(false);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$SELECT, $SHAPE} from \"../../config/classes\";\nimport {callFn} from \"../../module/util\";\nimport drag from \"../interactions/drag\";\n\nexport default {\n\t...drag,\n\n\t/**\n\t * Select a point\n\t * @param {object} target Target point\n\t * @param {object} d Data object\n\t * @param {number} i Index number\n\t * @private\n\t */\n\tselectPoint(target, d, i: number): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {main}, $T} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst cx = (isRotated ? $$.circleY : $$.circleX).bind($$);\n\t\tconst cy = (isRotated ? $$.circleX : $$.circleY).bind($$);\n\t\tconst r = $$.pointSelectR.bind($$);\n\n\t\tcallFn(config.data_onselected, $$.api, d, target.node());\n\n\t\t// add selected-circle on low layer g\n\t\t$T(main.select(`.${$SELECT.selectedCircles}${$$.getTargetSelectorSuffix(d.id)}`)\n\t\t\t.selectAll(`.${$SELECT.selectedCircle}-${i}`)\n\t\t\t.data([d])\n\t\t\t.enter()\n\t\t\t.append(\"circle\")\n\t\t\t.attr(\"class\", () => $$.generateClass($SELECT.selectedCircle, i))\n\t\t\t.attr(\"cx\", cx)\n\t\t\t.attr(\"cy\", cy)\n\t\t\t.attr(\"stroke\", $$.color)\n\t\t\t.attr(\"r\", d2 => $$.pointSelectR(d2) * 1.4)).attr(\"r\", r);\n\t},\n\n\t/**\n\t * Unelect a point\n\t * @param {object} target Target point\n\t * @param {object} d Data object\n\t * @param {number} i Index number\n\t * @private\n\t */\n\tunselectPoint(target, d, i: number): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {main}, $T} = $$;\n\n\t\tcallFn(config.data_onunselected, $$.api, d, target?.node());\n\n\t\t// remove selected-circle from low layer g\n\t\t$T(main.select(`.${$SELECT.selectedCircles}${$$.getTargetSelectorSuffix(d.id)}`)\n\t\t\t.selectAll(`.${$SELECT.selectedCircle}-${i}`))\n\t\t\t.attr(\"r\", 0)\n\t\t\t.remove();\n\t},\n\n\t/**\n\t * Toggles the selection of points\n\t * @param {boolean} selected whether or not to select.\n\t * @param {object} target Target object\n\t * @param {object} d Data object\n\t * @param {number} i Index number\n\t * @private\n\t */\n\ttogglePoint(selected, target, d, i: number): void {\n\t\tconst method = `${selected ? \"\" : \"un\"}selectPoint`;\n\n\t\tthis[method](target, d, i);\n\t},\n\n\t/**\n\t * Select a path\n\t * @param {object} target Target path\n\t * @param {object} d Data object\n\t * @private\n\t */\n\tselectPath(target, d): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tcallFn(config.data_onselected, $$.api, d, target.node());\n\n\t\tif (config.interaction_brighten) {\n\t\t\ttarget.style(\"filter\", \"brightness(1.25)\");\n\t\t}\n\t},\n\n\t/**\n\t * Unelect a path\n\t * @private\n\t * @param {object} target Target path\n\t * @param {object} d Data object\n\t */\n\tunselectPath(target, d): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tcallFn(config.data_onunselected, $$.api, d, target.node());\n\n\t\tif (config.interaction_brighten) {\n\t\t\ttarget.style(\"filter\", null);\n\t\t}\n\t},\n\n\t/**\n\t * Toggles the selection of lines\n\t * @param {boolean} selected whether or not to select.\n\t * @param {object} target Target object\n\t * @param {object} d Data object\n\t * @param {number} i Index number\n\t * @private\n\t */\n\ttogglePath(selected, target, d, i: number): void {\n\t\tthis[\n\t\t\t`${selected ? \"\" : \"un\"}selectPath`\n\t\t](target, d, i);\n\t},\n\n\t/**\n\t * Returns the toggle method of the target\n\t * @param {object} that shape\n\t * @param {object} d Data object\n\t * @returns {Function} toggle method\n\t * @private\n\t */\n\tgetToggle(that, d): Function {\n\t\tconst $$ = this;\n\n\t\treturn that.nodeName === \"path\" ? $$.togglePath : (\n\t\t\t$$.isStepType(d) ?\n\t\t\t\t() => {} : // circle is hidden in step chart, so treat as within the click area\n\t\t\t\t$$.togglePoint\n\t\t);\n\t},\n\n\t/**\n\t * Toggles the selection of shapes\n\t * @param {object} that shape\n\t * @param {object} d Data object\n\t * @param {number} i Index number\n\t * @private\n\t */\n\ttoggleShape(that, d, i: number): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {main}} = $$;\n\n\t\tif (config.data_selection_enabled && config.data_selection_isselectable.bind($$.api)(d)) {\n\t\t\tconst shape = d3Select(that);\n\t\t\tconst isSelected = shape.classed($SELECT.SELECTED);\n\t\t\tconst toggle = $$.getToggle(that, d).bind($$);\n\t\t\tlet toggledShape;\n\n\t\t\tif (!config.data_selection_multiple) {\n\t\t\t\tconst focusOnly = $$.isPointFocusOnly?.();\n\t\t\t\tlet selector = `.${focusOnly ? $SELECT.selectedCircles : $SHAPE.shapes}`;\n\n\t\t\t\tif (config.data_selection_grouped) {\n\t\t\t\t\tselector += $$.getTargetSelectorSuffix(d.id);\n\t\t\t\t}\n\n\t\t\t\tmain.selectAll(selector)\n\t\t\t\t\t.selectAll(\n\t\t\t\t\t\tfocusOnly ?\n\t\t\t\t\t\t\t`.${$SELECT.selectedCircle}` :\n\t\t\t\t\t\t\t`.${$SHAPE.shape}.${$SELECT.SELECTED}`\n\t\t\t\t\t)\n\t\t\t\t\t.classed($SELECT.SELECTED, false)\n\t\t\t\t\t.each(function(d) {\n\t\t\t\t\t\tconst shape = d3Select(this);\n\n\t\t\t\t\t\ttoggledShape = shape;\n\t\t\t\t\t\ttoggle(false, shape, d, d.index);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!toggledShape || toggledShape.node() !== shape.node()) {\n\t\t\t\tshape.classed($SELECT.SELECTED, !isSelected);\n\t\t\t\ttoggle(!isSelected, shape, d, i);\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * data.selection config options\n */\nexport default {\n\t/**\n\t * Set data selection enabled<br><br>\n\t * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).\n\t *  - **NOTE:** for ESM imports, needs to import 'selection' exports and instantiate it by calling `selection()`.\n\t *    - `enabled: selection()`\n\t * @name data․selection․enabled\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)\n\t * @example\n\t * data: {\n\t *    selection: {\n\t *       enabled: true\n\t *    }\n\t * }\n\t * @example\n\t * // importing ESM\n\t * import bb, {selection} from \"billboard.js\";\n\t *\n\t * data: {\n\t *    selection: {\n\t *       enabled: selection(),\n\t *       ...\n\t *    }\n\t * }\n\t */\n\tdata_selection_enabled: false,\n\n\t/**\n\t * Set grouped selection enabled.<br><br>\n\t * If this option set true, multiple data points that have same x value will be selected by one selection.\n\t * @name data․selection․grouped\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * data: {\n\t *    selection: {\n\t *       grouped: true\n\t *    }\n\t * }\n\t */\n\tdata_selection_grouped: false,\n\n\t/**\n\t * Set a callback for each data point to determine if it's selectable or not.<br><br>\n\t * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.\n\t * @name data․selection․isselectable\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function() { return true; }\n\t * @example\n\t * data: {\n\t *    selection: {\n\t *       isselectable: function(d) { ... }\n\t *    }\n\t * }\n\t */\n\tdata_selection_isselectable: () => true,\n\n\t/**\n\t * Set multiple data points selection enabled.<br><br>\n\t * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.\n\t * @name data․selection․multiple\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * data: {\n\t *    selection: {\n\t *       multiple: false\n\t *    }\n\t * }\n\t */\n\tdata_selection_multiple: true,\n\n\t/**\n\t * Enable to select data points by dragging.\n\t * If this option set true, data points can be selected by dragging.\n\t * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.\n\t * @name data․selection․draggable\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * data: {\n\t *    selection: {\n\t *       draggable: true\n\t *   }\n\t * }\n\t */\n\tdata_selection_draggable: false,\n\n\t/**\n\t * Set a callback for on data selection.\n\t * @name data․onselected\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function() {}\n\t * @example\n\t * data: {\n\t *     onselected: function(d, element) {\n\t *        // d - ex) {x: 4, value: 150, id: \"data1\", index: 4, name: \"data1\"}\n\t *        // element - <circle>\n\t *        ...\n\t *    }\n\t * }\n\t */\n\tdata_onselected: () => {},\n\n\t/**\n\t * Set a callback for on data un-selection.\n\t * @name data․onunselected\n\t * @memberof Options\n\t * @type {Function}\n\t * @default function() {}\n\t * @example\n\t * data: {\n\t *     onunselected: function(d, element) {\n\t *        // d - ex) {x: 4, value: 150, id: \"data1\", index: 4, name: \"data1\"}\n\t *        // element - <circle>\n\t *        ...\n\t *    }\n\t * }\n\t */\n\tdata_onunselected: () => {}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * x Axis config options\n */\nexport default {\n\t/**\n\t * Set subchart options.\n\t * - **NOTE:** Not supported for `bubble`, `scatter` and non-Axis based(pie, donut, gauge, radar) types.\n\t * @name subchart\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} subchart Subchart object\n\t * @property {boolean} [subchart.show=false] Show sub chart on the bottom of the chart.\n\t *  - **NOTE:** for ESM imports, needs to import 'subchart' exports and instantiate it by calling `subchart()`.\n\t *    - `show: subchart()`\n\t * @property {boolean} [subchart.showHandle=false] Show sub chart's handle.\n\t * @property {boolean} [subchart.axis.x.show=true] Show or hide x axis.\n\t * @property {boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.\n\t * @property {Function|string} [subchart.axis.x.tick.format] Use custom format for x axis ticks - see [axis.x.tick.format](#.axis․x․tick․format) for details.\n\t * @property {boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.\n\t * @property {Array} [subchart.init.range] Set initial selection domain range.\n\t * @property {number} [subchart.size.height] Change the height of the subchart.\n\t * @property {Function} [subchart.onbrush] Set callback for brush event.<br>\n\t *  Specified function receives the current zoomed x domain.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)\n\t * @example\n\t *  subchart: {\n\t *      show: true,\n\t *      showHandle: true,\n\t *      size: {\n\t *          height: 20\n\t *      },\n\t *      init: {\n\t *          // specify initial range domain selection\n\t *          range: [1, 2]\n\t *      },\n\t *      axis: {\n\t *      \tx: {\n\t *      \t  show: true,\n\t *      \t    tick: {\n\t *      \t      show: true,\n\t *      \t      format: (x) => d3Format(\".1f\")(x)\n\t *      \t      text: {\n\t *      \t        show: false\n\t *      \t      }\n\t *      \t    }\n\t *      \t}\n\t *      },\n\t *      onbrush: function(domain) { ... }\n\t *  }\n\t * @example\n\t * // importing ESM\n\t * import bb, {subchart} from \"billboard.js\";\n\t *\n\t * subchart: {\n\t *      show: subchart(),\n\t *      ...\n\t * }\n\t */\n\tsubchart_show: false,\n\tsubchart_showHandle: false,\n\tsubchart_size_height: 60,\n\tsubchart_axis_x_show: true,\n\tsubchart_axis_x_tick_show: true,\n\tsubchart_axis_x_tick_format: <Function | string | undefined>undefined,\n\tsubchart_axis_x_tick_text_show: true,\n\tsubchart_init_range: <undefined | [number, number]>undefined,\n\tsubchart_onbrush: () => {}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * zoom config options\n */\nexport default {\n\t/**\n\t * Set zoom options\n\t * @name zoom\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} zoom Zoom object\n\t * @property {boolean} [zoom.enabled=false] Enable zooming.\n\t *  - **NOTE:** for ESM imports, needs to import 'zoom' exports and instantiate it by calling `zoom()`.\n\t *    - `enabled: zoom()`\n\t * @property {string} [zoom.type='wheel'] Set zoom interaction type.\n\t *  - **Available types:**\n\t *    - wheel\n\t *    - drag\n\t * @property {boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>\n\t *  If true set, y domain will be updated according to the zoomed region.\n\t * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.\n\t * @property {number|Date} [zoom.x.min] Set x Axis minimum zoom range\n\t * @property {number|Date} [zoom.x.max] Set x Axis maximum zoom range\n\t * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>\n\t *  Specified function receives the zoom event.\n\t * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>\n\t *  Specified function receives the zoomed domain.\n\t * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>\n\t *  Specified function receives the zoomed domain.\n\t * @property {boolean|object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom\n\t * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.\n\t * @property {string} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.\n\t * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)\n\t * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)\n\t * @example\n\t *  zoom: {\n\t *      enabled: true,\n\t *      type: \"drag\",\n\t *      rescale: true,\n\t *      extent: [1, 100]  // enable more zooming\n\t *      x: {\n\t *          min: -1,  // set min range\n\t *          max: 10  // set max range\n\t *      },\n\t *      onzoomstart: function(event) { ... },\n\t *      onzoom: function(domain) { ... },\n\t *      onzoomend: function(domain) { ... },\n\t *\n\t *      // show reset button when is zoomed-in\n\t *      resetButton: true,\n\t *\n\t *      resetButton: {\n\t *          // onclick callback when reset button is clicked\n\t *          onclick: function(button) {\n\t *            button; // Reset button element reference\n\t *            ...\n\t *          },\n\t *\n\t *          // customized text value for reset zoom button\n\t *          text: \"Unzoom\"\n\t *      }\n\t *  }\n\t * @example\n\t * // importing ESM\n\t * import bb, {zoom} from \"billboard.js\";\n\t *\n\t * zoom: {\n\t *      enabled: zoom(),\n\t *      ...\n\t * }\n\t */\n\tzoom_enabled: <boolean>false,\n\tzoom_type: <\"wheel\" | \"drag\">\"wheel\",\n\tzoom_extent: <number[] | undefined>undefined,\n\tzoom_privileged: false,\n\tzoom_rescale: false,\n\tzoom_onzoom: <Function | undefined>undefined,\n\tzoom_onzoomstart: <Function | undefined>undefined,\n\tzoom_onzoomend: <Function | undefined>undefined,\n\tzoom_resetButton: <{text: string} | boolean>true,\n\tzoom_x_min: <number | Date | undefined>undefined,\n\tzoom_x_max: <number | Date | undefined>undefined\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport Chart from \"../../Chart/Chart\";\nimport ChartInternal from \"../../ChartInternal/ChartInternal\";\nimport {extend} from \"../../module/util\";\nimport Options from \"../Options/Options\";\n\n// Chart\nimport apiSelection from \"../../Chart/api/selection\";\nimport apiSubchart from \"../../Chart/api/subchart\";\nimport apiZoom from \"../../Chart/api/zoom\";\n\n// ChartInternal\nimport subchart from \"../../ChartInternal/interactions/subchart\";\nimport zoom from \"../../ChartInternal/interactions/zoom\";\nimport selection from \"../../ChartInternal/internals/selection\";\n\n// Axis based options\nimport optDataSelection from \"../Options/data/selection\";\nimport optSubchart from \"../Options/interaction/subchart\";\nimport optZoom from \"../Options/interaction/zoom\";\n\nexport {selectionModule as selection, subchartModule as subchart, zoomModule as zoom};\n\nlet selectionModule = (): boolean => {\n\textend(ChartInternal.prototype, selection);\n\textend(Chart.prototype, apiSelection);\n\tOptions.setOptions([optDataSelection]);\n\n\treturn (selectionModule = () => true)();\n};\n\nlet subchartModule = (): boolean => {\n\textend(ChartInternal.prototype, subchart);\n\textend(Chart.prototype, apiSubchart);\n\tOptions.setOptions([optSubchart]);\n\n\treturn (subchartModule = () => true)();\n};\n\nlet zoomModule = (): boolean => {\n\textend(ChartInternal.prototype, zoom);\n\textend(Chart.prototype, apiZoom);\n\tOptions.setOptions([optZoom]);\n\n\treturn (zoomModule = () => true)();\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {isDefined, isNumber, isObjectType, isValue} from \"../../module/util\";\n\ntype AxisOption = {x?: number | false, y?: number | false, y2?: number | false} | number | false;\n\ntype RangeAxisOption = {min?: AxisOption, max?: AxisOption};\n\n/**\n * Set the min/max value\n * @param {Chart} $$ Chart instance\n * @param {string} type Set type 'min' or 'max'\n * @param {object} value Value to be set\n * @private\n */\nfunction setMinMax($$, type: \"min\" | \"max\", value: AxisOption): void {\n\tconst {config} = $$;\n\tconst helper = (key, value) => {\n\t\tconst v = isNumber(value) ? value : (\n\t\t\tvalue === false ? undefined : null\n\t\t);\n\n\t\tif (v !== null) {\n\t\t\tconfig[`axis_${key}_${type}`] = v;\n\t\t}\n\t};\n\n\tif (isDefined(value)) {\n\t\tif (isObjectType(value)) {\n\t\t\tObject.keys(value).forEach(key => {\n\t\t\t\thelper(key, value[key]);\n\t\t\t});\n\t\t} else if (isNumber(value) || value === false) {\n\t\t\t// shorthand values affects only y and y2.\n\t\t\t[\"y\", \"y2\"].forEach(key => {\n\t\t\t\thelper(key, value);\n\t\t\t});\n\t\t}\n\n\t\t$$.redraw({\n\t\t\twithUpdateOrgXDomain: true,\n\t\t\twithUpdateXDomain: true\n\t\t});\n\t}\n}\n\n/**\n * Get the min/max value\n * @param {Chart} $$ Chart instance\n * @param {string} type Set type 'min' or 'max'\n * @returns {{x, y, y2}}\n * @private\n */\nfunction getMinMax($$, type: \"min\" | \"max\"): {x: number, y: number, y2: number} {\n\tconst {config} = $$;\n\n\treturn {\n\t\tx: config[`axis_x_${type}`],\n\t\ty: config[`axis_y_${type}`],\n\t\ty2: config[`axis_y2_${type}`]\n\t};\n}\n\n/**\n * Define axis\n * @ignore\n */\nconst axis = {\n\t/**\n\t * Get and set axis labels.\n\t * - **NOTE:** Only applicable for chart types which has x and y axes.\n\t * @function axis․labels\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} labels specified axis' label to be updated.\n\t * @param {string} [labels.x] x Axis string\n\t * @param {string} [labels.y] y Axis string\n\t * @param {string} [labels.y2] y2 Axis string\n\t * @returns {object|undefined} axis labels text object\n\t * @example\n\t * // Update axis' label\n\t * chart.axis.labels({\n\t *   x: \"New X Axis Label\",\n\t *   y: \"New Y Axis Label\",\n\t *   y2: \"New Y2 Axis Label\"\n\t * });\n\t *\n\t * chart.axis.labels();\n\t * // --> {\n\t * //  x: \"New X Axis Label\",\n\t * //  y: \"New Y Axis Label\",\n\t * //  y2: \"New Y2 Axis Label\"\n\t * // }\n\t */\n\tlabels: function<T>(labels?: {x?: string, y?: string, y2?: string}): T | undefined {\n\t\tconst $$ = this.internal;\n\t\tlet labelText;\n\n\t\tif (labels) {\n\t\t\tObject.keys(labels).forEach(axisId => {\n\t\t\t\t$$.axis.setLabelText(axisId, labels[axisId]);\n\t\t\t});\n\n\t\t\t$$.axis.updateLabels();\n\t\t}\n\n\t\t[\"x\", \"y\", \"y2\"].forEach(v => {\n\t\t\tconst text = $$.axis.getLabelText(v);\n\n\t\t\tif (text) {\n\t\t\t\t!labelText && (labelText = {});\n\t\t\t\tlabelText[v] = text;\n\t\t\t}\n\t\t});\n\n\t\treturn <T>labelText;\n\t},\n\n\t/**\n\t * Get and set axis min value.\n\t * - **NOTE:** Only applicable for chart types which has x and y axes.\n\t * @function axis․min\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} min If min is given, specified axis' min value will be updated.<br>\n\t *   If no argument is given, the min values set on generating option for each axis will be returned.\n\t *   If not set any min values on generation, it will return `undefined`.<br>\n\t *   To unset specific axis max, set `false` to each of them.\n\t * @returns {object|undefined}\n\t * @example\n\t * // Update axis' min\n\t * chart.axis.min({\n\t *   x: -10,\n\t *   y: 1000,\n\t *   y2: 100\n\t * });\n\t *\n\t * // To unset specific axis min, set false to each of them.\n\t * chart.axis.min({\n\t *   x: false,\n\t *   y: false,\n\t *   y2: false\n\t * });\n\t *\n\t * // shorthand (only affects y and y2 axis)\n\t * chart.axis.min(-50);\n\t * chart.axis.min(false);\n\t */\n\tmin: function(min?: AxisOption): object | void {\n\t\tconst $$ = this.internal;\n\n\t\treturn isValue(min) || min === false ?\n\t\t\tsetMinMax($$, \"min\", min as AxisOption) :\n\t\t\tgetMinMax($$, \"min\");\n\t},\n\n\t/**\n\t * Get and set axis max value.\n\t * - **NOTE:** Only applicable for chart types which has x and y axes.\n\t * @function axis․max\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} max If max is given, specified axis' max value will be updated.<br>\n\t *   If no argument is given, the max values set on generating option for each axis will be returned.\n\t *   If not set any max values on generation, it will return `undefined`.<br>\n\t *   To unset specific axis max, set `false` to each of them.\n\t * @returns {object|undefined}\n\t * @example\n\t * // Update axis' label\n\t * chart.axis.max({\n\t *    x: 100,\n\t *    y: 1000,\n\t *    y2: 10000\n\t * });\n\t *\n\t * // To unset specific axis max, set false to each of them.\n\t * chart.axis.max({\n\t *   x: false,\n\t *   y: false,\n\t *   y2: false\n\t * });\n\t *\n\t * // shorthand (only affects y and y2 axis)\n\t * chart.axis.max(10);\n\t * chart.axis.max(false);\n\t */\n\tmax: function(max?: AxisOption): object | void {\n\t\tconst $$ = this.internal;\n\n\t\treturn isValue(max) || max === false ?\n\t\t\tsetMinMax($$, \"max\", max as AxisOption) :\n\t\t\tgetMinMax($$, \"max\");\n\t},\n\n\t/**\n\t * Get and set axis min and max value.\n\t * - **NOTE:** Only applicable for chart types which has x and y axes.\n\t * @function axis․range\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} range If range is given, specified axis' min and max value will be updated.\n\t *   If no argument is given, the current min and max values for each axis will be returned.<br>\n\t *   To unset specific axis max, set `false` to each of them.\n\t * @returns {object|undefined}\n\t * @example\n\t * // Update axis' label\n\t * chart.axis.range({\n\t *   min: {\n\t *     x: -10,\n\t *     y: -1000,\n\t *     y2: -10000\n\t *   },\n\t *   max: {\n\t *     x: 100,\n\t *     y: 1000,\n\t *     y2: 10000\n\t *   },\n\t * });\n\t *\n\t * // To unset specific axis max, set false to each of them.\n\t * chart.axis.range({\n\t *   min: {\n\t *     x: false,\n\t *     y: false,\n\t *     y2: false\n\t *   },\n\t *   max: {\n\t *     x: false,\n\t *     y: false,\n\t *     y2: false\n\t *   },\n\t * });\n\t *\n\t * // shorthand (only affects y and y2 axis)\n\t * chart.axis.range({ min: -50, max: 1000 });\n\t * chart.axis.range({ min: false, max: false });\n\t */\n\trange: function(range: RangeAxisOption): object | void {\n\t\tconst {axis} = this;\n\n\t\tif (arguments.length) {\n\t\t\tconst {min, max} = range;\n\n\t\t\tisDefined(max) && axis.max(max);\n\t\t\tisDefined(min) && axis.min(min);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmax: axis.max(),\n\t\t\t\tmin: axis.min()\n\t\t\t};\n\t\t}\n\n\t\treturn undefined;\n\t}\n};\n\nexport default {axis};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {isEmpty} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Set specified category name on category axis.\n\t * @function category\n\t * @instance\n\t * @memberof Chart\n\t * @param {number} i index of category to be changed\n\t * @param {string} category category value to be changed\n\t * @returns {string}\n\t * @example\n\t * chart.category(2, \"Category 3\");\n\t */\n\tcategory(i: number, category: string): string {\n\t\tconst $$ = this.internal;\n\t\tconst {config} = $$;\n\n\t\tif (arguments.length > 1) {\n\t\t\tconfig.axis_x_categories[i] = category;\n\t\t\t$$.redraw();\n\t\t}\n\n\t\treturn config.axis_x_categories[i];\n\t},\n\n\t/**\n\t * Set or get category names on category axis.\n\t * @function categories\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.\n\t * @returns {Array}\n\t * @example\n\t * chart.categories([\n\t *      \"Category 1\", \"Category 2\", ...\n\t * ]);\n\t */\n\tcategories(categories?: string[]): string[] {\n\t\tconst $$ = this.internal;\n\t\tconst {config} = $$;\n\n\t\tif (!categories || !Array.isArray(categories)) {\n\t\t\tconst cat = config.axis_x_categories;\n\n\t\t\treturn isEmpty(cat) ? Object.values($$.data.xs)[0] as string[] : cat;\n\t\t}\n\n\t\tconfig.axis_x_categories = categories;\n\t\t$$.redraw();\n\n\t\treturn config.axis_x_categories;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {isDefined, isTabVisible, isValue, parseDate} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Flow data to the chart.<br><br>\n\t * By this API, you can append new data points to the chart.\n\t * @function flow\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} args The object can consist with following members:<br>\n\t *\n\t *    | Key | Type | Description |\n\t *    | --- | --- | --- |\n\t *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |\n\t *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |\n\t *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |\n\t *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |\n\t *    | length | Number | The lower x edge will move by the number of this argument |\n\t *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |\n\t *    | done | Function | The specified function will be called when flow ends |\n\t *\n\t * - **NOTE:**\n\t *   - If json, rows and columns given, the data will be loaded.\n\t *   - If data that has the same target id is given, the chart will be appended.\n\t *   - Otherwise, new target will be added. One of these is required when calling.\n\t *   - If json specified, keys is required as well as data.json.\n\t * \t - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.\n\t * @example\n\t * // 2 data points will be apprended to the tail and popped from the head.\n\t * // After that, 4 data points will be appended and no data points will be poppoed.\n\t * chart.flow({\n\t *  columns: [\n\t *    [\"x\", \"2018-01-11\", \"2018-01-21\"],\n\t *    [\"data1\", 500, 200],\n\t *    [\"data2\", 100, 300],\n\t *    [\"data3\", 200, 120]\n\t *  ],\n\t *  to: \"2013-01-11\",\n\t *  done: function () {\n\t *    chart.flow({\n\t *      columns: [\n\t *        [\"x\", \"2018-02-11\", \"2018-02-12\", \"2018-02-13\", \"2018-02-14\"],\n\t *        [\"data1\", 200, 300, 100, 250],\n\t *        [\"data2\", 100, 90, 40, 120],\n\t *        [\"data3\", 100, 100, 300, 500]\n\t *      ],\n\t *      length: 2,\n\t *      duration: 1500\n\t *    });\n\t *  }\n\t * });\n\t */\n\tflow(args): void {\n\t\tconst $$ = this.internal;\n\t\tlet data;\n\n\t\tif (args.json || args.rows || args.columns) {\n\t\t\t$$.convertData(args, res => {\n\t\t\t\tdata = res;\n\t\t\t\t_();\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Process flows\n\t\t * @private\n\t\t */\n\t\tfunction _(): void {\n\t\t\tlet domain;\n\t\t\tlet length: number = 0;\n\t\t\tlet tail = 0;\n\t\t\tlet diff;\n\t\t\tlet to;\n\n\t\t\tif ($$.state.redrawing || !data || !isTabVisible()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst notfoundIds: string[] = [];\n\t\t\tconst orgDataCount = $$.getMaxDataCount();\n\t\t\tconst targets = $$.convertDataToTargets(data, true);\n\t\t\tconst isTimeSeries = $$.axis.isTimeSeries();\n\n\t\t\t// Update/Add data\n\t\t\t$$.data.targets.forEach(t => {\n\t\t\t\tlet found = false;\n\n\t\t\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\t\t\tif (t.id === targets[i].id) {\n\t\t\t\t\t\tfound = true;\n\n\t\t\t\t\t\tif (t.values[t.values.length - 1]) {\n\t\t\t\t\t\t\ttail = t.values[t.values.length - 1].index + 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlength = targets[i].values.length;\n\n\t\t\t\t\t\tfor (let j = 0; j < length; j++) {\n\t\t\t\t\t\t\ttargets[i].values[j].index = tail + j;\n\n\t\t\t\t\t\t\tif (!isTimeSeries) {\n\t\t\t\t\t\t\t\ttargets[i].values[j].x = tail + j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt.values = t.values.concat(targets[i].values);\n\t\t\t\t\t\ttargets.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t!found && notfoundIds.push(t.id);\n\t\t\t});\n\n\t\t\t// Append null for not found targets\n\t\t\t$$.data.targets.forEach(t => {\n\t\t\t\tfor (let i = 0; i < notfoundIds.length; i++) {\n\t\t\t\t\tif (t.id === notfoundIds[i]) {\n\t\t\t\t\t\ttail = t.values[t.values.length - 1].index + 1;\n\n\t\t\t\t\t\tfor (let j = 0; j < length; j++) {\n\t\t\t\t\t\t\tt.values.push({\n\t\t\t\t\t\t\t\tid: t.id,\n\t\t\t\t\t\t\t\tindex: tail + j,\n\t\t\t\t\t\t\t\tx: isTimeSeries ? $$.getOtherTargetX(tail + j) : tail + j,\n\t\t\t\t\t\t\t\tvalue: null\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Generate null values for new target\n\t\t\tif ($$.data.targets.length) {\n\t\t\t\ttargets.forEach(t => {\n\t\t\t\t\tconst missing: any[] = [];\n\n\t\t\t\t\tfor (let i = $$.data.targets[0].values[0].index; i < tail; i++) {\n\t\t\t\t\t\tmissing.push({\n\t\t\t\t\t\t\tid: t.id,\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tx: isTimeSeries ? $$.getOtherTargetX(i) : i,\n\t\t\t\t\t\t\tvalue: null\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tt.values.forEach(v => {\n\t\t\t\t\t\tv.index += tail;\n\n\t\t\t\t\t\tif (!isTimeSeries) {\n\t\t\t\t\t\t\tv.x += tail;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tt.values = missing.concat(t.values);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t$$.data.targets = $$.data.targets.concat(targets); // add remained\n\n\t\t\t// check data count because behavior needs to change when it\"s only one\n\t\t\t// const dataCount = $$.getMaxDataCount();\n\t\t\tconst baseTarget = $$.data.targets[0];\n\t\t\tconst baseValue = baseTarget.values[0];\n\n\t\t\t// Update length to flow if needed\n\t\t\tif (isDefined(args.to)) {\n\t\t\t\tlength = 0;\n\t\t\t\tto = isTimeSeries ? parseDate.call($$, args.to) : args.to;\n\n\t\t\t\tbaseTarget.values.forEach(v => {\n\t\t\t\t\tv.x < to && length++;\n\t\t\t\t});\n\t\t\t} else if (isDefined(args.length)) {\n\t\t\t\tlength = args.length;\n\t\t\t}\n\n\t\t\t// If only one data, update the domain to flow from left edge of the chart\n\t\t\tif (!orgDataCount) {\n\t\t\t\tif (isTimeSeries) {\n\t\t\t\t\tdiff = baseTarget.values.length > 1 ?\n\t\t\t\t\t\tbaseTarget.values[baseTarget.values.length - 1].x - baseValue.x :\n\t\t\t\t\t\tbaseValue.x - $$.getXDomain($$.data.targets)[0];\n\t\t\t\t} else {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\n\t\t\t\tdomain = [baseValue.x - diff, baseValue.x];\n\t\t\t} else if (orgDataCount === 1 && isTimeSeries) {\n\t\t\t\tdiff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;\n\t\t\t\tdomain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];\n\t\t\t}\n\n\t\t\tdomain && $$.updateXDomain(null, true, true, false, domain);\n\n\t\t\t// Set targets\n\t\t\t$$.updateTargets($$.data.targets);\n\n\t\t\t// Redraw with new targets\n\t\t\t$$.redraw({\n\t\t\t\tflow: {\n\t\t\t\t\tindex: baseValue.index,\n\t\t\t\t\tlength: length,\n\t\t\t\t\tduration: isValue(args.duration) ?\n\t\t\t\t\t\targs.duration :\n\t\t\t\t\t\t$$.config.transition_duration,\n\t\t\t\t\tdone: args.done,\n\t\t\t\t\torgDataCount: orgDataCount\n\t\t\t\t},\n\t\t\t\twithLegend: true,\n\t\t\t\twithTransition: orgDataCount > 1,\n\t\t\t\twithTrimXDomain: false,\n\t\t\t\twithUpdateXAxis: true\n\t\t\t});\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {extend, isTabVisible} from \"../../module/util\";\n\ntype GridsParam = {value?: number, class?: string, text?: string}[];\n\n/**\n * Update grid lines.\n * @param {Array} grids grid lines to update\n * @param {string} axisId axis' id: \"x\" or \"y\"\n * @returns {Array}\n * @private\n */\nfunction grid(grids: GridsParam, axisId: \"x\" | \"y\"): GridsParam {\n\tconst $$ = this.internal;\n\tconst {config} = $$;\n\tconst withTransition = config.transition_duration && isTabVisible();\n\tconst gridPropLines = `grid_${axisId}_lines`;\n\n\tif (!grids) {\n\t\treturn config[gridPropLines];\n\t}\n\n\tconfig[gridPropLines] = grids;\n\n\t$$.updateGrid();\n\t$$.redrawGrid(withTransition);\n\n\treturn config[gridPropLines];\n}\n\n/**\n * Add grid lines.\n * @param {Array|object} grids grid lines to add\n * @param {string} axisId axis' id: \"x\" or \"y\"\n * @returns {Array}\n * @private\n */\nfunction add(grids: GridsParam, axisId: \"x\" | \"y\"): GridsParam {\n\tconst gridPropLines = `grid_${axisId}_lines`;\n\n\treturn grid.bind(this)(\n\t\tthis.internal.config[gridPropLines].concat(grids || []),\n\t\taxisId\n\t);\n}\n\n/**\n * Remove grid lines.\n * @param {object} grids grid lines to remove\n * @param {boolean} isXAxis weather is x axis or not\n * @private\n */\nfunction remove(grids: GridsParam | undefined, isXAxis: boolean): void {\n\tthis.internal.removeGridLines(grids, isXAxis);\n}\n\n/**\n * Update x grid lines.\n * @function xgrids\n * @instance\n * @memberof Chart\n * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.\n * @returns {Array}\n * @example\n *  // Show 2 x grid lines\n * chart.xgrids([\n *    {value: 1, text: \"Label 1\"},\n *    {value: 4, text: \"Label 4\"}\n * ]);\n * // --> Returns: [{value: 1, text: \"Label 1\"}, {value: 4, text: \"Label 4\"}]\n */\nconst xgrids = function(grids: GridsParam): GridsParam {\n\treturn grid.bind(this)(grids, \"x\");\n};\n\nextend(xgrids, {\n\t/**\n\t * Add x grid lines.<br>\n\t * This API adds new x grid lines instead of replacing like xgrids.\n\t * @function xgrids․add\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array|object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.\n\t * @returns {Array}\n\t * @example\n\t *  // Add a new x grid line\n\t * chart.xgrids.add(\n\t *   {value: 4, text: \"Label 4\"}\n\t * );\n\t *\n\t * // Add new x grid lines\n\t * chart.xgrids.add([\n\t *   {value: 2, text: \"Label 2\"},\n\t *   {value: 4, text: \"Label 4\"}\n\t * ]);\n\t */\n\tadd(grids: GridsParam): GridsParam {\n\t\treturn add.bind(this)(grids, \"x\");\n\t},\n\n\t/**\n\t * Remove x grid lines.<br>\n\t * This API removes x grid lines.\n\t * @function xgrids․remove\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} grids This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.\n\t * @param {number} [grids.value] target value\n\t * @param {string} [grids.class] target class\n\t * @returns {void}\n\t * @example\n\t * // x grid line on x = 2 will be removed\n\t * chart.xgrids.remove({value: 2});\n\t *\n\t * // x grid lines that have 'grid-A' will be removed\n\t * chart.xgrids.remove({\n\t *   class: \"grid-A\"\n\t * });\n\t *\n\t * // all of x grid lines will be removed\n\t * chart.xgrids.remove();\n\t */\n\tremove(grids?: GridsParam): void { // TODO: multiple\n\t\treturn remove.bind(this)(grids, true);\n\t}\n});\n\n/**\n * Update y grid lines.\n * @function ygrids\n * @instance\n * @memberof Chart\n * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.\n * @returns {object}\n * @example\n *  // Show 2 y grid lines\n * chart.ygrids([\n *    {value: 100, text: \"Label 1\"},\n *    {value: 400, text: \"Label 4\"}\n * ]);\n * // --> Returns: [{value: 100, text: \"Label 1\"}, {value: 400, text: \"Label 4\"}]\n */\nconst ygrids = function(grids: GridsParam): GridsParam {\n\treturn grid.bind(this)(grids, \"y\");\n};\n\nextend(ygrids, {\n\t/**\n\t * Add y grid lines.<br>\n\t * This API adds new y grid lines instead of replacing like ygrids.\n\t * @function ygrids․add\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array|object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.\n\t * @returns {object}\n\t * @example\n\t *  // Add a new x grid line\n\t * chart.ygrids.add(\n\t *   {value: 400, text: \"Label 4\"}\n\t * );\n\t *\n\t * // Add new x grid lines\n\t * chart.ygrids.add([\n\t *   {value: 200, text: \"Label 2\"},\n\t *   {value: 400, text: \"Label 4\"}\n\t * ]);\n\t */\n\tadd(grids: GridsParam): GridsParam {\n\t\treturn add.bind(this)(grids, \"y\");\n\t},\n\n\t/**\n\t * Remove y grid lines.<br>\n\t * This API removes x grid lines.\n\t * @function ygrids․remove\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} grids This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.\n\t * @param {number} [grids.value] target value\n\t * @param {string} [grids.class] target class\n\t * @returns {void}\n\t * @example\n\t * // y grid line on y = 200 will be removed\n\t * chart.ygrids.remove({value: 200});\n\t *\n\t * // y grid lines that have 'grid-A' will be removed\n\t * chart.ygrids.remove({\n\t *   class: \"grid-A\"\n\t * });\n\t *\n\t * // all of y grid lines will be removed\n\t * chart.ygrids.remove();\n\t */\n\tremove(grids?: GridsParam): void { // TODO: multiple\n\t\treturn remove.bind(this)(grids, false);\n\t}\n});\n\nexport default {xgrids, ygrids};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {isUndefined} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Update groups for the targets.\n\t * @function groups\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.\n\t * @returns {Array} Grouped data names array\n\t * @example\n\t *  // data1 and data2 will be a new group.\n\t *  chart.groups([\n\t *     [\"data1\", \"data2\"]\n\t *  ]);\n\t */\n\tgroups<T = string[][]>(groups: T): T {\n\t\tconst $$ = this.internal;\n\t\tconst {config} = $$;\n\n\t\tif (isUndefined(groups)) {\n\t\t\treturn config.data_groups;\n\t\t}\n\n\t\tconfig.data_groups = groups;\n\t\t$$.redraw();\n\n\t\treturn config.data_groups;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$REGION} from \"../../config/classes\";\nimport {extend, getOption, isTabVisible} from \"../../module/util\";\n\ntype RegionsParam = {axis?: \"add\" | \"update\", class?: string, start?: number, end?: number}[];\n\n/**\n * Region add/update function\n * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.\n * @param {boolean} isAdd If true, add new regions, otherwise update regions\n * @returns {Array} regions\n * @private\n */\nfunction regionsFn(regions: RegionsParam, isAdd = false): RegionsParam {\n\tconst $$ = this.internal;\n\tconst {config} = $$;\n\tconst withTransition = config.transition_duration && isTabVisible();\n\n\tif (!regions) {\n\t\treturn config.regions;\n\t}\n\n\tconfig.regions = isAdd ? config.regions.concat(regions) : regions;\n\n\t$$.updateRegion();\n\t$$.redrawRegion(withTransition);\n\n\treturn isAdd ? config.regions : regions;\n}\n\n/**\n * Update regions.\n * @function regions\n * @instance\n * @memberof Chart\n * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as [regions](./Options.html#.regions) option.\n * @returns {Array} regions\n * @example\n * // Show 2 regions\n * chart.regions([\n *    {axis: \"x\", start: 5, class: \"regionX\"},\n *    {\n *      axis: \"y\", end: 50, class: \"regionY\",\n *      label: {\n *      \ttext: \"Region Text\",\n *      \tx: 5,  // position relative of the initial x coordinate\n *      \ty: 5,  // position relative of the initial y coordinate\n *      \tcolor: \"red\",  // color string\n *      \trotated: true  // make text to show in vertical or horizontal\n *      }\n *    }\n * ]);\n */\nconst regions = function(regions: RegionsParam): RegionsParam {\n\treturn regionsFn.bind(this)(regions);\n};\n\nextend(regions, {\n\t/**\n\t * Add new region.<br><br>\n\t * This API adds new region instead of replacing like regions.\n\t * @function regions․add\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array|object} regions New region will be added. The format of this argument is the same as [regions](./Options.html#.regions) and it's possible to give an Object if only one region will be added.\n\t * @returns {Array} regions\n\t * @example\n\t * // Add a new region\n\t * chart.regions.add(\n\t *    {\n\t *      axis: \"x\", start: 5, class: \"regionX\",\n\t *      label: {\n\t *      \ttext: \"Region Text\",\n\t *      \tcolor: \"red\"  // color string\n\t *      }\n\t *    }\n\t * );\n\t *\n\t * // Add new regions\n\t * chart.regions.add([\n\t *    {axis: \"x\", start: 5, class: \"regionX\"},\n\t *    {\n\t *      axis: \"y\", end: 50, class: \"regionY\",\n\t *      label: {\n\t *      \ttext: \"Region Text\",\n\t *      \tx: 5,  // position relative of the initial x coordinate\n\t *      \ty: 5,  // position relative of the initial y coordinate\n\t *      \tcolor: \"red\",  // color string\n\t *      \trotated: true  // make text to show in vertical or horizontal\n\t *      }\n\t *    }\n\t * ]);\n\t */\n\tadd: function(regions: RegionsParam): RegionsParam {\n\t\treturn regionsFn.bind(this)(regions, true);\n\t},\n\n\t/**\n\t * Remove regions.<br><br>\n\t * This API removes regions.\n\t * @function regions․remove\n\t * @instance\n\t * @memberof Chart\n\t * @param {object} optionsValue This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.\n\t * @returns {Array} regions Removed regions\n\t * @example\n\t * // regions that have 'region-A' or 'region-B' will be removed.\n\t * chart.regions.remove({\n\t *   classes: [\n\t *     \"region-A\", \"region-B\"\n\t *   ]\n\t * });\n\t *\n\t * // all of regions will be removed.\n\t * chart.regions.remove();\n\t */\n\tremove: function(optionsValue: RegionsParam): RegionsParam {\n\t\tconst $$ = this.internal;\n\t\tconst {config, $T} = $$;\n\n\t\tconst options = optionsValue || {};\n\t\tconst classes = getOption(options, \"classes\", [$REGION.region]);\n\t\tlet regions = $$.$el.main.select(`.${$REGION.regions}`)\n\t\t\t.selectAll(classes.map(c => `.${c}`));\n\n\t\t$T(regions)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\tregions = config.regions;\n\n\t\tif (Object.keys(options).length) {\n\t\t\tregions = regions.filter(region => {\n\t\t\t\tlet found = false;\n\n\t\t\t\tif (!region.class) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tregion.class.split(\" \").forEach(c => {\n\t\t\t\t\tif (classes.indexOf(c) >= 0) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn !found;\n\t\t\t});\n\n\t\t\tconfig.regions = regions;\n\t\t} else {\n\t\t\tconfig.regions = [];\n\t\t}\n\n\t\treturn regions;\n\t}\n});\n\nexport default {regions};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {isArray, isObject} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Get and set x values for the chart.\n\t * @function x\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.\n\t * @returns {object} xs\n\t * @example\n\t *  // Get current x values\n\t *  chart.x();\n\t *\n\t *  // Update x values for all targets\n\t *  chart.x([100, 200, 300, 400, ...]);\n\t */\n\tx(x?: number[]): {[key: string]: number[]} {\n\t\tconst $$ = this.internal;\n\t\tconst {axis, data} = $$;\n\t\tconst isCategorized = axis.isCustomX() && axis.isCategorized();\n\n\t\tif (isArray(x)) {\n\t\t\tif (isCategorized) {\n\t\t\t\tthis.categories(x);\n\t\t\t} else {\n\t\t\t\t$$.updateTargetX(data.targets, x);\n\n\t\t\t\t$$.redraw({\n\t\t\t\t\twithUpdateOrgXDomain: true,\n\t\t\t\t\twithUpdateXDomain: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn isCategorized ? this.categories() : data.xs;\n\t},\n\n\t/**\n\t * Get and set x values for the chart.\n\t * @function xs\n\t * @instance\n\t * @memberof Chart\n\t * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.\n\t * @returns {object} xs\n\t * @example\n\t *  // Get current x values\n\t *  chart.xs();\n\t *\n\t *  // Update x values for all targets\n\t *  chart.xs({\n\t *    data1: [10, 20, 30, 40, ...],\n\t *    data2: [100, 200, 300, 400, ...]\n\t *  });\n\t */\n\txs(xs?: {[key: string]: number[]}): {[key: string]: number[]} {\n\t\tconst $$ = this.internal;\n\n\t\tif (isObject(xs)) {\n\t\t\t$$.updateTargetXs($$.data.targets, xs);\n\n\t\t\t$$.redraw({\n\t\t\t\twithUpdateOrgXDomain: true,\n\t\t\t\twithUpdateXDomain: true\n\t\t\t});\n\t\t}\n\n\t\treturn $$.data.xs;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n * @ignore\n */\nimport type {d3Selection} from \"../../../types/types\";\nimport {getBBox, isDefined, isNumber, isString, isValue} from \"../../module/util\";\nimport {getScale} from \"../internals/scale\";\n\nexport default class AxisRendererHelper {\n\tprivate owner;\n\tprivate config;\n\tprivate scale;\n\tprivate charSize = {};\n\n\tconstructor(owner) {\n\t\tconst scale = getScale();\n\t\tconst {config, params} = owner;\n\n\t\tthis.owner = owner;\n\t\tthis.config = config;\n\t\tthis.scale = scale;\n\n\t\tif (config.noTransition || !params.config.transition_duration) {\n\t\t\tconfig.withoutTransition = true;\n\t\t}\n\n\t\t// set range\n\t\tconfig.range = this.scaleExtent((params.orgXScale || scale).range());\n\t}\n\n\t/**\n\t * Compute a character dimension\n\t * @param {string} orient Axis orientation\n\t * @param {d3.selection} text SVG text selection\n\t * @param {boolean} memoize memoize the calculated size\n\t * @returns {{w: number, h: number}}\n\t * @private\n\t */\n\tgetSizeFor1Char(orient: \"top\" | \"bottom\" | \"left\" | \"right\", text: d3Selection,\n\t\tmemoize = true): {w: number, h: number} {\n\t\t// default size for one character\n\t\tconst size = {\n\t\t\tw: 5.5,\n\t\t\th: 11.5\n\t\t};\n\n\t\tif (this.charSize[orient] && memoize) {\n\t\t\treturn this.charSize[orient];\n\t\t}\n\n\t\t!text.empty() && text\n\t\t\t.text(\"0\")\n\t\t\t.call((el: d3Selection) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst {width, height} = getBBox(el.node(), true);\n\n\t\t\t\t\tif (width && height) {\n\t\t\t\t\t\tsize.w = width;\n\t\t\t\t\t\tsize.h = height;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tel.text(\"\");\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.charSize[orient] = size;\n\n\t\treturn size;\n\t}\n\n\t/**\n\t * Get tick transform setter function\n\t * @param {string} id Axis id\n\t * @returns {Function} transfrom setter function\n\t * @private\n\t */\n\tgetTickTransformSetter(id: string): (selection: d3Selection, scale) => void {\n\t\tconst {config} = this;\n\t\tconst fn = id === \"x\" ?\n\t\t\tvalue => `translate(${value + config.tickOffset},0)` :\n\t\t\tvalue => `translate(0,${value})`;\n\n\t\treturn (selection, scale) => {\n\t\t\tselection.attr(\"transform\", d => {\n\t\t\t\tconst x = scale(d);\n\n\t\t\t\treturn isValue(d) ? fn(x) : null;\n\t\t\t});\n\t\t};\n\t}\n\n\tscaleExtent(domain: [number, number]): [number, number] {\n\t\tconst start = domain[0];\n\t\tconst stop = domain[domain.length - 1];\n\n\t\treturn start < stop ? [start, stop] : [stop, start];\n\t}\n\n\tgenerateTicks(scale, isYAxes: boolean): number[] {\n\t\tconst {tickStepSize} = this.owner.params;\n\t\tconst [start, end] = scale.domain();\n\t\tlet ticks: number[] = [];\n\n\t\t// When 'axis[y|y2].tick.stepSize' option is set\n\t\tif (isYAxes && tickStepSize) {\n\t\t\tlet interval = Math.round(start);\n\n\t\t\twhile (interval <= end) {\n\t\t\t\tticks.push(interval);\n\t\t\t\tinterval += tickStepSize;\n\t\t\t}\n\t\t} else if (scale.ticks) {\n\t\t\tconst {tickArguments} = this.config;\n\n\t\t\t// adjust excessive tick count show\n\t\t\tif (scale.type === \"log\" && !tickArguments) {\n\t\t\t\t// nicer symlog ticks didn't implemented yet: https://github.com/d3/d3-scale/issues/162\n\t\t\t\t// get ticks values from logScale\n\t\t\t\tconst s = getScale(\"_log\")\n\t\t\t\t\t.domain([start > 0 ? start : 1, end])\n\t\t\t\t\t.range(scale.range());\n\n\t\t\t\tticks = s.ticks();\n\n\t\t\t\tfor (let cnt = end.toFixed().length; ticks.length > 15; cnt--) {\n\t\t\t\t\tticks = s.ticks(cnt);\n\t\t\t\t}\n\n\t\t\t\tticks.splice(0, 1, start);\n\t\t\t\tticks.splice(ticks.length - 1, 1, end);\n\t\t\t} else {\n\t\t\t\tticks = scale\n\t\t\t\t\t.ticks(...(this.config.tickArguments || []));\n\t\t\t}\n\n\t\t\tticks = ticks\n\t\t\t\t.map(v => {\n\t\t\t\t\t// round the tick value if is number\n\t\t\t\t\tconst r = (isString(v) && isNumber(v) && !isNaN(v) &&\n\t\t\t\t\t\tMath.round(v * 10) / 10) || v;\n\n\t\t\t\t\treturn r;\n\t\t\t\t});\n\t\t}\n\n\t\treturn ticks;\n\t}\n\n\tcopyScale() {\n\t\tconst newScale = this.scale.copy();\n\n\t\tif (!newScale.domain().length) {\n\t\t\tnewScale.domain(this.scale.domain());\n\t\t}\n\n\t\tnewScale.type = this.scale.type;\n\n\t\treturn newScale;\n\t}\n\n\ttextFormatted(v: string | number | any): string {\n\t\tconst tickFormat = this.config.tickFormat;\n\n\t\t// to round float numbers from 'binary floating point'\n\t\t// https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n\t\t// https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand\n\t\tconst value = /\\d+\\.\\d+0{5,}\\d$/.test(v) ? +String(v).replace(/0+\\d$/, \"\") : v;\n\t\tconst formatted = tickFormat ? tickFormat(value) : value;\n\n\t\treturn isDefined(formatted) ? formatted : \"\";\n\t}\n\n\ttransitionise(selection): d3Selection {\n\t\tconst {config} = this;\n\t\tlet transitionSelection = selection;\n\n\t\tif (config.withoutTransition) {\n\t\t\ttransitionSelection = selection.interrupt();\n\t\t} else if (config.transition || !this.owner.params.noTransition) {\n\t\t\t// prevent for 'transition not found' case\n\t\t\t// https://github.com/naver/billboard.js/issues/2140\n\t\t\ttry {\n\t\t\t\ttransitionSelection = selection.transition(config.transition);\n\t\t\t} catch {}\n\t\t}\n\n\t\treturn transitionSelection;\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n * @ignore\n */\nimport {select as d3Select} from \"d3-selection\";\nimport type {d3Selection} from \"../../../types/types\";\nimport {$COMMON} from \"../../config/classes\";\nimport {isArray, isFunction, isNumber, isString, toArray} from \"../../module/util\";\nimport Helper from \"./AxisRendererHelper\";\n\nexport default class AxisRenderer {\n\tprivate helper;\n\tprivate config;\n\tprivate params;\n\tprivate g;\n\tprivate generatedTicks: (Date | number)[];\n\n\tconstructor(params: any = {}) {\n\t\tconst config = {\n\t\t\tinnerTickSize: 6,\n\t\t\touterTickSize: params.outerTick ? 6 : 0,\n\t\t\torient: \"bottom\",\n\t\t\trange: [],\n\t\t\ttickArguments: null,\n\t\t\ttickCentered: null,\n\t\t\ttickCulling: true,\n\t\t\ttickFormat: null,\n\t\t\ttickLength: 9,\n\t\t\ttickOffset: 0,\n\t\t\ttickPadding: 3,\n\t\t\ttickValues: null,\n\t\t\ttransition: null,\n\t\t\tnoTransition: params.noTransition\n\t\t};\n\n\t\tconfig.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding;\n\n\t\tthis.config = config;\n\t\tthis.params = params;\n\t\tthis.helper = new Helper(this);\n\t}\n\n\t/**\n\t * Create axis element\n\t * @param {d3.selection} g Axis selection\n\t * @private\n\t */\n\tcreate(g: d3Selection): void {\n\t\tconst ctx = this;\n\t\tconst {config, helper, params} = ctx;\n\t\tconst {scale} = helper;\n\t\tconst {orient} = config;\n\t\tconst splitTickText = this.splitTickText.bind(ctx);\n\t\tconst isLeftRight = /^(left|right)$/.test(orient);\n\t\tconst isTopBottom = /^(top|bottom)$/.test(orient);\n\n\t\t// line/text enter and path update\n\t\tconst tickTransform = helper.getTickTransformSetter(isTopBottom ? \"x\" : \"y\");\n\t\tconst axisPx = tickTransform === helper.axisX ? \"y\" : \"x\";\n\t\tconst sign = /^(top|left)$/.test(orient) ? -1 : 1;\n\n\t\t// tick text helpers\n\t\tconst rotate = params.tickTextRotate;\n\n\t\tthis.config.range = scale.rangeExtent ?\n\t\t\tscale.rangeExtent() :\n\t\t\thelper.scaleExtent((params.orgXScale || scale).range());\n\n\t\tconst {innerTickSize, tickLength, range} = config;\n\n\t\t// // get the axis' tick position configuration\n\t\tconst id = params.id;\n\t\tconst tickTextPos = id && /^(x|y|y2)$/.test(id) ?\n\t\t\tparams.config[`axis_${id}_tick_text_position`] :\n\t\t\t{x: 0, y: 0};\n\n\t\t// tick visiblity\n\t\tconst prefix = id === \"subX\" ? `subchart_axis_x` : `axis_${id}`;\n\t\tconst axisShow = params.config[`${prefix}_show`];\n\t\tconst tickShow = {\n\t\t\ttick: axisShow ? params.config[`${prefix}_tick_show`] : false,\n\t\t\ttext: axisShow ? params.config[`${prefix}_tick_text_show`] : false\n\t\t};\n\t\tconst evalTextSize = params.config.axis_evalTextSize;\n\n\t\tlet $g;\n\n\t\tg.each(function() {\n\t\t\tconst g = d3Select(this);\n\t\t\tlet scale0 = this.__chart__ || scale;\n\t\t\tlet scale1 = helper.copyScale();\n\n\t\t\t$g = g;\n\t\t\tthis.__chart__ = scale1;\n\n\t\t\tconfig.tickOffset = params.isCategory ? (scale1(1) - scale1(0)) / 2 : 0;\n\n\t\t\t// update selection - data join\n\t\t\tconst path = g.selectAll(\".domain\").data([0]);\n\n\t\t\t// enter + update selection\n\t\t\tpath.enter().append(\"path\")\n\t\t\t\t.attr(\"class\", \"domain\")\n\t\t\t\t// https://observablehq.com/@d3/d3-selection-2-0\n\t\t\t\t.merge(path as d3Selection)\n\t\t\t\t.attr(\"d\", () => {\n\t\t\t\t\tconst outerTickSized = config.outerTickSize * sign;\n\n\t\t\t\t\treturn isTopBottom ?\n\t\t\t\t\t\t`M${range[0]},${outerTickSized}V0H${range[1]}V${outerTickSized}` :\n\t\t\t\t\t\t`M${outerTickSized},${range[0]}H0V${range[1]}H${outerTickSized}`;\n\t\t\t\t});\n\n\t\t\tif (tickShow.tick || tickShow.text) {\n\t\t\t\t// count of tick data in array\n\t\t\t\tconst ticks = config.tickValues ||\n\t\t\t\t\thelper.generateTicks(scale1, isLeftRight || params.config.axis_rotated);\n\n\t\t\t\t// set generated ticks\n\t\t\t\tctx.generatedTicks = ticks;\n\n\t\t\t\t// update selection\n\t\t\t\tlet tick: d3Selection = g.selectAll(\".tick\")\n\t\t\t\t\t.data(ticks, scale1);\n\n\t\t\t\t// enter selection\n\t\t\t\tconst tickEnter = tick\n\t\t\t\t\t.enter()\n\t\t\t\t\t.insert(\"g\", \".domain\")\n\t\t\t\t\t.attr(\"class\", \"tick\");\n\n\t\t\t\t// MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.\n\t\t\t\tconst tickExit = tick.exit().remove();\n\n\t\t\t\t// enter + update selection\n\t\t\t\ttick = tickEnter.merge(tick);\n\n\t\t\t\ttickShow.tick && tickEnter.append(\"line\");\n\t\t\t\ttickShow.text && tickEnter.append(\"text\");\n\n\t\t\t\tconst tickText = tick.select(\"text\");\n\t\t\t\tconst counts: number[] = [];\n\t\t\t\tlet sizeFor1Char = {w: 0, h: 0};\n\n\t\t\t\tif (isFunction(evalTextSize)) {\n\t\t\t\t\t// set evalTextSize to dummy axis element to be used in .getMaxTickSize()\n\t\t\t\t\tsizeFor1Char = evalTextSize.bind(ctx.params.owner.api)(tickText.node(), id);\n\n\t\t\t\t\tif (this.classList.contains($COMMON.dummy)) {\n\t\t\t\t\t\tthis.sizeFor1Char = sizeFor1Char;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!sizeFor1Char || sizeFor1Char.w === 0 || sizeFor1Char.h === 0) {\n\t\t\t\t\tsizeFor1Char = ctx.helper.getSizeFor1Char(orient, tickText, !!evalTextSize);\n\t\t\t\t}\n\n\t\t\t\tlet tspan: d3Selection = tickText\n\t\t\t\t\t.selectAll(\"tspan\")\n\t\t\t\t\t.data((d, index) => {\n\t\t\t\t\t\tconst split = params.tickMultiline ?\n\t\t\t\t\t\t\tsplitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) :\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tisArray(helper.textFormatted(d)) ?\n\t\t\t\t\t\t\t\t\thelper.textFormatted(d).concat() :\n\t\t\t\t\t\t\t\t\t[helper.textFormatted(d)]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\tcounts[index] = split.length;\n\n\t\t\t\t\t\treturn split.map(splitted => ({index, splitted}));\n\t\t\t\t\t});\n\n\t\t\t\ttspan.exit().remove();\n\n\t\t\t\ttspan = tspan\n\t\t\t\t\t.enter()\n\t\t\t\t\t.append(\"tspan\")\n\t\t\t\t\t.merge(tspan)\n\t\t\t\t\t.text(d => d.splitted);\n\n\t\t\t\t// set <tspan>'s position\n\t\t\t\ttspan\n\t\t\t\t\t.attr(\"x\", isTopBottom ? 0 : tickLength * sign)\n\t\t\t\t\t.attr(\"dx\", (() => {\n\t\t\t\t\t\tlet dx = 0;\n\n\t\t\t\t\t\tif (/(top|bottom)/.test(orient) && rotate) {\n\t\t\t\t\t\t\tdx = 8 * Math.sin(Math.PI * (rotate / 180)) *\n\t\t\t\t\t\t\t\t(orient === \"top\" ? -1 : 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn dx + (tickTextPos.x || 0);\n\t\t\t\t\t})())\n\t\t\t\t\t.attr(\"dy\", (d, i) => {\n\t\t\t\t\t\tconst defValue = \".71em\";\n\t\t\t\t\t\tlet dy: number | string = 0;\n\n\t\t\t\t\t\tif (orient !== \"top\") {\n\t\t\t\t\t\t\tdy = sizeFor1Char.h;\n\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\tdy = isLeftRight ?\n\t\t\t\t\t\t\t\t\t-((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) :\n\t\t\t\t\t\t\t\t\t(tickTextPos.y === 0 ? defValue : 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || defValue;\n\t\t\t\t\t});\n\n\t\t\t\tconst lineUpdate = tick.select(\"line\");\n\t\t\t\tconst textUpdate = tick.select(\"text\");\n\n\t\t\t\ttickEnter.select(\"line\").attr(`${axisPx}2`, innerTickSize * sign);\n\t\t\t\ttickEnter.select(\"text\").attr(axisPx, tickLength * sign);\n\n\t\t\t\tctx.setTickLineTextPosition(lineUpdate, textUpdate, sizeFor1Char);\n\n\t\t\t\t// Append <title> for tooltip display\n\t\t\t\tif (params.tickTitle) {\n\t\t\t\t\tconst title = textUpdate.select(\"title\");\n\n\t\t\t\t\t(title.empty() ? textUpdate.append(\"title\") : title)\n\t\t\t\t\t\t.text(index => params.tickTitle[index]);\n\t\t\t\t}\n\n\t\t\t\tif (scale1.bandwidth) {\n\t\t\t\t\tconst x = scale1;\n\t\t\t\t\tconst dx = x.bandwidth() / 2;\n\n\t\t\t\t\tscale0 = d => x(d) + dx;\n\t\t\t\t\tscale1 = scale0;\n\t\t\t\t} else if (scale0.bandwidth) {\n\t\t\t\t\tscale0 = scale1;\n\t\t\t\t} else {\n\t\t\t\t\ttickTransform(tickExit, scale1);\n\t\t\t\t}\n\n\t\t\t\t// when .flow(), it should follow flow's transition config\n\t\t\t\t// otherwise make to use ChartInternals.$T()\n\t\t\t\ttick = params.owner.state.flowing ?\n\t\t\t\t\thelper.transitionise(tick) :\n\t\t\t\t\tparams.owner.$T(tick);\n\n\t\t\t\ttickTransform(tickEnter, scale0);\n\t\t\t\ttickTransform(tick.style(\"opacity\", null), scale1);\n\t\t\t}\n\t\t});\n\n\t\tthis.g = $g;\n\t}\n\n\t/**\n\t * Get generated ticks\n\t * @param {number} count Count of ticks\n\t * @returns {Array} Generated ticks\n\t * @private\n\t */\n\tgetGeneratedTicks(count: number): (Date | number)[] {\n\t\tconst len = this.generatedTicks?.length - 1;\n\t\tlet res = this.generatedTicks;\n\n\t\tif (len > count) {\n\t\t\tconst interval = Math.round((len / count) + 0.1);\n\n\t\t\tres = this.generatedTicks\n\t\t\t\t.map((v, i) => (i % interval === 0 ? v : null))\n\t\t\t\t.filter(v => v !== null)\n\t\t\t\t.splice(0, count) as (Date | number)[];\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Get tick x/y coordinate\n\t * @returns {{x: number, y: number}}\n\t * @private\n\t */\n\tgetTickXY(): {x: number, y: number} {\n\t\tconst {config} = this;\n\t\tconst pos = {x: 0, y: 0};\n\n\t\tif (this.params.isCategory) {\n\t\t\tpos.x = config.tickCentered ? 0 : config.tickOffset;\n\t\t\tpos.y = config.tickCentered ? config.tickOffset : 0;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Get tick size\n\t * @param {object} d data object\n\t * @returns {number}\n\t * @private\n\t */\n\tgetTickSize(d): number {\n\t\tconst {scale} = this.helper;\n\t\tconst {config} = this;\n\t\tconst {innerTickSize, range} = config;\n\n\t\tconst tickPosition = scale(d) +\n\t\t\t(config.tickCentered ? 0 : config.tickOffset);\n\n\t\treturn range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;\n\t}\n\n\t/**\n\t * Set tick's line & text position\n\t * @param {d3.selection} lineUpdate Line selection\n\t * @param {d3.selection} textUpdate Text selection\n\t * @param {object} sizeFor1Char Size for 1 char\n\t * @private\n\t */\n\tsetTickLineTextPosition(lineUpdate, textUpdate, sizeFor1Char): void {\n\t\tconst tickPos = this.getTickXY();\n\t\tconst {innerTickSize, orient, tickLength, tickOffset} = this.config;\n\t\tconst rotate = this.params.tickTextRotate;\n\t\tconst baseHeight = 6;\n\t\tconst charHeight = (sizeFor1Char.h / 2) - baseHeight;\n\n\t\tconst textAnchorForText = r => {\n\t\t\tconst value = [\"start\", \"end\"];\n\n\t\t\torient === \"top\" && value.reverse();\n\n\t\t\treturn !r ? \"middle\" : value[r > 0 ? 0 : 1];\n\t\t};\n\t\tconst textTransform = r => (r ? `rotate(${r})` : null);\n\t\tconst yForText = r => {\n\t\t\tconst r2 = r / (orient === \"bottom\" ? 15 : 23);\n\t\t\tconst y = r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;\n\n\t\t\treturn y;\n\t\t};\n\n\t\tconst {\n\t\t\tconfig: {\n\t\t\t\taxis_rotated: isRotated,\n\t\t\t\taxis_x_tick_text_inner: inner\n\t\t\t}\n\t\t} = this.params.owner;\n\n\t\tswitch (orient) {\n\t\t\tcase \"bottom\":\n\t\t\t\tlineUpdate\n\t\t\t\t\t.attr(\"x1\", tickPos.x)\n\t\t\t\t\t.attr(\"x2\", tickPos.x)\n\t\t\t\t\t.attr(\"y2\", this.getTickSize.bind(this));\n\n\t\t\t\ttextUpdate\n\t\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t\t.attr(\"y\", yForText(rotate))\n\t\t\t\t\t.style(\"text-anchor\", textAnchorForText(rotate))\n\t\t\t\t\t.style(\"text-anchor\", (d, i, {length}) => {\n\t\t\t\t\t\tif (!isRotated && i === 0 && (inner === true || inner.first)) {\n\t\t\t\t\t\t\treturn \"start\";\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!isRotated && i === length - 1 && (inner === true || inner.last)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn \"end\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn textAnchorForText(rotate);\n\t\t\t\t\t})\n\t\t\t\t\t.attr(\"transform\", textTransform(rotate));\n\t\t\t\tbreak;\n\t\t\tcase \"top\":\n\t\t\t\tlineUpdate\n\t\t\t\t\t.attr(\"x2\", 0)\n\t\t\t\t\t.attr(\"y2\", -innerTickSize);\n\n\t\t\t\ttextUpdate\n\t\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t\t.attr(\"y\", -(yForText(rotate) + charHeight + baseHeight))\n\t\t\t\t\t.style(\"text-anchor\", textAnchorForText(rotate))\n\t\t\t\t\t.attr(\"transform\", textTransform(rotate));\n\t\t\t\tbreak;\n\t\t\tcase \"left\":\n\t\t\t\tlineUpdate\n\t\t\t\t\t.attr(\"x2\", -innerTickSize)\n\t\t\t\t\t.attr(\"y1\", tickPos.y)\n\t\t\t\t\t.attr(\"y2\", tickPos.y);\n\n\t\t\t\ttextUpdate\n\t\t\t\t\t.attr(\"x\", -tickLength)\n\t\t\t\t\t.attr(\"y\", tickOffset + (isRotated ? charHeight / 4 : charHeight))\n\t\t\t\t\t.style(\"text-anchor\", \"end\");\n\t\t\t\tbreak;\n\t\t\tcase \"right\":\n\t\t\t\tlineUpdate\n\t\t\t\t\t.attr(\"x2\", innerTickSize)\n\t\t\t\t\t.attr(\"y2\", 0);\n\n\t\t\t\ttextUpdate\n\t\t\t\t\t.attr(\"x\", tickLength)\n\t\t\t\t\t.attr(\"y\", charHeight)\n\t\t\t\t\t.style(\"text-anchor\", \"start\");\n\t\t}\n\t}\n\n\t// this should be called only when category axis\n\tsplitTickText(d, scale, ticks, isLeftRight, charWidth) {\n\t\tconst {params} = this;\n\t\tconst tickText = this.helper.textFormatted(d);\n\t\tconst splitted = isString(tickText) && tickText.indexOf(\"\\n\") > -1 ?\n\t\t\ttickText.split(\"\\n\") :\n\t\t\t[];\n\n\t\tif (splitted.length) {\n\t\t\treturn splitted;\n\t\t}\n\n\t\tif (isArray(tickText)) {\n\t\t\treturn tickText;\n\t\t}\n\n\t\tlet tickWidth = params.tickWidth;\n\n\t\tif (!tickWidth || tickWidth <= 0) {\n\t\t\ttickWidth = isLeftRight ? 95 : (\n\t\t\t\tparams.isCategory ?\n\t\t\t\t\t(\n\t\t\t\t\t\tparams.isInverted ?\n\t\t\t\t\t\t\tscale(ticks[0]) - scale(ticks[1]) :\n\t\t\t\t\t\t\tscale(ticks[1]) - scale(ticks[0])\n\t\t\t\t\t) - 12 :\n\t\t\t\t\t110\n\t\t\t);\n\t\t}\n\n\t\t// split given text by tick width size\n\t\t// eslint-disable-next-line\n\t\tfunction split(splitted, text) {\n\t\t\tlet subtext;\n\t\t\tlet spaceIndex;\n\t\t\tlet textWidth;\n\n\t\t\tfor (let i = 1; i < text.length; i++) {\n\t\t\t\tif (text.charAt(i) === \" \") {\n\t\t\t\t\tspaceIndex = i;\n\t\t\t\t}\n\n\t\t\t\tsubtext = text.substr(0, i + 1);\n\t\t\t\ttextWidth = charWidth * subtext.length;\n\n\t\t\t\t// if text width gets over tick width, split by space index or current index\n\t\t\t\tif (tickWidth < textWidth) {\n\t\t\t\t\treturn split(\n\t\t\t\t\t\tsplitted.concat(text.substr(0, spaceIndex || i)),\n\t\t\t\t\t\ttext.slice(spaceIndex ? spaceIndex + 1 : i)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn splitted.concat(text);\n\t\t}\n\n\t\treturn split(splitted, String(tickText));\n\t}\n\n\tscale(x?): AxisRenderer {\n\t\tif (!arguments.length) {\n\t\t\treturn this.helper.scale;\n\t\t}\n\n\t\tthis.helper.scale = x;\n\n\t\treturn this;\n\t}\n\n\torient(x): AxisRenderer {\n\t\tif (!arguments.length) {\n\t\t\treturn this.config.orient;\n\t\t}\n\n\t\tthis.config.orient = x in {\n\t\t\t\ttop: 1,\n\t\t\t\tright: 1,\n\t\t\t\tbottom: 1,\n\t\t\t\tleft: 1\n\t\t\t} ?\n\t\t\tString(x) :\n\t\t\t\"bottom\";\n\n\t\treturn this;\n\t}\n\n\ttickFormat(format): AxisRenderer {\n\t\tconst {config} = this;\n\n\t\tif (!arguments.length) {\n\t\t\treturn config.tickFormat;\n\t\t}\n\n\t\tconfig.tickFormat = format;\n\n\t\treturn this;\n\t}\n\n\ttickCentered(isCentered: boolean): AxisRenderer {\n\t\tconst {config} = this;\n\n\t\tif (!arguments.length) {\n\t\t\treturn config.tickCentered;\n\t\t}\n\n\t\tconfig.tickCentered = isCentered;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return tick's offset value.\n\t * The value will be set for 'category' axis type.\n\t * @returns {number}\n\t * @private\n\t */\n\ttickOffset(): number {\n\t\treturn this.config.tickOffset;\n\t}\n\n\t/**\n\t * Get tick interval count\n\t * @private\n\t * @param {number} size Total data size\n\t * @returns {number}\n\t */\n\ttickInterval(size: number): number {\n\t\tconst {outerTickSize, tickOffset, tickValues} = this.config;\n\t\tlet interval;\n\n\t\tif (this.params.isCategory) {\n\t\t\tinterval = tickOffset * 2;\n\t\t} else {\n\t\t\tconst scale = this.params.owner.scale.zoom ?? this.helper.scale;\n\t\t\tconst length = this.g.select(\"path.domain\")\n\t\t\t\t.node()\n\t\t\t\t.getTotalLength() - outerTickSize * 2;\n\n\t\t\tinterval = length / (size || this.g.selectAll(\"line\").size());\n\n\t\t\t// get the interval by its values\n\t\t\tconst intervalByValue = tickValues ?\n\t\t\t\ttickValues\n\t\t\t\t\t.map((v, i, arr) => {\n\t\t\t\t\t\tconst next = i + 1;\n\n\t\t\t\t\t\treturn next < arr.length ? scale(arr[next]) - scale(v) : null;\n\t\t\t\t\t}).filter(Boolean) :\n\t\t\t\t[];\n\n\t\t\tinterval = Math.min(...intervalByValue, interval);\n\t\t}\n\n\t\treturn interval === Infinity ? 0 : interval;\n\t}\n\n\tticks(...args): AxisRenderer {\n\t\tconst {config} = this;\n\n\t\tif (!args.length) {\n\t\t\treturn config.tickArguments;\n\t\t}\n\n\t\tconfig.tickArguments = toArray(args);\n\n\t\treturn this;\n\t}\n\n\ttickCulling(culling): AxisRenderer {\n\t\tconst {config} = this;\n\n\t\tif (!arguments.length) {\n\t\t\treturn config.tickCulling;\n\t\t}\n\n\t\tconfig.tickCulling = culling;\n\n\t\treturn this;\n\t}\n\n\ttickValues(\n\t\tx?: (number | Date | string)[] | Function\n\t): AxisRenderer | (number | Date | string)[] {\n\t\tconst {config} = this;\n\n\t\tif (isFunction(x)) {\n\t\t\tconfig.tickValues = () => x(this.helper.scale.domain());\n\t\t} else {\n\t\t\tif (!arguments.length) {\n\t\t\t\treturn config.tickValues;\n\t\t\t}\n\n\t\t\tconfig.tickValues = x;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tsetTransition(t): AxisRenderer {\n\t\tthis.config.transition = t;\n\n\t\treturn this;\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {\n\taxisBottom as d3AxisBottom,\n\taxisLeft as d3AxisLeft,\n\taxisRight as d3AxisRight,\n\taxisTop as d3AxisTop\n} from \"d3-axis\";\nimport type {AxisType} from \"../../../types/types\";\nimport {$AXIS, $COMMON} from \"../../config/classes\";\nimport {\n\tcapitalize,\n\tgetBoundingRect,\n\tisArray,\n\tisEmpty,\n\tisFunction,\n\tisNumber,\n\tisObjectType,\n\tisString,\n\tisValue,\n\tmergeObj,\n\tnotEmpty,\n\tparseDate,\n\tsortValue\n} from \"../../module/util\";\nimport {getScale} from \"../internals/scale\";\nimport AxisRenderer from \"./AxisRenderer\";\n\nexport default {\n\tgetAxisInstance: function() {\n\t\treturn this.axis || new Axis(this);\n\t}\n};\n\nclass Axis {\n\tpublic owner;\n\n\tpublic x;\n\tpublic subX;\n\tpublic y;\n\tpublic y2;\n\n\tprivate axesList = {};\n\tpublic tick = {\n\t\tx: null,\n\t\ty: null,\n\t\ty2: null\n\t};\n\tpublic xs = [];\n\tprivate orient = {\n\t\tx: \"bottom\",\n\t\ty: \"left\",\n\t\ty2: \"right\",\n\t\tsubX: \"bottom\"\n\t};\n\n\tconstructor(owner) {\n\t\tthis.owner = owner;\n\t\tthis.setOrient();\n\t}\n\n\tprivate getAxisClassName(id) {\n\t\treturn `${$AXIS.axis} ${$AXIS[`axis${capitalize(id)}`]}`;\n\t}\n\n\tprivate isHorizontal($$, forHorizontal) {\n\t\tconst isRotated = $$.config.axis_rotated;\n\n\t\treturn forHorizontal ? isRotated : !isRotated;\n\t}\n\n\tpublic isCategorized() {\n\t\tconst {config, state} = this.owner;\n\n\t\treturn config.axis_x_type.indexOf(\"category\") >= 0 || state.hasRadar;\n\t}\n\n\tpublic isCustomX() {\n\t\tconst {config} = this.owner;\n\n\t\treturn !this.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));\n\t}\n\n\tpublic isTimeSeries(id = \"x\") {\n\t\treturn this.owner.config[`axis_${id}_type`] === \"timeseries\";\n\t}\n\n\tpublic isLog(id = \"x\") {\n\t\treturn this.owner.config[`axis_${id}_type`] === \"log\";\n\t}\n\n\tpublic isTimeSeriesY() {\n\t\treturn this.isTimeSeries(\"y\");\n\t}\n\n\tpublic getAxisType(id = \"x\"): string {\n\t\tlet type = \"linear\";\n\n\t\tif (this.isTimeSeries(id)) {\n\t\t\ttype = this.owner.config.axis_x_localtime ? \"time\" : \"utc\";\n\t\t} else if (this.isLog(id)) {\n\t\t\ttype = \"log\";\n\t\t}\n\n\t\treturn type;\n\t}\n\n\t/**\n\t * Get extent value\n\t * @returns {Array} default extent\n\t * @private\n\t */\n\tpublic getExtent(): number[] {\n\t\tconst $$ = this.owner;\n\t\tconst {config, scale} = $$;\n\t\tlet extent = config.axis_x_extent;\n\n\t\tif (extent) {\n\t\t\tif (isFunction(extent)) {\n\t\t\t\textent = extent.bind($$.api)($$.getXDomain($$.data.targets), scale.subX);\n\t\t\t} else if (this.isTimeSeries() && extent.every(isNaN)) {\n\t\t\t\tconst fn = parseDate.bind($$);\n\n\t\t\t\textent = extent.map(v => scale.subX(fn(v)));\n\t\t\t}\n\t\t}\n\n\t\treturn extent;\n\t}\n\n\tinit() {\n\t\tconst $$ = this.owner;\n\t\tconst {config, $el: {main, axis}, state: {clip}} = $$;\n\t\tconst target = [\"x\", \"y\"];\n\n\t\tconfig.axis_y2_show && target.push(\"y2\");\n\n\t\ttarget.forEach(v => {\n\t\t\tconst classAxis = this.getAxisClassName(v);\n\n\t\t\taxis[v] = main.append(\"g\")\n\t\t\t\t.attr(\"class\", classAxis)\n\t\t\t\t.attr(\"clip-path\", () => {\n\t\t\t\t\tlet res = null;\n\n\t\t\t\t\tif (v === \"x\") {\n\t\t\t\t\t\tres = clip.pathXAxis;\n\t\t\t\t\t} else if (v === \"y\") { // || v === \"y2\") {\n\t\t\t\t\t\tres = clip.pathYAxis;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res;\n\t\t\t\t})\n\t\t\t\t.attr(\"transform\", $$.getTranslate(v))\n\t\t\t\t.style(\"visibility\", config[`axis_${v}_show`] ? null : \"hidden\");\n\n\t\t\tthis.generateAxes(v);\n\t\t});\n\t}\n\n\t/**\n\t * Set axis orient according option value\n\t * @private\n\t */\n\tsetOrient() {\n\t\tconst $$ = this.owner;\n\t\tconst {\n\t\t\taxis_rotated: isRotated,\n\t\t\taxis_y_inner: yInner,\n\t\t\taxis_y2_inner: y2Inner\n\t\t} = $$.config;\n\n\t\tthis.orient = {\n\t\t\tx: isRotated ? \"left\" : \"bottom\",\n\t\t\ty: isRotated ? (yInner ? \"top\" : \"bottom\") : (yInner ? \"right\" : \"left\"),\n\t\t\ty2: isRotated ? (y2Inner ? \"bottom\" : \"top\") : (y2Inner ? \"left\" : \"right\"),\n\t\t\tsubX: isRotated ? \"left\" : \"bottom\"\n\t\t};\n\t}\n\n\t/**\n\t * Generate axes\n\t * It's used when axis' axes option is set\n\t * @param {string} id Axis id\n\t * @private\n\t */\n\tgenerateAxes(id: string) {\n\t\tconst $$ = this.owner;\n\t\tconst {config} = $$;\n\t\tconst axes: any[] = [];\n\t\tconst axesConfig = config[`axis_${id}_axes`];\n\t\tconst isRotated = config.axis_rotated;\n\t\tlet d3Axis;\n\n\t\tif (id === \"x\") {\n\t\t\td3Axis = isRotated ? d3AxisLeft : d3AxisBottom;\n\t\t} else if (id === \"y\") {\n\t\t\td3Axis = isRotated ? d3AxisBottom : d3AxisLeft;\n\t\t} else if (id === \"y2\") {\n\t\t\td3Axis = isRotated ? d3AxisTop : d3AxisRight;\n\t\t}\n\n\t\tif (axesConfig.length) {\n\t\t\taxesConfig.forEach(v => {\n\t\t\t\tconst tick = v.tick || {};\n\t\t\t\tconst scale = $$.scale[id].copy();\n\n\t\t\t\tv.domain && scale.domain(v.domain);\n\n\t\t\t\taxes.push(\n\t\t\t\t\td3Axis(scale)\n\t\t\t\t\t\t.ticks(tick.count)\n\t\t\t\t\t\t.tickFormat(\n\t\t\t\t\t\t\tisFunction(tick.format) ? tick.format.bind($$.api) : ((x: any) => x)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.tickValues(tick.values)\n\t\t\t\t\t\t.tickSizeOuter(tick.outer === false ? 0 : 6)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\tthis.axesList[id] = axes;\n\t}\n\n\t/**\n\t * Update axes nodes\n\t * @private\n\t */\n\tupdateAxes() {\n\t\tconst $$ = this.owner;\n\t\tconst {config, $el: {main}, $T} = $$;\n\n\t\tObject.keys(this.axesList).forEach(id => {\n\t\t\tconst axesConfig = config[`axis_${id}_axes`];\n\t\t\tconst scale = $$.scale[id].copy();\n\t\t\tconst range = scale.range();\n\n\t\t\tthis.axesList[id].forEach((v, i) => {\n\t\t\t\tconst axisRange = v.scale().range();\n\n\t\t\t\t// adjust range value with the current\n\t\t\t\t// https://github.com/naver/billboard.js/issues/859\n\t\t\t\tif (!range.every((v, i) => v === axisRange[i])) {\n\t\t\t\t\tv.scale().range(range);\n\t\t\t\t}\n\n\t\t\t\tconst className = `${this.getAxisClassName(id)}-${i + 1}`;\n\t\t\t\tlet g = main.select(`.${className.replace(/\\s/, \".\")}`);\n\n\t\t\t\tif (g.empty()) {\n\t\t\t\t\tg = main.append(\"g\")\n\t\t\t\t\t\t.attr(\"class\", className)\n\t\t\t\t\t\t.style(\"visibility\", config[`axis_${id}_show`] ? null : \"hidden\")\n\t\t\t\t\t\t.call(v);\n\t\t\t\t} else {\n\t\t\t\t\taxesConfig[i].domain && scale.domain(axesConfig[i].domain);\n\n\t\t\t\t\t$T(g).call(v.scale(scale));\n\t\t\t\t}\n\n\t\t\t\tg.attr(\"transform\", $$.getTranslate(id, i + 1));\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set Axis & tick values\n\t * called from: updateScales()\n\t * @param {string} id Axis id string\n\t * @param {d3Scale} scale Scale\n\t * @param {boolean} outerTick If show outer tick\n\t * @param {boolean} noTransition If with no transition\n\t * @private\n\t */\n\tsetAxis(id, scale, outerTick, noTransition): void {\n\t\tconst $$ = this.owner;\n\n\t\tif (id !== \"subX\") {\n\t\t\tthis.tick[id] = this.getTickValues(id);\n\t\t}\n\n\t\t// @ts-ignore\n\t\tthis[id] = this.getAxis(\n\t\t\tid,\n\t\t\tscale,\n\t\t\touterTick,\n\t\t\t// do not transit x Axis on zoom and resizing\n\t\t\t// https://github.com/naver/billboard.js/issues/1949\n\t\t\tid === \"x\" && ($$.scale.zoom || $$.config.subchart_show || $$.state.resizing) ?\n\t\t\t\ttrue :\n\t\t\t\tnoTransition\n\t\t);\n\t}\n\n\t// called from : getMaxTickSize()\n\tgetAxis(id, scale, outerTick, noTransition, noTickTextRotate): AxisRenderer {\n\t\tconst $$ = this.owner;\n\t\tconst {config} = $$;\n\t\tconst isX = /^(x|subX)$/.test(id);\n\t\tconst type = isX ? \"x\" : id;\n\t\tconst isCategory = isX && this.isCategorized();\n\t\tconst orient = this.orient[id];\n\t\tconst tickTextRotate = noTickTextRotate ? 0 : $$.getAxisTickRotate(type);\n\t\tlet tickFormat;\n\n\t\tif (isX) {\n\t\t\ttickFormat = (id === \"subX\") ? $$.format.subXAxisTick : $$.format.xAxisTick;\n\t\t} else {\n\t\t\tconst fn = config[`axis_${id}_tick_format`];\n\n\t\t\tif (isFunction(fn)) {\n\t\t\t\ttickFormat = fn.bind($$.api);\n\t\t\t}\n\t\t}\n\n\t\tlet tickValues = this.tick[type];\n\n\t\tconst axisParams = mergeObj({\n\t\t\touterTick,\n\t\t\tnoTransition,\n\t\t\tconfig,\n\t\t\tid,\n\t\t\ttickTextRotate,\n\t\t\towner: $$\n\t\t}, isX && {\n\t\t\tisCategory,\n\t\t\tisInverted: config.axis_x_inverted,\n\t\t\ttickMultiline: config.axis_x_tick_multiline,\n\t\t\ttickWidth: config.axis_x_tick_width,\n\t\t\ttickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),\n\t\t\torgXScale: $$.scale.x\n\t\t});\n\n\t\tif (!isX) {\n\t\t\taxisParams.tickStepSize = config[`axis_${type}_tick_stepSize`];\n\t\t}\n\n\t\tconst axis = new AxisRenderer(axisParams)\n\t\t\t.scale((isX && $$.scale.zoom) || scale)\n\t\t\t.orient(orient);\n\n\t\tif (isX && this.isTimeSeries() && tickValues && !isFunction(tickValues)) {\n\t\t\tconst fn = parseDate.bind($$);\n\n\t\t\ttickValues = tickValues.map(v => fn(v));\n\t\t} else if (!isX && this.isTimeSeriesY()) {\n\t\t\t// https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time\n\t\t\taxis.ticks(config.axis_y_tick_time_value);\n\t\t\ttickValues = null;\n\t\t}\n\n\t\ttickValues && axis.tickValues(tickValues);\n\n\t\t// Set tick\n\t\taxis.tickFormat(\n\t\t\ttickFormat || (\n\t\t\t\t!isX && ($$.isStackNormalized() && (x => `${x}%`))\n\t\t\t)\n\t\t);\n\n\t\tif (isCategory) {\n\t\t\taxis.tickCentered(config.axis_x_tick_centered);\n\n\t\t\tif (isEmpty(config.axis_x_tick_culling)) {\n\t\t\t\tconfig.axis_x_tick_culling = false;\n\t\t\t}\n\t\t}\n\n\t\tconst tickCount = config[`axis_${type}_tick_count`];\n\n\t\ttickCount && axis.ticks(tickCount);\n\n\t\treturn axis;\n\t}\n\n\tupdateXAxisTickValues(targets, axis?): string[] {\n\t\tconst $$ = this.owner;\n\t\tconst {config} = $$;\n\t\tconst fit = config.axis_x_tick_fit;\n\t\tlet count = config.axis_x_tick_count;\n\t\tlet values;\n\n\t\tif (fit || (count && fit)) {\n\t\t\tvalues = $$.mapTargetsToUniqueXs(targets);\n\n\t\t\t// if given count is greater than the value length, then limit the count.\n\t\t\tif (this.isCategorized() && count > values.length) {\n\t\t\t\tcount = values.length;\n\t\t\t}\n\n\t\t\tvalues = this.generateTickValues(\n\t\t\t\tvalues,\n\t\t\t\tcount,\n\t\t\t\tthis.isTimeSeries()\n\t\t\t);\n\t\t}\n\n\t\tif (axis) {\n\t\t\taxis.tickValues(values);\n\t\t} else if (this.x) {\n\t\t\tthis.x.tickValues(values);\n\t\t\tthis.subX?.tickValues(values);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tgetId(id: string): string {\n\t\tconst {config, scale} = this.owner;\n\t\tlet axis = config.data_axes[id];\n\n\t\t// when data.axes option has 'y2', but 'axis.y2.show=true' isn't set will return 'y'\n\t\tif (!axis || !scale[axis]) {\n\t\t\taxis = \"y\";\n\t\t}\n\n\t\treturn axis;\n\t}\n\n\tgetXAxisTickFormat(forSubchart?: boolean): Function {\n\t\tconst $$ = this.owner;\n\t\tconst {config, format} = $$;\n\t\t// enable different tick format for x and subX - subX format defaults to x format if not defined\n\t\tconst tickFormat = forSubchart ?\n\t\t\tconfig.subchart_axis_x_tick_format || config.axis_x_tick_format :\n\t\t\tconfig.axis_x_tick_format;\n\t\tconst isTimeSeries = this.isTimeSeries();\n\t\tconst isCategorized = this.isCategorized();\n\t\tlet currFormat;\n\n\t\tif (tickFormat) {\n\t\t\tif (isFunction(tickFormat)) {\n\t\t\t\tcurrFormat = tickFormat.bind($$.api);\n\t\t\t} else if (isTimeSeries) {\n\t\t\t\tcurrFormat = date => (date ? format.axisTime(tickFormat)(date) : \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tcurrFormat = isTimeSeries ? format.defaultAxisTime : (\n\t\t\t\tisCategorized ? $$.categoryName : v => (v < 0 ? v.toFixed(0) : v)\n\t\t\t);\n\t\t}\n\n\t\treturn isFunction(currFormat) ?\n\t\t\tv => currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]) :\n\t\t\tcurrFormat;\n\t}\n\n\tgetTickValues(id: string) {\n\t\tconst $$ = this.owner;\n\t\tconst tickValues = $$.config[`axis_${id}_tick_values`];\n\t\tconst axis = $$[`${id}Axis`];\n\n\t\treturn (isFunction(tickValues) ? tickValues.call($$.api) : tickValues) ||\n\t\t\t(axis ? axis.tickValues() : undefined);\n\t}\n\n\tgetLabelOptionByAxisId(id: string) {\n\t\treturn this.owner.config[`axis_${id}_label`];\n\t}\n\n\tgetLabelText(id: string) {\n\t\tconst option = this.getLabelOptionByAxisId(id);\n\n\t\treturn isString(option) ? option : (\n\t\t\toption ? option.text : null\n\t\t);\n\t}\n\n\tsetLabelText(id: string, text: string) {\n\t\tconst $$ = this.owner;\n\t\tconst {config} = $$;\n\t\tconst option = this.getLabelOptionByAxisId(id);\n\n\t\tif (isString(option)) {\n\t\t\tconfig[`axis_${id}_label`] = text;\n\t\t} else if (option) {\n\t\t\toption.text = text;\n\t\t}\n\t}\n\n\tgetLabelPosition(id: string, defaultPosition) {\n\t\tconst isRotated = this.owner.config.axis_rotated;\n\t\tconst option = this.getLabelOptionByAxisId(id);\n\t\tconst position = (isObjectType(option) && option.position) ?\n\t\t\toption.position :\n\t\t\tdefaultPosition[+!isRotated];\n\n\t\tconst has = v => !!~position.indexOf(v);\n\n\t\treturn {\n\t\t\tisInner: has(\"inner\"),\n\t\t\tisOuter: has(\"outer\"),\n\t\t\tisLeft: has(\"left\"),\n\t\t\tisCenter: has(\"center\"),\n\t\t\tisRight: has(\"right\"),\n\t\t\tisTop: has(\"top\"),\n\t\t\tisMiddle: has(\"middle\"),\n\t\t\tisBottom: has(\"bottom\")\n\t\t};\n\t}\n\n\tgetAxisLabelPosition(id: string) {\n\t\treturn this.getLabelPosition(id,\n\t\t\tid === \"x\" ? [\"inner-top\", \"inner-right\"] : [\"inner-right\", \"inner-top\"]);\n\t}\n\n\tgetLabelPositionById(id: string) {\n\t\treturn this.getAxisLabelPosition(id);\n\t}\n\n\txForAxisLabel(id: string) {\n\t\tconst $$ = this.owner;\n\t\tconst {state: {width, height}} = $$;\n\t\tconst position = this.getAxisLabelPosition(id);\n\t\tlet x = position.isMiddle ? -height / 2 : 0;\n\n\t\tif (this.isHorizontal($$, id !== \"x\")) {\n\t\t\tx = position.isLeft ? 0 : (\n\t\t\t\tposition.isCenter ? width / 2 : width\n\t\t\t);\n\t\t} else if (position.isBottom) {\n\t\t\tx = -height;\n\t\t}\n\n\t\treturn x;\n\t}\n\n\ttextAnchorForAxisLabel(id: string) {\n\t\tconst $$ = this.owner;\n\t\tconst position = this.getAxisLabelPosition(id);\n\t\tlet anchor = position.isMiddle ? \"middle\" : \"end\";\n\n\t\tif (this.isHorizontal($$, id !== \"x\")) {\n\t\t\tanchor = position.isLeft ? \"start\" : (\n\t\t\t\tposition.isCenter ? \"middle\" : \"end\"\n\t\t\t);\n\t\t} else if (position.isBottom) {\n\t\t\tanchor = \"start\";\n\t\t}\n\n\t\treturn anchor;\n\t}\n\n\tdxForAxisLabel(id: string) {\n\t\tconst $$ = this.owner;\n\t\tconst position = this.getAxisLabelPosition(id);\n\t\tlet dx = position.isBottom ? \"0.5em\" : \"0\";\n\n\t\tif (this.isHorizontal($$, id !== \"x\")) {\n\t\t\tdx = position.isLeft ? \"0.5em\" : (\n\t\t\t\tposition.isRight ? \"-0.5em\" : \"0\"\n\t\t\t);\n\t\t} else if (position.isTop) {\n\t\t\tdx = \"-0.5em\";\n\t\t}\n\n\t\treturn dx;\n\t}\n\n\tdyForAxisLabel(id: AxisType) {\n\t\tconst $$ = this.owner;\n\t\tconst {config} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isInner = this.getAxisLabelPosition(id).isInner;\n\t\tconst tickRotate = config[`axis_${id}_tick_rotate`] ? $$.getHorizontalAxisHeight(id) : 0;\n\t\tconst {width: maxTickWidth} = this.getMaxTickSize(id);\n\t\tlet dy;\n\n\t\tif (id === \"x\") {\n\t\t\tconst xHeight = config.axis_x_height;\n\n\t\t\tif (isRotated) {\n\t\t\t\tdy = isInner ? \"1.2em\" : -25 - maxTickWidth;\n\t\t\t} else if (isInner) {\n\t\t\t\tdy = \"-0.5em\";\n\t\t\t} else if (xHeight) {\n\t\t\t\tdy = xHeight - 10;\n\t\t\t} else if (tickRotate) {\n\t\t\t\tdy = tickRotate - 10;\n\t\t\t} else {\n\t\t\t\tdy = \"3em\";\n\t\t\t}\n\t\t} else {\n\t\t\tdy = {\n\t\t\t\ty: [\"-0.5em\", 10, \"3em\", \"1.2em\", 10],\n\t\t\t\ty2: [\"1.2em\", -20, \"-2.2em\", \"-0.5em\", 15]\n\t\t\t}[id];\n\n\t\t\tif (isRotated) {\n\t\t\t\tif (isInner) {\n\t\t\t\t\tdy = dy[0];\n\t\t\t\t} else if (tickRotate) {\n\t\t\t\t\tdy = tickRotate * (id === \"y2\" ? -1 : 1) - dy[1];\n\t\t\t\t} else {\n\t\t\t\t\tdy = dy[2];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdy = isInner ? dy[3] : (\n\t\t\t\t\tdy[4] + (\n\t\t\t\t\t\tconfig[`axis_${id}_inner`] ? 0 : (maxTickWidth + dy[4])\n\t\t\t\t\t)\n\t\t\t\t) * (id === \"y\" ? -1 : 1);\n\t\t\t}\n\t\t}\n\n\t\treturn dy;\n\t}\n\n\t/**\n\t * Get max tick size\n\t * @param {string} id axis id string\n\t * @param {boolean} withoutRecompute wheather or not to recompute\n\t * @returns {object} {width, height}\n\t * @private\n\t */\n\tgetMaxTickSize(id: AxisType, withoutRecompute?: boolean): {width: number, height: number} {\n\t\tconst $$ = this.owner;\n\t\tconst {config, state: {current, resizing}, $el: {svg, chart}} = $$;\n\t\tconst currentTickMax = current.maxTickSize[id];\n\t\tconst configPrefix = `axis_${id}`;\n\t\tconst max = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\n\t\tif (\n\t\t\tresizing || withoutRecompute || !config[`${configPrefix}_show`] || (\n\t\t\t\tcurrentTickMax.width > 0 && $$.filterTargetsToShow().length === 0\n\t\t\t)\n\t\t) {\n\t\t\treturn currentTickMax;\n\t\t}\n\n\t\tif (svg) {\n\t\t\tconst isYAxis = /^y2?$/.test(id);\n\t\t\tconst targetsToShow = $$.filterTargetsToShow($$.data.targets);\n\t\t\tconst scale = $$.scale[id].copy().domain(\n\t\t\t\t$$[`get${isYAxis ? \"Y\" : \"X\"}Domain`](targetsToShow, id)\n\t\t\t);\n\t\t\tconst domain = scale.domain();\n\n\t\t\tconst isDomainSame = domain[0] === domain[1] && domain.every(v => v > 0);\n\t\t\tconst isCurrentMaxTickDomainSame = isArray(currentTickMax.domain) &&\n\t\t\t\tcurrentTickMax.domain[0] === currentTickMax.domain[1] &&\n\t\t\t\tcurrentTickMax.domain.every(v => v > 0);\n\n\t\t\t// do not compute if domain or currentMaxTickDomain is same\n\t\t\tif (isDomainSame || isCurrentMaxTickDomainSame) {\n\t\t\t\treturn currentTickMax.size;\n\t\t\t} else {\n\t\t\t\tcurrentTickMax.domain = domain;\n\t\t\t}\n\n\t\t\t// reset old max state value to prevent from new data loading\n\t\t\tif (!isYAxis) {\n\t\t\t\tcurrentTickMax.ticks.splice(0);\n\t\t\t}\n\n\t\t\tconst axis = this.getAxis(id, scale, false, false, true);\n\t\t\tconst tickRotate = config[`${configPrefix}_tick_rotate`];\n\t\t\tconst tickCount = config[`${configPrefix}_tick_count`];\n\t\t\tconst tickValues = config[`${configPrefix}_tick_values`];\n\n\t\t\t// Make to generate the final tick text to be rendered\n\t\t\t// https://github.com/naver/billboard.js/issues/920\n\t\t\t// Do not generate if 'tick values' option is given\n\t\t\t// https://github.com/naver/billboard.js/issues/1251\n\t\t\tif (!tickValues && tickCount) {\n\t\t\t\taxis.tickValues(\n\t\t\t\t\tthis.generateTickValues(\n\t\t\t\t\t\tdomain,\n\t\t\t\t\t\ttickCount,\n\t\t\t\t\t\tisYAxis ? this.isTimeSeriesY() : this.isTimeSeries()\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t!isYAxis && this.updateXAxisTickValues(targetsToShow, axis);\n\n\t\t\tconst dummy = chart.append(\"svg\")\n\t\t\t\t.style(\"visibility\", \"hidden\")\n\t\t\t\t.style(\"position\", \"fixed\")\n\t\t\t\t.style(\"top\", \"0\")\n\t\t\t\t.style(\"left\", \"0\");\n\n\t\t\tconst g = dummy\n\t\t\t\t.append(\"g\")\n\t\t\t\t.attr(\"class\", `${$AXIS[`axis${capitalize(id)}`]} ${$COMMON.dummy}`);\n\n\t\t\taxis.create(g);\n\n\t\t\t// when evalTextSize is set as function, sizeFor1Char is set to the dummy element\n\t\t\tconst {sizeFor1Char} = g.node();\n\n\t\t\tdummy.selectAll(\"text\")\n\t\t\t\t.attr(\"transform\", isNumber(tickRotate) ? `rotate(${tickRotate})` : null)\n\t\t\t\t.each(function(d, i) {\n\t\t\t\t\tconst {width, height} = sizeFor1Char ?\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twidth: this.textContent.length * sizeFor1Char.w,\n\t\t\t\t\t\t\theight: sizeFor1Char.h\n\t\t\t\t\t\t} :\n\t\t\t\t\t\tgetBoundingRect(this, true);\n\n\t\t\t\t\tmax.width = Math.max(max.width, width);\n\t\t\t\t\tmax.height = Math.max(max.height, height);\n\n\t\t\t\t\t// cache tick text width for getXAxisTickTextY2Overflow()\n\t\t\t\t\tif (!isYAxis) {\n\t\t\t\t\t\tcurrentTickMax.ticks[i] = width;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tdummy.remove();\n\t\t}\n\n\t\tObject.keys(max).forEach(key => {\n\t\t\tif (max[key] > 0) {\n\t\t\t\tcurrentTickMax[key] = max[key];\n\t\t\t}\n\t\t});\n\n\t\treturn currentTickMax;\n\t}\n\n\tgetXAxisTickTextY2Overflow(defaultPadding) {\n\t\tconst $$ = this.owner;\n\t\tconst {axis, config, state: {current, isLegendRight, legendItemWidth}} = $$;\n\t\tconst xAxisTickRotate = $$.getAxisTickRotate(\"x\");\n\t\tconst positiveRotation = xAxisTickRotate > 0 && xAxisTickRotate < 90;\n\n\t\tif (\n\t\t\t(axis.isCategorized() || axis.isTimeSeries()) &&\n\t\t\tconfig.axis_x_tick_fit &&\n\t\t\t(!config.axis_x_tick_culling || isEmpty(config.axis_x_tick_culling)) &&\n\t\t\t!config.axis_x_tick_multiline &&\n\t\t\tpositiveRotation\n\t\t) {\n\t\t\tconst y2AxisWidth = (config.axis_y2_show && current.maxTickSize.y2.width) || 0;\n\t\t\tconst legendWidth = (isLegendRight && legendItemWidth) || 0;\n\t\t\tconst widthWithoutCurrentPaddingLeft = current.width -\n\t\t\t\t$$.getCurrentPaddingByDirection(\"left\");\n\t\t\tconst maxOverflow = this.getXAxisTickMaxOverflow(\n\t\t\t\txAxisTickRotate,\n\t\t\t\twidthWithoutCurrentPaddingLeft - defaultPadding\n\t\t\t) - y2AxisWidth - legendWidth;\n\t\t\tconst xAxisTickTextY2Overflow = Math.max(0, maxOverflow) +\n\t\t\t\tdefaultPadding; // for display inconsistencies between browsers\n\n\t\t\treturn Math.min(xAxisTickTextY2Overflow, widthWithoutCurrentPaddingLeft / 2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tgetXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft) {\n\t\tconst $$ = this.owner;\n\t\tconst {axis, config, state} = $$;\n\t\tconst isTimeSeries = axis.isTimeSeries();\n\n\t\tconst tickTextWidths = state.current.maxTickSize.x.ticks;\n\t\tconst tickCount = tickTextWidths.length;\n\t\tconst {left, right} = state.axis.x.padding;\n\t\tlet maxOverflow = 0;\n\n\t\tconst remaining = tickCount - (isTimeSeries && config.axis_x_tick_fit ? 0.5 : 0);\n\n\t\tfor (let i = 0; i < tickCount; i++) {\n\t\t\tconst tickIndex = i + 1;\n\t\t\tconst rotatedTickTextWidth = Math.cos(Math.PI * xAxisTickRotate / 180) *\n\t\t\t\ttickTextWidths[i];\n\t\t\tconst ticksBeforeTickText = tickIndex - (isTimeSeries ? 1 : 0.5) + left;\n\n\t\t\t// Skip ticks if there are no ticks before them\n\t\t\tif (ticksBeforeTickText <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst xAxisLengthWithoutTickTextWidth = widthWithoutCurrentPaddingLeft -\n\t\t\t\trotatedTickTextWidth;\n\t\t\tconst tickLength = xAxisLengthWithoutTickTextWidth / ticksBeforeTickText;\n\t\t\tconst remainingTicks = remaining - tickIndex;\n\n\t\t\tconst paddingRightLength = right * tickLength;\n\t\t\tconst remainingTickWidth = (remainingTicks * tickLength) + paddingRightLength;\n\t\t\tconst overflow = rotatedTickTextWidth - (tickLength / 2) - remainingTickWidth;\n\n\t\t\tmaxOverflow = Math.max(maxOverflow, overflow);\n\t\t}\n\n\t\tconst filteredTargets = $$.filterTargetsToShow($$.data.targets);\n\t\tlet tickOffset = 0;\n\n\t\tif (\n\t\t\t!isTimeSeries &&\n\t\t\tconfig.axis_x_tick_count <= filteredTargets.length && filteredTargets[0].values.length\n\t\t) {\n\t\t\tconst scale = getScale($$.axis.getAxisType(\"x\"), 0,\n\t\t\t\twidthWithoutCurrentPaddingLeft - maxOverflow)\n\t\t\t\t.domain([\n\t\t\t\t\tleft * -1,\n\t\t\t\t\t$$.getXDomainMax($$.data.targets) + 1 + right\n\t\t\t\t]);\n\n\t\t\ttickOffset = (scale(1) - scale(0)) / 2;\n\t\t}\n\n\t\treturn maxOverflow + tickOffset;\n\t}\n\n\t/**\n\t * Update axis label text\n\t * @param {boolean} withTransition Weather update with transition\n\t * @private\n\t */\n\tupdateLabels(withTransition: boolean): void {\n\t\tconst $$ = this.owner;\n\t\tconst {config, $el: {main}, $T} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\t[\"x\", \"y\", \"y2\"].forEach((id: AxisType) => {\n\t\t\tconst text = this.getLabelText(id);\n\t\t\tconst selector = `axis${capitalize(id)}`;\n\t\t\tconst classLabel = $AXIS[`${selector}Label`];\n\n\t\t\tif (text) {\n\t\t\t\tlet axisLabel = main.select(`text.${classLabel}`);\n\n\t\t\t\t// generate eleement if not exists\n\t\t\t\tif (axisLabel.empty()) {\n\t\t\t\t\taxisLabel = main.select(`g.${$AXIS[selector]}`)\n\t\t\t\t\t\t.insert(\"text\", \":first-child\")\n\t\t\t\t\t\t.attr(\"class\", classLabel)\n\t\t\t\t\t\t.attr(\"transform\", [\"rotate(-90)\", null][\n\t\t\t\t\t\t\tid === \"x\" ? +!isRotated : +isRotated\n\t\t\t\t\t\t])\n\t\t\t\t\t\t.style(\"text-anchor\", () => this.textAnchorForAxisLabel(id));\n\t\t\t\t}\n\n\t\t\t\t// @check $$.$T(node, withTransition)\n\t\t\t\t$T(axisLabel, withTransition)\n\t\t\t\t\t.attr(\"x\", () => this.xForAxisLabel(id))\n\t\t\t\t\t.attr(\"dx\", () => this.dxForAxisLabel(id))\n\t\t\t\t\t.attr(\"dy\", () => this.dyForAxisLabel(id))\n\t\t\t\t\t.text(text);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get axis padding value\n\t * @param {number|object} padding Padding object\n\t * @param {string} key Key string of padding\n\t * @param {Date|number} defaultValue Default value\n\t * @param {number} domainLength Domain length\n\t * @returns {number} Padding value in scale\n\t * @private\n\t */\n\tgetPadding(padding: number | {[key: string]: number}, key: string, defaultValue: number,\n\t\tdomainLength: number): number {\n\t\tconst p = isNumber(padding) ? padding : padding[key];\n\n\t\tif (!isValue(p)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn this.owner.convertPixelToScale(\n\t\t\t/(bottom|top)/.test(key) ? \"y\" : \"x\",\n\t\t\tp,\n\t\t\tdomainLength\n\t\t);\n\t}\n\n\tgenerateTickValues(values, tickCount, forTimeSeries) {\n\t\tlet tickValues = values;\n\n\t\tif (tickCount) {\n\t\t\tconst targetCount = isFunction(tickCount) ? tickCount() : tickCount;\n\n\t\t\t// compute ticks according to tickCount\n\t\t\tif (targetCount === 1) {\n\t\t\t\ttickValues = [values[0]];\n\t\t\t} else if (targetCount === 2) {\n\t\t\t\ttickValues = [values[0], values[values.length - 1]];\n\t\t\t} else if (targetCount > 2) {\n\t\t\t\tconst isCategorized = this.isCategorized();\n\n\t\t\t\tconst count = targetCount - 2;\n\t\t\t\tconst start = values[0];\n\t\t\t\tconst end = values[values.length - 1];\n\t\t\t\tconst interval = (end - start) / (count + 1);\n\t\t\t\tlet tickValue;\n\n\t\t\t\t// re-construct unique values\n\t\t\t\ttickValues = [start];\n\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\ttickValue = +start + interval * (i + 1);\n\t\t\t\t\ttickValues.push(\n\t\t\t\t\t\tforTimeSeries ? new Date(tickValue) : (\n\t\t\t\t\t\t\tisCategorized ? Math.round(tickValue) : tickValue\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\ttickValues.push(end);\n\t\t\t}\n\t\t}\n\n\t\tif (!forTimeSeries) {\n\t\t\ttickValues = tickValues.sort((a, b) => a - b);\n\t\t}\n\n\t\treturn tickValues;\n\t}\n\n\tgenerateTransitions(withTransition) {\n\t\tconst $$ = this.owner;\n\t\tconst {$el: {axis}, $T} = $$;\n\n\t\tconst [axisX, axisY, axisY2, axisSubX] = [\"x\", \"y\", \"y2\", \"subX\"]\n\t\t\t.map(v => $T(axis[v], withTransition));\n\n\t\treturn {axisX, axisY, axisY2, axisSubX};\n\t}\n\n\tredraw(transitions, isHidden, isInit) {\n\t\tconst $$ = this.owner;\n\t\tconst {config, state, $el} = $$;\n\t\tconst opacity = isHidden ? \"0\" : null;\n\n\t\t[\"x\", \"y\", \"y2\", \"subX\"].forEach(id => {\n\t\t\tconst axis = this[id];\n\t\t\tconst $axis = $el.axis[id];\n\n\t\t\tif (axis && $axis) {\n\t\t\t\tif (!isInit && !config.transition_duration) {\n\t\t\t\t\taxis.config.withoutTransition = true;\n\t\t\t\t}\n\n\t\t\t\t$axis.style(\"opacity\", opacity);\n\t\t\t\taxis.create(transitions[`axis${capitalize(id)}`]);\n\t\t\t}\n\t\t});\n\n\t\tthis.updateAxes();\n\t\t!state.rendered && config.axis_tooltip && this.setAxisTooltip();\n\t}\n\n\t/**\n\t * Redraw axis\n\t * @param {Array} targetsToShow targets data to be shown\n\t * @param {object} wth option object\n\t * @param {d3.Transition} transitions Transition object\n\t * @param {object} flow flow object\n\t * @param {boolean} isInit called from initialization\n\t * @private\n\t */\n\tredrawAxis(targetsToShow, wth, transitions, flow, isInit: boolean): void {\n\t\tconst $$ = this.owner;\n\t\tconst {config, scale, $el} = $$;\n\t\tconst hasZoom = !!scale.zoom;\n\t\tlet xDomainForZoom;\n\n\t\tif (!hasZoom && this.isCategorized() && targetsToShow.length === 0) {\n\t\t\tscale.x.domain([0, $el.axis.x.selectAll(\".tick\").size()]);\n\t\t}\n\n\t\tif (scale.x && targetsToShow.length) {\n\t\t\t!hasZoom &&\n\t\t\t\t$$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain,\n\t\t\t\t\twth.TrimXDomain);\n\n\t\t\tif (!config.axis_x_tick_values) {\n\t\t\t\tthis.updateXAxisTickValues(targetsToShow);\n\t\t\t}\n\t\t} else if (this.x) {\n\t\t\tthis.x.tickValues([]);\n\t\t\tthis.subX?.tickValues([]);\n\t\t}\n\n\t\tif (config.zoom_rescale && !flow) {\n\t\t\txDomainForZoom = scale.x.orgDomain();\n\t\t}\n\n\t\t[\"y\", \"y2\"].forEach(key => {\n\t\t\tconst prefix = `axis_${key}_`;\n\t\t\tconst axisScale = scale[key];\n\n\t\t\tif (axisScale) {\n\t\t\t\tconst tickValues = config[`${prefix}tick_values`];\n\t\t\t\tconst tickCount = config[`${prefix}tick_count`];\n\n\t\t\t\taxisScale.domain($$.getYDomain(targetsToShow, key, xDomainForZoom));\n\n\t\t\t\tif (!tickValues && tickCount) {\n\t\t\t\t\tconst axis = $$.axis[key];\n\t\t\t\t\tconst domain = axisScale.domain();\n\n\t\t\t\t\taxis.tickValues(\n\t\t\t\t\t\tthis.generateTickValues(\n\t\t\t\t\t\t\tdomain,\n\t\t\t\t\t\t\tdomain.every(v => v === 0) ? 1 : tickCount,\n\t\t\t\t\t\t\tthis.isTimeSeriesY()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// axes\n\t\tthis.redraw(transitions, $$.hasArcType(), isInit);\n\n\t\t// Update axis label\n\t\tthis.updateLabels(wth.Transition);\n\n\t\t// show/hide if manual culling needed\n\t\tif ((wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length) {\n\t\t\tthis.setCulling();\n\t\t}\n\n\t\t// Update sub domain\n\t\tif (wth.Y) {\n\t\t\tscale.subY?.domain($$.getYDomain(targetsToShow, \"y\"));\n\t\t\tscale.subY2?.domain($$.getYDomain(targetsToShow, \"y2\"));\n\t\t}\n\t}\n\n\t/**\n\t * Set manual culling\n\t * @private\n\t */\n\tsetCulling() {\n\t\tconst $$ = this.owner;\n\t\tconst {config, state: {clip, current}, $el} = $$;\n\n\t\t[\"subX\", \"x\", \"y\", \"y2\"].forEach(type => {\n\t\t\tconst axis = $el.axis[type];\n\n\t\t\t// subchart x axis should be aligned with x axis culling\n\t\t\tconst id = type === \"subX\" ? \"x\" : type;\n\n\t\t\tconst cullingOptionPrefix = `axis_${id}_tick_culling`;\n\t\t\tconst toCull = config[cullingOptionPrefix];\n\n\t\t\tif (axis && toCull) {\n\t\t\t\tconst tickNodes = axis.selectAll(\".tick\");\n\t\t\t\tconst tickValues = sortValue(tickNodes.data(),\n\t\t\t\t\t!config[`${cullingOptionPrefix}_reverse`]);\n\t\t\t\tconst tickSize = tickValues.length;\n\t\t\t\tconst cullingMax = config[`${cullingOptionPrefix}_max`];\n\t\t\t\tconst lines = config[`${cullingOptionPrefix}_lines`];\n\t\t\t\tlet intervalForCulling;\n\n\t\t\t\tif (tickSize) {\n\t\t\t\t\tfor (let i = 1; i < tickSize; i++) {\n\t\t\t\t\t\tif (tickSize / i < cullingMax) {\n\t\t\t\t\t\t\tintervalForCulling = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttickNodes\n\t\t\t\t\t\t.each(function(d) {\n\t\t\t\t\t\t\tconst node = lines ? this.querySelector(\"text\") : this;\n\n\t\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\t\tnode.style.display = tickValues.indexOf(d) % intervalForCulling ?\n\t\t\t\t\t\t\t\t\t\"none\" :\n\t\t\t\t\t\t\t\t\tnull;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttickNodes.style(\"display\", null);\n\t\t\t\t}\n\n\t\t\t\t// set/unset x_axis_tick_clippath\n\t\t\t\tif (type === \"x\") {\n\t\t\t\t\tconst clipPath = current.maxTickSize.x.clipPath ?\n\t\t\t\t\t\tclip.pathXAxisTickTexts :\n\t\t\t\t\t\tnull;\n\n\t\t\t\t\t$el.svg.selectAll(`.${$AXIS.axisX} .tick text`)\n\t\t\t\t\t\t.attr(\"clip-path\", clipPath);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Set axis tooltip\n\t * @private\n\t */\n\tsetAxisTooltip(): void {\n\t\tconst $$ = this.owner;\n\t\tconst {config: {axis_rotated: isRotated, axis_tooltip}, $el: {axis, axisTooltip}} = $$;\n\t\tconst bgColor = axis_tooltip.backgroundColor ?? \"black\";\n\n\t\t$$.generateTextBGColorFilter(\n\t\t\tbgColor,\n\t\t\t{\n\t\t\t\tx: -0.15,\n\t\t\t\ty: -0.2,\n\t\t\t\twidth: 1.3,\n\t\t\t\theight: 1.3\n\t\t\t}\n\t\t);\n\n\t\t[\"x\", \"y\", \"y2\"].forEach(v => {\n\t\t\tif (isString(bgColor) || bgColor[v]) {\n\t\t\t\taxisTooltip[v] = axis[v]?.append(\"text\")\n\t\t\t\t\t.classed($AXIS[`axis${v.toUpperCase()}Tooltip`], true)\n\t\t\t\t\t.attr(\"filter\", $$.updateTextBGColor({id: v}, bgColor));\n\n\t\t\t\tif (isRotated) {\n\t\t\t\t\tconst pos = v === \"x\" ? \"x\" : \"y\";\n\t\t\t\t\tconst val = v === \"y\" ? \"1.15em\" : (v === \"x\" ? \"-0.3em\" : \"-0.4em\");\n\n\t\t\t\t\taxisTooltip[v]?.attr(pos, val)\n\t\t\t\t\t\t.attr(`d${v === \"x\" ? \"y\" : \"x\"}`, v === \"x\" ? \"0.4em\" : \"-1.3em\")\n\t\t\t\t\t\t.style(\"text-anchor\", v === \"x\" ? \"end\" : null);\n\t\t\t\t} else {\n\t\t\t\t\tconst pos = v === \"x\" ? \"y\" : \"x\";\n\t\t\t\t\tconst val = v === \"x\" ? \"1.15em\" : `${v === \"y\" ? \"-\" : \"\"}0.4em`;\n\n\t\t\t\t\taxisTooltip[v]?.attr(pos, val)\n\t\t\t\t\t\t.attr(`d${v === \"x\" ? \"x\" : \"y\"}`, v === \"x\" ? \"-1em\" : \"0.3em\")\n\t\t\t\t\t\t.style(\"text-anchor\", v === \"y\" ? \"end\" : null);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {d3Selection} from \"../../../types\";\nimport {$COMMON, $EVENT, $SHAPE} from \"../../config/classes\";\nimport {\n\tgetBoundingRect,\n\tgetPointer,\n\tgetScrollPosition,\n\tisBoolean,\n\tisFunction\n} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Initialize the area that detects the event.\n\t * Add a container for the zone that detects the event.\n\t * @private\n\t */\n\tinitEventRect(): void {\n\t\tconst $$ = this;\n\n\t\t$$.$el.main.select(`.${$COMMON.chart}`)\n\t\t\t.append(\"g\")\n\t\t\t.attr(\"class\", $EVENT.eventRects)\n\t\t\t.style(\"fill-opacity\", \"0\");\n\t},\n\n\t/**\n\t * Redraws the area that detects the event.\n\t * @private\n\t */\n\tredrawEventRect(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el} = $$;\n\t\tconst isMultipleX = $$.isMultipleX();\n\t\tconst isInverted = config.axis_x_inverted;\n\n\t\tif ($el.eventRect) {\n\t\t\t$$.updateEventRect($el.eventRect, true);\n\n\t\t\t// do not initialize eventRect when data is empty\n\t\t} else if ($$.data.targets.length) {\n\t\t\tconst eventRects = $$.$el.main.select(`.${$EVENT.eventRects}`)\n\t\t\t\t.style(\"cursor\", config.zoom_enabled && config.zoom_type !== \"drag\" ?\n\t\t\t\t\t(\n\t\t\t\t\t\tconfig.axis_rotated ? \"ns-resize\" : \"ew-resize\"\n\t\t\t\t\t) :\n\t\t\t\t\tnull)\n\t\t\t\t.classed($EVENT.eventRectsMultiple, isMultipleX)\n\t\t\t\t.classed($EVENT.eventRectsSingle, !isMultipleX);\n\n\t\t\t// append event <rect>\n\t\t\tconst eventRectUpdate = eventRects.selectAll(`.${$EVENT.eventRect}`)\n\t\t\t\t.data([0])\n\t\t\t\t.enter()\n\t\t\t\t.append(\"rect\");\n\n\t\t\t$$.updateEventRect(eventRectUpdate);\n\n\t\t\t// bind event to <rect> element\n\t\t\t$$.updateEventType(eventRectUpdate);\n\n\t\t\t// bind draggable selection\n\t\t\teventRectUpdate.call($$.getDraggableSelection());\n\n\t\t\t$el.eventRect = eventRectUpdate;\n\n\t\t\tif (\n\t\t\t\t$$.state.inputType === \"touch\" && !$el.svg.on(\"touchstart.eventRect\") &&\n\t\t\t\t!$$.hasArcType()\n\t\t\t) {\n\t\t\t\t$$.bindTouchOnEventRect();\n\t\t\t}\n\n\t\t\t// when initilazed with empty data and data loaded later, need to update eventRect\n\t\t\tstate.rendered && $$.updateEventRect($el.eventRect, true);\n\t\t}\n\n\t\tif (!isMultipleX) {\n\t\t\t// Set data and update eventReceiver.data\n\t\t\tconst xAxisTickValues = $$.getMaxDataCountTarget();\n\n\t\t\tif (!config.data_xSort || isInverted) {\n\t\t\t\txAxisTickValues.sort((a, b) => (isInverted ? b.x - a.x : a.x - b.x));\n\t\t\t}\n\n\t\t\t// update data's index value to be alinged with the x Axis\n\t\t\t$$.updateDataIndexByX(xAxisTickValues);\n\t\t\t$$.updateXs(xAxisTickValues);\n\t\t\t$$.updatePointClass?.(true);\n\n\t\t\tstate.eventReceiver.data = xAxisTickValues;\n\t\t}\n\n\t\t$$.updateEventRectData();\n\t},\n\n\tbindTouchOnEventRect(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {eventRect, svg}} = $$;\n\n\t\tconst selectRect = context => {\n\t\t\tif ($$.isMultipleX()) {\n\t\t\t\t$$.selectRectForMultipleXs(context);\n\t\t\t} else {\n\t\t\t\tconst index = $$.getDataIndexFromEvent(state.event);\n\n\t\t\t\t$$.callOverOutForTouch(index);\n\n\t\t\t\tindex === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, index);\n\t\t\t}\n\t\t};\n\n\t\tconst unselectRect = () => {\n\t\t\t$$.unselectRect();\n\t\t\t$$.callOverOutForTouch();\n\t\t};\n\n\t\t// call event.preventDefault()\n\t\t// according 'interaction.inputType.touch.preventDefault' option\n\t\tconst preventDefault = config.interaction_inputType_touch.preventDefault;\n\t\tconst isPrevented = (isBoolean(preventDefault) && preventDefault) || false;\n\t\tconst preventThreshold = (!isNaN(preventDefault) && preventDefault) || null;\n\t\tlet startPx;\n\n\t\tconst preventEvent = event => {\n\t\t\tconst eventType = event.type;\n\t\t\tconst touch = event.changedTouches[0];\n\t\t\tconst currentXY = touch[`client${config.axis_rotated ? \"Y\" : \"X\"}`];\n\n\t\t\t// prevent document scrolling\n\t\t\tif (eventType === \"touchstart\") {\n\t\t\t\tif (isPrevented) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t} else if (preventThreshold !== null) {\n\t\t\t\t\tstartPx = currentXY;\n\t\t\t\t}\n\t\t\t} else if (eventType === \"touchmove\") {\n\t\t\t\tif (\n\t\t\t\t\tisPrevented || startPx === true || (\n\t\t\t\t\t\tpreventThreshold !== null &&\n\t\t\t\t\t\tMath.abs(startPx - currentXY) >= preventThreshold\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// once prevented, keep prevented during whole 'touchmove' context\n\t\t\t\t\tstartPx = true;\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// bind touch events\n\t\teventRect\n\t\t\t.on(\"touchstart\", event => {\n\t\t\t\tstate.event = event;\n\t\t\t\t$$.updateEventRect();\n\t\t\t})\n\t\t\t.on(\"touchstart.eventRect touchmove.eventRect\", event => {\n\t\t\t\tstate.event = event;\n\n\t\t\t\tif (!eventRect.empty() && eventRect.classed($EVENT.eventRect)) {\n\t\t\t\t\t// if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.\n\t\t\t\t\tif (\n\t\t\t\t\t\tstate.dragging || state.flowing || $$.hasArcType() ||\n\t\t\t\t\t\tevent.touches.length > 1\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tpreventEvent(event);\n\t\t\t\t\tselectRect(eventRect.node());\n\t\t\t\t} else {\n\t\t\t\t\tunselectRect();\n\t\t\t\t}\n\t\t\t}, true)\n\t\t\t.on(\"touchend.eventRect\", event => {\n\t\t\t\tstate.event = event;\n\n\t\t\t\tif (!eventRect.empty() && eventRect.classed($EVENT.eventRect)) {\n\t\t\t\t\tif ($$.hasArcType() || !$$.toggleShape || state.cancelClick) {\n\t\t\t\t\t\tstate.cancelClick && (state.cancelClick = false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, true);\n\n\t\tsvg.on(\"touchstart\", event => {\n\t\t\tstate.event = event;\n\t\t\tconst {target} = event;\n\n\t\t\tif (target && target !== eventRect.node()) {\n\t\t\t\tunselectRect();\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Update event rect size\n\t * @param {d3Selection} eventRect Event <rect> element\n\t * @param {boolean} force Force to update\n\t * @private\n\t */\n\tupdateEventRect(eventRect?, force = false): void {\n\t\tconst $$ = this;\n\t\tconst {state, $el} = $$;\n\t\tconst {eventReceiver, width, height, rendered, resizing} = state;\n\t\tconst rectElement = eventRect || $el.eventRect;\n\n\t\tconst updateClientRect = (): void => {\n\t\t\tif (eventReceiver) {\n\t\t\t\tconst scrollPos = getScrollPosition($el.chart.node());\n\n\t\t\t\teventReceiver.rect = getBoundingRect(rectElement.node(), true)\n\t\t\t\t\t.toJSON();\n\n\t\t\t\teventReceiver.rect.top += scrollPos.y;\n\t\t\t\teventReceiver.rect.left += scrollPos.x;\n\t\t\t}\n\t\t};\n\n\t\tif (!rendered || resizing || force) {\n\t\t\trectElement\n\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t.attr(\"y\", 0)\n\t\t\t\t.attr(\"width\", width)\n\t\t\t\t.attr(\"height\", height);\n\n\t\t\t// only for init\n\t\t\tif (!rendered || force) {\n\t\t\t\trectElement.classed($EVENT.eventRect, true);\n\t\t\t}\n\t\t}\n\n\t\tupdateClientRect();\n\t},\n\n\t/**\n\t * Update event type (single or multiple x)\n\t * @param {d3Selection | boolean} target Target element or boolean to rebind event\n\t */\n\tupdateEventType(target: d3Selection | boolean): void {\n\t\tconst $$ = this;\n\t\tconst isRebindCall = isBoolean(target);\n\t\tconst eventRect = isRebindCall ? $$.$el.eventRect : target;\n\t\tconst unbindEvent = isRebindCall ? target !== eventRect?.datum().multipleX : false;\n\n\t\tif (eventRect) {\n\t\t\t// release previous event listeners\n\t\t\tunbindEvent && eventRect?.on(\"mouseover mousemove mouseout click\", null);\n\n\t\t\t$$.isMultipleX() ?\n\t\t\t\t$$.generateEventRectsForMultipleXs(eventRect) :\n\t\t\t\t$$.generateEventRectsForSingleX(eventRect);\n\t\t}\n\t},\n\n\t/**\n\t * Updates the location and size of the eventRect.\n\t * @private\n\t */\n\tupdateEventRectData(): void {\n\t\tconst $$ = this;\n\t\tconst {config, scale, state} = $$;\n\t\tconst xScale = scale.zoom || scale.x;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isMultipleX = $$.isMultipleX();\n\t\tlet x;\n\t\tlet y;\n\t\tlet w;\n\t\tlet h;\n\n\t\t$$.updateEventType(isMultipleX);\n\n\t\tif (isMultipleX) {\n\t\t\t// TODO: rotated not supported yet\n\t\t\tx = 0;\n\t\t\ty = 0;\n\t\t\tw = state.width;\n\t\t\th = state.height;\n\t\t} else {\n\t\t\tlet rectW;\n\t\t\tlet rectX;\n\n\t\t\tif ($$.axis.isCategorized()) {\n\t\t\t\trectW = $$.getEventRectWidth();\n\t\t\t\trectX = d => xScale(d.x) - (rectW / 2);\n\t\t\t} else {\n\t\t\t\tconst getPrevNextX = ({index}) => ({\n\t\t\t\t\tprev: $$.getPrevX(index),\n\t\t\t\t\tnext: $$.getNextX(index)\n\t\t\t\t});\n\n\t\t\t\trectW = (d): number => {\n\t\t\t\t\tconst x = getPrevNextX(d);\n\t\t\t\t\tconst xDomain = xScale.domain();\n\t\t\t\t\tlet val: number;\n\n\t\t\t\t\t// if there this is a single data point make the eventRect full width (or height)\n\t\t\t\t\tif (x.prev === null && x.next === null) {\n\t\t\t\t\t\tval = isRotated ? state.height : state.width;\n\t\t\t\t\t} else if (x.prev === null) {\n\t\t\t\t\t\tval = (xScale(x.next) + xScale(d.x)) / 2;\n\t\t\t\t\t} else if (x.next === null) {\n\t\t\t\t\t\tval = xScale(xDomain[1]) - (\n\t\t\t\t\t\t\t(xScale(x.prev) + xScale(d.x)) / 2\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.keys(x).forEach((key, i) => {\n\t\t\t\t\t\t\tx[key] = x[key] ?? xDomain[i];\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tval = Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn val;\n\t\t\t\t};\n\n\t\t\t\trectX = (d): number => {\n\t\t\t\t\tconst x = getPrevNextX(d);\n\t\t\t\t\tlet val: number;\n\n\t\t\t\t\t// if there this is a single data point position the eventRect at 0\n\t\t\t\t\tif (x.prev === null && x.next === null) {\n\t\t\t\t\t\tval = 0;\n\t\t\t\t\t} else if (x.prev === null) {\n\t\t\t\t\t\tval = xScale(xScale.domain()[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = (xScale(d.x) + xScale(x.prev)) / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn val;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tx = isRotated ? 0 : rectX;\n\t\t\ty = isRotated ? rectX : 0;\n\t\t\tw = isRotated ? state.width : rectW;\n\t\t\th = isRotated ? rectW : state.height;\n\t\t}\n\n\t\tconst {eventReceiver} = state;\n\t\tconst call: any = (fn, v) => (isFunction(fn) ? fn(v) : fn);\n\n\t\t// reset for possible remains coords data before the data loading\n\t\teventReceiver.coords.splice(eventReceiver.data.length);\n\n\t\teventReceiver.data.forEach((d, i) => {\n\t\t\teventReceiver.coords[i] = {\n\t\t\t\tx: call(x, d),\n\t\t\t\ty: call(y, d),\n\t\t\t\tw: call(w, d),\n\t\t\t\th: call(h, d)\n\t\t\t};\n\t\t});\n\t},\n\n\t/**\n\t * Seletct rect for single x value\n\t * @param {d3Selection} context Event rect element\n\t * @param {number} index x Axis index\n\t * @private\n\t */\n\tselectRectForSingle(context: SVGRectElement, index: number): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {main, circle}} = $$;\n\t\tconst isSelectionEnabled = config.data_selection_enabled;\n\t\tconst isSelectionGrouped = config.data_selection_grouped;\n\t\tconst isSelectable = config.data_selection_isselectable;\n\t\tconst isTooltipGrouped = config.tooltip_grouped;\n\t\tconst selectedData = $$.getAllValuesOnIndex(index);\n\n\t\tif (isTooltipGrouped) {\n\t\t\t$$.showTooltip(selectedData, context);\n\t\t\t$$.showGridFocus?.(selectedData);\n\n\t\t\tif (!isSelectionEnabled || isSelectionGrouped) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// remove possible previous focused state\n\t\t!circle &&\n\t\t\tmain.selectAll(`.${$COMMON.EXPANDED}:not(.${$SHAPE.shape}-${index})`).classed(\n\t\t\t\t$COMMON.EXPANDED,\n\t\t\t\tfalse\n\t\t\t);\n\n\t\tconst shapeAtIndex = main.selectAll(`.${$SHAPE.shape}-${index}`)\n\t\t\t.classed($COMMON.EXPANDED, true)\n\t\t\t.style(\"cursor\", isSelectable ? \"pointer\" : null)\n\t\t\t.filter(function(d) {\n\t\t\t\treturn $$.isWithinShape(this, d);\n\t\t\t});\n\n\t\tif (shapeAtIndex.empty() && !isTooltipGrouped && config.interaction_onout) {\n\t\t\t$$.hideGridFocus?.();\n\t\t\t$$.hideTooltip();\n\n\t\t\t!isSelectionGrouped && $$.setExpand(index);\n\t\t}\n\n\t\tshapeAtIndex\n\t\t\t.call(selected => {\n\t\t\t\tconst d = selected.data();\n\n\t\t\t\tif (\n\t\t\t\t\tisSelectionEnabled &&\n\t\t\t\t\t(isSelectionGrouped || isSelectable?.bind($$.api)(d))\n\t\t\t\t) {\n\t\t\t\t\tcontext.style.cursor = \"pointer\";\n\t\t\t\t}\n\n\t\t\t\tif (!isTooltipGrouped) {\n\t\t\t\t\t$$.showTooltip(d, context);\n\t\t\t\t\t$$.showGridFocus?.(d);\n\t\t\t\t\t$$.unexpandCircles?.();\n\n\t\t\t\t\tselected.each(d => $$.setExpand(index, d.id));\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\t/**\n\t * Select rect for multiple x values\n\t * @param {d3Selection} context Event rect element\n\t * @param {boolean} [triggerEvent=true] Whether trigger event or not\n\t * @private\n\t */\n\tselectRectForMultipleXs(context: SVGRectElement, triggerEvent = true): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst targetsToShow = $$.filterTargetsToShow($$.data.targets);\n\n\t\t// do nothing when dragging\n\t\tif (state.dragging || $$.hasArcType(targetsToShow)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mouse = getPointer(state.event, context);\n\t\tconst closest = $$.findClosestFromTargets(targetsToShow, mouse);\n\n\t\tif (triggerEvent && state.mouseover && (!closest || closest.id !== state.mouseover.id)) {\n\t\t\tconfig.data_onout.call($$.api, state.mouseover);\n\t\t\tstate.mouseover = undefined;\n\t\t}\n\n\t\tif (!closest) {\n\t\t\t$$.unselectRect();\n\t\t\treturn;\n\t\t}\n\n\t\tconst sameXData = (\n\t\t\t\t$$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped\n\t\t\t) ?\n\t\t\t[closest] :\n\t\t\t$$.filterByX(targetsToShow, closest.x);\n\n\t\t// show tooltip when cursor is close to some point\n\t\tconst selectedData = sameXData.map(d => $$.addName(d));\n\n\t\t$$.showTooltip(selectedData, context);\n\n\t\t// expand points\n\t\t$$.setExpand(closest.index, closest.id, true);\n\n\t\t// Show xgrid focus line\n\t\t$$.showGridFocus(selectedData);\n\n\t\tconst dist = $$.dist(closest, mouse);\n\n\t\t// Show cursor as pointer if point is close to mouse position\n\t\tif ($$.isBarType(closest.id) || dist < $$.getPointSensitivity(closest)) {\n\t\t\t$$.$el.svg.select(`.${$EVENT.eventRect}`).style(\"cursor\", \"pointer\");\n\n\t\t\tif (triggerEvent && !state.mouseover) {\n\t\t\t\tconfig.data_onover.call($$.api, closest);\n\t\t\t\tstate.mouseover = closest;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Unselect EventRect.\n\t * @private\n\t */\n\tunselectRect(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {circle, tooltip}} = $$;\n\n\t\t$$.$el.svg.select(`.${$EVENT.eventRect}`).style(\"cursor\", null);\n\t\t$$.hideGridFocus();\n\n\t\tif (tooltip) {\n\t\t\t$$.hideTooltip();\n\t\t\t$$._handleLinkedCharts(false);\n\t\t}\n\n\t\tcircle && !$$.isPointFocusOnly() && $$.unexpandCircles();\n\t\t$$.expandBarTypeShapes(false);\n\t},\n\n\t/**\n\t * Create eventRect for each data on the x-axis.\n\t * Register touch and drag events.\n\t * @param {object} eventRectEnter d3.select($EVENT.eventRects) object.\n\t * @returns {object} d3.select($EVENT.eventRects) object.\n\t * @private\n\t */\n\tgenerateEventRectsForSingleX(eventRectEnter) {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst {eventReceiver} = state;\n\n\t\tconst rect = eventRectEnter\n\t\t\t.style(\"cursor\",\n\t\t\t\tconfig.data_selection_enabled && config.data_selection_grouped ? \"pointer\" : null)\n\t\t\t.on(\"click\", function(event) {\n\t\t\t\tstate.event = event;\n\n\t\t\t\tconst {currentIdx, data} = eventReceiver;\n\t\t\t\tconst d = data[\n\t\t\t\t\tcurrentIdx === -1 ? $$.getDataIndexFromEvent(event) : currentIdx\n\t\t\t\t];\n\n\t\t\t\t$$.clickHandlerForSingleX.bind(this)(d, $$);\n\t\t\t})\n\t\t\t.datum({multipleX: false});\n\n\t\tif (state.inputType === \"mouse\") {\n\t\t\tconst getData = event => {\n\t\t\t\tconst index = event ? $$.getDataIndexFromEvent(event) : eventReceiver.currentIdx;\n\n\t\t\t\treturn index > -1 ? eventReceiver.data[index] : null;\n\t\t\t};\n\n\t\t\trect\n\t\t\t\t.on(\"mouseover\", event => {\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\t$$.updateEventRect();\n\n\t\t\t\t\tObject.values($$.$el.axisTooltip)\n\t\t\t\t\t\t.forEach((v: d3Selection) => v?.style(\"display\", null));\n\t\t\t\t})\n\t\t\t\t.on(\"mousemove\", function(event) {\n\t\t\t\t\tconst d = getData(event);\n\n\t\t\t\t\tstate.event = event;\n\n\t\t\t\t\tif (!d) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet {index} = d;\n\t\t\t\t\tconst stepType = config.line_step_type;\n\n\t\t\t\t\t// tooltip position match for step-before & step-after\n\t\t\t\t\tif (\n\t\t\t\t\t\tconfig.line_step_tooltipMatch && $$.hasType(\"step\") &&\n\t\t\t\t\t\t/^step\\-(before|after)$/.test(stepType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst scale = $$.scale.zoom || $$.scale.x;\n\t\t\t\t\t\tconst xs = $$.axis.xs[index];\n\t\t\t\t\t\tconst inverted = scale.invert(getPointer(event, this)[0]);\n\n\t\t\t\t\t\tif (stepType === \"step-after\" && inverted < xs) {\n\t\t\t\t\t\t\tindex -= 1;\n\t\t\t\t\t\t} else if (stepType === \"step-before\" && inverted > xs) {\n\t\t\t\t\t\t\tindex += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$$.showAxisGridFocus();\n\n\t\t\t\t\tconst eventOnSameIdx = config.tooltip_grouped &&\n\t\t\t\t\t\tindex === eventReceiver.currentIdx;\n\n\t\t\t\t\t// do nothing while dragging/flowing\n\t\t\t\t\tif (state.dragging || state.flowing || $$.hasArcType() || eventOnSameIdx) {\n\t\t\t\t\t\tconfig.tooltip_show && eventOnSameIdx && $$.setTooltipPosition();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index !== eventReceiver.currentIdx) {\n\t\t\t\t\t\t$$.setOverOut(false, eventReceiver.currentIdx);\n\t\t\t\t\t\teventReceiver.currentIdx = index;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, index);\n\n\t\t\t\t\t// As of individual data point(or <path>) element can't bind mouseover/out event\n\t\t\t\t\t// to determine current interacting element, so use 'mousemove' event instead.\n\t\t\t\t\t$$.setOverOut(index !== -1, index);\n\t\t\t\t})\n\t\t\t\t.on(\"mouseout\", event => {\n\t\t\t\t\tstate.event = event;\n\n\t\t\t\t\t// chart is destroyed\n\t\t\t\t\tif (\n\t\t\t\t\t\t!config || $$.hasArcType() || eventReceiver.currentIdx === -1 ||\n\t\t\t\t\t\t!config.interaction_onout\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t$$.hideAxisGridFocus();\n\n\t\t\t\t\t$$.unselectRect();\n\t\t\t\t\t$$.setOverOut(false, eventReceiver.currentIdx);\n\n\t\t\t\t\t// reset the event current index\n\t\t\t\t\teventReceiver.currentIdx = -1;\n\t\t\t\t});\n\t\t}\n\n\t\treturn rect;\n\t},\n\n\tclickHandlerForSingleX(d, ctx): void {\n\t\tconst $$ = ctx;\n\t\tconst {config, state, $el: {main}} = $$;\n\n\t\tif (!d || $$.hasArcType() || state.cancelClick) {\n\t\t\tstate.cancelClick && (state.cancelClick = false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst {index} = d;\n\n\t\tmain.selectAll(`.${$SHAPE.shape}-${index}`)\n\t\t\t.each(function(d2) {\n\t\t\t\tif (config.data_selection_grouped || $$.isWithinShape(this, d2)) {\n\t\t\t\t\t$$.toggleShape?.(this, d2, index);\n\t\t\t\t\tconfig.data_onclick.bind($$.api)(d2, this);\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\t/**\n\t * Create an eventRect,\n\t * Register touch and drag events.\n\t * @param {object} eventRectEnter d3.select($EVENT.eventRects) object.\n\t * @private\n\t */\n\tgenerateEventRectsForMultipleXs(eventRectEnter): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\n\t\teventRectEnter\n\t\t\t.on(\"click\", function(event) {\n\t\t\t\tstate.event = event;\n\t\t\t\t$$.clickHandlerForMultipleXS.bind(this)($$);\n\t\t\t})\n\t\t\t.datum({multipleX: true});\n\n\t\tif (state.inputType === \"mouse\") {\n\t\t\teventRectEnter\n\t\t\t\t.on(\"mouseover mousemove\", function(event) {\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\t$$.selectRectForMultipleXs(this);\n\t\t\t\t})\n\t\t\t\t.on(\"mouseout\", event => {\n\t\t\t\t\tstate.event = event;\n\n\t\t\t\t\t// chart is destroyed\n\t\t\t\t\tif (!$$.config || $$.hasArcType() || !config.interaction_onout) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t$$.unselectRect();\n\t\t\t\t});\n\t\t}\n\t},\n\n\tclickHandlerForMultipleXS(ctx): void {\n\t\tconst $$ = ctx;\n\t\tconst {config, state} = $$;\n\t\tconst targetsToShow = $$.filterTargetsToShow($$.data.targets);\n\n\t\tif ($$.hasArcType(targetsToShow)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mouse = getPointer(state.event, this);\n\t\tconst closest = $$.findClosestFromTargets(targetsToShow, mouse);\n\t\tconst sensitivity = $$.getPointSensitivity(closest);\n\n\t\tif (!closest) {\n\t\t\treturn;\n\t\t}\n\n\t\t// select if selection enabled\n\t\tif ($$.isBarType(closest.id) || $$.dist(closest, mouse) < sensitivity) {\n\t\t\t$$.$el.main.selectAll(`.${$SHAPE.shapes}${$$.getTargetSelectorSuffix(closest.id)}`)\n\t\t\t\t.selectAll(`.${$SHAPE.shape}-${closest.index}`)\n\t\t\t\t.each(function() {\n\t\t\t\t\tif (config.data_selection_grouped || $$.isWithinShape(this, closest)) {\n\t\t\t\t\t\t$$.toggleShape?.(this, closest, closest.index);\n\t\t\t\t\t\tconfig.data_onclick.bind($$.api)(closest, this);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {easeLinear as d3EaseLinear} from \"d3-ease\";\nimport CLASS from \"../../config/classes\";\nimport {generateWait} from \"../../module/generator\";\nimport {diffDomain} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Generate flow\n\t * @param {object} args option object\n\t * @returns {Function}\n\t * @private\n\t */\n\tgenerateFlow(args): Function {\n\t\tconst $$ = this;\n\t\tconst {data, state, $el} = $$;\n\n\t\treturn function() {\n\t\t\tconst flowLength = args.flow.length;\n\n\t\t\t// set flag\n\t\t\tstate.flowing = true;\n\n\t\t\t// remove head data after rendered\n\t\t\tdata.targets.forEach(d => {\n\t\t\t\td.values.splice(0, flowLength);\n\t\t\t});\n\n\t\t\t// update elements related to x scale\n\t\t\tif ($$.updateXGrid) {\n\t\t\t\t$$.updateXGrid(true);\n\t\t\t}\n\n\t\t\t// target elements\n\t\t\tconst elements = {};\n\n\t\t\t[\n\t\t\t\t\"axis.x\",\n\t\t\t\t\"grid.x\",\n\t\t\t\t\"gridLines.x\",\n\t\t\t\t\"region.list\",\n\t\t\t\t\"text\",\n\t\t\t\t\"bar\",\n\t\t\t\t\"line\",\n\t\t\t\t\"area\",\n\t\t\t\t\"circle\"\n\t\t\t]\n\t\t\t\t.forEach(v => {\n\t\t\t\t\tconst name = v.split(\".\");\n\t\t\t\t\tlet node = $el[name[0]];\n\n\t\t\t\t\tif (node && name.length > 1) {\n\t\t\t\t\t\tnode = node[name[1]];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node?.size()) {\n\t\t\t\t\t\telements[v] = node;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t$$.hideGridFocus();\n\t\t\t$$.setFlowList(elements, args);\n\t\t};\n\t},\n\n\t/**\n\t * Set flow list\n\t * @param {object} elements Target elements\n\t * @param {object} args option object\n\t * @private\n\t */\n\tsetFlowList(elements, args): void {\n\t\tconst $$ = this;\n\t\tconst {flow, targets} = args;\n\t\tconst {\n\t\t\tduration = args.duration,\n\t\t\tindex: flowIndex,\n\t\t\tlength: flowLength,\n\t\t\torgDataCount\n\t\t} = flow;\n\n\t\tconst transform = $$.getFlowTransform(targets, orgDataCount, flowIndex, flowLength);\n\t\tconst wait = generateWait();\n\t\tlet n;\n\n\t\twait.add(Object.keys(elements).map(v => {\n\t\t\tn = elements[v]\n\t\t\t\t.transition()\n\t\t\t\t.ease(d3EaseLinear)\n\t\t\t\t.duration(duration);\n\n\t\t\tif (v === \"axis.x\") {\n\t\t\t\tn = n.call(g => {\n\t\t\t\t\t$$.axis.x.setTransition(g).create(g);\n\t\t\t\t});\n\t\t\t} else if (v === \"region.list\") {\n\t\t\t\tn = n.filter($$.isRegionOnX)\n\t\t\t\t\t.attr(\"transform\", transform);\n\t\t\t} else {\n\t\t\t\tn = n.attr(\"transform\", transform);\n\t\t\t}\n\n\t\t\treturn n;\n\t\t}));\n\n\t\tn.call(wait, () => {\n\t\t\t$$.cleanUpFlow(elements, args);\n\t\t});\n\t},\n\n\t/**\n\t * Clean up flow\n\t * @param {object} elements Target elements\n\t * @param {object} args option object\n\t * @private\n\t */\n\tcleanUpFlow(elements, args): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {svg}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\tconst {flow, shape, xv} = args;\n\t\tconst {cx, cy, xForText, yForText} = shape.pos;\n\t\tconst {\n\t\t\tdone = () => {},\n\t\t\tlength: flowLength\n\t\t} = flow;\n\n\t\t// Remove flowed elements\n\t\tif (flowLength) {\n\t\t\t[\"circle\", \"text\", \"shape\", \"eventRect\"].forEach(v => {\n\t\t\t\tconst target: string[] = [];\n\n\t\t\t\tfor (let i = 0; i < flowLength; i++) {\n\t\t\t\t\ttarget.push(`.${CLASS[v]}-${i}`);\n\t\t\t\t}\n\n\t\t\t\tsvg.selectAll(`.${CLASS[`${v}s`]}`) // circles, shapes, texts, eventRects\n\t\t\t\t\t.selectAll(target)\n\t\t\t\t\t.remove();\n\t\t\t});\n\n\t\t\tsvg.select(`.${CLASS.xgrid}`)\n\t\t\t\t.remove();\n\t\t}\n\n\t\t// draw again for removing flowed elements and reverting attr\n\t\tObject.keys(elements).forEach(v => {\n\t\t\tconst n = elements[v];\n\n\t\t\tif (v !== \"axis.x\") {\n\t\t\t\tn.attr(\"transform\", null);\n\t\t\t}\n\n\t\t\tif (v === \"grid.x\") {\n\t\t\t\tn.attr(state.xgridAttr);\n\t\t\t} else if (v === \"gridLines.x\") {\n\t\t\t\tn.attr(\"x1\", isRotated ? 0 : xv)\n\t\t\t\t\t.attr(\"x2\", isRotated ? state.width : xv);\n\n\t\t\t\tn.select(\"text\")\n\t\t\t\t\t.attr(\"x\", isRotated ? state.width : 0)\n\t\t\t\t\t.attr(\"y\", xv);\n\t\t\t} else if (/^(area|bar|line)$/.test(v)) {\n\t\t\t\tn.attr(\"d\", shape.type[v]);\n\t\t\t} else if (v === \"text\") {\n\t\t\t\tn.attr(\"x\", xForText)\n\t\t\t\t\t.attr(\"y\", yForText)\n\t\t\t\t\t.style(\"fill-opacity\", $$.opacityForText.bind($$));\n\t\t\t} else if (v === \"circle\") {\n\t\t\t\tif ($$.isCirclePoint()) {\n\t\t\t\t\tn.attr(\"cx\", cx).attr(\"cy\", cy);\n\t\t\t\t} else {\n\t\t\t\t\tconst xFunc = d => cx(d) - config.point_r;\n\t\t\t\t\tconst yFunc = d => cy(d) - config.point_r;\n\n\t\t\t\t\tn.attr(\"x\", xFunc).attr(\"y\", yFunc);\n\t\t\t\t}\n\t\t\t} else if (v === \"region.list\") {\n\t\t\t\tn.select(\"rect\").filter($$.isRegionOnX)\n\t\t\t\t\t.attr(\"x\", $$.regionX.bind($$))\n\t\t\t\t\t.attr(\"width\", $$.regionWidth.bind($$));\n\t\t\t}\n\t\t});\n\n\t\tconfig.interaction_enabled && $$.redrawEventRect();\n\n\t\t// callback for end of flow\n\t\tdone.call($$.api);\n\n\t\tstate.flowing = false;\n\t},\n\n\t/**\n\t * Get flow transform value\n\t * @param {object} targets target\n\t * @param {number} orgDataCount original data count\n\t * @param {number} flowIndex flow index\n\t * @param {number} flowLength flow length\n\t * @returns {string}\n\t * @private\n\t */\n\tgetFlowTransform(targets, orgDataCount, flowIndex, flowLength): string {\n\t\tconst $$ = this;\n\t\tconst {data, scale: {x}} = $$;\n\t\tconst dataValues = data.targets[0].values;\n\n\t\tlet flowStart = $$.getValueOnIndex(dataValues, flowIndex);\n\t\tlet flowEnd = $$.getValueOnIndex(dataValues, flowIndex + flowLength);\n\t\tlet translateX;\n\n\t\t// update x domain to generate axis elements for flow\n\t\tconst orgDomain = x.domain();\n\t\tconst domain = $$.updateXDomain(targets, true, true);\n\n\t\t// generate transform to flow\n\t\tif (!orgDataCount) { // if empty\n\t\t\tif (dataValues.length !== 1) {\n\t\t\t\ttranslateX = x(orgDomain[0]) - x(domain[0]);\n\t\t\t} else {\n\t\t\t\tif ($$.axis.isTimeSeries()) {\n\t\t\t\t\tflowStart = $$.getValueOnIndex(dataValues, 0);\n\t\t\t\t\tflowEnd = $$.getValueOnIndex(dataValues, dataValues.length - 1);\n\t\t\t\t\ttranslateX = x(flowStart.x) - x(flowEnd.x);\n\t\t\t\t} else {\n\t\t\t\t\ttranslateX = diffDomain(domain) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (orgDataCount === 1 || flowStart?.x === flowEnd?.x) {\n\t\t\ttranslateX = x(orgDomain[0]) - x(domain[0]);\n\t\t} else {\n\t\t\ttranslateX = $$.axis.isTimeSeries() ?\n\t\t\t\tx(orgDomain[0]) - x(domain[0]) :\n\t\t\t\tx(flowStart?.x || 0) - x(flowEnd.x);\n\t\t}\n\n\t\tconst scaleX = diffDomain(orgDomain) / diffDomain(domain);\n\n\t\treturn `translate(${translateX},0) scale(${scaleX},1)`;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n\nexport default {\n\tinitClip(): void {\n\t\tconst $$ = this;\n\t\tconst {clip, datetimeId} = $$.state;\n\n\t\t// MEMO: clipId needs to be unique because it conflicts when multiple charts exist\n\t\tclip.id = `${datetimeId}-clip`;\n\n\t\tclip.idXAxis = `${clip.id}-xaxis`;\n\t\tclip.idYAxis = `${clip.id}-yaxis`;\n\t\tclip.idGrid = `${clip.id}-grid`;\n\n\t\t// Define 'clip-path' attribute values\n\t\tclip.path = $$.getClipPath(clip.id);\n\t\tclip.pathXAxis = $$.getClipPath(clip.idXAxis);\n\t\tclip.pathYAxis = $$.getClipPath(clip.idYAxis);\n\t\tclip.pathGrid = $$.getClipPath(clip.idGrid);\n\t},\n\n\tgetClipPath(id: string): string | null {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tif (\n\t\t\t(!config.clipPath && /-clip$/.test(id)) ||\n\t\t\t(!config.axis_x_clipPath && /-clip-xaxis$/.test(id)) ||\n\t\t\t(!config.axis_y_clipPath && /-clip-yaxis$/.test(id))\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn `url(#${id})`;\n\t},\n\n\tappendClip(parent, id: string): void {\n\t\tid && parent.append(\"clipPath\")\n\t\t\t.attr(\"id\", id)\n\t\t\t.append(\"rect\");\n\t},\n\n\t/**\n\t * Set x Axis clipPath dimension\n\t * @param {d3Selecton} node clipPath <rect> selection\n\t * @private\n\t */\n\tsetXAxisClipPath(node): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {margin, width, height}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst left = Math.max(30, margin.left) - (isRotated ? 0 : 20);\n\n\t\t// less than 20 is not enough to show the axis label 'outer' without legend\n\t\tconst h = (isRotated ? (margin.top + height) + 10 : margin.bottom) + 20;\n\t\tconst x = isRotated ? -(1 + left) : -(left - 1);\n\t\tconst y = -15; // -Math.max(15, margin.top);\n\t\tconst w = isRotated ? margin.left + 20 : width + 10 + left;\n\n\t\tnode\n\t\t\t.attr(\"x\", x)\n\t\t\t.attr(\"y\", y)\n\t\t\t.attr(\"width\", w)\n\t\t\t.attr(\"height\", h);\n\t},\n\n\t/**\n\t * Set y Axis clipPath dimension\n\t * @param {d3Selection} node clipPath <rect> selection\n\t * @private\n\t */\n\tsetYAxisClipPath(node): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {margin, width, height}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\tconst left = Math.max(30, margin.left) - (isRotated ? 20 : 0);\n\t\tconst isInner = config.axis_y_inner;\n\n\t\tconst x = isInner && !isRotated ?\n\t\t\t(config.axis_y_label.text ? -20 : -1) :\n\t\t\t(isRotated ? -(1 + left) : -(left - 1));\n\t\tconst y = -(isRotated ? 20 : margin.top);\n\t\tconst w = (isRotated ? width + 15 + left : margin.left + 20) + (isInner ? 20 : 0);\n\t\tconst h = (isRotated ? margin.bottom + 10 : (margin.top + height)) + 10;\n\n\t\tnode\n\t\t\t.attr(\"x\", x)\n\t\t\t.attr(\"y\", y)\n\t\t\t.attr(\"width\", w)\n\t\t\t.attr(\"height\", h);\n\t},\n\n\tupdateXAxisTickClip(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {clip, xAxisHeight}, $el: {defs}} = $$;\n\t\tconst newXAxisHeight = $$.getHorizontalAxisHeight(\"x\");\n\n\t\tif (defs && !clip.idXAxisTickTexts) {\n\t\t\tconst clipId = `${clip.id}-xaxisticktexts`;\n\n\t\t\t$$.appendClip(defs, clipId);\n\t\t\tclip.pathXAxisTickTexts = $$.getClipPath(clip.idXAxisTickTexts);\n\t\t\tclip.idXAxisTickTexts = clipId;\n\t\t}\n\n\t\tif (\n\t\t\t!config.axis_x_tick_multiline &&\n\t\t\t$$.getAxisTickRotate(\"x\") &&\n\t\t\tnewXAxisHeight !== xAxisHeight\n\t\t) {\n\t\t\t$$.setXAxisTickClipWidth();\n\t\t\t$$.setXAxisTickTextClipPathWidth();\n\t\t}\n\n\t\t$$.state.xAxisHeight = newXAxisHeight;\n\t},\n\n\tsetXAxisTickClipWidth(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {current: {maxTickSize}}} = $$;\n\n\t\tconst xAxisTickRotate = $$.getAxisTickRotate(\"x\");\n\n\t\tif (!config.axis_x_tick_multiline && xAxisTickRotate) {\n\t\t\tconst sinRotation = Math.sin(Math.PI / 180 * Math.abs(xAxisTickRotate));\n\n\t\t\tmaxTickSize.x.clipPath = ($$.getHorizontalAxisHeight(\"x\") - 20) / sinRotation;\n\t\t} else {\n\t\t\tmaxTickSize.x.clipPath = null;\n\t\t}\n\t},\n\n\tsetXAxisTickTextClipPathWidth(): void {\n\t\tconst $$ = this;\n\t\tconst {state: {clip, current}, $el: {svg}} = $$;\n\n\t\tif (svg) {\n\t\t\tsvg.select(`#${clip.idXAxisTickTexts} rect`)\n\t\t\t\t.attr(\"width\", current.maxTickSize.x.clipPath)\n\t\t\t\t.attr(\"height\", 30);\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select, selectAll as d3SelectAll} from \"d3-selection\";\nimport type {d3Selection} from \"../../../types/types\";\nimport {$AXIS, $COMMON, $FOCUS, $GRID} from \"../../config/classes\";\nimport {getPointer, isArray, isValue} from \"../../module/util\";\n\n// Grid position and text anchor helpers\nconst getGridTextAnchor = d => isValue(d.position) || \"end\";\nconst getGridTextDx = d => (d.position === \"start\" ? 4 : (d.position === \"middle\" ? 0 : -4));\n\n/**\n * Get grid text x value getter function\n * @param {boolean} isX Is x Axis\n * @param {number} width Width value\n * @param {number} height Height value\n * @returns {Function}\n * @private\n */\nfunction getGridTextX(isX, width, height): Function {\n\treturn d => {\n\t\tlet x = isX ? 0 : width;\n\n\t\tif (d.position === \"start\") {\n\t\t\tx = isX ? -height : 0;\n\t\t} else if (d.position === \"middle\") {\n\t\t\tx = (isX ? -height : width) / 2;\n\t\t}\n\n\t\treturn x;\n\t};\n}\n\n/**\n * Update coordinate attributes value\n * @param {d3.selection} el Target node\n * @param {string} type Type\n * @private\n */\nfunction smoothLines(el, type: string): void {\n\tif (type === \"grid\") {\n\t\tel.each(function() {\n\t\t\tconst g = d3Select(this);\n\n\t\t\t[\"x1\", \"x2\", \"y1\", \"y2\"]\n\t\t\t\t.forEach(v => g.attr(v, +g.attr(v)));\n\t\t});\n\t}\n}\n\nexport default {\n\thasGrid(): boolean {\n\t\tconst {config} = this;\n\n\t\treturn [\"x\", \"y\"]\n\t\t\t.some(v => config[`grid_${v}_show`] || config[`grid_${v}_lines`].length);\n\t},\n\n\tinitGrid() {\n\t\tconst $$ = this;\n\n\t\t$$.hasGrid() && $$.initGridLines();\n\t\t$$.initFocusGrid();\n\t},\n\n\tinitGridLines(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {clip}, $el} = $$;\n\n\t\tif (config.grid_x_lines.length || config.grid_y_lines.length) {\n\t\t\t$el.gridLines.main = $el.main.insert(\"g\",\n\t\t\t\t`.${$COMMON.chart}${config.grid_lines_front ? \" + *\" : \"\"}`)\n\t\t\t\t.attr(\"clip-path\", clip.pathGrid)\n\t\t\t\t.attr(\"class\", `${$GRID.grid} ${$GRID.gridLines}`);\n\n\t\t\t$el.gridLines.main.append(\"g\").attr(\"class\", $GRID.xgridLines);\n\t\t\t$el.gridLines.main.append(\"g\").attr(\"class\", $GRID.ygridLines);\n\n\t\t\t$el.gridLines.x = d3SelectAll([]);\n\t\t}\n\t},\n\n\tupdateXGrid(withoutUpdate): void {\n\t\tconst $$ = this;\n\t\tconst {config, scale, state, $el: {main, grid}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst xgridData = $$.generateGridData(config.grid_x_type, scale.x);\n\t\tconst tickOffset = $$.axis.isCategorized() ? $$.axis.x.tickOffset() : 0;\n\t\tconst pos = d =>\n\t\t\t(scale.zoom || scale.x)(d) + (\n\t\t\t\ttickOffset * (isRotated ? -1 : 1)\n\t\t\t);\n\n\t\tstate.xgridAttr = isRotated ?\n\t\t\t{\n\t\t\t\tx1: 0,\n\t\t\t\tx2: state.width,\n\t\t\t\ty1: pos,\n\t\t\t\ty2: pos\n\t\t\t} :\n\t\t\t{\n\t\t\t\tx1: pos,\n\t\t\t\tx2: pos,\n\t\t\t\ty1: 0,\n\t\t\t\ty2: state.height\n\t\t\t};\n\n\t\tgrid.x = main.select(`.${$GRID.xgrids}`)\n\t\t\t.selectAll(`.${$GRID.xgrid}`)\n\t\t\t.data(xgridData);\n\n\t\tgrid.x.exit().remove();\n\n\t\tgrid.x = grid.x.enter()\n\t\t\t.append(\"line\")\n\t\t\t.attr(\"class\", $GRID.xgrid)\n\t\t\t.merge(grid.x);\n\n\t\tif (!withoutUpdate) {\n\t\t\tgrid.x.each(function() {\n\t\t\t\tconst grid = d3Select(this);\n\n\t\t\t\tObject.keys(state.xgridAttr).forEach(id => {\n\t\t\t\t\tgrid.attr(id, state.xgridAttr[id])\n\t\t\t\t\t\t.style(\"opacity\", () => (\n\t\t\t\t\t\t\tgrid.attr(isRotated ? \"y1\" : \"x1\") === (isRotated ? state.height : 0) ?\n\t\t\t\t\t\t\t\t\"0\" :\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t},\n\n\tupdateYGrid(): void {\n\t\tconst $$ = this;\n\t\tconst {axis, config, scale, state, $el: {grid, main}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst pos = d => scale.y(d);\n\t\tconst gridValues = axis.y.getGeneratedTicks(config.grid_y_ticks) ||\n\t\t\t$$.scale.y.ticks(config.grid_y_ticks);\n\n\t\tgrid.y = main.select(`.${$GRID.ygrids}`)\n\t\t\t.selectAll(`.${$GRID.ygrid}`)\n\t\t\t.data(gridValues);\n\n\t\tgrid.y.exit().remove();\n\n\t\tgrid.y = grid.y\n\t\t\t.enter()\n\t\t\t.append(\"line\")\n\t\t\t.attr(\"class\", $GRID.ygrid)\n\t\t\t.merge(grid.y);\n\n\t\tgrid.y.attr(\"x1\", isRotated ? pos : 0)\n\t\t\t.attr(\"x2\", isRotated ? pos : state.width)\n\t\t\t.attr(\"y1\", isRotated ? 0 : pos)\n\t\t\t.attr(\"y2\", isRotated ? state.height : pos);\n\n\t\tsmoothLines(grid.y, \"grid\");\n\t},\n\n\tupdateGrid() {\n\t\tconst $$ = this;\n\t\tconst {$el: {grid, gridLines}} = $$;\n\n\t\t!gridLines.main && $$.initGridLines();\n\n\t\t// hide if arc type\n\t\tgrid.main.style(\"visibility\", $$.hasArcType() ? \"hidden\" : null);\n\n\t\t$$.hideGridFocus();\n\t\t$$.updateGridLines(\"x\");\n\t\t$$.updateGridLines(\"y\");\n\t},\n\n\t/**\n\t * Update Grid lines\n\t * @param {string} type x | y\n\t * @private\n\t */\n\tupdateGridLines(type: \"x\" | \"y\"): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {gridLines, main}, $T} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isX = type === \"x\";\n\n\t\tconfig[`grid_${type}_show`] && $$[`update${type.toUpperCase()}Grid`]();\n\n\t\tlet lines = main.select(`.${$GRID[`${type}gridLines`]}`)\n\t\t\t.selectAll(`.${$GRID[`${type}gridLine`]}`)\n\t\t\t.data(config[`grid_${type}_lines`]);\n\n\t\t// exit\n\t\t$T(lines.exit())\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\t// enter\n\t\tconst gridLine = lines.enter().append(\"g\");\n\n\t\tgridLine.append(\"line\")\n\t\t\t.style(\"opacity\", \"0\");\n\n\t\tlines = gridLine.merge(lines);\n\n\t\tlines.each(function(d) {\n\t\t\tconst g = d3Select(this);\n\n\t\t\tif (g.select(\"text\").empty() && d.text) {\n\t\t\t\tg.append(\"text\")\n\t\t\t\t\t.style(\"opacity\", \"0\");\n\t\t\t}\n\t\t});\n\n\t\t$T(lines\n\t\t\t.attr(\"class\", d => `${$GRID[`${type}gridLine`]} ${d.class || \"\"}`.trim())\n\t\t\t.select(\"text\")\n\t\t\t.attr(\"text-anchor\", getGridTextAnchor)\n\t\t\t.attr(\"transform\",\n\t\t\t\t() => (isX ?\n\t\t\t\t\t(isRotated ? null : \"rotate(-90)\") :\n\t\t\t\t\t(isRotated ? \"rotate(-90)\" : null)))\n\t\t\t.attr(\"dx\", getGridTextDx)\n\t\t\t.attr(\"dy\", -5))\n\t\t\t.text(function(d) {\n\t\t\t\treturn d.text ?? this.remove();\n\t\t\t});\n\n\t\tgridLines[type] = lines;\n\t},\n\n\tredrawGrid(withTransition: boolean): any[] {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\tconfig: {axis_rotated: isRotated},\n\t\t\tstate: {width, height},\n\t\t\t$el: {gridLines},\n\t\t\t$T\n\t\t} = $$;\n\t\tconst xv = $$.xv.bind($$);\n\t\tconst yv = $$.yv.bind($$);\n\n\t\tlet xLines = gridLines.x.select(\"line\");\n\t\tlet xTexts = gridLines.x.select(\"text\");\n\n\t\tlet yLines = gridLines.y.select(\"line\");\n\t\tlet yTexts = gridLines.y.select(\"text\");\n\n\t\txLines = $T(xLines, withTransition)\n\t\t\t.attr(\"x1\", isRotated ? 0 : xv)\n\t\t\t.attr(\"x2\", isRotated ? width : xv)\n\t\t\t.attr(\"y1\", isRotated ? xv : 0)\n\t\t\t.attr(\"y2\", isRotated ? xv : height);\n\n\t\txTexts = $T(xTexts, withTransition)\n\t\t\t.attr(\"x\", getGridTextX(!isRotated, width, height))\n\t\t\t.attr(\"y\", xv);\n\n\t\tyLines = $T(yLines, withTransition)\n\t\t\t.attr(\"x1\", isRotated ? yv : 0)\n\t\t\t.attr(\"x2\", isRotated ? yv : width)\n\t\t\t.attr(\"y1\", isRotated ? 0 : yv)\n\t\t\t.attr(\"y2\", isRotated ? height : yv);\n\n\t\tyTexts = $T(yTexts, withTransition)\n\t\t\t.attr(\"x\", getGridTextX(isRotated, width, height))\n\t\t\t.attr(\"y\", yv);\n\n\t\treturn [\n\t\t\txLines.style(\"opacity\", null),\n\t\t\txTexts.style(\"opacity\", null),\n\t\t\tyLines.style(\"opacity\", null),\n\t\t\tyTexts.style(\"opacity\", null)\n\t\t];\n\t},\n\n\tinitFocusGrid(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {clip}, $el} = $$;\n\t\tconst isFront = config.grid_front;\n\t\tconst className = `.${isFront && $el.gridLines.main ? $GRID.gridLines : $COMMON.chart}${\n\t\t\tisFront ? \" + *\" : \"\"\n\t\t}`;\n\n\t\tconst grid = $el.main.insert(\"g\", className)\n\t\t\t.attr(\"clip-path\", clip.pathGrid)\n\t\t\t.attr(\"class\", $GRID.grid);\n\n\t\t$el.grid.main = grid;\n\n\t\tconfig.grid_x_show &&\n\t\t\tgrid.append(\"g\").attr(\"class\", $GRID.xgrids);\n\n\t\tconfig.grid_y_show &&\n\t\t\tgrid.append(\"g\").attr(\"class\", $GRID.ygrids);\n\n\t\tif (config.axis_tooltip) {\n\t\t\tconst axis = grid.append(\"g\").attr(\"class\", \"bb-axis-tooltip\");\n\n\t\t\taxis.append(\"line\").attr(\"class\", \"bb-axis-tooltip-x\");\n\t\t\taxis.append(\"line\").attr(\"class\", \"bb-axis-tooltip-y\");\n\t\t}\n\n\t\tif (config.interaction_enabled && config.grid_focus_show && !config.axis_tooltip) {\n\t\t\tgrid.append(\"g\")\n\t\t\t\t.attr(\"class\", $FOCUS.xgridFocus)\n\t\t\t\t.append(\"line\")\n\t\t\t\t.attr(\"class\", $FOCUS.xgridFocus);\n\n\t\t\t// to show xy focus grid line, should be 'tooltip.grouped=false'\n\t\t\tif (config.grid_focus_y && !config.tooltip_grouped) {\n\t\t\t\tgrid.append(\"g\")\n\t\t\t\t\t.attr(\"class\", $FOCUS.ygridFocus)\n\t\t\t\t\t.append(\"line\")\n\t\t\t\t\t.attr(\"class\", $FOCUS.ygridFocus);\n\t\t\t}\n\t\t}\n\t},\n\n\tshowAxisGridFocus() {\n\t\tconst $$ = this;\n\t\tconst {config, format, state: {event, width, height}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\t// get mouse event position\n\t\tconst [x, y] = getPointer(event, $$.$el.eventRect?.node());\n\t\tconst pos = {x, y};\n\n\t\tfor (const [axis, node] of Object.entries($$.$el.axisTooltip)) {\n\t\t\tconst attr = (axis === \"x\" && !isRotated) || (axis !== \"x\" && isRotated) ? \"x\" : \"y\";\n\t\t\tconst value = pos[attr];\n\t\t\tlet scaleText = $$.scale[axis]?.invert(value);\n\n\t\t\tif (scaleText) {\n\t\t\t\tscaleText = axis === \"x\" && $$.axis.isTimeSeries() ?\n\t\t\t\t\tformat.xAxisTick(scaleText) :\n\t\t\t\t\tscaleText?.toFixed(2);\n\n\t\t\t\t// set position & its text value based on position\n\t\t\t\t(node as d3Selection)?.attr(attr, value)\n\t\t\t\t\t.text(scaleText);\n\t\t\t}\n\t\t}\n\n\t\t$$.$el.main.selectAll(\n\t\t\t`line.bb-axis-tooltip-x, line.bb-axis-tooltip-y`\n\t\t).style(\"visibility\", null)\n\t\t\t.each(function(d, i) {\n\t\t\t\tconst line = d3Select(this);\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tline\n\t\t\t\t\t\t.attr(\"x1\", x)\n\t\t\t\t\t\t.attr(\"x2\", x)\n\t\t\t\t\t\t.attr(\"y1\", i ? 0 : height)\n\t\t\t\t\t\t.attr(\"y2\", i ? height : 0);\n\t\t\t\t} else {\n\t\t\t\t\tline\n\t\t\t\t\t\t.attr(\"x1\", i ? 0 : width)\n\t\t\t\t\t\t.attr(\"x2\", i ? width : 0)\n\t\t\t\t\t\t.attr(\"y1\", y)\n\t\t\t\t\t\t.attr(\"y2\", y);\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\thideAxisGridFocus() {\n\t\tconst $$ = this;\n\n\t\t$$.$el.main.selectAll(\n\t\t\t`line.${$AXIS.axisTooltipX}, line.${$AXIS.axisTooltipY}`\n\t\t).style(\"visibility\", \"hidden\");\n\n\t\tObject.values($$.$el.axisTooltip)\n\t\t\t.forEach((v: d3Selection) => v?.style(\"display\", \"none\"));\n\t},\n\n\t/**\n\t * Show grid focus line\n\t * @param {Array} data Selected data\n\t * @private\n\t */\n\tshowGridFocus(data?): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {width, height}} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst focusEl = $$.$el.main.selectAll(\n\t\t\t`line.${$FOCUS.xgridFocus}, line.${$FOCUS.ygridFocus}`\n\t\t);\n\n\t\tconst dataToShow = (data || [focusEl.datum()]).filter(d =>\n\t\t\td && isValue($$.getBaseValue(d))\n\t\t);\n\n\t\t// Hide when bubble/scatter/stanford plot exists\n\t\tif (\n\t\t\t!config.tooltip_show || dataToShow.length === 0 || (\n\t\t\t\t!config.axis_x_forceAsSingle && $$.hasType(\"bubble\")\n\t\t\t) || $$.hasArcType()\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isEdge = config.grid_focus_edge && !config.tooltip_grouped;\n\t\tconst xx = $$.xx.bind($$);\n\n\t\tfocusEl\n\t\t\t.style(\"visibility\", null)\n\t\t\t.data(dataToShow.concat(dataToShow))\n\t\t\t.each(function(d) {\n\t\t\t\tconst el = d3Select(this);\n\t\t\t\tconst pos = {\n\t\t\t\t\tx: xx(d),\n\t\t\t\t\ty: $$.getYScaleById(d.id)(d.value)\n\t\t\t\t};\n\t\t\t\tlet xy;\n\n\t\t\t\tif (el.classed($FOCUS.xgridFocus)) {\n\t\t\t\t\t// will contain 'x1, y1, x2, y2' order\n\t\t\t\t\txy = isRotated ?\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnull, // x1\n\t\t\t\t\t\t\tpos.x, // y1\n\t\t\t\t\t\t\tisEdge ? pos.y : width, // x2\n\t\t\t\t\t\t\tpos.x // y2\n\t\t\t\t\t\t] :\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tpos.x,\n\t\t\t\t\t\t\tisEdge ? pos.y : null,\n\t\t\t\t\t\t\tpos.x,\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tconst isY2 = $$.axis.getId(d.id) === \"y2\";\n\n\t\t\t\t\txy = isRotated ?\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tpos.y, // x1\n\t\t\t\t\t\t\tisEdge && !isY2 ? pos.x : null, // y1\n\t\t\t\t\t\t\tpos.y, // x2\n\t\t\t\t\t\t\tisEdge && isY2 ? pos.x : height // y2\n\t\t\t\t\t\t] :\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tisEdge && isY2 ? pos.x : null,\n\t\t\t\t\t\t\tpos.y,\n\t\t\t\t\t\t\tisEdge && !isY2 ? pos.x : width,\n\t\t\t\t\t\t\tpos.y\n\t\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t[\"x1\", \"y1\", \"x2\", \"y2\"]\n\t\t\t\t\t.forEach((v, i) => el.attr(v, xy[i]));\n\t\t\t});\n\n\t\tsmoothLines(focusEl, \"grid\");\n\t\t$$.showCircleFocus?.(data);\n\t},\n\n\thideGridFocus(): void {\n\t\tconst $$ = this;\n\t\tconst {state: {inputType, resizing}, $el: {main}} = $$;\n\n\t\tif (inputType === \"mouse\" || !resizing) {\n\t\t\tmain.selectAll(`line.${$FOCUS.xgridFocus}, line.${$FOCUS.ygridFocus}`)\n\t\t\t\t.style(\"visibility\", \"hidden\");\n\n\t\t\t$$.hideCircleFocus?.();\n\t\t}\n\t},\n\n\tupdateGridFocus(): boolean {\n\t\tconst $$ = this;\n\t\tconst {state: {inputType, width, height, resizing}, $el: {grid}} = $$;\n\t\tconst xgridFocus = grid.main.select(`line.${$FOCUS.xgridFocus}`);\n\n\t\tif (inputType === \"touch\") {\n\t\t\tif (xgridFocus.empty()) {\n\t\t\t\tresizing && $$.showCircleFocus?.();\n\t\t\t} else {\n\t\t\t\t$$.showGridFocus();\n\t\t\t}\n\t\t} else {\n\t\t\tconst isRotated = $$.config.axis_rotated;\n\n\t\t\txgridFocus\n\t\t\t\t.attr(\"x1\", isRotated ? 0 : -10)\n\t\t\t\t.attr(\"x2\", isRotated ? width : -10)\n\t\t\t\t.attr(\"y1\", isRotated ? -10 : 0)\n\t\t\t\t.attr(\"y2\", isRotated ? -10 : height);\n\t\t}\n\n\t\t// need to return 'true' as of being pushed to the redraw list\n\t\t// ref: getRedrawList()\n\t\treturn true;\n\t},\n\n\tgenerateGridData(type: string, scale) {\n\t\tconst $$ = this;\n\t\tconst tickNum = $$.$el.main.select(`.${$AXIS.axisX}`)\n\t\t\t.selectAll(\".tick\")\n\t\t\t.size();\n\t\tlet gridData: Date[] = [];\n\n\t\tif (type === \"year\") {\n\t\t\tconst xDomain = $$.getXDomain();\n\t\t\tconst [firstYear, lastYear] = xDomain.map(v => v.getFullYear());\n\n\t\t\tfor (let i = firstYear; i <= lastYear; i++) {\n\t\t\t\tgridData.push(new Date(`${i}-01-01 00:00:00`));\n\t\t\t}\n\t\t} else {\n\t\t\tgridData = scale.ticks(10);\n\n\t\t\tif (gridData.length > tickNum) { // use only int\n\t\t\t\tgridData = gridData.filter(d => String(d).indexOf(\".\") < 0);\n\t\t\t}\n\t\t}\n\n\t\treturn gridData;\n\t},\n\n\tgetGridFilterToRemove(params): Function {\n\t\treturn params ?\n\t\t\tline => {\n\t\t\t\tlet found = false;\n\n\t\t\t\t(isArray(params) ? params.concat() : [params]).forEach(param => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t((\"value\" in param && line.value === param.value) ||\n\t\t\t\t\t\t\t(\"class\" in param && line.class === param.class))\n\t\t\t\t\t) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn found;\n\t\t\t} :\n\t\t\t() => true;\n\t},\n\n\tremoveGridLines(params, forX?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {config, $T} = $$;\n\t\tconst toRemove = $$.getGridFilterToRemove(params);\n\t\tconst toShow = line => !toRemove(line);\n\t\tconst classLines = forX ? $GRID.xgridLines : $GRID.ygridLines;\n\t\tconst classLine = forX ? $GRID.xgridLine : $GRID.ygridLine;\n\n\t\t$T($$.$el.main.select(`.${classLines}`)\n\t\t\t.selectAll(`.${classLine}`)\n\t\t\t.filter(toRemove))\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\tconst gridLines = `grid_${forX ? \"x\" : \"y\"}_lines`;\n\n\t\tconfig[gridLines] = config[gridLines].filter(toShow);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\"; // selection\nimport type {RegionOptions} from \"../../../types/options\";\nimport type {AxisType} from \"../../../types/types\";\nimport {$REGION} from \"../../config/classes\";\nimport {getBoundingRect, isString, isValue, parseDate} from \"../../module/util\";\n\nexport default {\n\tinitRegion(): void {\n\t\tconst $$ = this;\n\t\tconst {$el} = $$;\n\n\t\t$el.region.main = $el.main\n\t\t\t.insert(\"g\", \":first-child\")\n\t\t\t.attr(\"clip-path\", $$.state.clip.path)\n\t\t\t.attr(\"class\", $REGION.regions);\n\t},\n\n\tupdateRegion(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {region}, $T} = $$;\n\n\t\tif (!region.main) {\n\t\t\t$$.initRegion();\n\t\t}\n\n\t\t// hide if arc type\n\t\tregion.main.style(\"visibility\", $$.hasArcType() ? \"hidden\" : null);\n\n\t\t// select <g> element\n\t\tconst regions = region.main\n\t\t\t.selectAll(`.${$REGION.region}`)\n\t\t\t.data(config.regions);\n\n\t\t$T(regions.exit())\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\tconst regionsEnter = regions\n\t\t\t.enter()\n\t\t\t.append(\"g\");\n\n\t\tregionsEnter\n\t\t\t.append(\"rect\")\n\t\t\t.style(\"fill-opacity\", \"0\");\n\n\t\tregion.list = regionsEnter\n\t\t\t.merge(regions)\n\t\t\t.attr(\"class\", $$.classRegion.bind($$));\n\n\t\tregion.list.each(function(d) {\n\t\t\tconst g = d3Select(this);\n\n\t\t\tif (g.select(\"text\").empty() && d.label?.text) {\n\t\t\t\td3Select(this).append(\"text\")\n\t\t\t\t\t.style(\"opacity\", \"0\");\n\t\t\t}\n\t\t});\n\t},\n\n\tredrawRegion(withTransition: boolean) {\n\t\tconst $$ = this;\n\t\tconst {$el: {region}, $T} = $$;\n\t\tconst regionX = $$.regionX.bind($$);\n\t\tconst regionY = $$.regionY.bind($$);\n\t\tconst attr = [\"width\", \"height\"];\n\t\tlet regions = region.list.select(\"rect\");\n\t\tlet label = region.list.selectAll(\"text\");\n\n\t\tregions = $T(regions, withTransition)\n\t\t\t.attr(\"x\", regionX)\n\t\t\t.attr(\"y\", regionY)\n\t\t\t.attr(\"width\", $$.regionWidth.bind($$))\n\t\t\t.attr(\"height\", $$.regionHeight.bind($$));\n\n\t\tlabel = $T(label, withTransition)\n\t\t\t.text(d => d.label?.text)\n\t\t\t.attr(\"transform\", ({label}) => label.rotated ? ` rotate(-90)` : null)\n\t\t\t.attr(\"transform\", function(d) {\n\t\t\t\tconst {x = 0, y = 0, center = false, rotated = false} = d.label ?? {};\n\t\t\t\tconst rect = this.previousElementSibling;\n\t\t\t\tconst pos = {x: 0, y: 0};\n\n\t\t\t\tif (isString(center)) {\n\t\t\t\t\t[\"x\", \"y\"].forEach((v, i) => {\n\t\t\t\t\t\tif (center.indexOf(v) > -1) {\n\t\t\t\t\t\t\tpos[v] =\n\t\t\t\t\t\t\t\t(+rect.getAttribute(attr[i]) - getBoundingRect(this)[attr[i]]) / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn `translate(${regionX(d) + pos.x + x}, ${regionY(d) + pos.y + y})${\n\t\t\t\t\trotated ? ` rotate(-90)` : ``\n\t\t\t\t}`;\n\t\t\t})\n\t\t\t.attr(\"text-anchor\", ({label}) => label?.rotated ? \"end\" : null)\n\t\t\t.attr(\"dy\", \"1em\")\n\t\t\t.style(\"fill\", ({label}) => label?.color ?? null);\n\n\t\treturn [\n\t\t\tregions\n\t\t\t\t.style(\"fill-opacity\", d => (isValue(d.opacity) ? d.opacity : null))\n\t\t\t\t.on(\"end\", function() {\n\t\t\t\t\t// remove unnecessary rect after transition\n\t\t\t\t\td3Select(this.parentNode)\n\t\t\t\t\t\t.selectAll(\"rect:not([x])\")\n\t\t\t\t\t\t.remove();\n\t\t\t\t}),\n\t\t\tlabel.style(\"opacity\", null)\n\t\t];\n\t},\n\n\tregionX(d: RegionOptions): number {\n\t\treturn this.getRegionSize(\"x\", d);\n\t},\n\n\tregionY(d: RegionOptions): number {\n\t\treturn this.getRegionSize(\"y\", d);\n\t},\n\n\tregionWidth(d: RegionOptions): number {\n\t\treturn this.getRegionSize(\"width\", d);\n\t},\n\n\tregionHeight(d: RegionOptions): number {\n\t\treturn this.getRegionSize(\"height\", d);\n\t},\n\n\t/**\n\t * Get Region size according start/end position\n\t * @param {string} type Type string\n\t * @param {ojbect} d Data object\n\t * @returns {number}\n\t * @private\n\t */\n\tgetRegionSize(type: AxisType | \"width\" | \"height\", d: RegionOptions): number {\n\t\tconst $$ = this;\n\t\tconst {config, scale, state} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isAxisType = /(x|y|y2)/.test(type);\n\n\t\tconst isType = isAxisType ? type === \"x\" : type === \"width\";\n\t\tconst start = !isAxisType && $$[isType ? \"regionX\" : \"regionY\"](d);\n\t\tlet key = isAxisType ? \"start\" : \"end\";\n\t\tlet pos = isAxisType ? 0 : state[type];\n\t\tlet currScale;\n\n\t\tif (d.axis === \"y\" || d.axis === \"y2\") {\n\t\t\tif (!isAxisType && !isType) {\n\t\t\t\tkey = \"start\";\n\t\t\t} else if (isAxisType && !isType) {\n\t\t\t\tkey = \"end\";\n\t\t\t}\n\n\t\t\tif ((isType ? isRotated : !isRotated) && key in d) {\n\t\t\t\tcurrScale = scale[d.axis];\n\t\t\t}\n\t\t} else if ((isType ? !isRotated : isRotated) && key in d) {\n\t\t\tcurrScale = scale.zoom || scale.x;\n\t\t}\n\n\t\tif (currScale) {\n\t\t\tlet offset = 0;\n\t\t\tpos = d[key];\n\n\t\t\tif ($$.axis.isTimeSeries(d.axis)) {\n\t\t\t\tpos = parseDate.call($$, pos);\n\t\t\t} else if (/(x|width)/.test(type) && $$.axis.isCategorized() && isNaN(pos)) {\n\t\t\t\tpos = config.axis_x_categories.indexOf(pos);\n\t\t\t\toffset = $$.axis.x.tickOffset() * (key === \"start\" ? -1 : 1);\n\t\t\t}\n\n\t\t\tpos = currScale(pos) + offset;\n\t\t}\n\n\t\treturn isAxisType ? pos : pos < start ? 0 : pos - start;\n\t},\n\n\tisRegionOnX(d: RegionOptions): boolean {\n\t\treturn !d.axis || d.axis === \"x\";\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {AxisType} from \"../../../types/types\";\nimport {isNumber} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Get Axis size according its position\n\t * @param {string} id Axis id value - x, y or y2\n\t * @returns {number} size Axis size value\n\t * @private\n\t */\n\tgetAxisSize(id: AxisType): number {\n\t\tconst $$ = this;\n\t\tconst isRotated = $$.config.axis_rotated;\n\n\t\treturn (isRotated && id === \"x\") || (!isRotated && /y2?/.test(id)) ?\n\t\t\t$$.getAxisWidthByAxisId(id, true) :\n\t\t\t$$.getHorizontalAxisHeight(id);\n\t},\n\n\tgetAxisWidthByAxisId(id: AxisType, withoutRecompute?: boolean): number {\n\t\tconst $$ = this;\n\n\t\tif ($$.axis) {\n\t\t\tconst position = $$.axis?.getLabelPositionById(id);\n\t\t\tconst {width} = $$.axis.getMaxTickSize(id, withoutRecompute);\n\t\t\tconst gap = width === 0 ? 0.5 : 0;\n\n\t\t\treturn width + (\n\t\t\t\t$$.config.padding?.mode === \"fit\" ?\n\t\t\t\t\tposition.isInner ? (10 + gap) : 10 :\n\t\t\t\t\tposition.isInner ?\n\t\t\t\t\t(20 + gap) :\n\t\t\t\t\t40\n\t\t\t);\n\t\t} else {\n\t\t\treturn 40;\n\t\t}\n\t},\n\n\tgetHorizontalAxisHeight(id: AxisType): number {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst {rotatedPadding, isLegendRight, isLegendInset} = state;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isFitPadding = config.padding?.mode === \"fit\";\n\t\tconst isInner = config[`axis_${id}_inner`];\n\t\tconst hasLabelText = config[`axis_${id}_label`].text;\n\t\tconst defaultHeight = 13;\n\t\tlet h = config.padding?.mode === \"fit\" ?\n\t\t\t(isInner && !hasLabelText ? (id === \"y\" ? 1 : 0) : 20) :\n\t\t\t30;\n\n\t\tif (id === \"x\" && !config.axis_x_show) {\n\t\t\treturn 8;\n\t\t}\n\n\t\tif (id === \"x\" && isNumber(config.axis_x_height)) {\n\t\t\treturn config.axis_x_height;\n\t\t}\n\n\t\tif (id === \"y\" && !config.axis_y_show) {\n\t\t\treturn config.legend_show &&\n\t\t\t\t\t!isLegendRight &&\n\t\t\t\t\t!isLegendInset ?\n\t\t\t\t10 :\n\t\t\t\t1;\n\t\t}\n\n\t\tif (id === \"y2\" && !config.axis_y2_show) {\n\t\t\treturn isFitPadding ? 0 : rotatedPadding.top;\n\t\t}\n\n\t\tconst maxtickSize = $$.axis.getMaxTickSize(id);\n\n\t\tconst isXAxisTickRotated = Math.abs(config.axis_x_tick_rotate) > 0 && (\n\t\t\t!config.axis_x_tick_autorotate || $$.needToRotateXAxisTickTexts()\n\t\t);\n\n\t\tif (\n\t\t\t(config.axis_x_tick_multiline || isXAxisTickRotated) &&\n\t\t\tmaxtickSize.height > defaultHeight\n\t\t) {\n\t\t\th += maxtickSize.height - defaultHeight;\n\t\t}\n\n\t\treturn h +\n\t\t\t($$.axis.getLabelPositionById(id).isInner ? 0 : 10) +\n\t\t\t(id === \"y2\" && !isRotated ? -10 : 0);\n\t},\n\n\tgetEventRectWidth(): number {\n\t\tconst $$ = this;\n\t\tconst {config, axis} = $$;\n\t\tconst isInverted = config.axis_x_inverted;\n\t\tconst tickInterval = axis.x.tickInterval();\n\n\t\treturn Math.max(0, isInverted ? Math.abs(tickInterval) : tickInterval);\n\t},\n\n\t/**\n\t * Get axis tick test rotate value\n\t * @param {string} id Axis id\n\t * @returns {number} rotate value\n\t * @private\n\t */\n\tgetAxisTickRotate(id: AxisType): number {\n\t\tconst $$ = this;\n\t\tconst {axis, config, state, $el} = $$;\n\t\tlet rotate = config[`axis_${id}_tick_rotate`];\n\n\t\tif (id === \"x\") {\n\t\t\tconst allowedXAxisTypes = axis.isCategorized() || axis.isTimeSeries();\n\n\t\t\tif (config.axis_x_tick_fit && allowedXAxisTypes) {\n\t\t\t\tconst xTickCount = config.axis_x_tick_count;\n\t\t\t\tconst currentXTicksLength = state.current.maxTickSize.x.ticks.length;\n\t\t\t\tlet tickCount = 0;\n\n\t\t\t\tif (xTickCount) {\n\t\t\t\t\ttickCount = xTickCount > currentXTicksLength ? currentXTicksLength : xTickCount;\n\t\t\t\t} else if (currentXTicksLength) {\n\t\t\t\t\ttickCount = currentXTicksLength;\n\t\t\t\t}\n\n\t\t\t\tif (tickCount !== state.axis.x.tickCount) {\n\t\t\t\t\tconst {targets} = $$.data;\n\n\t\t\t\t\tstate.axis.x.padding = $$.getXDomainPadding([\n\t\t\t\t\t\t$$.getXDomainMinMax(targets, \"min\"),\n\t\t\t\t\t\t$$.getXDomainMinMax(targets, \"max\")\n\t\t\t\t\t], tickCount);\n\t\t\t\t}\n\n\t\t\t\tstate.axis.x.tickCount = tickCount;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t$el.svg &&\n\t\t\t\tconfig.axis_x_tick_autorotate &&\n\t\t\t\tconfig.axis_x_tick_fit &&\n\t\t\t\t!config.axis_x_tick_multiline &&\n\t\t\t\t!config.axis_x_tick_culling &&\n\t\t\t\tallowedXAxisTypes\n\t\t\t) {\n\t\t\t\trotate = $$.needToRotateXAxisTickTexts() ? config.axis_x_tick_rotate : 0;\n\t\t\t}\n\t\t}\n\n\t\treturn rotate;\n\t},\n\n\t/**\n\t * Check weather axis tick text needs to be rotated\n\t * @returns {boolean}\n\t * @private\n\t */\n\tneedToRotateXAxisTickTexts(): boolean {\n\t\tconst $$ = this;\n\t\tconst {state: {axis, current, isLegendRight, legendItemWidth}} = $$;\n\t\tconst legendWidth = isLegendRight && legendItemWidth;\n\t\tconst xAxisLength = current.width - legendWidth -\n\t\t\t$$.getCurrentPaddingByDirection(\"left\") - $$.getCurrentPaddingByDirection(\"right\");\n\t\tconst tickCountWithPadding = axis.x.tickCount +\n\t\t\taxis.x.padding.left + axis.x.padding.right;\n\n\t\tconst {width} = $$.axis.getMaxTickSize(\"x\");\n\t\tconst tickLength = tickCountWithPadding ? xAxisLength / tickCountWithPadding : 0;\n\n\t\treturn width > tickLength;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * x Axis config options\n */\nexport default {\n\t/**\n\t * Set clip-path attribute for x axis element\n\t * @name axis․x․clipPath\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo]()\n\t * @example\n\t * // don't set 'clip-path' attribute\n\t * clipPath: false\n\t */\n\taxis_x_clipPath: true,\n\n\t/**\n\t * Show or hide x axis.\n\t * @name axis․x․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     show: false\n\t *   }\n\t * }\n\t */\n\taxis_x_show: true,\n\n\t/**\n\t * Force the x axis to interact as single rather than multiple x axes.\n\t * - **NOTE:** The tooltip event will be triggered nearing each data points(for multiple xs) rather than x axis based(as single x does) in below condition:\n\t *   - for `bubble` & `scatter` type\n\t *   - when `data.xs` is set\n\t *   - when `tooltip.grouped=false` is set\n\t *     - `tooltip.grouped` options will take precedence over `axis.forceSingleX` option.\n\t * @name axis․x․forceAsSingle\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.ForceAsSingle)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *      // will work as single x axis\n\t *      forceAsSingle: true\n\t *   }\n\t * }\n\t */\n\taxis_x_forceAsSingle: false,\n\n\t/**\n\t * Set type of x axis.<br><br>\n\t * **Available Values:**\n\t * - category\n\t * - indexed\n\t * - log\n\t * - timeseries\n\t *\n\t * **NOTE:**<br>\n\t * - **log** type:\n\t *   - the x values specified by [`data.x`](#.data%25E2%2580%25A4x)(or by any equivalent option), must be exclusively-positive.\n\t *   - x axis min value should be >= 0.\n\t *   - for 'category' type, `data.xs` option isn't supported.\n\t * @name axis․x․type\n\t * @memberof Options\n\t * @type {string}\n\t * @default indexed\n\t * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)\n\t * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)\n\t * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)\n\t * @see [Demo: log](https://naver.github.io/billboard.js/demo/#Axis.LogScales)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     type: \"timeseries\"\n\t *   }\n\t * }\n\t */\n\taxis_x_type: <\"category\" | \"indexed\" | \"log\" | \"timeseries\">\"indexed\",\n\n\t/**\n\t * Set how to treat the timezone of x values.<br>\n\t * If true, treat x value as localtime. If false, convert to UTC internally.\n\t * @name axis․x․localtime\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     localtime: false\n\t *   }\n\t * }\n\t */\n\taxis_x_localtime: true,\n\n\t/**\n\t * Set category names on category axis.\n\t * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.\n\t * @name axis․x․categories\n\t * @memberof Options\n\t * @type {Array}\n\t * @default []\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     categories: [\"Category 1\", \"Category 2\", ...]\n\t *   }\n\t * }\n\t */\n\taxis_x_categories: <string[]>[],\n\n\t/**\n\t * centerize ticks on category axis.\n\t * @name axis․x․tick․centered\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       centered: true\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_centered: false,\n\n\t/**\n\t * A function to format tick value. Format string is also available for timeseries data.\n\t * @name axis․x․tick․format\n\t * @memberof Options\n\t * @type {Function|string}\n\t * @default undefined\n\t * @see [D3's time specifier](https://d3js.org/d3-time-format#locale_format)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *        // for timeseries, a 'datetime' object is given as parameter\n\t *       format: function(x) {\n\t *           return x.getFullYear();\n\t *       }\n\t *\n\t *       // for category, index(Number) and categoryName(String) are given as parameter\n\t *       format: function(index, categoryName) {\n\t *           return categoryName.substr(0, 10);\n\t *       },\n\t *\n\t *        // for timeseries format specifier\n\t *        format: \"%Y-%m-%d %H:%M:%S\"\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_format: <Function | string | undefined>undefined,\n\n\t/**\n\t * Setting for culling ticks.\n\t * - `true`: the ticks will be culled, then only limited tick text will be shown.<br>\n\t *   This option does not hide the tick lines by default, if want to hide tick lines, set `axis.x.tick.culling.lines=false`.\n\t * - `false`: all of ticks will be shown.<br><br>\n\t * The number of ticks to be shown can be chaned by `axis.x.tick.culling.max`.\n\t * @name axis․x․tick․culling\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default\n\t * `true` for indexed axis and timeseries axis, `false` for category axis\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       culling: false,\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_culling: {},\n\n\t/**\n\t * The number of tick texts will be adjusted to less than this value.\n\t * @name axis․x․tick․culling․max\n\t * @memberof Options\n\t * @type {number}\n\t * @default 10\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       culling: {\n\t *           max: 5\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_culling_max: 10,\n\n\t/**\n\t * Control visibility of tick lines within culling option, along with tick text.\n\t * @name axis․x․tick․culling․lines\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       culling: {\n\t *           lines: false,\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_culling_lines: true,\n\n\t/**\n\t * Control culling start point to be reversed. If set to true, the culling will be started from the end to start.\n\t * - **NOTE:** This option is only available when `axis.x.tick.culling` is set to truthy value.\n\t * @name axis․x․tick․culling․reverse\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickCulling)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       culling: {\n\t *           reverse: true,\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_culling_reverse: false,\n\n\t/**\n\t * The number of x axis ticks to show.<br><br>\n\t * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).\n\t * @name axis․x․tick․count\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       count: 5\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_count: <number | undefined>undefined,\n\n\t/**\n\t * Show or hide x axis tick line.\n\t * @name axis․x․tick․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       show: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_show: true,\n\n\t/**\n\t * Show or hide x axis tick text.\n\t * @name axis․x․tick․text․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       text: {\n\t *           show: false\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_text_show: true,\n\n\t/**\n\t * Set the first/last axis tick text to be positioned inside of the chart on non-rotated axis.\n\t * @name axis․x․tick․text․inner\n\t * @memberof Options\n\t * @type {boolean|object}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickInner)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       text: {\n\t *          inner: true,\n\t *\n\t *          // or specify each position of the first and last tick text\n\t *          inner: {\n\t *       \t   first: true,\n\t *       \t   last: true\n\t *       \t}\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_text_inner: <{first?: boolean, last?: boolean} | boolean>false,\n\n\t/**\n\t * Set the x Axis tick text's position relatively its original position\n\t * @name axis․x․tick․text․position\n\t * @memberof Options\n\t * @type {object}\n\t * @default {x: 0, y:0}\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       text: {\n\t *         position: {\n\t *           x: 10,\n\t *           y: 10\n\t *         }\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_text_position: {x: 0, y: 0},\n\n\t/**\n\t * Fit x axis ticks.\n\t * - **true**: ticks will be shown according to x value of the data points.\n\t * - **false**: ticks will be shown as to have same intervals.\n\t * @name axis․x․tick․fit\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)\n\t * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       fit: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_fit: true,\n\n\t/**\n\t * Set the x values of ticks manually.<br><br>\n\t * If this option is provided, the position of the ticks will be determined based on those values.<br>\n\t * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.\n\t * @name axis․x․tick․values\n\t * @memberof Options\n\t * @type {Array|Function}\n\t * @default null\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       values: [1, 2, 4, 8, 16, 32, ...],\n\t *\n\t *       // an Array value should be returned\n\t *       values: function() {\n\t *       \treturn [ ... ];\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_values: <(string | Date | number)[] | (() => number[]) | null>null,\n\n\t/**\n\t * Rotate x axis tick text if there is not enough space for 'category' and 'timeseries' type axis.\n\t * - **NOTE:** The conditions where `autorotate` is enabled are:\n\t *   - axis.x.type='category' or 'timeseries\n\t *   - axis.x.tick.multiline=false\n\t *   - axis.x.tick.culling=false\n\t *   - axis.x.tick.fit=true\n\t * - **NOTE:** axis.x.tick.clippath=false is necessary for calculating the overflow padding between the end of x axis and the width of the SVG\n\t * @name axis․x․tick․autorotate\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickAutorotate)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       rotate: 15,\n\t *       autorotate: true,\n\t *       multiline: false,\n\t *       culling: false,\n\t *       fit: true\n\t *     },\n\t *     clipPath: false\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_autorotate: false,\n\n\t/**\n\t * Rotate x axis tick text.\n\t * - If you set negative value, it will rotate to opposite direction.\n\t * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.\n\t * - As long as `axis_x_tick_fit` is set to `true` it will calculate an overflow for the y2 axis and add this value to the right padding.\n\t * @name axis․x․tick․rotate\n\t * @memberof Options\n\t * @type {number}\n\t * @default 0\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       rotate: 60\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_rotate: 0,\n\n\t/**\n\t * Show x axis outer tick.\n\t * @name axis․x․tick․outer\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       outer: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_outer: true,\n\n\t/**\n\t * Set tick text to be multiline\n\t * - **NOTE:**\n\t *  > When x tick text contains `\\n`, it's used as line break and 'axis.x.tick.width' option is ignored.\n\t * @name axis․x․tick․multiline\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       multiline: false\n\t *     }\n\t *   }\n\t * }\n\t * @example\n\t * // example of line break with '\\n'\n\t * // In this case, 'axis.x.tick.width' is ignored\n\t * data: {\n\t *    x: \"x\",\n\t *    columns: [\n\t *        [\"x\", \"long\\ntext\", \"Another\\nLong\\nText\"],\n\t *        ...\n\t *    ],\n\t * }\n\t */\n\taxis_x_tick_multiline: true,\n\n\t/**\n\t * Set tick width\n\t * - **NOTE:**\n\t *  > When x tick text contains `\\n`, this option is ignored.\n\t * @name axis․x․tick․width\n\t * @memberof Options\n\t * @type {number}\n\t * @default null\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       width: 50\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_width: <number | null>null,\n\n\t/**\n\t * Set to display system tooltip(via `<title>` element) for tick text\n\t * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)\n\t * @name axis․x․tick․tooltip\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     tick: {\n\t *       tooltip: true\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_tick_tooltip: false,\n\n\t/**\n\t * Set max value of x axis range.\n\t * @name axis․x․max\n\t * @memberof Options\n\t * @property {number} max Set the max value\n\t * @property {boolean} [max.fit=false] When specified `max.value` is greater than the bound data value, setting `true` will make x axis max to be fitted to the bound data max value.\n\t * - **NOTE:** If the bound data max value is greater than the `max.value`, the x axis max will be limited as the given `max.value`.\n\t * @property {number} [max.value] Set the max value\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     max: 100,\n\t *\n\t *     max: {\n\t *       // 'fit=true' will make x axis max to be limited as the bound data value max when 'max.value' is greater.\n\t *       // - when bound data max is '10' and max.value: '100' ==>  x axis max will be '10'\n\t *       // - when bound data max is '1000' and max.value: '100' ==> x axis max will be '100'\n\t *       fit: true,\n\t *       value: 100\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_max: <number | undefined>undefined,\n\n\t/**\n\t * Set min value of x axis range.\n\t * @name axis․x․min\n\t * @memberof Options\n\t * @property {number} min Set the min value\n\t * @property {boolean} [min.fit=false] When specified `min.value` is lower than the bound data value, setting `true` will make x axis min to be fitted to the bound data min value.\n\t * - **NOTE:** If the bound data min value is lower than the `min.value`, the x axis min will be limited as the given `min.value`.\n\t * @property {number} [min.value] Set the min value\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     min: -100,\n\t *\n\t *     min: {\n\t *       // 'fit=true' will make x axis min to be limited as the bound data value min when 'min.value' is lower.\n\t *       // - when bound data min is '-10' and min.value: '-100' ==>  x axis min will be '-10'\n\t *       // - when bound data min is '-1000' and min.value: '-100' ==> x axis min will be '-100'\n\t *       fit: true,\n\t *       value: -100\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_min: <number | undefined>undefined,\n\n\t/**\n\t * Change the direction of x axis.<br><br>\n\t * If true set, the direction will be `right -> left`.\n\t * @name axis․x․inverted\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.InvertedAxis)\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     inverted: true\n\t *   }\n\t * }\n\t */\n\taxis_x_inverted: false,\n\n\t/**\n\t * Set padding for x axis.<br><br>\n\t * If this option is set, the range of x axis will increase/decrease according to the values.\n\t * If no padding is needed in the rage of x axis, 0 should be set.\n\t * By default, left/right padding are set depending on x axis type or chart types.\n\t * - **NOTE:**\n\t *   - The meaning of padding values, differs according axis types:<br>\n\t *     - **category/indexed:** The unit of tick value\n\t *       ex. the given value `1`, is same as the width of 1 tick width\n\t *     - **timeseries:** Numeric time value\n\t *       ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width\n\t *   - If want values to be treated as pixels, specify `unit:\"px\"`.\n\t *     - The pixel value will be convered based on the scale values. Hence can not reflect accurate padding result.\n\t * @name axis․x․padding\n\t * @memberof Options\n\t * @type {object|number}\n\t * @default {}\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     padding: {\n\t *       // when axis type is 'category'\n\t *       left: 1,  // set left padding width of equivalent value of a tick's width\n\t *       right: 0.5  // set right padding width as half of equivalent value of tick's width\n\t *\n\t *       // when axis type is 'timeseries'\n\t *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width\n\t *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width\n\t *     },\n\t *\n\t *     // or set both values at once.\n\t *     padding: 10,\n\t *\n\t *     // or set padding values as pixel unit.\n\t *     padding: {\n\t *       left: 100,\n\t *       right: 50,\n\t *       unit: \"px\"\n\t *     },\n\t *   }\n\t * }\n\t */\n\taxis_x_padding: <number | {left?: number, right?: number}>{},\n\n\t/**\n\t * Set height of x axis.<br><br>\n\t * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.\n\t * @name axis․x․height\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     height: 20\n\t *   }\n\t * }\n\t */\n\taxis_x_height: <number | undefined>undefined,\n\n\t/**\n\t * Set extent for subchart and zoom(drag only). This can be an array or function that returns an array.\n\t * - **NOTE:** Specifying value, will limit the zoom scope selection within.\n\t * @name axis․x․extent\n\t * @memberof Options\n\t * @type {Array|Function}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     // extent range as a pixel value\n\t *     extent: [0, 200],\n\t *\n\t *     // when axis is 'timeseries', parsable datetime string\n\t *     extent: [\"2019-03-01\", \"2019-03-05\"],\n\t *\n\t *     // return extent value\n\t *     extent: function(domain, scale) {\n\t *    \t var extent = domain.map(function(v) {\n\t *     \t    return scale(v);\n\t *     \t });\n\t *\n\t *   \t // it should return a format of array\n\t *   \t // ex) [0, 584]\n\t *     \t return extent;\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_extent: <(number | string)[] | Function | undefined>undefined,\n\n\t/**\n\t * Set label on x axis.<br><br>\n\t * You can set x axis label and change its position by this option.\n\t * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>\n\t * Available position differs according to the axis direction (vertical or horizontal).\n\t * If string set, the position will be the default.\n\t *\n\t *  - **If it's horizontal axis:**\n\t *    - inner-right [default]\n\t *    - inner-center\n\t *    - inner-left\n\t *    - outer-right\n\t *    - outer-center\n\t *    - outer-left\n\t *  - **If it's vertical axis:**\n\t *    - inner-top [default]\n\t *    - inner-middle\n\t *    - inner-bottom\n\t *    - outer-top\n\t *    - outer-middle\n\t *    - outer-bottom\n\t * @name axis․x․label\n\t * @memberof Options\n\t * @type {string|object}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   x: {\n\t *     label: \"Your X Axis\"\n\t *   }\n\t * }\n\t *\n\t * axis: {\n\t *   x: {\n\t *     label: {\n\t *        text: \"Your X Axis\",\n\t *        position: \"outer-center\"\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_x_label: {},\n\n\t/**\n\t * Set additional axes for x Axis.\n\t * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.\n\t *\n\t * Each axis object should consist with following options:\n\t *\n\t * | Name | Type | Default | Description |\n\t * | --- | --- | --- | --- |\n\t * | domain | Array | - | Set the domain value |\n\t * | tick.outer | boolean | true | Show outer tick |\n\t * | tick.format | Function | - | Set formatter for tick text |\n\t * | tick.count | Number | - | Set the number of y axis ticks |\n\t * | tick.values | Array | - | Set tick values manually |\n\t * @name axis․x․axes\n\t * @memberof Options\n\t * @type {Array}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)\n\t * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)\n\t * @example\n\t * x: {\n\t *    axes: [\n\t *      {\n\t *        // if set, will not be correlated with the main x Axis domain value\n\t *        domain: [0, 1000],\n\t *        tick: {\n\t *          outer: false,\n\t *          format: function(x) {\n\t *             return x + \"%\";\n\t *          },\n\t *          count: 2,\n\t *          values: [10, 20, 30]\n\t *        }\n\t *      },\n\t *      ...\n\t *    ]\n\t * }\n\t */\n\taxis_x_axes: <object[]>[]\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * y Axis  config options\n */\nexport default {\n\t/**\n\t * Set clip-path attribute for y axis element\n\t * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.\n\t * @name axis․y․clipPath\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * // don't set 'clip-path' attribute\n\t * clipPath: false\n\t */\n\taxis_y_clipPath: true,\n\n\t/**\n\t * Show or hide y axis.\n\t * @name axis․y․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     show: false\n\t *   }\n\t * }\n\t */\n\taxis_y_show: true,\n\n\t/**\n\t * Set type of y axis.<br><br>\n\t * **Available Values:**\n\t *  - indexed\n\t *  - log\n\t *  - timeseries\n\t *\n\t * **NOTE:**<br>\n\t * - **log** type:\n\t *   - the bound data values must be exclusively-positive.\n\t *   - y axis min value should be >= 0.\n\t *   - [`data.groups`](#.data%25E2%2580%25A4groups)(stacked data) option aren't supported.\n\t *\n\t * @name axis․y․type\n\t * @memberof Options\n\t * @type {string}\n\t * @default \"indexed\"\n\t * @see [Demo: log](https://naver.github.io/billboard.js/demo/#Axis.LogScales)\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     type: \"log\"\n\t *   }\n\t * }\n\t */\n\taxis_y_type: <\"indexed\" | \"log\" | \"timeseries\">\"indexed\",\n\n\t/**\n\t * Set max value of y axis.\n\t * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).\n\t * @name axis․y․max\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     max: 1000\n\t *   }\n\t * }\n\t */\n\taxis_y_max: <number | undefined>undefined,\n\n\t/**\n\t * Set min value of y axis.\n\t * - **NOTE:**\n\t *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).\n\t * @name axis․y․min\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     min: 1000\n\t *   }\n\t * }\n\t */\n\taxis_y_min: <number | undefined>undefined,\n\n\t/**\n\t * Change the direction of y axis.<br><br>\n\t * If true set, the direction will be `top -> bottom`.\n\t * @name axis․y․inverted\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.InvertedAxis)\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     inverted: true\n\t *   }\n\t * }\n\t */\n\taxis_y_inverted: false,\n\n\t/**\n\t * Set center value of y axis.\n\t * @name axis․y․center\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     center: 0\n\t *   }\n\t * }\n\t */\n\taxis_y_center: <number | undefined>undefined,\n\n\t/**\n\t * Show y axis inside of the chart.\n\t * @name axis․y․inner\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     inner: true\n\t *   }\n\t * }\n\t */\n\taxis_y_inner: false,\n\n\t/**\n\t * Set label on y axis.<br><br>\n\t * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).\n\t * @name axis․y․label\n\t * @memberof Options\n\t * @type {string|object}\n\t * @default {}\n\t * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     label: \"Your Y Axis\"\n\t *   }\n\t * }\n\t *\n\t * axis: {\n\t *   y: {\n\t *     label: {\n\t *        text: \"Your Y Axis\",\n\t *        position: \"outer-middle\"\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_label: <string | object>{},\n\n\t/**\n\t * Set formatter for y axis tick text.<br><br>\n\t * This option accepts d3.format object as well as a function you define.\n\t * @name axis․y․tick․format\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       format: function(x) {\n\t *           return x.getFullYear();\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_format: <Function | undefined>undefined,\n\n\t/**\n\t * Setting for culling ticks.\n\t * - `true`: the ticks will be culled, then only limited tick text will be shown.<br>\n\t *   This option does not hide the tick lines by default, if want to hide tick lines, set `axis.y.tick.culling.lines=false`.\n\t * - `false`: all of ticks will be shown.<br><br>\n\t * The number of ticks to be shown can be chaned by `axis.y.tick.culling.max`.\n\t * @name axis․y․tick․culling\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       culling: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_culling: false,\n\n\t/**\n\t * The number of tick texts will be adjusted to less than this value.\n\t * @name axis․y․tick․culling․max\n\t * @memberof Options\n\t * @type {number}\n\t * @default 5\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       culling: {\n\t *           max: 5\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_culling_max: 5,\n\n\t/**\n\t * Control visibility of tick lines within culling option, along with tick text.\n\t * @name axis․y․tick․culling․lines\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       culling: {\n\t *           lines: false,\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_culling_lines: true,\n\n\t/**\n\t * Control culling start point to be reversed. If set to true, the culling will be started from the end to start.\n\t * - **NOTE:** This option is only available when `axis.y.tick.culling` is set to truthy value.\n\t * @name axis․y․tick․culling․reverse\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       culling: {\n\t *           reverse: true,\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_culling_reverse: false,\n\n\t/**\n\t * Show y axis outer tick.\n\t * @name axis․y․tick․outer\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       outer: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_outer: true,\n\n\t/**\n\t * Set y axis tick values manually.\n\t * @name axis․y․tick․values\n\t * @memberof Options\n\t * @type {Array|Function}\n\t * @default null\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       values: [100, 1000, 10000],\n\t *\n\t *       // an Array value should be returned\n\t *       values: function() {\n\t *       \treturn [ ... ];\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_values: <number[] | (() => number[]) | null>null,\n\n\t/**\n\t * Rotate y axis tick text.\n\t * - If you set negative value, it will rotate to opposite direction.\n\t * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.\n\t * @name axis․y․tick․rotate\n\t * @memberof Options\n\t * @type {number}\n\t * @default 0\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       rotate: 60\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_rotate: 0,\n\n\t/**\n\t * Set the number of y axis ticks.<br><br>\n\t * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.\n\t * @name axis․y․tick․count\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       count: 5\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_count: <number | undefined>undefined,\n\n\t/**\n\t * Show or hide y axis tick line.\n\t * @name axis․y․tick․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       show: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_show: true,\n\n\t/**\n\t * Set axis tick step(interval) size.\n\t * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.\n\t * @name axis․y․tick․stepSize\n\t * @memberof Options\n\t * @type {number}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       // tick value will step as indicated interval value.\n\t *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]\n\t *       stepSize: 15\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_stepSize: <number | null>null,\n\n\t/**\n\t * Show or hide y axis tick text.\n\t * @name axis․y․tick․text․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       text: {\n\t *           show: false\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_text_show: true,\n\n\t/**\n\t * Set the y Axis tick text's position relatively its original position\n\t * @name axis․y․tick․text․position\n\t * @memberof Options\n\t * @type {object}\n\t * @default {x: 0, y:0}\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       text: {\n\t *         position: {\n\t *           x: 10,\n\t *           y: 10\n\t *         }\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y_tick_text_position: {x: 0, y: 0},\n\n\t/**\n\t * Set the number of y axis ticks.<br><br>\n\t * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.\n\t * @name axis․y․tick․time\n\t * @memberof Options\n\t * @private\n\t * @type {object}\n\t * @property {object} time time object\n\t * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     tick: {\n\t *       time: {\n\t *          // ticks at 15-minute intervals\n\t *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks\n\t *          value: d3.timeMinute.every(15)\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\t// @TODO: not fully implemented yet\n\taxis_y_tick_time_value: <Function | undefined>undefined,\n\n\t/**\n\t * Set padding for y axis.<br><br>\n\t * You can set padding for y axis to create more space on the edge of the axis.\n\t * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.\n\t *\n\t * - **NOTE:**\n\t *   - Given values are translated relative to the y Axis domain value for padding\n\t *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.\n\t * @name axis․y․padding\n\t * @memberof Options\n\t * @type {object|number}\n\t * @default {}\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     padding: {\n\t *       top: 0,\n\t *       bottom: 0\n\t *     },\n\t *\n\t *     // or set both values at once.\n\t *     padding: 10\n\t *   }\n\t * }\n\t */\n\taxis_y_padding: <number | {top?: number, bottom?: number}>{},\n\n\t/**\n\t * Set default range of y axis.<br><br>\n\t * This option set the default value for y axis when there is no data on init.\n\t * @name axis․y․default\n\t * @memberof Options\n\t * @type {Array}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y: {\n\t *     default: [0, 1000]\n\t *   }\n\t * }\n\t */\n\taxis_y_default: <number[] | undefined>undefined,\n\n\t/**\n\t * Set additional axes for y Axis.\n\t * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.\n\t *\n\t * Each axis object should consist with following options:\n\t *\n\t * | Name | Type | Default | Description |\n\t * | --- | --- | --- | --- |\n\t * | domain | Array | - | Set the domain value |\n\t * | tick.outer | boolean | true | Show outer tick |\n\t * | tick.format | Function | - | Set formatter for tick text |\n\t * | tick.count | Number | - | Set the number of y axis ticks |\n\t * | tick.values | Array | - | Set tick values manually |\n\t * @name axis․y․axes\n\t * @memberof Options\n\t * @type {Array}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)\n\t * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)\n\t * @example\n\t * y: {\n\t *    axes: [\n\t *      {\n\t *        // if set, will not be correlated with the main y Axis domain value\n\t *        domain: [0, 1000],\n\t *        tick: {\n\t *          outer: false,\n\t *          format: function(x) {\n\t *             return x + \"%\";\n\t *          },\n\t *          count: 2,\n\t *          values: [10, 20, 30]\n\t *        }\n\t *      },\n\t *      ...\n\t *    ]\n\t * }\n\t */\n\taxis_y_axes: <object[]>[]\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * y2 Axis  config options\n */\nexport default {\n\t/**\n\t * Show or hide y2 axis.\n\t * - **NOTE**:\n\t *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.\n\t *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.\n\t * @name axis․y2․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     show: true\n\t *   }\n\t * }\n\t */\n\taxis_y2_show: false,\n\n\t/**\n\t * Set type of y2 axis.<br><br>\n\t * **Available Values:**\n\t *  - indexed\n\t *  - log\n\t *  - timeseries\n\t *\n\t * **NOTE:**<br>\n\t * - **log** type:\n\t *   - the bound data values must be exclusively-positive.\n\t *   - y2 axis min value should be >= 0.\n\t *   - [`data.groups`](#.data%25E2%2580%25A4groups)(stacked data) option aren't supported.\n\t *\n\t * @name axis․y2․type\n\t * @memberof Options\n\t * @type {string}\n\t * @default \"indexed\"\n\t * @see [Demo: log](https://naver.github.io/billboard.js/demo/#Axis.LogScales)\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     type: \"indexed\"\n\t *   }\n\t * }\n\t */\n\taxis_y2_type: <\"indexed\" | \"log\" | \"timeseries\">\"indexed\",\n\n\t/**\n\t * Set max value of y2 axis.\n\t * @name axis․y2․max\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     max: 1000\n\t *   }\n\t * }\n\t */\n\taxis_y2_max: <number | undefined>undefined,\n\n\t/**\n\t * Set min value of y2 axis.\n\t * @name axis․y2․min\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     min: -1000\n\t *   }\n\t * }\n\t */\n\taxis_y2_min: <number | undefined>undefined,\n\n\t/**\n\t * Change the direction of y2 axis.<br><br>\n\t * If true set, the direction will be `top -> bottom`.\n\t * @name axis․y2․inverted\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.InvertedAxis)\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     inverted: true\n\t *   }\n\t * }\n\t */\n\taxis_y2_inverted: false,\n\n\t/**\n\t * Set center value of y2 axis.\n\t * @name axis․y2․center\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     center: 0\n\t *   }\n\t * }\n\t */\n\taxis_y2_center: <number | undefined>undefined,\n\n\t/**\n\t * Show y2 axis inside of the chart.\n\t * @name axis․y2․inner\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     inner: true\n\t *   }\n\t * }\n\t */\n\taxis_y2_inner: false,\n\n\t/**\n\t * Set label on y2 axis.<br><br>\n\t * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).\n\t * @name axis․y2․label\n\t * @memberof Options\n\t * @type {string|object}\n\t * @default {}\n\t * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     label: \"Your Y2 Axis\"\n\t *   }\n\t * }\n\t *\n\t * axis: {\n\t *   y2: {\n\t *     label: {\n\t *        text: \"Your Y2 Axis\",\n\t *        position: \"outer-middle\"\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_label: <string | object>{},\n\n\t/**\n\t * Set formatter for y2 axis tick text.<br><br>\n\t * This option works in the same way as axis.y.format.\n\t * @name axis․y2․tick․format\n\t * @memberof Options\n\t * @type {Function}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       format: d3.format(\"$,\")\n\t *       //or format: function(d) { return \"$\" + d; }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_format: <Function | undefined>undefined,\n\n\t/**\n\t * Setting for culling ticks.\n\t * - `true`: the ticks will be culled, then only limited tick text will be shown.<br>\n\t *   This option does not hide the tick lines by default, if want to hide tick lines, set `axis.y2.tick.culling.lines=false`.\n\t * - `false`: all of ticks will be shown.<br><br>\n\t * The number of ticks to be shown can be chaned by `axis.y2.tick.culling.max`.\n\t * @name axis․y2․tick․culling\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       culling: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_culling: false,\n\n\t/**\n\t * The number of tick texts will be adjusted to less than this value.\n\t * @name axis․y2․tick․culling․max\n\t * @memberof Options\n\t * @type {number}\n\t * @default 5\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       culling: {\n\t *           max: 5\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_culling_max: 5,\n\n\t/**\n\t * Control visibility of tick lines within culling option, along with tick text.\n\t * @name axis․y2․tick․culling․lines\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       culling: {\n\t *           lines: false,\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_culling_lines: true,\n\n\t/**\n\t * Control culling start point to be reversed. If set to true, the culling will be started from the end to start.\n\t * - **NOTE:** This option is only available when `axis.y2.tick.culling` is set to truthy value.\n\t * @name axis․y2․tick․culling․reverse\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       culling: {\n\t *           reverse: true,\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_culling_reverse: false,\n\n\t/**\n\t * Show or hide y2 axis outer tick.\n\t * @name axis․y2․tick․outer\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       outer: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_outer: true,\n\n\t/**\n\t * Set y2 axis tick values manually.\n\t * @name axis․y2․tick․values\n\t * @memberof Options\n\t * @type {Array|Function}\n\t * @default null\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       values: [100, 1000, 10000],\n\t *\n\t *       // an Array value should be returned\n\t *       values: function() {\n\t *       \treturn [ ... ];\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_values: <number[] | (() => number[]) | null>null,\n\n\t/**\n\t * Rotate y2 axis tick text.\n\t * - If you set negative value, it will rotate to opposite direction.\n\t * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.\n\t * @name axis․y2․tick․rotate\n\t * @memberof Options\n\t * @type {number}\n\t * @default 0\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       rotate: 60\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_rotate: 0,\n\n\t/**\n\t * Set the number of y2 axis ticks.\n\t * - **NOTE:** This works in the same way as axis.y.tick.count.\n\t * @name axis․y2․tick․count\n\t * @memberof Options\n\t * @type {number}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       count: 5\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_count: <number | undefined>undefined,\n\n\t/**\n\t * Show or hide y2 axis tick line.\n\t * @name axis․y2․tick․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       show: false\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_show: true,\n\n\t/**\n\t * Set axis tick step(interval) size.\n\t * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.\n\t * @name axis․y2․tick․stepSize\n\t * @memberof Options\n\t * @type {number}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       // tick value will step as indicated interval value.\n\t *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]\n\t *       stepSize: 15\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_stepSize: <number | null>null,\n\n\t/**\n\t * Show or hide y2 axis tick text.\n\t * @name axis․y2․tick․text․show\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       text: {\n\t *           show: false\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_text_show: true,\n\n\t/**\n\t * Set the y2 Axis tick text's position relatively its original position\n\t * @name axis․y2․tick․text․position\n\t * @memberof Options\n\t * @type {object}\n\t * @default {x: 0, y:0}\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     tick: {\n\t *       text: {\n\t *         position: {\n\t *           x: 10,\n\t *           y: 10\n\t *         }\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t */\n\taxis_y2_tick_text_position: {x: 0, y: 0},\n\n\t/**\n\t * Set padding for y2 axis.<br><br>\n\t * You can set padding for y2 axis to create more space on the edge of the axis.\n\t * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.\n\t *\n\t * - **NOTE:**\n\t *   - Given values are translated relative to the y2 Axis domain value for padding\n\t *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.\n\t * @name axis․y2․padding\n\t * @memberof Options\n\t * @type {object|number}\n\t * @default {}\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     padding: {\n\t *       top: 100,\n\t *       bottom: 100\n\t *     }\n\t *\n\t *     // or set both values at once.\n\t *     padding: 10\n\t * }\n\t */\n\taxis_y2_padding: <number | {top?: number, bottom?: number}>{},\n\n\t/**\n\t * Set default range of y2 axis.<br><br>\n\t * This option set the default value for y2 axis when there is no data on init.\n\t * @name axis․y2․default\n\t * @memberof Options\n\t * @type {Array}\n\t * @default undefined\n\t * @example\n\t * axis: {\n\t *   y2: {\n\t *     default: [0, 1000]\n\t *   }\n\t * }\n\t */\n\taxis_y2_default: undefined,\n\n\t/**\n\t * Set additional axes for y2 Axis.\n\t * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.\n\t *\n\t * Each axis object should consist with following options:\n\t *\n\t * | Name | Type | Default | Description |\n\t * | --- | --- | --- | --- |\n\t * | domain | Array | - | Set the domain value |\n\t * | tick.outer | boolean | true | Show outer tick |\n\t * | tick.format | Function | - | Set formatter for tick text |\n\t * | tick.count | Number | - | Set the number of y axis ticks |\n\t * | tick.values | Array | - | Set tick values manually |\n\t * @name axis․y2․axes\n\t * @memberof Options\n\t * @type {Array}\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)\n\t * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)\n\t * @example\n\t * y2: {\n\t *    axes: [\n\t *      {\n\t *        // if set, will not be correlated with the main y2 Axis domain value\n\t *        domain: [0, 1000],\n\t *        tick: {\n\t *          outer: false,\n\t *          format: function(x) {\n\t *             return x + \"%\";\n\t *          },\n\t *          count: 2,\n\t *          values: [10, 20, 30]\n\t *        }\n\t *      },\n\t *      ...\n\t *    ]\n\t * }\n\t */\n\taxis_y2_axes: []\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport x from \"./x\";\nimport y from \"./y\";\nimport y2 from \"./y2\";\n\n/**\n * y Axis  config options\n */\nexport default {\n\t/**\n\t * Setup the way to evaluate tick text size.\n\t * - **NOTE:**\n\t *   - Setting `false` or custom evaluator, highly recommended to memoize evaluated text dimension value to not degrade performance.\n\t * @name axis․evalTextSize\n\t * @memberof Options\n\t * @type {boolean|Function}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.AxisEvalTextSize)\n\t * @example\n\t * axis: {\n\t *   // will evaluate getting text size every time.\n\t *   evalTextSize: false.\n\t *\n\t *   // set a custom evaluator\n\t *   evalTextSize: function(textElement, axisId) {\n\t *     // set some character to be evaluated\n\t *     // NOTE: The dummy textElement is a descendant of given axisId('x', 'y' or 'y2').\n\t *     textElement.textContent = \"0\";\n\t *\n\t *     // get the size\n\t *     const box = textElement.getBBox();\n\t *\n\t *     // clear text\n\t *     textElement.textContent = \"\";\n\t *\n\t *     return { w: 7, h: 12};\n\t *   },\n\t *\n\t *   // set a custom evaluator by returning fixed value\n\t *   evalTextSize: function(textElement, axisId) {\n\t *     return {\n\t *        x: {w: 7, h: 12},\n\t *        y: {w: 15.75, h: 30},\n\t *        y2: {w: 9.5, h: 18}\n\t *     }[axisId];\n\t *   }\n\t * }\n\t */\n\taxis_evalTextSize: <\n\t\t| boolean\n\t\t| ((text: SVGTextElement, axisId: \"x\" | \"y\" | \"y2\") => {w: number, h: number})\n\t>true,\n\n\t/**\n\t * Switch x and y axis position.\n\t * @name axis․rotated\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @example\n\t * axis: {\n\t *   rotated: true\n\t * }\n\t */\n\taxis_rotated: false,\n\n\t/**\n\t * Set axis tooltip.\n\t * - **NOTE:**\n\t *   - When enabled, will disable default focus grid line.\n\t *   - For `timeseries` x Axis, tootlip will be formatted using x Axis' tick format.\n\t *   - For `category` x Axis, tootlip will be displaying scales' value text.\n\t * @name axis․tooltip\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @property {object} axis Axis object\n\t * @property {boolean} [axis.tooltip=false] Show tooltip or not.\n\t * @property {string|object} [axis.tooltip.backgroundColor] Set axis tooltip text background colors.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.AxisTooltip)\n\t * @example\n\t * axis: {\n\t *     tooltip: true, // default background color is\n\t *\n\t *     // set backgound color for axis tooltip texts\n\t *     tooltip: {\n\t *          backgroundColor: \"red\",\n\t *\n\t *          // set differenct backround colors per axes\n\t *          // NOTE: In this case, only specified axes tooltip will appear.\n\t *          backgroundColor: {\n\t *               x: \"green\",\n\t *               y: \"yellow\",\n\t *               y2: \"red\"\n\t *          }\n\t *     }\n\t * }\n\t */\n\taxis_tooltip: <boolean | {\n\t\tbackgroundColor?: string | {x?: string, y?: string, y2?: string}\n\t}>false,\n\t...x,\n\t...y,\n\t...y2\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * grid config options\n */\ntype Lines = {value?: number, text?: string, class?: string, position?: string}[];\n\nexport default {\n\t/**\n\t * Set related options\n\t * @name grid\n\t * @memberof Options\n\t * @type {object}\n\t * @property {boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.\n\t * @property {object} x Grid x object\n\t * @property {boolean} [x.show=false] Show grids along x axis.\n\t * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>\n\t *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.\n\t *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.\n\t * @property {object} y Grid y object\n\t * @property {boolean} [y.show=false] Show grids along x axis.\n\t * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>\n\t *  This option accepts array including object that has value, text, position and class.\n\t * @property {number} [y.ticks=undefined] Number of y grids to be shown.\n\t * @property {object} focus Grid focus object\n\t * @property {boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.\n\t * @property {boolean} [focus.show=true] Show grid line when focus.\n\t * @property {boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.\n\t * @property {object} lines Grid lines object\n\t * @property {boolean} [lines.front=true] Set grid lines to be positioned over chart elements.\n\t * @default undefined\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)\n\t * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)\n\t * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)\n\t * @example\n\t * grid: {\n\t *   x: {\n\t *     show: true,\n\t *     lines: [\n\t *       {value: 2, text: \"Label on 2\"},\n\t *       {value: 5, text: \"Label on 5\", class: \"label-5\"},\n\t *       {value: 6, text: \"Label on 6\", position: \"start\"}\n\t *     ]\n\t *   },\n\t *   y: {\n\t *     show: true,\n\t *     lines: [\n\t *       {value: 100, text: \"Label on 100\"},\n\t *       {value: 200, text: \"Label on 200\", class: \"label-200\"},\n\t *       {value: 300, text: \"Label on 300\", position: 'middle'}\n\t *     ],\n\t *     ticks: 5\n\t *   },\n\t *   front: true,\n\t *   focus: {\n\t *      show: false,\n\t *\n\t *      // Below options are available when 'tooltip.grouped=false' option is set\n\t *      edge: true,\n\t *      y: true\n\t *   },\n\t *   lines: {\n\t *      front: false\n\t *   }\n\t * }\n\t */\n\tgrid_x_show: false,\n\tgrid_x_type: \"tick\",\n\tgrid_x_lines: <Lines>[],\n\tgrid_y_show: false,\n\tgrid_y_lines: <Lines>[],\n\tgrid_y_ticks: <number | undefined>undefined,\n\tgrid_focus_edge: false,\n\tgrid_focus_show: true,\n\tgrid_focus_y: false,\n\tgrid_front: false,\n\tgrid_lines_front: true\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport type {DataRegionsType} from \"../../../../types/types\";\n\n/**\n * Axis based chart data config options\n */\nexport default {\n\t/**\n\t * Specify the keys of the x values for each data.<br><br>\n\t * This option can be used if we want to show the data that has different x values.\n\t * @name data․xs\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @example\n\t * data: {\n\t *   xs: {\n\t *      data1: \"x1\",\n\t *      data2: \"x2\"\n\t *   }\n\t * }\n\t */\n\tdata_xs: {},\n\n\t/**\n\t * Set a format specifier to parse string specifed as x.\n\t * @name data․xFormat\n\t * @memberof Options\n\t * @type {string}\n\t * @default %Y-%m-%d\n\t * @example\n\t * data: {\n\t *    x: \"x\",\n\t *    columns: [\n\t *        [\"x\", \"01012019\", \"02012019\", \"03012019\"],\n\t *        [\"data1\", 30, 200, 100]\n\t *    ],\n\t *    // Format specifier to parse as datetime for given 'x' string value\n\t *    xFormat: \"%m%d%Y\"\n\t * },\n\t * axis: {\n\t *    x: {\n\t *        type: \"timeseries\"\n\t *    }\n\t * }\n\t * @see [D3's time specifier](https://d3js.org/d3-time-format#locale_format)\n\t */\n\tdata_xFormat: \"%Y-%m-%d\",\n\n\t/**\n\t * Set localtime format to parse x axis.\n\t * @name data․xLocaltime\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @example\n\t * data: {\n\t *   xLocaltime: false\n\t * }\n\t */\n\tdata_xLocaltime: true,\n\n\t/**\n\t * Sort on x axis.\n\t * - **NOTE:** This option works for lineish(area/line/spline/step) types only.\n\t * @name data․xSort\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default true\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataXSort)\n\t * @example\n\t * data: {\n\t *   xSort: false,\n\t *   x: \"x\",\n\t *   columns: [\n\t *     // The line graph will start to be drawn following the x axis sequence\n\t *     // Below data, wil start drawing x=1: 200, x=2: 300, x=3: 100\n\t *     [\"x\", 3, 1, 2],\n\t *     [\"data1\", 100, 200, 300]\n\t *   ]\n\t * }\n\t */\n\tdata_xSort: true,\n\n\t/**\n\t * Set y axis the data related to. y and y2 can be used.\n\t * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data\n\t * @name data․axes\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @example\n\t * data: {\n\t *   axes: {\n\t *     data1: \"y\",\n\t *     data2: \"y2\"\n\t *   }\n\t * }\n\t */\n\tdata_axes: <{[key: string]: string}>{},\n\n\t/**\n\t * Define regions for each data.<br>\n\t * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.\n\t * - The object type should be as:\n\t *   - start {number}: Start data point number. If not set, the start will be the first data point.\n\t *   - [end] {number}: End data point number. If not set, the end will be the last data point.\n\t *   - [style.dasharray=\"2 2\"] {string}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.\n\t * - **NOTE:**\n\t *   - Supports only line type.\n\t *   - `start` and `end` values should be in the exact x value range.\n\t *   - Dashes will be applied using `stroke-dasharray` css property when data doesn't contain nullish value(or nullish value with `line.connectNull=true` set).\n\t *   - Dashes will be applied via path command when data contains nullish value.\n\t * @name data․regions\n\t * @memberof Options\n\t * @type {object}\n\t * @default {}\n\t * @example\n\t * data: {\n\t *   regions: {\n\t *     data1: [{\n\t *         start: 1,\n\t *         end: 2,\n\t *         style: {\n\t *             dasharray: \"5 2\"\n\t *         }\n\t *     }, {\n\t *         start: 3\n\t *     }],\n\t *     ...\n\t *   }\n\t * }\n\t */\n\tdata_regions: <DataRegionsType>{},\n\n\t/**\n\t * Set the stacking to be normalized\n\t * - **NOTE:**\n\t *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set\n\t *   - y Axis will be set in percentage value (0 ~ 100%)\n\t *   - Must have postive values\n\t * @name data․stack․normalize\n\t * @memberof Options\n\t * @type {boolean}\n\t * @default false\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)\n\t * @example\n\t * data: {\n\t *   stack: {\n\t *      normalize: true\n\t *   }\n\t * }\n\t */\n\tdata_stack_normalize: false\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * Modules exports for Axis based chart\n */\n// Chart\nimport apiAxis from \"../../Chart/api/axis\";\nimport apiCategory from \"../../Chart/api/category\";\nimport apiFlow from \"../../Chart/api/flow\";\nimport apiGrid from \"../../Chart/api/grid\";\nimport apiGroup from \"../../Chart/api/group\";\nimport apiRegion from \"../../Chart/api/regions\";\nimport apiX from \"../../Chart/api/x\";\n\n// ChartInternal\nimport axis from \"../../ChartInternal/Axis/Axis\";\nimport eventrect from \"../../ChartInternal/interactions/eventrect\";\nimport flow from \"../../ChartInternal/interactions/flow\";\n\nimport clip from \"../../ChartInternal/internals/clip\";\nimport grid from \"../../ChartInternal/internals/grid\";\nimport region from \"../../ChartInternal/internals/region\";\nimport sizeAxis from \"../../ChartInternal/internals/size.axis\";\n\n// Axis based options\nimport optAxis from \"../Options/axis/axis\";\nimport optGrid from \"../Options/common/grid\";\nimport optDataAxis from \"../Options/data/axis\";\n\nexport const api = [\n\tapiAxis,\n\tapiCategory,\n\tapiFlow,\n\tapiGrid,\n\tapiGroup,\n\tapiRegion,\n\tapiX\n];\n\nexport const internal = {\n\taxis,\n\tclip,\n\teventrect,\n\tflow,\n\tgrid,\n\tregion,\n\tsizeAxis\n};\n\nexport const options = {\n\toptDataAxis,\n\toptAxis,\n\toptGrid\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {interpolate as d3Interpolate} from \"d3-interpolate\";\nimport {select as d3Select} from \"d3-selection\";\nimport {arc as d3Arc, pie as d3Pie} from \"d3-shape\";\nimport type {d3Selection} from \"../../../types/types\";\nimport {$ARC, $COMMON, $FOCUS, $GAUGE} from \"../../config/classes\";\nimport {document} from \"../../module/browser\";\nimport {\n\tcallFn,\n\tendall,\n\tisDefined,\n\tisFunction,\n\tisNumber,\n\tisObject,\n\tisUndefined,\n\tsetTextValue,\n\ttplProcess\n} from \"../../module/util\";\nimport type {IArcData, IArcDataRow, IData} from \"../data/IData\";\n\n/**\n * Get radius functions\n * @param {number} expandRate Expand rate number.\n *   - If 0, means for \"normal\" radius.\n *   - If > 0, means for \"expanded\" radius.\n * @returns {object} radius functions\n * @private\n */\nfunction getRadiusFn(expandRate = 0) {\n\tconst $$ = this;\n\tconst {config, state} = $$;\n\tconst hasMultiArcGauge = $$.hasMultiArcGauge();\n\tconst singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length;\n\tconst expandWidth = expandRate ?\n\t\t(\n\t\t\tMath.min(\n\t\t\t\tstate.radiusExpanded * expandRate - state.radius,\n\t\t\t\tsingleArcWidth * 0.8 - (1 - expandRate) * 100\n\t\t\t)\n\t\t) :\n\t\t0;\n\n\treturn {\n\t\t/**\n\t\t * Getter of arc innerRadius value\n\t\t * @param {IArcData} d Data object\n\t\t * @returns {number} innerRadius value\n\t\t * @private\n\t\t */\n\t\tinner(d: IArcData) {\n\t\t\tconst {innerRadius} = $$.getRadius(d);\n\n\t\t\treturn hasMultiArcGauge ?\n\t\t\t\tstate.radius - singleArcWidth * (d.index + 1) :\n\t\t\t\t(isNumber(innerRadius) ? innerRadius : 0);\n\t\t},\n\n\t\t/**\n\t\t * Getter of arc outerRadius value\n\t\t * @param {IArcData} d Data object\n\t\t * @returns {number} outerRadius value\n\t\t * @private\n\t\t */\n\t\touter(d: IArcData) {\n\t\t\tconst {outerRadius} = $$.getRadius(d);\n\t\t\tlet radius: number;\n\n\t\t\tif (hasMultiArcGauge) {\n\t\t\t\tradius = state.radius - singleArcWidth * d.index + expandWidth;\n\t\t\t} else if ($$.hasType(\"polar\") && !expandRate) {\n\t\t\t\tradius = $$.getPolarOuterRadius(d, outerRadius);\n\t\t\t} else {\n\t\t\t\tradius = outerRadius;\n\n\t\t\t\tif (expandRate) {\n\t\t\t\t\tlet {radiusExpanded} = state;\n\n\t\t\t\t\tif (state.radius !== outerRadius) {\n\t\t\t\t\t\tradiusExpanded -= Math.abs(state.radius - outerRadius);\n\t\t\t\t\t}\n\n\t\t\t\t\tradius = radiusExpanded * expandRate;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn radius;\n\t\t},\n\n\t\t/**\n\t\t * Getter of arc cornerRadius value\n\t\t * @param {IArcData} d Data object\n\t\t * @param {number} outerRadius outer radius value\n\t\t * @returns {number} cornerRadius value\n\t\t * @private\n\t\t */\n\t\tcorner(d: IArcData, outerRadius): number {\n\t\t\tconst {\n\t\t\t\tarc_cornerRadius_ratio: ratio = 0,\n\t\t\t\tarc_cornerRadius: cornerRadius = 0\n\t\t\t} = config;\n\t\t\tconst {data: {id}, value} = d;\n\t\t\tlet corner = 0;\n\n\t\t\tif (ratio) {\n\t\t\t\tcorner = ratio * outerRadius;\n\t\t\t} else {\n\t\t\t\tcorner = isNumber(cornerRadius) ?\n\t\t\t\t\tcornerRadius :\n\t\t\t\t\tcornerRadius.call($$.api, id, value, outerRadius);\n\t\t\t}\n\n\t\t\treturn corner;\n\t\t}\n\t};\n}\n\n/**\n * Get attrTween function to get interpolated value on transition\n * @param {Function} fn Arc function to execute\n * @returns {Function} attrTween function\n * @private\n */\nfunction getAttrTweenFn(fn: (d: IArcData) => string) {\n\treturn function(d: IArcData): (t: number) => string {\n\t\tconst getAngleKeyValue = ({startAngle = 0, endAngle = 0, padAngle = 0}) => ({\n\t\t\tstartAngle,\n\t\t\tendAngle,\n\t\t\tpadAngle\n\t\t});\n\n\t\t// d3.interpolate interpolates id value, if id is given as color string(ex. gold, silver, etc)\n\t\t// to avoid unexpected behavior, interpolate only angle values\n\t\t// https://github.com/naver/billboard.js/issues/3321\n\t\tconst interpolate = d3Interpolate(\n\t\t\tgetAngleKeyValue(this._current),\n\t\t\tgetAngleKeyValue(d)\n\t\t);\n\n\t\tthis._current = d;\n\n\t\treturn function(t: number): string {\n\t\t\tconst interpolated = interpolate(t) as IArcData;\n\t\t\tconst {data, index, value} = d;\n\n\t\t\treturn fn({...interpolated, data, index, value});\n\t\t};\n\t};\n}\n\nexport default {\n\tinitPie(): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst dataType = config.data_type;\n\t\tconst padding = config[`${dataType}_padding`];\n\t\tconst startingAngle = config[`${dataType}_startingAngle`] || 0;\n\t\tconst padAngle = (\n\t\t\tpadding ? padding * 0.01 : config[`${dataType}_padAngle`]\n\t\t) || 0;\n\n\t\t$$.pie = d3Pie()\n\t\t\t.startAngle(startingAngle)\n\t\t\t.endAngle(startingAngle + (2 * Math.PI))\n\t\t\t.padAngle(padAngle)\n\t\t\t.value((d: IData | any) => d.values?.reduce((a, b) => a + b.value, 0) ?? d)\n\t\t\t.sort($$.getSortCompareFn.bind($$)(true));\n\t},\n\n\tupdateRadius(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst dataType = config.data_type;\n\t\tconst padding = config[`${dataType}_padding`];\n\t\tconst w = config.gauge_width || config.donut_width;\n\t\tconst gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length *\n\t\t\tconfig.gauge_arcs_minWidth;\n\n\t\t// determine radius\n\t\tstate.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * (\n\t\t\t$$.hasMultiArcGauge() && config.gauge_label_show ? 0.85 : 1\n\t\t);\n\n\t\tstate.radius = state.radiusExpanded * 0.95;\n\t\tstate.innerRadiusRatio = w ? (state.radius - w) / state.radius : 0.6;\n\n\t\tstate.gaugeArcWidth = w || (\n\t\t\tgaugeArcWidth <= state.radius - state.innerRadius ?\n\t\t\t\tstate.radius - state.innerRadius :\n\t\t\t\t(gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius)\n\t\t);\n\n\t\tconst innerRadius = config.pie_innerRadius || (\n\t\t\tpadding ? padding * (state.innerRadiusRatio + 0.1) : 0\n\t\t);\n\n\t\t// NOTE: inner/outerRadius can be an object by user setting, only for 'pie' type\n\t\tstate.outerRadius = config.pie_outerRadius;\n\t\tstate.innerRadius = $$.hasType(\"donut\") || $$.hasType(\"gauge\") ?\n\t\t\tstate.radius * state.innerRadiusRatio :\n\t\t\tinnerRadius;\n\t},\n\n\t/**\n\t * Get pie's inner & outer radius value\n\t * @param {object|undefined} d Data object\n\t * @returns {object}\n\t * @private\n\t */\n\tgetRadius(d: IArcData): {innerRadius: number, outerRadius: number} {\n\t\tconst $$ = this;\n\t\tconst data = d?.data;\n\t\tlet {innerRadius, outerRadius} = $$.state;\n\n\t\tif (!isNumber(innerRadius) && data) {\n\t\t\tinnerRadius = innerRadius[data.id] || 0;\n\t\t}\n\n\t\tif (isObject(outerRadius) && data && data.id in outerRadius) {\n\t\t\touterRadius = outerRadius[data.id];\n\t\t} else if (!isNumber(outerRadius)) {\n\t\t\touterRadius = $$.state.radius;\n\t\t}\n\n\t\treturn {innerRadius, outerRadius};\n\t},\n\n\tupdateArc(): void {\n\t\tconst $$ = this;\n\n\t\t$$.updateRadius();\n\t\t$$.svgArc = $$.getSvgArc();\n\t\t$$.svgArcExpanded = $$.getSvgArcExpanded();\n\t},\n\n\tgetArcLength(): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst arcLengthInPercent = config.gauge_arcLength * 3.6;\n\t\tlet len = 2 * (arcLengthInPercent / 360);\n\n\t\tif (arcLengthInPercent < -360) {\n\t\t\tlen = -2;\n\t\t} else if (arcLengthInPercent > 360) {\n\t\t\tlen = 2;\n\t\t}\n\n\t\treturn len * Math.PI;\n\t},\n\n\tgetStartingAngle(): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst dataType = config.data_type;\n\t\tconst isFullCircle = $$.hasType(\"gauge\") ? config.gauge_fullCircle : false;\n\t\tconst defaultStartAngle = -1 * Math.PI / 2;\n\t\tconst defaultEndAngle = Math.PI / 2;\n\t\tlet startAngle = config[`${dataType}_startingAngle`] || 0;\n\n\t\tif (!isFullCircle && startAngle <= defaultStartAngle) {\n\t\t\tstartAngle = defaultStartAngle;\n\t\t} else if (!isFullCircle && startAngle >= defaultEndAngle) {\n\t\t\tstartAngle = defaultEndAngle;\n\t\t} else if (startAngle > Math.PI || startAngle < -1 * Math.PI) {\n\t\t\tstartAngle = Math.PI;\n\t\t}\n\n\t\treturn startAngle;\n\t},\n\n\t/**\n\t * Update angle data\n\t * @param {object} dValue Data object\n\t * @param {boolean} forRange Weather is for ranged text option(arc.rangeText.values)\n\t * @returns {object|null} Updated angle data\n\t * @private\n\t */\n\tupdateAngle(dValue: IArcData, forRange = false) {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst hasGauge = forRange && $$.hasType(\"gauge\");\n\n\t\t// to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value\n\t\t// const totalSum = $$.getTotalDataSum(state.rendered);\n\t\tlet {pie} = $$;\n\t\tlet d = dValue;\n\t\tlet found = false;\n\n\t\tif (!config) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst gStart = $$.getStartingAngle();\n\t\tconst radius = config.gauge_fullCircle || (forRange && !hasGauge) ?\n\t\t\t$$.getArcLength() :\n\t\t\tgStart * -2;\n\n\t\tif (d.data && $$.isGaugeType(d.data) && !$$.hasMultiArcGauge()) {\n\t\t\tconst {gauge_min: gMin, gauge_max: gMax} = config;\n\n\t\t\t// to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value\n\t\t\tconst totalSum = $$.getTotalDataSum(state.rendered);\n\n\t\t\t// https://github.com/naver/billboard.js/issues/2123\n\t\t\tconst gEnd = radius * ((totalSum - gMin) / (gMax - gMin));\n\n\t\t\tpie = pie\n\t\t\t\t.startAngle(gStart)\n\t\t\t\t.endAngle(gEnd + gStart);\n\t\t}\n\n\t\tif (forRange === false) {\n\t\t\tpie($$.filterTargetsToShow())\n\t\t\t\t.forEach((t, i) => {\n\t\t\t\t\tif (!found && t.data.id === d.data?.id) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\td = t;\n\t\t\t\t\t\td.index = i;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\n\t\tif (isNaN(d.startAngle)) {\n\t\t\td.startAngle = 0;\n\t\t}\n\n\t\tif (isNaN(d.endAngle)) {\n\t\t\td.endAngle = d.startAngle;\n\t\t}\n\n\t\tif (forRange || (d.data && (config.gauge_enforceMinMax || $$.hasMultiArcGauge()))) {\n\t\t\tconst {gauge_min: gMin, gauge_max: gMax} = config;\n\t\t\tconst max = forRange && !hasGauge ? $$.getTotalDataSum(state.rendered) : gMax;\n\t\t\tconst gTic = radius / (max - gMin);\n\t\t\tconst value = d.value ?? 0;\n\t\t\tconst gValue = value < gMin ? 0 : value < max ? value - gMin : (max - gMin);\n\n\t\t\td.startAngle = gStart;\n\t\t\td.endAngle = gStart + gTic * gValue;\n\t\t}\n\n\t\treturn found || forRange ? d : null;\n\t},\n\n\tgetSvgArc(): Function {\n\t\tconst $$ = this;\n\t\tconst {inner, outer, corner} = getRadiusFn.call($$);\n\n\t\tconst arc = d3Arc()\n\t\t\t.innerRadius(inner)\n\t\t\t.outerRadius(outer);\n\n\t\tconst newArc = function(d: IArcData, withoutUpdate) {\n\t\t\tlet path: string | null = \"M 0 0\";\n\n\t\t\tif (d.value || d.data) {\n\t\t\t\tconst data = withoutUpdate ? d : $$.updateAngle(d) ?? null;\n\n\t\t\t\tif (data) {\n\t\t\t\t\tpath = arc.cornerRadius(\n\t\t\t\t\t\tcorner(data, outer(data))\n\t\t\t\t\t)(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn path;\n\t\t};\n\n\t\t// TODO: extends all function\n\t\tnewArc.centroid = arc.centroid;\n\n\t\treturn newArc;\n\t},\n\n\t/**\n\t * Get expanded arc path function\n\t * @param {number} rate Expand rate\n\t * @returns {Function} Expanded arc path getter function\n\t * @private\n\t */\n\tgetSvgArcExpanded(rate = 1): (d: IArcData) => string {\n\t\tconst $$ = this;\n\t\tconst {inner, outer, corner} = getRadiusFn.call($$, rate);\n\n\t\tconst arc = d3Arc()\n\t\t\t.innerRadius(inner)\n\t\t\t.outerRadius(outer);\n\n\t\treturn (d: IArcData): string => {\n\t\t\tconst updated = $$.updateAngle(d);\n\t\t\tconst outerR = outer(updated);\n\t\t\tlet cornerR = 0;\n\n\t\t\tif (updated) {\n\t\t\t\tcornerR = corner(updated, outerR);\n\t\t\t}\n\n\t\t\treturn updated ? <string>arc.cornerRadius(cornerR)(updated) : \"M 0 0\";\n\t\t};\n\t},\n\n\tgetArc(d, withoutUpdate: boolean, force?: boolean): string {\n\t\treturn force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : \"M 0 0\";\n\t},\n\n\t/**\n\t * Render range value text\n\t * @private\n\t */\n\tredrawArcRangeText(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {arcs}, state, $T} = $$;\n\t\tconst format = config.arc_rangeText_format;\n\t\tconst fixed = $$.hasType(\"gauge\") && config.arc_rangeText_fixed;\n\t\tlet values = config.arc_rangeText_values;\n\n\t\tif (values?.length) {\n\t\t\tconst isPercent = config.arc_rangeText_unit === \"%\";\n\t\t\tconst totalSum = $$.getTotalDataSum(state.rendered);\n\n\t\t\tif (isPercent) {\n\t\t\t\tvalues = values.map(v => totalSum / 100 * v);\n\t\t\t}\n\n\t\t\tconst pieData = $$.pie(values).map((d, i) => ((d.index = i), d));\n\t\t\tlet rangeText = arcs.selectAll(`.${$ARC.arcRange}`)\n\t\t\t\t.data(values);\n\n\t\t\trangeText.exit();\n\n\t\t\trangeText = $T(rangeText.enter()\n\t\t\t\t.append(\"text\")\n\t\t\t\t.attr(\"class\", $ARC.arcRange)\n\t\t\t\t.style(\"text-anchor\", \"middle\")\n\t\t\t\t.style(\"pointer-events\", \"none\")\n\t\t\t\t.style(\"opacity\", \"0\")\n\t\t\t\t.text(v => {\n\t\t\t\t\tconst range = isPercent ? (v / totalSum * 100) : v;\n\n\t\t\t\t\treturn isFunction(format) ? format(range) : (\n\t\t\t\t\t\t`${range}${isPercent ? \"%\" : \"\"}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.merge(rangeText));\n\n\t\t\tif ((!state.rendered || (state.rendered && !fixed)) && totalSum > 0) {\n\t\t\t\trangeText.attr(\"transform\", (d, i) => $$.transformForArcLabel(pieData[i], true));\n\t\t\t}\n\n\t\t\trangeText.style(\"opacity\",\n\t\t\t\td => (!fixed && (d > totalSum || totalSum === 0) ? \"0\" : null));\n\t\t}\n\t},\n\n\t/**\n\t * Set transform attributes to arc label text\n\t * @param {object} d Data object\n\t * @param {boolean} forRange Weather is for ranged text option(arc.rangeText.values)\n\t * @returns {string} Translate attribute string\n\t * @private\n\t */\n\ttransformForArcLabel(d: IArcData, forRange = false): string {\n\t\tconst $$ = this;\n\t\tconst {config, state: {radiusExpanded}} = $$;\n\t\tconst updated = $$.updateAngle(d, forRange);\n\t\tlet translate = \"\";\n\n\t\tif (updated) {\n\t\t\tif (forRange || $$.hasMultiArcGauge()) {\n\t\t\t\tconst y1 = Math.sin(updated.endAngle - Math.PI / 2);\n\t\t\t\tconst rangeTextPosition = config.arc_rangeText_position;\n\t\t\t\tlet x = Math.cos(updated.endAngle - Math.PI / 2) *\n\t\t\t\t\t(radiusExpanded + (forRange ? 5 : 25));\n\t\t\t\tlet y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;\n\n\t\t\t\tif (forRange && rangeTextPosition) {\n\t\t\t\t\tconst rangeValues = config.arc_rangeText_values;\n\t\t\t\t\tconst pos = isFunction(rangeTextPosition) ?\n\t\t\t\t\t\trangeTextPosition(rangeValues[d.index]) :\n\t\t\t\t\t\trangeTextPosition;\n\n\t\t\t\t\tx += pos?.x ?? 0;\n\t\t\t\t\ty += pos?.y ?? 0;\n\t\t\t\t}\n\n\t\t\t\ttranslate = `translate(${x},${y})`;\n\t\t\t} else if (!$$.hasType(\"gauge\") || $$.data.targets.length > 1) {\n\t\t\t\tlet {outerRadius} = $$.getRadius(d);\n\n\t\t\t\tif ($$.hasType(\"polar\")) {\n\t\t\t\t\touterRadius = $$.getPolarOuterRadius(d, outerRadius);\n\t\t\t\t}\n\n\t\t\t\tconst c = this.svgArc.centroid(updated);\n\t\t\t\tconst [x, y] = c.map(v => (isNaN(v) ? 0 : v));\n\t\t\t\tconst h = Math.sqrt(x * x + y * y);\n\n\t\t\t\tlet ratio = [\"donut\", \"gauge\", \"pie\", \"polar\"]\n\t\t\t\t\t.filter($$.hasType.bind($$))\n\t\t\t\t\t.map(v => config[`${v}_label_ratio`])?.[0];\n\n\t\t\t\tif (ratio) {\n\t\t\t\t\tratio = isFunction(ratio) ? ratio.bind($$.api)(d, outerRadius, h) : ratio;\n\t\t\t\t} else {\n\t\t\t\t\tratio = outerRadius && (\n\t\t\t\t\t\th ?\n\t\t\t\t\t\t\t(36 / outerRadius > 0.375 ? 1.175 - 36 / outerRadius : 0.8) *\n\t\t\t\t\t\t\touterRadius / h :\n\t\t\t\t\t\t\t0\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\ttranslate = `translate(${x * ratio},${y * ratio})`;\n\t\t\t}\n\t\t}\n\n\t\treturn translate;\n\t},\n\n\tconvertToArcData(d: IArcData | IArcDataRow): object {\n\t\treturn this.addName({\n\t\t\tid: \"data\" in d ? d.data.id : d.id,\n\t\t\tvalue: d.value,\n\t\t\tratio: this.getRatio(\"arc\", d),\n\t\t\tindex: d.index\n\t\t});\n\t},\n\n\ttextForArcLabel(selection: d3Selection): void {\n\t\tconst $$ = this;\n\t\tconst hasGauge = $$.hasType(\"gauge\");\n\n\t\tif ($$.shouldShowArcLabel()) {\n\t\t\tselection\n\t\t\t\t.style(\"fill\", $$.updateTextColor.bind($$))\n\t\t\t\t.attr(\"filter\", d =>\n\t\t\t\t\t$$.updateTextBGColor.bind($$)(d, $$.config.data_labels_backgroundColors))\n\t\t\t\t.each(function(d) {\n\t\t\t\t\tconst node = d3Select(this);\n\t\t\t\t\tconst updated = $$.updateAngle(d);\n\t\t\t\t\tconst ratio = $$.getRatio(\"arc\", updated);\n\t\t\t\t\tconst isUnderThreshold = $$.meetsLabelThreshold(ratio,\n\t\t\t\t\t\t[\"donut\", \"gauge\", \"pie\", \"polar\"].filter($$.hasType.bind($$))?.[0]);\n\n\t\t\t\t\tif (isUnderThreshold) {\n\t\t\t\t\t\tconst {value} = updated || d;\n\t\t\t\t\t\tconst text = (\n\t\t\t\t\t\t\t$$.getArcLabelFormat() || $$.defaultArcValueFormat\n\t\t\t\t\t\t)(value, ratio, d.data.id).toString();\n\n\t\t\t\t\t\tsetTextValue(node, text, [-1, 1], hasGauge);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.text(\"\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t},\n\n\texpandArc(targetIds: string[]): void {\n\t\tconst $$ = this;\n\t\tconst {state: {transiting}, $el} = $$;\n\n\t\t// MEMO: avoid to cancel transition\n\t\tif (transiting) {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (!transiting) {\n\t\t\t\t\tclearInterval(interval);\n\n\t\t\t\t\t$el.legend.selectAll(`.${$FOCUS.legendItemFocused}`).size() > 0 &&\n\t\t\t\t\t\t$$.expandArc(targetIds);\n\t\t\t\t}\n\t\t\t}, 10);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst newTargetIds = $$.mapToTargetIds(targetIds);\n\n\t\t$el.svg.selectAll($$.selectorTargets(newTargetIds, `.${$ARC.chartArc}`))\n\t\t\t.each(function(d) {\n\t\t\t\tif (!$$.shouldExpand(d.data.id)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst expandDuration = $$.getExpandConfig(d.data.id, \"duration\");\n\t\t\t\tconst svgArcExpandedSub = $$.getSvgArcExpanded(\n\t\t\t\t\t$$.getExpandConfig(d.data.id, \"rate\")\n\t\t\t\t);\n\n\t\t\t\td3Select(this).selectAll(\"path\")\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t.transition()\n\t\t\t\t\t.duration(expandDuration)\n\t\t\t\t\t.attrTween(\"d\", getAttrTweenFn($$.svgArcExpanded.bind($$)))\n\t\t\t\t\t.transition()\n\t\t\t\t\t.duration(expandDuration * 2)\n\t\t\t\t\t.attrTween(\"d\", getAttrTweenFn(svgArcExpandedSub.bind($$)));\n\t\t\t});\n\t},\n\n\tunexpandArc(targetIds: string[]): void {\n\t\tconst $$ = this;\n\t\tconst {state: {transiting}, $el: {svg}} = $$;\n\n\t\tif (transiting) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newTargetIds = $$.mapToTargetIds(targetIds);\n\n\t\tsvg.selectAll($$.selectorTargets(newTargetIds, `.${$ARC.chartArc}`))\n\t\t\t.selectAll(\"path\")\n\t\t\t.transition()\n\t\t\t.duration(d => $$.getExpandConfig(d.data.id, \"duration\"))\n\t\t\t.attrTween(\"d\", getAttrTweenFn($$.svgArc.bind($$)));\n\n\t\tsvg.selectAll(`${$ARC.arc}`)\n\t\t\t.style(\"opacity\", null);\n\t},\n\n\t/**\n\t * Get expand config value\n\t * @param {string} id data ID\n\t * @param {string} key config key: 'duration | rate'\n\t * @returns {number}\n\t * @private\n\t */\n\tgetExpandConfig(id: string, key: \"duration\" | \"rate\"): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst def = {\n\t\t\tduration: 50,\n\t\t\trate: 0.98\n\t\t};\n\t\tlet type;\n\n\t\tif ($$.isDonutType(id)) {\n\t\t\ttype = \"donut\";\n\t\t} else if ($$.isGaugeType(id)) {\n\t\t\ttype = \"gauge\";\n\t\t} else if ($$.isPieType(id)) {\n\t\t\ttype = \"pie\";\n\t\t}\n\n\t\treturn type ? config[`${type}_expand_${key}`] : def[key];\n\t},\n\n\tshouldExpand(id: string): boolean {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\treturn ($$.isDonutType(id) && config.donut_expand) ||\n\t\t\t($$.isGaugeType(id) && config.gauge_expand) ||\n\t\t\t($$.isPieType(id) && config.pie_expand);\n\t},\n\n\tshouldShowArcLabel(): boolean {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\treturn [\"donut\", \"gauge\", \"pie\", \"polar\"]\n\t\t\t.some(v => $$.hasType(v) && config[`${v}_label_show`]);\n\t},\n\n\tgetArcLabelFormat(): number | string {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tlet format = v => v;\n\n\t\t[\"donut\", \"gauge\", \"pie\", \"polar\"]\n\t\t\t.filter($$.hasType.bind($$))\n\t\t\t.forEach(v => {\n\t\t\t\tformat = config[`${v}_label_format`];\n\t\t\t});\n\n\t\treturn isFunction(format) ? format.bind($$.api) : format;\n\t},\n\n\tupdateTargetsForArc(targets: IData): void {\n\t\tconst $$ = this;\n\t\tconst {$el} = $$;\n\t\tconst hasGauge = $$.hasType(\"gauge\");\n\t\tconst classChartArc = $$.getChartClass(\"Arc\");\n\t\tconst classArcs = $$.getClass(\"arcs\", true);\n\t\tconst classFocus = $$.classFocus.bind($$);\n\t\tconst chartArcs = $el.main.select(`.${$ARC.chartArcs}`);\n\n\t\tconst mainPieUpdate = chartArcs\n\t\t\t.selectAll(`.${$ARC.chartArc}`)\n\t\t\t.data($$.pie(targets))\n\t\t\t.attr(\"class\", d => classChartArc(d) + classFocus(d.data));\n\n\t\tconst mainPieEnter = mainPieUpdate.enter().append(\"g\")\n\t\t\t.attr(\"class\", classChartArc)\n\t\t\t.call(\n\t\t\t\tthis.setCssRule(false, `.${$ARC.chartArcs} text`, [\n\t\t\t\t\t\"pointer-events:none\",\n\t\t\t\t\t\"text-anchor:middle\"\n\t\t\t\t])\n\t\t\t);\n\n\t\tmainPieEnter.append(\"g\")\n\t\t\t.attr(\"class\", classArcs)\n\t\t\t.merge(mainPieUpdate);\n\n\t\tmainPieEnter.append(\"text\")\n\t\t\t.attr(\"dy\", hasGauge && !$$.hasMultiTargets() ? \"-.1em\" : \".35em\")\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.style(\"text-anchor\", $$.getStylePropValue(\"middle\"))\n\t\t\t.style(\"pointer-events\", $$.getStylePropValue(\"none\"));\n\n\t\t$el.text = chartArcs.selectAll(`.${$COMMON.target} text`);\n\t\t// MEMO: can not keep same color..., but not bad to update color in redraw\n\t\t// mainPieUpdate.exit().remove();\n\t},\n\n\tinitArc(): void {\n\t\tconst $$ = this;\n\t\tconst {$el} = $$;\n\n\t\t$el.arcs = $el.main.select(`.${$COMMON.chart}`)\n\t\t\t.append(\"g\")\n\t\t\t.attr(\"class\", $ARC.chartArcs)\n\t\t\t.attr(\"transform\", $$.getTranslate(\"arc\"));\n\n\t\t$$.setArcTitle();\n\t},\n\n\t/**\n\t * Set arc title text\n\t * @param {string} str Title text\n\t * @private\n\t */\n\tsetArcTitle(str?: string) {\n\t\tconst $$ = this;\n\t\tconst title = str || $$.getArcTitle();\n\t\tconst hasGauge = $$.hasType(\"gauge\");\n\n\t\tif (title) {\n\t\t\tconst className = hasGauge ? $GAUGE.chartArcsGaugeTitle : $ARC.chartArcsTitle;\n\t\t\tlet text = $$.$el.arcs.select(`.${className}`);\n\n\t\t\tif (text.empty()) {\n\t\t\t\ttext = $$.$el.arcs.append(\"text\")\n\t\t\t\t\t.attr(\"class\", className)\n\t\t\t\t\t.style(\"text-anchor\", \"middle\");\n\t\t\t}\n\n\t\t\thasGauge && text.attr(\"dy\", \"-0.3em\");\n\n\t\t\tsetTextValue(text, title, hasGauge ? undefined : [-0.6, 1.35], true);\n\t\t}\n\t},\n\n\t/**\n\t * Return arc title text\n\t * @returns {string} Arc title text\n\t * @private\n\t */\n\tgetArcTitle(): string {\n\t\tconst $$ = this;\n\t\tconst type = ($$.hasType(\"donut\") && \"donut\") || ($$.hasType(\"gauge\") && \"gauge\");\n\n\t\treturn type ? $$.config[`${type}_title`] : \"\";\n\t},\n\n\t/**\n\t * Get arc title text with needle value\n\t * @returns {string|boolean} When title contains needle template string will return processed string, otherwise false\n\t * @private\n\t */\n\tgetArcTitleWithNeedleValue(): string | false {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst title = $$.getArcTitle();\n\n\t\tif (title && $$.config.arc_needle_show && /{=[A-Z_]+}/.test(title)) {\n\t\t\tlet value = state.current.needle;\n\n\t\t\tif (!isNumber(value)) {\n\t\t\t\tvalue = config.arc_needle_value;\n\t\t\t}\n\n\t\t\treturn tplProcess(title, {\n\t\t\t\tNEEDLE_VALUE: ~~value\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tredrawArc(duration: number, durationForExit: number, withTransform?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {main}} = $$;\n\t\tconst hasInteraction = config.interaction_enabled;\n\t\tconst isSelectable = hasInteraction && config.data_selection_isselectable;\n\n\t\tlet mainArc = main.selectAll(`.${$ARC.arcs}`)\n\t\t\t.selectAll(`.${$ARC.arc}`)\n\t\t\t.data($$.arcData.bind($$));\n\n\t\tmainArc.exit()\n\t\t\t.transition()\n\t\t\t.duration(durationForExit)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\tmainArc = mainArc.enter()\n\t\t\t.append(\"path\")\n\t\t\t.attr(\"class\", $$.getClass(\"arc\", true))\n\t\t\t.style(\"fill\", d => $$.color(d.data))\n\t\t\t.style(\"cursor\", d => (isSelectable?.bind?.($$.api)(d) ? \"pointer\" : null))\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.each(function(d) {\n\t\t\t\tif ($$.isGaugeType(d.data)) {\n\t\t\t\t\td.startAngle = config.gauge_startingAngle;\n\t\t\t\t\td.endAngle = config.gauge_startingAngle;\n\t\t\t\t}\n\n\t\t\t\tthis._current = d;\n\t\t\t})\n\t\t\t.merge(mainArc);\n\n\t\tif ($$.hasType(\"gauge\")) {\n\t\t\t$$.updateGaugeMax();\n\t\t\t$$.hasMultiArcGauge() && $$.redrawArcGaugeLine();\n\t\t}\n\n\t\tmainArc\n\t\t\t.attr(\"transform\", d => (!$$.isGaugeType(d.data) && withTransform ? \"scale(0)\" : \"\"))\n\t\t\t.style(\"opacity\", function(d) {\n\t\t\t\treturn d === this._current ? \"0\" : null;\n\t\t\t})\n\t\t\t.each(() => {\n\t\t\t\tstate.transiting = true;\n\t\t\t})\n\t\t\t.transition()\n\t\t\t.duration(duration)\n\t\t\t.attrTween(\"d\", function(d) {\n\t\t\t\tconst updated = $$.updateAngle(d);\n\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn () => \"M 0 0\";\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(this._current.startAngle)) {\n\t\t\t\t\tthis._current.startAngle = 0;\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(this._current.endAngle)) {\n\t\t\t\t\tthis._current.endAngle = this._current.startAngle;\n\t\t\t\t}\n\n\t\t\t\tconst interpolate = d3Interpolate(this._current, updated);\n\n\t\t\t\tthis._current = interpolate(0);\n\n\t\t\t\treturn function(t) {\n\t\t\t\t\tconst interpolated = interpolate(t);\n\n\t\t\t\t\tinterpolated.data = d.data; // data.id will be updated by interporator\n\n\t\t\t\t\treturn $$.getArc(interpolated, true);\n\t\t\t\t};\n\t\t\t})\n\t\t\t.attr(\"transform\", withTransform ? \"scale(1)\" : \"\")\n\t\t\t.style(\"fill\", d => {\n\t\t\t\tlet color;\n\n\t\t\t\tif ($$.levelColor) {\n\t\t\t\t\tcolor = $$.levelColor(d.data.values[0].value);\n\n\t\t\t\t\t// update data's color\n\t\t\t\t\tconfig.data_colors[d.data.id] = color;\n\t\t\t\t} else {\n\t\t\t\t\tcolor = $$.color(d.data);\n\t\t\t\t}\n\n\t\t\t\treturn color;\n\t\t\t})\n\t\t\t// Where gauge reading color would receive customization.\n\t\t\t.style(\"opacity\", null)\n\t\t\t.call(endall, function() {\n\t\t\t\tif ($$.levelColor) {\n\t\t\t\t\tconst path = d3Select(this);\n\t\t\t\t\tconst d: any = path.datum(this._current);\n\n\t\t\t\t\t$$.updateLegendItemColor(d.data.id, path.style(\"fill\"));\n\t\t\t\t}\n\n\t\t\t\tstate.transiting = false;\n\t\t\t\tcallFn(config.onrendered, $$.api);\n\t\t\t});\n\n\t\t// bind arc events\n\t\thasInteraction && $$.bindArcEvent(mainArc);\n\n\t\t$$.hasType(\"polar\") && $$.redrawPolar();\n\t\t$$.hasType(\"gauge\") && $$.redrawBackgroundArcs();\n\n\t\tconfig.arc_needle_show && $$.redrawNeedle();\n\t\t$$.redrawArcText(duration);\n\t\t$$.redrawArcRangeText();\n\t},\n\n\t/**\n\t * Update needle element\n\t * @private\n\t */\n\tredrawNeedle(): void {\n\t\tconst $$ = this;\n\t\tconst {$el, config, state: {hiddenTargetIds, radius}} = $$;\n\t\tconst length = (radius - 1) / 100 * config.arc_needle_length;\n\t\tconst hasDataToShow = hiddenTargetIds.length !== $$.data.targets.length;\n\t\tlet needle = $$.$el.arcs.select(`.${$ARC.needle}`);\n\n\t\t// needle options\n\t\tconst pathFn = config.arc_needle_path;\n\t\tconst baseWidth = config.arc_needle_bottom_width / 2;\n\t\tconst topWidth = config.arc_needle_top_width / 2;\n\t\tconst topRx = config.arc_needle_top_rx;\n\t\tconst topRy = config.arc_needle_top_ry;\n\t\tconst bottomLen = config.arc_needle_bottom_len;\n\t\tconst bottomRx = config.arc_needle_bottom_rx;\n\t\tconst bottomRy = config.arc_needle_bottom_ry;\n\t\tconst needleAngle = $$.getNeedleAngle();\n\n\t\tconst updateNeedleValue = () => {\n\t\t\tconst title = $$.getArcTitleWithNeedleValue();\n\n\t\t\ttitle && $$.setArcTitle(title);\n\t\t};\n\n\t\tupdateNeedleValue();\n\n\t\tif (needle.empty()) {\n\t\t\tneedle = $el.arcs\n\t\t\t\t.append(\"path\")\n\t\t\t\t.classed($ARC.needle, true);\n\n\t\t\t$el.needle = needle;\n\n\t\t\t/**\n\t\t\t * Function to be exposed as public to facilitate updating needle\n\t\t\t * @param {number} v Value to be updated\n\t\t\t * @param {boolean} updateConfig Weather update config's value\n\t\t\t * @private\n\t\t\t */\n\t\t\t$el.needle.updateHelper = (v: number, updateConfig = false): void => {\n\t\t\t\tif ($el.needle.style(\"display\") !== \"none\") {\n\t\t\t\t\t$$.$T($el.needle)\n\t\t\t\t\t\t.style(\"transform\", `rotate(${$$.getNeedleAngle(v)}deg)`)\n\t\t\t\t\t\t.call(endall, () => {\n\t\t\t\t\t\t\tupdateConfig && (config.arc_needle_value = v);\n\t\t\t\t\t\t\tupdateNeedleValue();\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif (hasDataToShow) {\n\t\t\tconst path = isFunction(pathFn) ?\n\t\t\t\tpathFn.call($$, length) :\n\t\t\t\t`M-${baseWidth} ${bottomLen} A${bottomRx} ${bottomRy} 0 0 0 ${baseWidth} ${bottomLen} L${topWidth} -${length} A${topRx} ${topRy} 0 0 0 -${topWidth} -${length} L-${baseWidth} ${bottomLen} Z`;\n\n\t\t\t$$.$T(needle)\n\t\t\t\t.attr(\"d\", path)\n\t\t\t\t.style(\"fill\", config.arc_needle_color)\n\t\t\t\t.style(\"display\", null)\n\t\t\t\t.style(\"transform\", `rotate(${needleAngle}deg)`);\n\t\t} else {\n\t\t\tneedle.style(\"display\", \"none\");\n\t\t}\n\t},\n\n\t/**\n\t * Get needle angle value relative given value\n\t * @param {number} v Value to be calculated angle\n\t * @returns {number} angle value\n\t * @private\n\t */\n\tgetNeedleAngle(v?: number): number {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst arcLength = $$.getArcLength();\n\t\tconst hasGauge = $$.hasType(\"gauge\");\n\t\tconst total = $$.getTotalDataSum(true);\n\t\tlet value = isDefined(v) ? v : config.arc_needle_value;\n\t\tlet startingAngle = config[`${config.data_type}_startingAngle`] || 0;\n\t\tlet radian = 0;\n\n\t\tif (!isNumber(value)) {\n\t\t\tvalue = hasGauge && $$.data.targets.length === 1 ? total : 0;\n\t\t}\n\n\t\tstate.current.needle = value;\n\n\t\tif (hasGauge) {\n\t\t\tstartingAngle = $$.getStartingAngle();\n\n\t\t\tconst radius = config.gauge_fullCircle ? arcLength : startingAngle * -2;\n\t\t\tconst {gauge_min: min, gauge_max: max} = config;\n\n\t\t\tradian = radius * ((value - min) / (max - min));\n\t\t} else {\n\t\t\tradian = arcLength * (value / total);\n\t\t}\n\n\t\treturn (startingAngle + radian) * (180 / Math.PI);\n\t},\n\n\tredrawBackgroundArcs() {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst hasMultiArcGauge = $$.hasMultiArcGauge();\n\t\tconst isFullCircle = config.gauge_fullCircle;\n\t\tconst showEmptyTextLabel = $$.filterTargetsToShow($$.data.targets).length === 0 &&\n\t\t\t!!config.data_empty_label_text;\n\n\t\tconst startAngle = $$.getStartingAngle();\n\t\tconst endAngle = isFullCircle ? startAngle + $$.getArcLength() : startAngle * -1;\n\n\t\tlet backgroundArc = $$.$el.arcs.select(\n\t\t\t`${hasMultiArcGauge ? \"g\" : \"\"}.${$ARC.chartArcsBackground}`\n\t\t);\n\n\t\tif (hasMultiArcGauge) {\n\t\t\tlet index = 0;\n\n\t\t\tbackgroundArc = backgroundArc\n\t\t\t\t.selectAll(`path.${$ARC.chartArcsBackground}`)\n\t\t\t\t.data($$.data.targets);\n\n\t\t\tbackgroundArc.enter()\n\t\t\t\t.append(\"path\")\n\t\t\t\t.attr(\"class\", (d, i) =>\n\t\t\t\t\t`${$ARC.chartArcsBackground} ${$ARC.chartArcsBackground}-${i}`)\n\t\t\t\t.merge(backgroundArc)\n\t\t\t\t.style(\"fill\", (config.gauge_background) || null)\n\t\t\t\t.attr(\"d\", ({id}) => {\n\t\t\t\t\tif (showEmptyTextLabel || state.hiddenTargetIds.indexOf(id) >= 0) {\n\t\t\t\t\t\treturn \"M 0 0\";\n\t\t\t\t\t}\n\n\t\t\t\t\tconst d = {\n\t\t\t\t\t\tdata: [{value: config.gauge_max}],\n\t\t\t\t\t\tstartAngle,\n\t\t\t\t\t\tendAngle,\n\t\t\t\t\t\tindex: index++\n\t\t\t\t\t};\n\n\t\t\t\t\treturn $$.getArc(d, true, true);\n\t\t\t\t});\n\n\t\t\tbackgroundArc.exit().remove();\n\t\t} else {\n\t\t\tbackgroundArc.attr(\"d\", showEmptyTextLabel ? \"M 0 0\" : () => {\n\t\t\t\tconst d = {\n\t\t\t\t\tdata: [{value: config.gauge_max}],\n\t\t\t\t\tstartAngle,\n\t\t\t\t\tendAngle\n\t\t\t\t};\n\n\t\t\t\treturn $$.getArc(d, true, true);\n\t\t\t});\n\t\t}\n\t},\n\n\tbindArcEvent(arc): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst isTouch = state.inputType === \"touch\";\n\t\tconst isMouse = state.inputType === \"mouse\";\n\n\t\t// eslint-disable-next-line\n\t\tfunction selectArc(_this, arcData, id) {\n\t\t\t// transitions\n\t\t\t$$.expandArc(id);\n\t\t\t$$.api.focus(id);\n\t\t\t$$.toggleFocusLegend(id, true);\n\t\t\t$$.showTooltip([arcData], _this);\n\t\t}\n\n\t\t// eslint-disable-next-line\n\t\tfunction unselectArc(arcData?) {\n\t\t\tconst id = arcData?.id || undefined;\n\n\t\t\t$$.unexpandArc(id);\n\t\t\t$$.api.revert();\n\t\t\t$$.revertLegend();\n\t\t\t$$.hideTooltip();\n\t\t}\n\n\t\tarc\n\t\t\t.on(\"click\", function(event, d, i) {\n\t\t\t\tconst updated = $$.updateAngle(d);\n\t\t\t\tlet arcData;\n\n\t\t\t\tif (updated) {\n\t\t\t\t\tarcData = $$.convertToArcData(updated);\n\n\t\t\t\t\t$$.toggleShape?.(this, arcData, i);\n\t\t\t\t\tconfig.data_onclick.bind($$.api)(arcData, this);\n\t\t\t\t}\n\t\t\t});\n\n\t\t// mouse events\n\t\tif (isMouse) {\n\t\t\tarc\n\t\t\t\t.on(\"mouseover\", function(event, d) {\n\t\t\t\t\tif (state.transiting) { // skip while transiting\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\tconst updated = $$.updateAngle(d);\n\t\t\t\t\tconst arcData = updated ? $$.convertToArcData(updated) : null;\n\t\t\t\t\tconst id = arcData?.id || undefined;\n\n\t\t\t\t\tselectArc(this, arcData, id);\n\t\t\t\t\t$$.setOverOut(true, arcData);\n\t\t\t\t})\n\t\t\t\t.on(\"mouseout\", (event, d) => {\n\t\t\t\t\tif (state.transiting || !config.interaction_onout) { // skip while transiting\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\tconst updated = $$.updateAngle(d);\n\t\t\t\t\tconst arcData = updated ? $$.convertToArcData(updated) : null;\n\n\t\t\t\t\tunselectArc();\n\t\t\t\t\t$$.setOverOut(false, arcData);\n\t\t\t\t})\n\t\t\t\t.on(\"mousemove\", function(event, d) {\n\t\t\t\t\tconst updated = $$.updateAngle(d);\n\t\t\t\t\tconst arcData = updated ? $$.convertToArcData(updated) : null;\n\n\t\t\t\t\tstate.event = event;\n\t\t\t\t\t$$.showTooltip([arcData], this);\n\t\t\t\t});\n\t\t}\n\n\t\t// touch events\n\t\tif (isTouch && $$.hasArcType() && !$$.radars) {\n\t\t\tconst getEventArc = event => {\n\t\t\t\tconst {clientX, clientY} = event.changedTouches?.[0] ?? {clientX: 0, clientY: 0};\n\t\t\t\tconst eventArc = d3Select(document.elementFromPoint(clientX, clientY));\n\n\t\t\t\treturn eventArc;\n\t\t\t};\n\n\t\t\t$$.$el.svg\n\t\t\t\t.on(\"touchstart touchmove\", function(event) {\n\t\t\t\t\tif (state.transiting) { // skip while transiting\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.event = event;\n\n\t\t\t\t\tconst eventArc = getEventArc(event);\n\t\t\t\t\tconst datum: any = eventArc.datum();\n\t\t\t\t\tconst updated = (datum?.data && datum.data.id) ? $$.updateAngle(datum) : null;\n\t\t\t\t\tconst arcData = updated ? $$.convertToArcData(updated) : null;\n\t\t\t\t\tconst id = arcData?.id || undefined;\n\n\t\t\t\t\t$$.callOverOutForTouch(arcData);\n\n\t\t\t\t\tisUndefined(id) ? unselectArc() : selectArc(this, arcData, id);\n\t\t\t\t});\n\t\t}\n\t},\n\n\tredrawArcText(duration: number): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {main, arcs}} = $$;\n\t\tconst hasGauge = $$.hasType(\"gauge\");\n\t\tconst hasMultiArcGauge = $$.hasMultiArcGauge();\n\t\tlet text;\n\n\t\t// for gauge type, update text when has no title & multi data\n\t\tif (!(hasGauge && $$.data.targets.length === 1 && config.gauge_title)) {\n\t\t\ttext = main.selectAll(`.${$ARC.chartArc}`)\n\t\t\t\t.select(\"text\")\n\t\t\t\t.style(\"opacity\", \"0\")\n\t\t\t\t.attr(\"class\", d => ($$.isGaugeType(d.data) ? $GAUGE.gaugeValue : null))\n\t\t\t\t.call($$.textForArcLabel.bind($$))\n\t\t\t\t.attr(\"transform\", d => $$.transformForArcLabel.bind($$)(d))\n\t\t\t\t.style(\"font-size\", d => (\n\t\t\t\t\t$$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ?\n\t\t\t\t\t\t`${Math.round(state.radius / 5)}px` :\n\t\t\t\t\t\tnull\n\t\t\t\t))\n\t\t\t\t.transition()\n\t\t\t\t.duration(duration)\n\t\t\t\t.style(\"opacity\",\n\t\t\t\t\td => ($$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? null : \"0\"));\n\n\t\t\thasMultiArcGauge && text.attr(\"dy\", \"-.1em\");\n\t\t}\n\n\t\tmain.select(`.${$ARC.chartArcsTitle}`)\n\t\t\t.style(\"opacity\", $$.hasType(\"donut\") || hasGauge ? null : \"0\");\n\n\t\tif (hasGauge) {\n\t\t\tconst isFullCircle = config.gauge_fullCircle;\n\n\t\t\tisFullCircle &&\n\t\t\t\ttext?.attr(\"dy\", `${hasMultiArcGauge ? 0 : Math.round(state.radius / 14)}`);\n\n\t\t\tif (config.gauge_label_show) {\n\t\t\t\tarcs.select(`.${$GAUGE.chartArcsGaugeUnit}`)\n\t\t\t\t\t.attr(\"dy\", `${isFullCircle ? 1.5 : 0.75}em`)\n\t\t\t\t\t.text(config.gauge_units);\n\n\t\t\t\tarcs.select(`.${$GAUGE.chartArcsGaugeMin}`)\n\t\t\t\t\t.attr(\"dx\", `${\n\t\t\t\t\t\t-1 *\n\t\t\t\t\t\t(state.innerRadius +\n\t\t\t\t\t\t\t((state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)))\n\t\t\t\t\t}px`)\n\t\t\t\t\t.attr(\"dy\", \"1.2em\")\n\t\t\t\t\t.text($$.textForGaugeMinMax(config.gauge_min, false));\n\n\t\t\t\t// show max text when isn't fullCircle\n\t\t\t\t!isFullCircle && arcs.select(`.${$GAUGE.chartArcsGaugeMax}`)\n\t\t\t\t\t.attr(\"dx\", `${state.innerRadius + ((state.radius - state.innerRadius) / 2)}px`)\n\t\t\t\t\t.attr(\"dy\", \"1.2em\")\n\t\t\t\t\t.text($$.textForGaugeMinMax(config.gauge_max, true));\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get Arc element by id or index\n\t * @param {string|number} value id or index of Arc\n\t * @returns {d3Selection} Arc path element\n\t * @private\n\t */\n\tgetArcElementByIdOrIndex(value: string | number): d3Selection {\n\t\tconst $$ = this;\n\t\tconst {$el: {arcs}} = $$;\n\t\tconst filterFn = isNumber(value) ? d => d.index === value : d => d.data.id === value;\n\n\t\treturn arcs?.selectAll(`.${$COMMON.target} path`)\n\t\t\t.filter(filterFn);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {area as d3Area} from \"d3-shape\";\nimport {d3Selection} from \"../../../types\";\nimport {$AREA, $CIRCLE, $LINE} from \"../../config/classes\";\nimport {getRandom} from \"../../module/util\";\nimport type {IData, IDataRow} from \"../data/IData\";\n\ntype Indices = {[key: string | \"__max__\"]: number};\n\nexport default {\n\tinitArea(mainLine: d3Selection): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tmainLine\n\t\t\t.insert(\"g\", `.${config.area_front ? $CIRCLE.circles : $LINE.lines}`)\n\t\t\t.attr(\"class\", $$.getClass(\"areas\", true));\n\t},\n\n\t/**\n\t * Update area color\n\t * @param {object} d Data object\n\t * @returns {string} Color string\n\t * @private\n\t */\n\tupdateAreaColor(d: IDataRow): string {\n\t\tconst $$ = this;\n\n\t\treturn $$.config.area_linearGradient ? $$.getGradienColortUrl(d.id) : $$.color(d);\n\t},\n\n\t/**\n\t * Generate/Update elements\n\t * @param {boolean} withTransition Transition for exit elements\n\t * @param {boolean} isSub Subchart draw\n\t * @private\n\t */\n\tupdateArea(withTransition: boolean, isSub = false): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el, $T} = $$;\n\t\tconst $root = isSub ? $el.subchart : $el;\n\n\t\tconfig.area_linearGradient && $$.updateLinearGradient();\n\n\t\tconst area = $root.main.selectAll(`.${$AREA.areas}`)\n\t\t\t.selectAll(`.${$AREA.area}`)\n\t\t\t.data($$.lineData.bind($$));\n\n\t\t$T(area.exit(), withTransition)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\t$root.area = area.enter().append(\"path\")\n\t\t\t.attr(\"class\", $$.getClass(\"area\", true))\n\t\t\t.style(\"fill\", $$.updateAreaColor.bind($$))\n\t\t\t.style(\"opacity\", function() {\n\t\t\t\tstate.orgAreaOpacity = d3Select(this).style(\"opacity\");\n\t\t\t\treturn \"0\";\n\t\t\t})\n\t\t\t.merge(area);\n\n\t\tarea.style(\"opacity\", state.orgAreaOpacity);\n\n\t\t// calculate ratio if grouped data exists\n\t\t$$.setRatioForGroupedData($root.area.data());\n\t},\n\n\t/**\n\t * Redraw function\n\t * @param {Function} drawFn Retuned functino from .generateDrawCandlestick()\n\t * @param {boolean} withTransition With or without transition\n\t * @param {boolean} isSub Subchart draw\n\t * @returns {Array}\n\t */\n\tredrawArea(drawFn: Function, withTransition?: boolean, isSub = false): d3Selection[] {\n\t\tconst $$ = this;\n\t\tconst {area} = isSub ? this.$el.subchart : this.$el;\n\t\tconst {orgAreaOpacity} = $$.state;\n\n\t\treturn [\n\t\t\t$$.$T(area, withTransition, getRandom())\n\t\t\t\t.attr(\"d\", drawFn)\n\t\t\t\t.style(\"fill\", $$.updateAreaColor.bind($$))\n\t\t\t\t.style(\"opacity\",\n\t\t\t\t\td => String($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity))\n\t\t];\n\t},\n\n\t/**\n\t * Generate area path data\n\t * @param {object} areaIndices Indices\n\t * @param {boolean} isSub Weather is sub axis\n\t * @returns {Function}\n\t * @private\n\t */\n\tgenerateDrawArea(areaIndices: Indices, isSub?: boolean): (d: IData) => string {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst lineConnectNull = config.line_connectNull;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\tconst getPoints = $$.generateGetAreaPoints(areaIndices, isSub);\n\t\tconst yScale = $$.getYScaleById.bind($$);\n\n\t\tconst xValue = d => (isSub ? $$.subxx : $$.xx).call($$, d);\n\t\tconst value0 = (d, i) => ($$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)(\n\t\t\t$$.isAreaRangeType(d) ? $$.getRangedData(d, \"high\") : $$.getShapeYMin(d.id)\n\t\t));\n\t\tconst value1 = (d, i) => ($$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScale(d.id, isSub)(\n\t\t\t$$.isAreaRangeType(d) ? $$.getRangedData(d, \"low\") : d.value\n\t\t));\n\n\t\treturn d => {\n\t\t\tlet values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values;\n\t\t\tlet x0 = 0;\n\t\t\tlet y0 = 0;\n\t\t\tlet path;\n\n\t\t\tif ($$.isAreaType(d)) {\n\t\t\t\tlet area = d3Area();\n\n\t\t\t\tarea = isRotated ?\n\t\t\t\t\tarea.y(xValue)\n\t\t\t\t\t\t.x0(value0)\n\t\t\t\t\t\t.x1(value1) :\n\t\t\t\t\tarea.x(xValue)\n\t\t\t\t\t\t.y0(config.area_above ? 0 : (\n\t\t\t\t\t\t\tconfig.area_below ? $$.state.height : value0\n\t\t\t\t\t\t))\n\t\t\t\t\t\t.y1(value1);\n\n\t\t\t\tif (!lineConnectNull) {\n\t\t\t\t\tarea = area.defined(d => $$.getBaseValue(d) !== null);\n\t\t\t\t}\n\n\t\t\t\tif ($$.isStepType(d)) {\n\t\t\t\t\tvalues = $$.convertValuesToStep(values);\n\t\t\t\t}\n\n\t\t\t\tpath = area.curve($$.getCurve(d))(values);\n\t\t\t} else {\n\t\t\t\tif (values[0]) {\n\t\t\t\t\tx0 = $$.scale.x(values[0].x);\n\t\t\t\t\ty0 = $$.getYScaleById(d.id)(values[0].value);\n\t\t\t\t}\n\n\t\t\t\tpath = isRotated ? `M ${y0} ${x0}` : `M ${x0} ${y0}`;\n\t\t\t}\n\n\t\t\treturn path || \"M 0 0\";\n\t\t};\n\t},\n\n\tgenerateGetAreaPoints(\n\t\tareaIndices: Indices,\n\t\tisSub?: boolean\n\t): (d: IDataRow, i: number) => [number, number][] {\n\t\t// partial duplication of generateGetBarPoints\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst x = $$.getShapeX(0, areaIndices, isSub);\n\t\tconst y = $$.getShapeY(!!isSub);\n\t\tconst areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, isSub);\n\t\tconst yScale = $$.getYScaleById.bind($$);\n\n\t\treturn function(d, i) {\n\t\t\tconst y0 = yScale.call($$, d.id, isSub)($$.getShapeYMin(d.id));\n\t\t\tconst offset = areaOffset(d, i) || y0; // offset is for stacked area chart\n\t\t\tconst posX = x(d);\n\t\t\tconst value = d.value as number;\n\t\t\tlet posY = y(d);\n\n\t\t\t// fix posY not to overflow opposite quadrant\n\t\t\tif (\n\t\t\t\tconfig.axis_rotated && (\n\t\t\t\t\t(value > 0 && posY < y0) || (value < 0 && y0 < posY)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tposY = y0;\n\t\t\t}\n\n\t\t\t// 1 point that marks the area position\n\t\t\treturn [\n\t\t\t\t[posX, offset],\n\t\t\t\t[posX, posY - (y0 - offset)],\n\t\t\t\t[posX, posY - (y0 - offset)], // needed for compatibility\n\t\t\t\t[posX, offset] // needed for compatibility\n\t\t\t];\n\t\t};\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport type {d3Selection, DataRow} from \"../../../types/types\";\nimport {$BAR, $COMMON} from \"../../config/classes\";\nimport {getRandom, isNumber} from \"../../module/util\";\nimport type {IBarData} from \"../data/IData\";\nimport type {IOffset} from \"./shape\";\n\ntype BarTypeDataRow = DataRow<number | number[]>;\ntype BarConnectLine = {x: number, y: number, width: number, height: number};\ntype BarPath = (string | BarConnectLine)[];\n\n/**\n * Get the type of connect line for bar chart\n * @param {string} id Data id\n * @returns {string|null} Connect line type or null if not applicable\n */\nfunction getConnectLineType(id: string): string | null {\n\tconst connectLine = this.config.bar_connectLine;\n\tconst type = connectLine?.[id] || connectLine;\n\n\treturn (/^(start|end)\\-(start|end)$/.test(type)) ? type : null;\n}\n\nexport default {\n\tinitBar(): void {\n\t\tconst {$el, config, state: {clip}} = this;\n\n\t\t$el.bar = $el.main.select(`.${$COMMON.chart}`);\n\t\t$el.bar = config.bar_front ? $el.bar.append(\"g\") : $el.bar.insert(\"g\", \":first-child\");\n\n\t\t$el.bar\n\t\t\t.attr(\"class\", $BAR.chartBars)\n\t\t\t.call(this.setCssRule(false, `.${$BAR.chartBars}`, [\"pointer-events:none\"]));\n\n\t\t// set clip-path attribute when condition meet\n\t\t// https://github.com/naver/billboard.js/issues/2421\n\t\tif (\n\t\t\tconfig.clipPath === false && (\n\t\t\t\tconfig.bar_radius || config.bar_radius_ratio\n\t\t\t)\n\t\t) {\n\t\t\t$el.bar.attr(\"clip-path\", clip.pathXAxis.replace(/#[^)]*/, `#${clip.id}`));\n\t\t}\n\t},\n\n\tupdateTargetsForBar(targets: BarTypeDataRow[]): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el} = $$;\n\t\tconst classChartBar = $$.getChartClass(\"Bar\");\n\t\tconst classBars = $$.getClass(\"bars\", true);\n\t\tconst classFocus = $$.classFocus.bind($$);\n\t\tconst isSelectable = config.interaction_enabled && config.data_selection_isselectable;\n\n\t\tif (!$el.bar) {\n\t\t\t$$.initBar();\n\t\t}\n\n\t\tconst mainBarUpdate = $el.main.select(`.${$BAR.chartBars}`)\n\t\t\t.selectAll(`.${$BAR.chartBar}`)\n\t\t\t.data($$.filterNullish(targets))\n\t\t\t.attr(\"class\", d => classChartBar(d) + classFocus(d));\n\n\t\tconst mainBarEnter = mainBarUpdate.enter().append(\"g\")\n\t\t\t.attr(\"class\", classChartBar)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.style(\"pointer-events\", $$.getStylePropValue(\"none\"));\n\n\t\t// Bars for each data\n\t\tmainBarEnter.append(\"g\")\n\t\t\t.attr(\"class\", classBars)\n\t\t\t.style(\"cursor\", d => (isSelectable?.bind?.($$.api)(d) ? \"pointer\" : null))\n\t\t\t.call(selection => {\n\t\t\t\t$$.setCssRule(true, ` .${$BAR.bar}`, [\"fill\"], $$.color)(selection);\n\n\t\t\t\t// add bar connect line\n\t\t\t\tselection.each(function(d) {\n\t\t\t\t\tif (getConnectLineType.call($$, d.id)) {\n\t\t\t\t\t\td3Select(this).append(\"path\")\n\t\t\t\t\t\t\t.attr(\"class\", $BAR.barConnectLine);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t},\n\n\t/**\n\t * Generate/Update elements\n\t * @param {boolean} withTransition Transition for exit elements\n\t * @param {boolean} isSub Subchart draw\n\t * @private\n\t */\n\tupdateBar(withTransition: boolean, isSub = false): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el, $T} = $$;\n\t\tconst $root = isSub ? $el.subchart : $el;\n\t\tconst classBar = $$.getClass(\"bar\", true);\n\t\tconst initialOpacity = $$.initialOpacity.bind($$);\n\n\t\tconfig.bar_linearGradient && $$.updateLinearGradient();\n\n\t\tconst bar = $root.main.selectAll(`.${$BAR.bars}`)\n\t\t\t.selectAll(`.${$BAR.bar}`)\n\t\t\t.data($$.labelishData.bind($$));\n\n\t\t$T(bar.exit(), withTransition)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\t$root.bar = bar.enter().append(\"path\")\n\t\t\t.attr(\"class\", classBar)\n\t\t\t.style(\"fill\", $$.updateBarColor.bind($$))\n\t\t\t.merge(bar)\n\t\t\t.style(\"opacity\", initialOpacity);\n\n\t\t// calculate ratio if grouped data exists\n\t\t$$.setRatioForGroupedData($root.bar.data());\n\t},\n\n\t/**\n\t * Update bar color\n\t * @param {object} d Data object\n\t * @returns {string} Color string\n\t * @private\n\t */\n\tupdateBarColor(d: IBarData): string | null {\n\t\tconst $$ = this;\n\t\tconst fn = $$.getStylePropValue($$.color);\n\n\t\treturn $$.config.bar_linearGradient ? $$.getGradienColortUrl(d.id) : (fn ? fn(d) : null);\n\t},\n\n\t/**\n\t * Redraw function\n\t * @param {Function} drawFn Retuned function from .getDrawShape() => .generateDrawBar()\n\t * @param {boolean} withTransition With or without transition\n\t * @param {boolean} isSub Subchart draw\n\t * @returns {Array}\n\t * @private\n\t */\n\tredrawBar(drawFn, withTransition?: boolean, isSub = false) {\n\t\tconst $$ = this;\n\t\tconst {bar} = isSub ? $$.$el.subchart : $$.$el;\n\t\tconst barPath: BarConnectLine[] = [];\n\n\t\treturn [\n\t\t\t$$.$T(bar, withTransition, getRandom())\n\t\t\t\t.attr(\"d\", function(d, i, arr) {\n\t\t\t\t\tconst path = (isNumber(d.value) || $$.isBarRangeType(d)) && drawFn(d, i);\n\t\t\t\t\tconst connectLineType = getConnectLineType.call($$, d.id);\n\n\t\t\t\t\t// for bar.coonectLine option\n\t\t\t\t\tif (path.length > 1) {\n\t\t\t\t\t\tbarPath.push(path[1]);\n\n\t\t\t\t\t\tif (i === arr.length - 1) {\n\t\t\t\t\t\t\tconst barConnectLineNode = $$.$T(\n\t\t\t\t\t\t\t\td3Select(this.parentNode.querySelector(`.${$BAR.barConnectLine}`)),\n\t\t\t\t\t\t\t\twithTransition,\n\t\t\t\t\t\t\t\tgetRandom()\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t$$.updateConnectLine(barConnectLineNode, connectLineType, barPath);\n\t\t\t\t\t\t\tbarPath.splice(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn path[0];\n\t\t\t\t})\n\t\t\t\t.style(\"fill\", $$.updateBarColor.bind($$))\n\t\t\t\t.style(\"clip-path\", d => d.clipPath)\n\t\t\t\t.style(\"opacity\", null)\n\t\t];\n\t},\n\n\t/**\n\t * Generate draw function\n\t * @param {object} barIndices data order within x axis.\n\t * barIndices ==> {data1: 0, data2: 0, data3: 1, data4: 1, __max__: 1}\n\t *\n\t * When gropus given as:\n\t *  groups: [\n\t * \t\t[\"data1\", \"data2\"],\n\t * \t\t[\"data3\", \"data4\"]\n\t * \t],\n\t *\n\t * Will be rendered as:\n\t * \t\tdata1 data3   data1 data3\n\t * \t\tdata2 data4   data2 data4\n\t * \t\t-------------------------\n\t * \t\t\t 0             1\n\t * @param {boolean} isSub If is for subchart\n\t * @returns {Function}\n\t * @private\n\t */\n\tgenerateDrawBar(barIndices, isSub?: boolean): (d: IBarData, i: number) => BarPath {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst getPoints = $$.generateGetBarPoints(barIndices, isSub);\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst barRadius = config.bar_radius;\n\t\tconst barRadiusRatio = config.bar_radius_ratio;\n\n\t\t// get the bar radius\n\t\tconst getRadius = isNumber(barRadius) && barRadius > 0 ? () => barRadius : (\n\t\t\tisNumber(barRadiusRatio) ? w => w * barRadiusRatio : null\n\t\t);\n\n\t\treturn (d: IBarData, i: number): BarPath => {\n\t\t\t// 4 points that make a bar\n\t\t\tconst points = getPoints(d, i);\n\n\t\t\t// switch points if axis is rotated, not applicable for sub chart\n\t\t\tconst indexX = +isRotated;\n\t\t\tconst indexY = +!indexX;\n\n\t\t\tconst isUnderZero = d.value as number < 0;\n\t\t\tconst isInverted = config[`axis_${$$.axis.getId(d.id)}_inverted`];\n\t\t\tconst isNegative = (!isInverted && isUnderZero) || (isInverted && !isUnderZero);\n\n\t\t\tconst pathRadius = [\"\", \"\"];\n\t\t\tconst isGrouped = $$.isGrouped(d.id);\n\t\t\tconst isRadiusData = getRadius && isGrouped ? $$.isStackingRadiusData(d) : false;\n\t\t\tconst init = [\n\t\t\t\tpoints[0][indexX],\n\t\t\t\tpoints[0][indexY]\n\t\t\t];\n\t\t\tlet radius = 0;\n\n\t\t\t// initialize as null to not set attribute if isn't needed\n\t\t\td.clipPath = null;\n\n\t\t\tif (getRadius) {\n\t\t\t\tconst index = isRotated ? indexY : indexX;\n\t\t\t\tconst barW = points[2][index] - points[0][index];\n\n\t\t\t\tradius = !isGrouped || isRadiusData ? getRadius(barW) : 0;\n\n\t\t\t\tconst arc = `a${radius} ${radius} ${isNegative ? `1 0 0` : `0 0 1`} `;\n\n\t\t\t\tpathRadius[+!isRotated] = `${arc}${radius},${radius}`;\n\t\t\t\tpathRadius[+isRotated] = `${arc}${\n\t\t\t\t\t[-radius, radius][isRotated ? \"sort\" : \"reverse\"]()\n\t\t\t\t}`;\n\n\t\t\t\tisNegative && pathRadius.reverse();\n\t\t\t}\n\n\t\t\tconst pos = isRotated ?\n\t\t\t\tpoints[1][indexX] + (isNegative ? radius : -radius) :\n\t\t\t\tpoints[1][indexY] + (isNegative ? -radius : radius);\n\n\t\t\t// Apply clip-path in case of radius angle surpass the bar shape\n\t\t\t// https://github.com/naver/billboard.js/issues/3903\n\t\t\tif (radius) {\n\t\t\t\tlet clipPath = \"\";\n\n\t\t\t\tif (isRotated) {\n\t\t\t\t\tif (isNegative && init[0] < pos) {\n\t\t\t\t\t\tclipPath = `0 ${pos - init[0]}px 0 0`;\n\t\t\t\t\t} else if (!isNegative && init[0] > pos) {\n\t\t\t\t\t\tclipPath = `0 0 0 ${init[0] - pos}px`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isNegative && init[1] > pos) {\n\t\t\t\t\t\tclipPath = `${init[1] - pos}px 0 0 0`;\n\t\t\t\t\t} else if (!isNegative && init[1] < pos) {\n\t\t\t\t\t\tclipPath = `0 0 ${pos - init[1]}px 0`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (clipPath) {\n\t\t\t\t\td.clipPath = `inset(${clipPath})`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// path string data shouldn't be containing new line chars\n\t\t\t// https://github.com/naver/billboard.js/issues/530\n\t\t\tconst path = isRotated ?\n\t\t\t\t`H${pos} ${pathRadius[0]}V${points[2][indexY] - radius} ${pathRadius[1]}H${\n\t\t\t\t\tpoints[3][indexX]\n\t\t\t\t}` :\n\t\t\t\t`V${pos} ${pathRadius[0]}H${points[2][indexX] - radius} ${pathRadius[1]}V${\n\t\t\t\t\tpoints[3][indexY]\n\t\t\t\t}`;\n\n\t\t\tconst coords: BarPath = [`M${points[0][indexX]},${points[0][indexY]}${path}z`];\n\n\t\t\tif (getConnectLineType.call($$, d.id)) {\n\t\t\t\tcoords.push(isRotated ?\n\t\t\t\t\t{\n\t\t\t\t\t\tx: points[0][indexX],\n\t\t\t\t\t\ty: points[0][indexY],\n\t\t\t\t\t\twidth: points[0][indexX] - pos,\n\t\t\t\t\t\theight: points[2][indexY] - points[0][indexY]\n\t\t\t\t\t} :\n\t\t\t\t\t{\n\t\t\t\t\t\tx: points[0][indexX],\n\t\t\t\t\t\ty: pos,\n\t\t\t\t\t\twidth: points[2][indexX] - points[0][indexX],\n\t\t\t\t\t\theight: points[3][indexY] - pos\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn coords;\n\t\t};\n\t},\n\n\t/**\n\t * Determine if given stacking bar data is radius type\n\t * @param {object} d Data row\n\t * @returns {boolean}\n\t */\n\tisStackingRadiusData(d: IBarData): boolean {\n\t\tconst $$ = this;\n\t\tconst {$el, config, data, state} = $$;\n\t\tconst {id, index, value} = d;\n\n\t\t// when the data is hidden, check if has rounded edges\n\t\tif (state.hiddenTargetIds.indexOf(id) > -1) {\n\t\t\tconst target = $el.bar.filter(d => d.id === id && d.value === value);\n\n\t\t\treturn !target.empty() && /a\\d+/i.test(target.attr(\"d\"));\n\t\t}\n\n\t\t// Find same grouped ids\n\t\tconst keys = config.data_groups.find(v => v.indexOf(id) > -1);\n\n\t\t// Get sorted list\n\t\tconst sortedList = $$.orderTargets(\n\t\t\t$$.filterTargetsToShow(data.targets.filter($$.isBarType, $$))\n\t\t).filter(v => keys.indexOf(v.id) > -1);\n\n\t\t// Get sorted Ids. Filter positive or negative values Ids from given value\n\t\tconst sortedIds = sortedList\n\t\t\t.map(v =>\n\t\t\t\tv.values.filter(\n\t\t\t\t\tv2 =>\n\t\t\t\t\t\tv2.index === index && (\n\t\t\t\t\t\t\tisNumber(value) && value > 0 ? v2.value > 0 : v2.value < 0\n\t\t\t\t\t\t)\n\t\t\t\t)[0]\n\t\t\t)\n\t\t\t.filter(Boolean)\n\t\t\t.map(v => v.id);\n\n\t\t// If the given id stays in the last position, then radius should be applied.\n\t\treturn value !== 0 && (sortedIds.indexOf(id) === sortedIds.length - 1);\n\t},\n\n\t/**\n\t * Generate bar coordinate points data\n\t * @param {object} barIndices Data order within x axis.\n\t * @param {boolean} isSub If is for subchart\n\t * @returns {Array} Array of coordinate points\n\t * @private\n\t */\n\tgenerateGetBarPoints(barIndices,\n\t\tisSub?: boolean): (d: IBarData, i: number) => [number, number][] {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst axis = isSub ? $$.axis.subX : $$.axis.x;\n\t\tconst barTargetsNum = $$.getIndicesMax(barIndices) + 1;\n\t\tconst barW: IOffset = $$.getBarW(\"bar\", axis, barTargetsNum);\n\t\tconst barX = $$.getShapeX(barW, barIndices, !!isSub);\n\t\tconst barY = $$.getShapeY(!!isSub);\n\t\tconst barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub);\n\t\tconst yScale = $$.getYScaleById.bind($$);\n\n\t\treturn (d: IBarData, i: number) => {\n\t\t\tconst {id} = d;\n\t\t\tconst y0 = yScale.call($$, id, isSub)($$.getShapeYMin(id));\n\t\t\tconst offset = barOffset(d, i) || y0; // offset is for stacked bar chart\n\t\t\tconst width = isNumber(barW) ? barW : barW[d.id] || barW._$width;\n\t\t\tconst isInverted = config[`axis_${$$.axis.getId(id)}_inverted`];\n\t\t\tconst value = d.value as number;\n\t\t\tconst posX = barX(d);\n\t\t\tlet posY = barY(d);\n\n\t\t\t// fix posY not to overflow opposite quadrant\n\t\t\tif (\n\t\t\t\tconfig.axis_rotated && !isInverted && (\n\t\t\t\t\t(value > 0 && posY < y0) || (value < 0 && y0 < posY)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tposY = y0;\n\t\t\t}\n\n\t\t\tif (!$$.isBarRangeType(d)) {\n\t\t\t\tposY -= y0 - offset;\n\t\t\t}\n\n\t\t\tconst startPosX = posX + width;\n\n\t\t\t// 4 points that make a bar\n\t\t\treturn [\n\t\t\t\t[posX, offset],\n\t\t\t\t[posX, posY],\n\t\t\t\t[startPosX, posY],\n\t\t\t\t[startPosX, offset]\n\t\t\t];\n\t\t};\n\t},\n\n\t/**\n\t * Update the bar connect line path\n\t * @param {d3Selection} node d3 selection of bar connect line\n\t * @param {string} type Type of connect line, one of \"start-start\", \"start-end\", \"end-start\", \"end-end\"\n\t * @param {Array} barPath d3 path data for the bar\n\t */\n\tupdateConnectLine(\n\t\tnode: d3Selection,\n\t\ttype: \"start-start\" | \"start-end\" | \"end-start\" | \"end-end\",\n\t\tbarPath: BarConnectLine[]\n\t): void {\n\t\tconst path = barPath.map((v: BarConnectLine, i: number, arr: BarConnectLine[]): string => {\n\t\t\tconst isRotated = this.config.axis_rotated;\n\t\t\tconst isStart = /^start-(start|end)$/.test(type);\n\t\t\tconst isEnd = /^end-(start|end)$/.test(type);\n\t\t\tconst path: string[] = [];\n\n\t\t\tconst x = isRotated ? (isEnd ? v.x - v.width : v.x) : (v.x + v.width);\n\t\t\tconst y = isRotated ? v.y + v.height : isStart ? v.y + v.height : v.y;\n\n\t\t\tif (i === 0) {\n\t\t\t\tpath.push(`${x},${y}`);\n\t\t\t} else {\n\t\t\t\tpath.push(\n\t\t\t\t\tisRotated ?\n\t\t\t\t\t\t`L${v.x - (/\\w+-end$/.test(type) ? v.width : 0)},${v.y}` :\n\t\t\t\t\t\t`L${v.x},${v.y + (/\\w+-start$/.test(type) ? v.height : 0)}`\n\t\t\t\t);\n\n\t\t\t\tif (i < arr.length - 1) {\n\t\t\t\t\tpath.push(`M${x},${y}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn path.join(\" \");\n\t\t});\n\n\t\tnode.attr(\"d\", `M${path.join(\"\")}z`);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {KEY} from \"../../module/Cache\";\nimport {getMinMax, isFunction, isNumber, isObject} from \"../../module/util\";\n\nexport default {\n\t/**\n\t * Initializer\n\t * @private\n\t */\n\tinitBubble(): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tif ($$.hasType(\"bubble\")) {\n\t\t\tconfig.point_show = true;\n\t\t\tconfig.point_type = \"circle\";\n\t\t}\n\t},\n\n\t/**\n\t * Get user agent's computed value\n\t * @returns {number}\n\t * @private\n\t */\n\tgetBaseLength(): number {\n\t\tconst $$ = this;\n\t\tconst {width, height} = $$.state;\n\t\tconst cacheKey = KEY.bubbleBaseLength;\n\t\tlet baseLength = $$.cache.get(cacheKey);\n\n\t\tif (!baseLength) {\n\t\t\t$$.cache.add(cacheKey, baseLength = getMinMax(\"min\", [width, height]));\n\t\t}\n\n\t\treturn baseLength;\n\t},\n\n\t/**\n\t * Get the radius value for bubble circle\n\t * @param {object} d Data object\n\t * @returns {number}\n\t * @private\n\t */\n\tgetBubbleR(d): number {\n\t\tconst $$ = this;\n\t\tlet maxR = $$.config.bubble_maxR;\n\n\t\tif (isFunction(maxR)) {\n\t\t\tmaxR = maxR.bind($$.api)(d);\n\t\t} else if (!isNumber(maxR)) {\n\t\t\tmaxR = ($$.getBaseLength() / ($$.getMaxDataCount() * 2)) + 12;\n\t\t}\n\n\t\tconst max = getMinMax(\"max\", $$.getMinMaxData().max.map(d => (\n\t\t\t$$.isBubbleZType(d) ? $$.getBubbleZData(d.value, \"y\") : (\n\t\t\t\tisObject(d.value) ? d.value.mid : d.value\n\t\t\t)\n\t\t)));\n\t\tconst maxArea = maxR * maxR * Math.PI;\n\t\tconst area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, \"z\") : d.value) *\n\t\t\t(maxArea / max);\n\n\t\treturn Math.sqrt(area / Math.PI);\n\t},\n\n\t/**\n\t * Get bubble dimension data\n\t * @param {object|Array} d data value\n\t * @param {string} type - y or z\n\t * @returns {number}\n\t * @private\n\t */\n\tgetBubbleZData(d, type: \"y\" | \"z\"): number {\n\t\treturn isObject(d) ? d[type] : d[type === \"y\" ? 0 : 1];\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$CANDLESTICK, $COMMON} from \"../../config/classes\";\nimport {getRandom, isArray, isNumber, isObject} from \"../../module/util\";\nimport type {IOffset} from \"./shape\";\n\ninterface ICandlestickData {\n\topen: number;\n\thigh: number;\n\tlow: number;\n\tclose: number;\n\tvolume?: number;\n}\n\nexport default {\n\tinitCandlestick(): void {\n\t\tconst {$el} = this;\n\n\t\t$el.candlestick = $el.main.select(`.${$COMMON.chart}`)\n\t\t\t// should positioned at the beginning of the shape node to not overlap others\n\t\t\t.append(\"g\")\n\t\t\t.attr(\"class\", $CANDLESTICK.chartCandlesticks);\n\t},\n\n\t/**\n\t * Update targets by its data\n\t * called from: ChartInternal.updateTargets()\n\t * @param {Array} targets Filtered target by type\n\t * @private\n\t */\n\tupdateTargetsForCandlestick(targets): void {\n\t\tconst $$ = this;\n\t\tconst {$el} = $$;\n\t\tconst classChart = $$.getChartClass(\"Candlestick\");\n\n\t\tif (!$el.candlestick) {\n\t\t\t$$.initCandlestick();\n\t\t}\n\n\t\tconst mainUpdate = $$.$el.main.select(`.${$CANDLESTICK.chartCandlesticks}`)\n\t\t\t.selectAll(`.${$CANDLESTICK.chartCandlestick}`)\n\t\t\t.data($$.filterNullish(targets));\n\n\t\tmainUpdate.enter().append(\"g\")\n\t\t\t.attr(\"class\", classChart)\n\t\t\t.style(\"pointer-events\", \"none\");\n\t},\n\n\t/**\n\t * Generate/Update elements\n\t * @param {boolean} withTransition Transition for exit elements\n\t * @param {boolean} isSub Subchart draw\n\t * @private\n\t */\n\tupdateCandlestick(withTransition: boolean, isSub = false): void {\n\t\tconst $$ = this;\n\t\tconst {$el, $T} = $$;\n\t\tconst $root = isSub ? $el.subchart : $el;\n\t\tconst classSetter = $$.getClass(\"candlestick\", true);\n\t\tconst initialOpacity = $$.initialOpacity.bind($$);\n\n\t\tconst candlestick = $root.main.selectAll(`.${$CANDLESTICK.chartCandlestick}`)\n\t\t\t.selectAll(`.${$CANDLESTICK.candlestick}`)\n\t\t\t.data($$.labelishData.bind($$));\n\n\t\t$T(candlestick.exit(), withTransition)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\tconst candlestickEnter = candlestick.enter()\n\t\t\t.filter(d => d.value)\n\t\t\t.append(\"g\")\n\t\t\t.attr(\"class\", classSetter);\n\n\t\tcandlestickEnter.append(\"line\");\n\t\tcandlestickEnter.append(\"path\");\n\n\t\t$root.candlestick = candlestick.merge(candlestickEnter)\n\t\t\t.style(\"opacity\", initialOpacity);\n\t},\n\n\t/**\n\t * Get draw function\n\t * @param {object} indices Indice data\n\t * @param {boolean} isSub Subchart draw\n\t * @returns {Function}\n\t * @private\n\t */\n\tgenerateDrawCandlestick(indices, isSub) {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst getPoints = $$.generateGetCandlestickPoints(indices, isSub);\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst downColor = config.candlestick_color_down;\n\n\t\treturn (d, i, g) => {\n\t\t\tconst points = getPoints(d, i);\n\t\t\tconst value = $$.getCandlestickData(d);\n\t\t\tconst isUp = value?._isUp;\n\n\t\t\t// switch points if axis is rotated, not applicable for sub chart\n\t\t\tconst indexX = +isRotated;\n\t\t\tconst indexY = +!indexX;\n\n\t\t\tif (g.classed) {\n\t\t\t\tg.classed($CANDLESTICK[isUp ? \"valueUp\" : \"valueDown\"], true);\n\t\t\t}\n\n\t\t\tconst path = isRotated ?\n\t\t\t\t`H${points[1][1]} V${points[1][0]} H${points[0][1]}` :\n\t\t\t\t`V${points[1][1]} H${points[1][0]} V${points[0][1]}`;\n\n\t\t\tg.select(\"path\")\n\t\t\t\t.attr(\"d\", `M${points[0][indexX]},${points[0][indexY]}${path}z`)\n\t\t\t\t.style(\"fill\", d => {\n\t\t\t\t\tconst color = isUp ? $$.color(d) : (\n\t\t\t\t\t\tisObject(downColor) ? downColor[d.id] : downColor\n\t\t\t\t\t);\n\n\t\t\t\t\treturn color || $$.color(d);\n\t\t\t\t});\n\n\t\t\t// set line position\n\t\t\tconst line = g.select(\"line\");\n\t\t\tconst pos = isRotated ?\n\t\t\t\t{\n\t\t\t\t\tx1: points[2][1],\n\t\t\t\t\tx2: points[2][2],\n\t\t\t\t\ty1: points[2][0],\n\t\t\t\t\ty2: points[2][0]\n\t\t\t\t} :\n\t\t\t\t{\n\t\t\t\t\tx1: points[2][0],\n\t\t\t\t\tx2: points[2][0],\n\t\t\t\t\ty1: points[2][1],\n\t\t\t\t\ty2: points[2][2]\n\t\t\t\t};\n\n\t\t\tfor (const x in pos) {\n\t\t\t\tline.attr(x, pos[x]);\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t * Generate shape drawing points\n\t * @param {object} indices Indice data\n\t * @param {boolean} isSub Subchart draw\n\t * @returns {Function}\n\t */\n\tgenerateGetCandlestickPoints(indices, isSub = false): (d, i) => number[][] {\n\t\tconst $$ = this;\n\t\tconst axis = isSub ? $$.axis.subX : $$.axis.x;\n\t\tconst targetsNum = $$.getIndicesMax(indices) + 1;\n\t\tconst barW: IOffset = $$.getBarW(\"candlestick\", axis, targetsNum);\n\t\tconst x = $$.getShapeX(barW, indices, !!isSub);\n\t\tconst y = $$.getShapeY(!!isSub);\n\t\tconst shapeOffset = $$.getShapeOffset($$.isBarType, indices, !!isSub);\n\t\tconst yScale = $$.getYScaleById.bind($$);\n\n\t\treturn (d, i) => {\n\t\t\tconst y0 = yScale.call($$, d.id, isSub)($$.getShapeYMin(d.id));\n\t\t\tconst offset = shapeOffset(d, i) || y0; // offset is for stacked bar chart\n\t\t\tconst width = isNumber(barW) ? barW : barW[d.id] || barW._$width;\n\t\t\tconst value = $$.getCandlestickData(d);\n\t\t\tlet points;\n\n\t\t\tif (value && isNumber(value.open) && isNumber(value.close)) {\n\t\t\t\tconst posX = {\n\t\t\t\t\tstart: x(d),\n\t\t\t\t\tend: 0\n\t\t\t\t};\n\n\t\t\t\tposX.end = posX.start + width;\n\n\t\t\t\tconst posY = {\n\t\t\t\t\tstart: y(value.open),\n\t\t\t\t\tend: y(value.close)\n\t\t\t\t};\n\t\t\t\tconst posLine = {\n\t\t\t\t\tx: posX.start + (width / 2),\n\t\t\t\t\thigh: y(value.high),\n\t\t\t\t\tlow: y(value.low)\n\t\t\t\t};\n\n\t\t\t\tposY.start -= y0 - offset;\n\n\t\t\t\tpoints = [\n\t\t\t\t\t[posX.start, posY.start],\n\t\t\t\t\t[posX.end, posY.end],\n\t\t\t\t\t[posLine.x, posLine.low, posLine.high]\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tpoints = [[0, 0], [0, 0], [0, 0, 0]];\n\t\t\t}\n\n\t\t\treturn points;\n\t\t};\n\t},\n\n\t/**\n\t * Redraw function\n\t * @param {Function} drawFn Retuned functino from .generateDrawCandlestick()\n\t * @param {boolean} withTransition With or without transition\n\t * @param {boolean} isSub Subchart draw\n\t * @returns {Array}\n\t */\n\tredrawCandlestick(drawFn, withTransition?: boolean, isSub = false) {\n\t\tconst $$ = this;\n\t\tconst {$el, $T} = $$;\n\t\tconst {candlestick} = isSub ? $el.subchart : $el;\n\t\tconst rand = getRandom(true);\n\n\t\treturn [\n\t\t\tcandlestick\n\t\t\t\t.each(function(d, i) {\n\t\t\t\t\tconst g = $T(d3Select(this), withTransition, rand);\n\n\t\t\t\t\tdrawFn(d, i, g);\n\t\t\t\t})\n\t\t\t\t.style(\"opacity\", null)\n\t\t];\n\t},\n\n\t/**\n\t * Get candlestick data as object\n\t * @param {object} param Data object\n\t * @param {Array|object} param.value Data value\n\t * @returns {object|null} Converted data object\n\t * @private\n\t */\n\tgetCandlestickData({value}): ICandlestickData | null {\n\t\tlet d;\n\n\t\tif (isArray(value)) {\n\t\t\tconst [open, high, low, close, volume = false] = value;\n\n\t\t\td = {open, high, low, close};\n\n\t\t\tif (volume !== false) {\n\t\t\t\td.volume = volume;\n\t\t\t}\n\t\t} else if (isObject(value)) {\n\t\t\td = {...value};\n\t\t}\n\n\t\tif (d) {\n\t\t\td._isUp = d.close >= d.open;\n\t\t}\n\n\t\treturn d || null;\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$COMMON, $FUNNEL} from \"../../config/classes\";\nimport {isObject} from \"../../module/util\";\nimport type {IData, IDataRow, IFunnelData} from \"../data/IData\";\n\ntype TSize = { [key in \"width\" | \"height\" | \"top\" | \"left\"]: number };\ntype TSizeCurrent = Pick<TSize, \"width\" | \"height\">;\n\n/**\n * Get current size value\n * @param {boolean} checkNeck Determine if container width to not be less than neck width\n * @returns {object} size object\n * @private\n */\nfunction getSize(checkNeck = false): TSize {\n\tconst $$ = this;\n\tconst {config, state: {current: {width, height}}} = $$;\n\tconst padding = $$.getCurrentPadding();\n\n\tconst size = {\n\t\twidth: width - (padding.left + padding.right),\n\t\theight: height - (config.legend_show ? $$.getLegendHeight() + 10 : 0) -\n\t\t\t(padding.top + padding.bottom),\n\t\t...padding\n\t};\n\n\t// determine if container width to not be less than neck width\n\tif (checkNeck) {\n\t\tconst {width: neckWidth, height: neckHeight} = getNecklSize.call($$, {\n\t\t\twidth: size.width,\n\t\t\theight: size.height\n\t\t});\n\n\t\t// prevent neck size to not exceeed funnel size\n\t\tif (size.width < neckWidth) {\n\t\t\tsize.width = neckWidth;\n\t\t}\n\n\t\tif (size.height < neckHeight) {\n\t\t\tsize.height = neckHeight;\n\t\t}\n\t}\n\n\treturn size;\n}\n\n/**\n * Return neck size in pixels\n * @param {object} current Current size object\n * @returns {object} size object\n * @private\n */\nfunction getNecklSize(current: TSizeCurrent) {\n\tconst $$ = this;\n\tconst {config} = $$;\n\tlet width = config.funnel_neck_width;\n\tlet height = config.funnel_neck_height;\n\n\t[width, height] = [width, height].map((v, i) => {\n\t\tlet size = v;\n\n\t\tif (isObject(v)) {\n\t\t\tsize = current[i ? \"height\" : \"width\"] * v.ratio;\n\t\t}\n\n\t\treturn size;\n\t});\n\n\treturn {\n\t\twidth,\n\t\theight\n\t};\n}\n\n/**\n * Get coordinate points\n * @param {Array} d Data object\n * @returns {Array} Coordinate points\n * @private\n */\nfunction getCoord(d: IFunnelData[]) {\n\tconst $$ = this;\n\tconst {top, left, width} = getSize.call($$, true);\n\tconst coords: number[][][] = [];\n\n\td.forEach((d, i) => {\n\t\tconst {ratio} = d;\n\t\tconst y = i > 0 ? coords[i - 1][2][1] : top;\n\n\t\t// (M)(4) ------------> (1)\n\t\t//   ˄                   |\n\t\t//   |                   |\n\t\t//   |                   ˅\n\t\t//  (3) <-------------- (2)\n\t\tcoords.push(d.coords = [\n\t\t\t[left, y], // M\n\t\t\t[left + width, y], // 1\n\t\t\t[left + width, i > 0 ? ratio + y : ratio + top], // 2\n\t\t\t[left, i > 0 ? ratio + y : ratio + top], // 3\n\t\t\t[left, y] // 4\n\t\t]);\n\t});\n\n\treturn coords;\n}\n\n/**\n * Get clip path\n * @param {boolean} forBackground Determine if clip path for background\n * @returns {string} path\n * @private\n */\nfunction getClipPath(forBackground = false): string {\n\tconst $$ = this;\n\tconst {width, height, top, left} = getSize.call($$, true);\n\tconst neck = getNecklSize.call($$, {width, height});\n\tconst leftX = (width - neck.width) / 2;\n\tconst rightX = (width + neck.width) / 2;\n\tconst bodyHeigth = height - neck.height;\n\n\tconst coords = [\n\t\t[0, 0], // M\n\t\t[width, 0], // 1\n\t\t[rightX, bodyHeigth], // 2\n\t\t[rightX, height], // 3\n\t\t[leftX, height], // 4\n\t\t[leftX, bodyHeigth], // 5\n\t\t[0, 0] // 6\n\t];\n\n\tif (forBackground) {\n\t\tcoords.forEach(d => {\n\t\t\td[0] += left;\n\t\t\td[1] += top;\n\t\t});\n\t}\n\n\treturn `M${coords.join(\"L\")}z`;\n}\n\n/**\n * Get funnel data\n * @param {object} d data object\n * @returns {Array}\n * @private\n */\nfunction getFunnelData(d: IData[]): IFunnelData[] {\n\tconst $$ = this;\n\tconst {config} = $$;\n\tconst data: IFunnelData[] = d.map(d => ({\n\t\tid: d.id,\n\t\tvalue: d.values.reduce((a, b) => a + <number>b.value, 0)\n\t}));\n\n\tif (config.data_order) {\n\t\tdata.sort($$.getSortCompareFn.bind($$)(true));\n\t}\n\n\treturn updateRatio.call($$, data);\n}\n\n/**\n * Update ratio value\n * @param {Array} data Data object\n * @returns {Array} Updated data object\n * @private\n */\nfunction updateRatio(data: IFunnelData[]): IFunnelData[] {\n\tconst $$ = this;\n\tconst {height} = getSize.call($$);\n\tconst total = $$.getTotalDataSum(true);\n\n\tdata.forEach(d => {\n\t\t// ratio = shape's height\n\t\td.ratio = (d.value / total) * height;\n\t});\n\n\treturn data;\n}\n\nexport default {\n\t/**\n\t * Initialize polar\n\t * @private\n\t */\n\tinitFunnel(): void {\n\t\tconst $$ = this;\n\t\tconst {$el} = $$;\n\n\t\t$el.funnel = $el.main.select(`.${$COMMON.chart}`)\n\t\t\t.append(\"g\")\n\t\t\t.classed($FUNNEL.chartFunnels, true);\n\n\t\t// define background to prevent shape overflow\n\t\t$el.funnel.background = $el.funnel.append(\"path\")\n\t\t\t.classed($FUNNEL.funnelBackground, true);\n\n\t\t$$.bindFunnelEvent();\n\t},\n\n\t/**\n\t * Bind events\n\t * @private\n\t */\n\tbindFunnelEvent(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {funnel}, config, state} = $$;\n\t\tconst getTarget = event => {\n\t\t\tconst target = event.isTrusted ? event.target : state.eventReceiver.rect?.node();\n\t\t\tlet data;\n\n\t\t\tif (/^path$/i.test(target.tagName)) {\n\t\t\t\tstate.event = event;\n\t\t\t\tdata = d3Select(target).datum();\n\t\t\t}\n\n\t\t\treturn data;\n\t\t};\n\n\t\tif (config.interaction_enabled) {\n\t\t\tconst isTouch = state.inputType === \"touch\";\n\n\t\t\tfunnel\n\t\t\t\t.on(isTouch ? \"touchstart\" : \"mouseover mousemove\", event => {\n\t\t\t\t\tconst data = getTarget(event);\n\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\t$$.showTooltip([data], event.target);\n\t\t\t\t\t\t/^(touchstart|mouseover)$/.test(event.type) && $$.setOverOut(true, data);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.on(isTouch ? \"touchend\" : \"mouseout\", event => {\n\t\t\t\t\tconst data = getTarget(event);\n\n\t\t\t\t\tif (config.interaction_onout) {\n\t\t\t\t\t\t$$.hideTooltip();\n\t\t\t\t\t\t$$.setOverOut(false, data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Update polar based on given data array\n\t * @param {object} t Data object\n\t * @private\n\t */\n\tupdateTargetsForFunnel(t: IData[]): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {funnel}} = $$;\n\t\tconst classChartFunnel = $$.getChartClass(\"Funnel\");\n\t\tconst classFunnel = $$.getClass(\"funnel\", true);\n\n\t\tif (!funnel) {\n\t\t\t$$.initFunnel();\n\t\t}\n\n\t\tconst targets = getFunnelData.call($$, t.filter($$.isFunnelType.bind($$)));\n\n\t\tconst mainFunnelUpdate = funnel\n\t\t\t.selectAll(`.${$FUNNEL.chartFunnel}`)\n\t\t\t.data($$.filterNullish(targets));\n\n\t\tmainFunnelUpdate.exit().remove();\n\n\t\tconst mainFunnelEnter = mainFunnelUpdate\n\t\t\t.enter()\n\t\t\t.insert(\"g\", `.${$FUNNEL.funnelBackground}`);\n\n\t\tmainFunnelEnter\n\t\t\t.append(\"path\");\n\n\t\tfunnel.path = mainFunnelEnter\n\t\t\t.merge(mainFunnelUpdate)\n\t\t\t.attr(\"class\", d => classChartFunnel(d))\n\t\t\t.select(\"path\")\n\t\t\t.attr(\"class\", classFunnel)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.style(\"fill\", $$.color);\n\t},\n\n\t/**\n\t * Update funnel path selection\n\t * @param {object} targets Updated target data\n\t * @private\n\t */\n\tupdateFunnel(targets: IData[]): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {funnel}} = $$;\n\t\tconst targetIds = targets.map(({id}) => id);\n\n\t\tfunnel.path = funnel.path.filter(d => targetIds.indexOf(d.id) >= 0);\n\t},\n\n\t/**\n\t * Generate treemap coordinate points data\n\t * @returns {Array} Array of coordinate points\n\t * @private\n\t */\n\tgenerateGetFunnelPoints(): (d: IDataRow) => [number, number][] {\n\t\tconst $$ = this;\n\t\tconst {$el: {funnel}} = $$;\n\t\tconst targets = $$.filterTargetsToShow(funnel.path);\n\t\tconst {top, left, right} = getSize.call($$);\n\t\tconst center = (left - right) / 2;\n\t\tconst points = {};\n\t\tlet accumulatedHeight = top ?? 0;\n\n\t\ttargets.each((d, i) => {\n\t\t\tpoints[d.id] = [\n\t\t\t\t[center, accumulatedHeight],\n\t\t\t\t[center, accumulatedHeight += (targets?.[i] ?? d).ratio]\n\t\t\t];\n\t\t});\n\n\t\treturn d => points[d.id];\n\t},\n\n\t/**\n\t * Called whenever redraw happens\n\t * @private\n\t */\n\tredrawFunnel(): void {\n\t\tconst $$ = this;\n\t\tconst {$T, $el: {funnel}} = $$;\n\t\tconst targets = $$.filterTargetsToShow(funnel.path);\n\t\tconst coords = getCoord.call($$, updateRatio.call($$, targets.data()));\n\n\t\t// set neck path\n\t\tfunnel.attr(\"clip-path\", `path('${getClipPath.bind($$)()}')`);\n\t\tfunnel.background.attr(\"d\", getClipPath.call($$, true));\n\n\t\t$T(targets)\n\t\t\t.attr(\"d\", (d, i) => `M${coords[i].join(\"L\")}z`)\n\t\t\t.style(\"opacity\", \"1\");\n\n\t\tfunnel.selectAll(\"g\").style(\"opacity\", null);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$ARC, $COMMON, $GAUGE} from \"../../config/classes\";\nimport {isFunction} from \"../../module/util\";\n\nexport default {\n\tinitGauge(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {arcs}} = $$;\n\t\tconst appendText = (className = <null | string>null, value = \"\") => {\n\t\t\tarcs.append(\"text\")\n\t\t\t\t.attr(\"class\", className)\n\t\t\t\t.style(\"text-anchor\", \"middle\")\n\t\t\t\t.style(\"pointer-events\", \"none\")\n\t\t\t\t.text(value);\n\t\t};\n\n\t\tif ($$.hasType(\"gauge\")) {\n\t\t\tconst hasMulti = $$.hasMultiArcGauge();\n\n\t\t\tarcs.append(hasMulti ? \"g\" : \"path\")\n\t\t\t\t.attr(\"class\", $ARC.chartArcsBackground)\n\t\t\t\t.style(\"fill\", (!hasMulti && config.gauge_background) || null);\n\n\t\t\tconfig.gauge_units && appendText($GAUGE.chartArcsGaugeUnit);\n\n\t\t\t// append min/max value text\n\t\t\tif (config.gauge_label_show) {\n\t\t\t\tappendText($GAUGE.chartArcsGaugeMin);\n\t\t\t\t!config.gauge_fullCircle && appendText($GAUGE.chartArcsGaugeMax);\n\t\t\t}\n\t\t}\n\t},\n\n\tupdateGaugeMax(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state} = $$;\n\t\tconst hasMultiGauge = $$.hasMultiArcGauge();\n\n\t\t// to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value\n\t\tconst max = hasMultiGauge ?\n\t\t\t$$.getMinMaxData().max[0].value :\n\t\t\t$$.getTotalDataSum(state.rendered);\n\n\t\t// if gauge_max less than max, make max to max value\n\t\tif (\n\t\t\t!config.gauge_enforceMinMax && (\n\t\t\t\tmax + config.gauge_min * (config.gauge_min > 0 ? -1 : 1) > config.gauge_max\n\t\t\t)\n\t\t) {\n\t\t\tconfig.gauge_max = max - config.gauge_min;\n\t\t}\n\t},\n\n\tredrawArcGaugeLine(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el} = $$;\n\t\tconst {hiddenTargetIds} = $$.state;\n\n\t\tconst arcLabelLines = $el.main.selectAll(`.${$ARC.arcs}`)\n\t\t\t.selectAll(`.${$ARC.arcLabelLine}`)\n\t\t\t.data($$.arcData.bind($$));\n\n\t\tconst mainArcLabelLine = arcLabelLines.enter()\n\t\t\t.append(\"rect\")\n\t\t\t.attr(\"class\",\n\t\t\t\td => `${$ARC.arcLabelLine} ${$COMMON.target} ${$COMMON.target}-${d.data.id}`)\n\t\t\t.merge(arcLabelLines);\n\n\t\tmainArcLabelLine\n\t\t\t.style(\"fill\",\n\t\t\t\td => ($$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data)))\n\t\t\t.style(\"display\", config.gauge_label_show ? null : \"none\")\n\t\t\t.each(function(d) {\n\t\t\t\tlet lineLength = 0;\n\t\t\t\tconst lineThickness = 2;\n\t\t\t\tlet x = 0;\n\t\t\t\tlet y = 0;\n\t\t\t\tlet transform = \"\";\n\n\t\t\t\tif (hiddenTargetIds.indexOf(d.data.id) < 0) {\n\t\t\t\t\tconst updated = $$.updateAngle(d);\n\t\t\t\t\tconst innerLineLength = state.gaugeArcWidth /\n\t\t\t\t\t\t$$.filterTargetsToShow($$.data.targets).length *\n\t\t\t\t\t\t(updated.index + 1);\n\t\t\t\t\tconst lineAngle = updated.endAngle - Math.PI / 2;\n\t\t\t\t\tconst arcInnerRadius = state.radius - innerLineLength;\n\t\t\t\t\tconst linePositioningAngle = lineAngle -\n\t\t\t\t\t\t(arcInnerRadius === 0 ? 0 : (1 / arcInnerRadius));\n\n\t\t\t\t\tlineLength = state.radiusExpanded - state.radius + innerLineLength;\n\t\t\t\t\tx = Math.cos(linePositioningAngle) * arcInnerRadius;\n\t\t\t\t\ty = Math.sin(linePositioningAngle) * arcInnerRadius;\n\t\t\t\t\ttransform = `rotate(${lineAngle * 180 / Math.PI}, ${x}, ${y})`;\n\t\t\t\t}\n\n\t\t\t\td3Select(this)\n\t\t\t\t\t.attr(\"x\", x)\n\t\t\t\t\t.attr(\"y\", y)\n\t\t\t\t\t.attr(\"width\", lineLength)\n\t\t\t\t\t.attr(\"height\", lineThickness)\n\t\t\t\t\t.attr(\"transform\", transform)\n\t\t\t\t\t.style(\"stroke-dasharray\", `0, ${lineLength + lineThickness}, 0`);\n\t\t\t});\n\t},\n\n\ttextForGaugeMinMax(value: number, isMax?: boolean): number | string {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst format = config.gauge_label_extents;\n\n\t\treturn isFunction(format) ? format.bind($$.api)(value, isMax) : value;\n\t},\n\n\tgetGaugeLabelHeight(): 20 | 0 {\n\t\tconst {config} = this;\n\n\t\treturn this.config.gauge_label_show && !config.gauge_fullCircle ? 20 : 0;\n\t},\n\n\tgetPaddingBottomForGauge() {\n\t\tconst $$ = this;\n\n\t\treturn $$.getGaugeLabelHeight() * ($$.config.gauge_label_show ? 2 : 2.5);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {line as d3Line} from \"d3-shape\";\nimport {$COMMON, $LINE} from \"../../config/classes\";\nimport {\n\tgetPointer,\n\tgetRandom,\n\tisArray,\n\tisDefined,\n\tisUndefined,\n\tisValue,\n\tparseDate\n} from \"../../module/util\";\nimport type {IDataRow} from \"../data/IData\";\nimport {getScale} from \"../internals/scale\";\n\n/**\n * Get stroke dasharray style value\n * @param {number} start Start position in path length\n * @param {number} end End position in path length\n * @param {Array} pattern Dash array pattern\n * @param {boolean} isLastX Weather is last x tick\n * @returns {object} Stroke dasharray style value and its length\n * @private\n */\nfunction getStrokeDashArray(start: number, end: number, pattern: [number, number],\n\tisLastX = false): {dash: string, length: number} {\n\tconst dash = start ? [start, 0] : pattern;\n\n\tfor (let i = start ? start : pattern.reduce((a, c) => a + c); i <= end;) {\n\t\tpattern.forEach(v => {\n\t\t\tif (i + v <= end) {\n\t\t\t\tdash.push(v);\n\t\t\t}\n\n\t\t\ti += v;\n\t\t});\n\t}\n\n\t// make sure to have even length\n\tdash.length % 2 !== 0 && dash.push(isLastX ? pattern[1] : 0);\n\n\treturn {\n\t\tdash: dash.join(\" \"),\n\t\tlength: dash.reduce((a, b) => a + b, 0)\n\t};\n}\n\n/**\n * Get regions data\n * @param {Array} d Data object\n * @param {object} _regions regions to be set\n * @param {boolean} isTimeSeries whether is time series\n * @returns {object} Regions data\n * @private\n */\nfunction getRegions(d, _regions, isTimeSeries) {\n\tconst $$ = this;\n\tconst regions: {start: number | string, end: number | string, style: string}[] = [];\n\tconst dasharray = \"2 2\"; // default value\n\n\t// Check start/end of regions\n\tif (isDefined(_regions)) {\n\t\tconst getValue = (v: Date | any, def: number | Date): Date | any => (\n\t\t\tisUndefined(v) ? def : (isTimeSeries ? parseDate.call($$, v) : v)\n\t\t);\n\n\t\tfor (let i = 0, reg; (reg = _regions[i]); i++) {\n\t\t\tconst start = getValue(reg.start, d[0].x);\n\t\t\tconst end = getValue(reg.end, d[d.length - 1].x);\n\t\t\tconst style = reg.style || {dasharray};\n\n\t\t\tregions[i] = {start, end, style};\n\t\t}\n\t}\n\n\treturn regions;\n}\n\nexport default {\n\tinitLine(): void {\n\t\tconst {$el} = this;\n\n\t\t$el.line = $el.main.select(`.${$COMMON.chart}`).append(\"g\")\n\t\t\t.attr(\"class\", $LINE.chartLines)\n\t\t\t.call(this.setCssRule(false, `.${$LINE.chartLines}`, [\"pointer-events:none\"]));\n\t},\n\n\tupdateTargetsForLine(t): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {area, line, main}} = $$;\n\t\tconst classChartLine = $$.getChartClass(\"Line\");\n\t\tconst classLines = $$.getClass(\"lines\", true);\n\t\tconst classFocus = $$.classFocus.bind($$);\n\n\t\tif (!line) {\n\t\t\t$$.initLine();\n\t\t}\n\n\t\tconst targets = t.filter(d => !($$.isScatterType(d) || $$.isBubbleType(d)));\n\n\t\tconst mainLineUpdate = main.select(`.${$LINE.chartLines}`)\n\t\t\t.selectAll(`.${$LINE.chartLine}`)\n\t\t\t.data($$.filterNullish(targets))\n\t\t\t.attr(\"class\", d => classChartLine(d) + classFocus(d));\n\n\t\tconst mainLineEnter = mainLineUpdate.enter().append(\"g\")\n\t\t\t.attr(\"class\", classChartLine)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.style(\"pointer-events\", $$.getStylePropValue(\"none\"));\n\n\t\t// Lines for each data\n\t\tmainLineEnter.append(\"g\")\n\t\t\t.attr(\"class\", classLines);\n\n\t\t// Areas\n\t\tif ($$.hasTypeOf(\"Area\")) {\n\t\t\tconst mainLine = (\n\t\t\t\t!area && mainLineEnter.empty() ? mainLineUpdate : mainLineEnter\n\t\t\t).filter($$.isAreaType.bind($$));\n\n\t\t\t$$.initArea(mainLine);\n\t\t}\n\n\t\t$$.updateTargetForCircle(targets, mainLineEnter);\n\t},\n\n\t/**\n\t * Generate/Update elements\n\t * @param {boolean} withTransition Transition for exit elements\n\t * @param {boolean} isSub Subchart draw\n\t * @private\n\t */\n\tupdateLine(withTransition: boolean, isSub = false): void {\n\t\tconst $$ = this;\n\t\tconst {format: {extraLineClasses}, $el, $T} = $$;\n\t\tconst $root = isSub ? $el.subchart : $el;\n\n\t\tconst line = $root.main\n\t\t\t.selectAll(`.${$LINE.lines}`)\n\t\t\t.selectAll(`.${$LINE.line}`)\n\t\t\t.data($$.lineData.bind($$));\n\n\t\t$T(line.exit(), withTransition)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\t$root.line = line.enter()\n\t\t\t.append(\"path\")\n\t\t\t.attr(\"class\", d => `${$$.getClass(\"line\", true)(d)} ${extraLineClasses(d) || \"\"}`)\n\t\t\t.style(\"stroke\", $$.color)\n\t\t\t.merge(line)\n\t\t\t.style(\"opacity\", $$.initialOpacity.bind($$))\n\t\t\t.attr(\"transform\", null);\n\t},\n\n\t/**\n\t * Redraw function\n\t * @param {Function} drawFn Retuned functino from .generateDrawCandlestick()\n\t * @param {boolean} withTransition With or without transition\n\t * @param {boolean} isSub Subchart draw\n\t * @returns {Array}\n\t * @private\n\t */\n\tredrawLine(drawFn, withTransition?: boolean, isSub = false) {\n\t\tconst $$ = this;\n\t\tconst {$el, $T} = $$;\n\t\tconst {line} = isSub ? $el.subchart : $el;\n\n\t\treturn [\n\t\t\t$T(line, withTransition, getRandom())\n\t\t\t\t.attr(\"d\", drawFn)\n\t\t\t\t.style(\"stroke\", this.color)\n\t\t\t\t.style(\"opacity\", null)\n\t\t];\n\t},\n\n\t/**\n\t * Get the curve interpolate\n\t * @param {Array} d Data object\n\t * @returns {Function}\n\t * @private\n\t */\n\tgetCurve(d): Function {\n\t\tconst $$ = this;\n\t\tconst isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);\n\n\t\t// when is step & rotated, should be computed in different way\n\t\t// https://github.com/naver/billboard.js/issues/471\n\t\treturn isRotatedStepType ?\n\t\t\tcontext => {\n\t\t\t\tconst step = $$.getInterpolate(d)(context);\n\n\t\t\t\t// keep the original method\n\t\t\t\tstep.orgPoint = step.point;\n\n\t\t\t\t// to get rotated path data\n\t\t\t\tstep.pointRotated = function(x, y) {\n\t\t\t\t\tthis._point === 1 && (this._point = 2);\n\n\t\t\t\t\tconst y1 = this._y * (1 - this._t) + y * this._t;\n\n\t\t\t\t\tthis._context.lineTo(this._x, y1);\n\t\t\t\t\tthis._context.lineTo(x, y1);\n\n\t\t\t\t\tthis._x = x;\n\t\t\t\t\tthis._y = y;\n\t\t\t\t};\n\n\t\t\t\tstep.point = function(x, y) {\n\t\t\t\t\tthis._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);\n\t\t\t\t};\n\n\t\t\t\treturn step;\n\t\t\t} :\n\t\t\t$$.getInterpolate(d);\n\t},\n\n\tgenerateDrawLine(lineIndices, isSub?: boolean): (d) => string {\n\t\tconst $$ = this;\n\t\tconst {config, scale} = $$;\n\t\tconst lineConnectNull = config.line_connectNull;\n\t\tconst isRotated = config.axis_rotated;\n\n\t\tconst getPoints = $$.generateGetLinePoints(lineIndices, isSub);\n\t\tconst yScale = $$.getYScaleById.bind($$);\n\n\t\tconst xValue = d => (isSub ? $$.subxx : $$.xx).call($$, d);\n\t\tconst yValue = (d, i) => (\n\t\t\t$$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.getBaseValue(d))\n\t\t);\n\n\t\tlet line = d3Line();\n\n\t\tline = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);\n\n\t\tif (!lineConnectNull) {\n\t\t\tline = line.defined(d => $$.getBaseValue(d) !== null);\n\t\t}\n\n\t\tconst x = isSub ? scale.subX : scale.x;\n\n\t\treturn d => {\n\t\t\tconst y = yScale(d.id, isSub);\n\t\t\tlet values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values;\n\n\t\t\tlet x0 = 0;\n\t\t\tlet y0 = 0;\n\t\t\tlet path;\n\n\t\t\tif ($$.isLineType(d)) {\n\t\t\t\tconst regions = config.data_regions[d.id];\n\n\t\t\t\tif (regions) {\n\t\t\t\t\tif ($$.isAreaRangeType(d)) {\n\t\t\t\t\t\tvalues = values.map(dv => ({...dv, value: $$.getRangedData(dv, \"mid\")}));\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = $$.lineWithRegions(values, scale.zoom || x, y, regions);\n\t\t\t\t} else {\n\t\t\t\t\tif ($$.isStepType(d)) {\n\t\t\t\t\t\tvalues = $$.convertValuesToStep(values);\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = line.curve($$.getCurve(d))(values);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (values[0]) {\n\t\t\t\t\tx0 = x(values[0].x);\n\t\t\t\t\ty0 = y(values[0].value);\n\t\t\t\t}\n\n\t\t\t\tpath = isRotated ? `M ${y0} ${x0}` : `M ${x0} ${y0}`;\n\t\t\t}\n\n\t\t\treturn path || \"M 0 0\";\n\t\t};\n\t},\n\n\t/**\n\t * Set regions dasharray and get path\n\t * @param {Array} d Data object\n\t * @param {Function} x x scale function\n\t * @param {Function} y y scale function\n\t * @param {object} _regions regions to be set\n\t * @returns {stirng} Path string\n\t * @private\n\t */\n\tlineWithRegions(d: IDataRow[], x, y, _regions): string {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst isRotated = config.axis_rotated;\n\t\tconst isTimeSeries = $$.axis.isTimeSeries();\n\t\tconst dasharray = \"2 2\"; // default value\n\t\tconst regions = getRegions.bind($$)(d, _regions, isTimeSeries);\n\n\t\t// when contains null data, can't apply style dashed\n\t\tconst hasNullDataValue = $$.hasNullDataValue(d);\n\n\t\tlet xp;\n\t\tlet yp;\n\t\tlet diff;\n\t\tlet diffx2;\n\n\t\t// Set scales\n\t\tconst xValue = isRotated ? dt => y(dt.value) : dt => x(dt.x);\n\t\tconst yValue = isRotated ? dt => x(dt.x) : dt => y(dt.value);\n\n\t\t// Define svg generator function for region\n\t\tconst generateM = points =>\n\t\t\t`M${points[0][0]},${points[0][1]}L${points[1][0]},${points[1][1]}`;\n\t\tconst sWithRegion = isTimeSeries ?\n\t\t\t(d0, d1, k, timeseriesDiff) => {\n\t\t\t\tconst x0 = d0.x.getTime();\n\t\t\t\tconst xDiff = d1.x - d0.x;\n\t\t\t\tconst xv0 = new Date(x0 + xDiff * k);\n\t\t\t\tconst xv1 = new Date(x0 + xDiff * (k + timeseriesDiff));\n\n\t\t\t\tconst points = isRotated ?\n\t\t\t\t\t[[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] :\n\t\t\t\t\t[[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];\n\n\t\t\t\treturn generateM(points);\n\t\t\t} :\n\t\t\t(d0, d1, k, otherDiff) => {\n\t\t\t\tconst x0 = x(d1.x, !isRotated);\n\t\t\t\tconst y0 = y(d1.value, isRotated);\n\n\t\t\t\tconst gap = k + otherDiff;\n\t\t\t\tconst xValue = x(xp(k), !isRotated);\n\t\t\t\tconst yValue = y(yp(k), isRotated);\n\n\t\t\t\tlet xDiff = x(xp(gap), !isRotated);\n\t\t\t\tlet yDiff = y(yp(gap), isRotated);\n\n\t\t\t\t// fix diff values not to overflow\n\t\t\t\tif (xDiff > x0) {\n\t\t\t\t\txDiff = x0;\n\t\t\t\t}\n\n\t\t\t\tif (d0.value > d1.value && (isRotated ? yDiff < y0 : yDiff > y0)) {\n\t\t\t\t\tyDiff = y0;\n\t\t\t\t}\n\n\t\t\t\tconst points = [\n\t\t\t\t\t[xValue, yValue],\n\t\t\t\t\t[xDiff, yDiff]\n\t\t\t\t];\n\n\t\t\t\tisRotated && points.forEach(v => v.reverse());\n\n\t\t\t\treturn generateM(points);\n\t\t\t};\n\n\t\t// Generate\n\t\tconst axisType = {x: $$.axis.getAxisType(\"x\"), y: $$.axis.getAxisType(\"y\")};\n\t\tlet path = \"\";\n\n\t\t// clone the line path to be used to get length value\n\t\tconst target = $$.$el.line.filter(({id}) => id === d[0].id);\n\t\tconst tempNode = target.clone().style(\"display\", \"none\");\n\t\tconst getLength = (node, path) => node.attr(\"d\", path).node().getTotalLength();\n\t\tconst dashArray = {\n\t\t\tdash: <string[]>[],\n\t\t\tlastLength: 0\n\t\t};\n\t\tlet isLastX = false;\n\n\t\tfor (let i = 0, data; (data = d[i]); i++) {\n\t\t\tconst prevData = d[i - 1];\n\t\t\tconst hasPrevData = prevData && isValue(prevData.value);\n\t\t\tlet style = $$.isWithinRegions(data.x, regions);\n\n\t\t\t// https://github.com/naver/billboard.js/issues/1172\n\t\t\tif (!isValue(data.value)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Draw as normal\n\t\t\tif (isUndefined(regions) || !style || !hasPrevData) {\n\t\t\t\tpath += `${i && hasPrevData ? \"L\" : \"M\"}${xValue(data)},${yValue(data)}`;\n\t\t\t} else if (hasPrevData) {\n\t\t\t\tstyle = (style?.dasharray || dasharray).split(\" \").map(Number);\n\n\t\t\t\t// Draw with region // TODO: Fix for horizotal charts\n\t\t\t\txp = getScale(axisType.x, prevData.x, data.x);\n\t\t\t\typ = getScale(axisType.y, prevData.value, data.value);\n\n\t\t\t\t// when it contains null data, dash can't be applied with style\n\t\t\t\tif (hasNullDataValue) {\n\t\t\t\t\tconst dx = x(data.x) - x(prevData.x);\n\t\t\t\t\tconst dy = y(data.value) - y(prevData.value);\n\t\t\t\t\tconst dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n\n\t\t\t\t\tdiff = style[0] / dd; // dash\n\t\t\t\t\tdiffx2 = diff * style[1]; // gap\n\n\t\t\t\t\tfor (let j = diff; j <= 1; j += diffx2) {\n\t\t\t\t\t\tpath += sWithRegion(prevData, data, j, diff);\n\n\t\t\t\t\t\t// to make sure correct line drawing\n\t\t\t\t\t\tif (j + diffx2 >= 1) {\n\t\t\t\t\t\t\tpath += sWithRegion(prevData, data, 1, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet points = <number[][]>[];\n\t\t\t\t\tisLastX = data.x === d[d.length - 1].x;\n\n\t\t\t\t\tif (isTimeSeries) {\n\t\t\t\t\t\tconst x0 = +prevData.x;\n\t\t\t\t\t\tconst xv0 = new Date(x0);\n\t\t\t\t\t\tconst xv1 = new Date(x0 + (+data.x - x0));\n\n\t\t\t\t\t\tpoints = [\n\t\t\t\t\t\t\t[x(xv0), y(yp(0))], // M\n\t\t\t\t\t\t\t[x(xv1), y(yp(1))] // L\n\t\t\t\t\t\t];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints = [\n\t\t\t\t\t\t\t[x(xp(0)), y(yp(0))], // M\n\t\t\t\t\t\t\t[x(xp(1)), y(yp(1))] // L\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\n\t\t\t\t\tisRotated && points.forEach(v => v.reverse());\n\n\t\t\t\t\tconst startLength = getLength(tempNode, path);\n\t\t\t\t\tconst endLength = getLength(tempNode, path += `L${points[1].join(\",\")}`);\n\n\t\t\t\t\tconst strokeDashArray = getStrokeDashArray(\n\t\t\t\t\t\tstartLength - dashArray.lastLength,\n\t\t\t\t\t\tendLength - dashArray.lastLength,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tisLastX\n\t\t\t\t\t);\n\n\t\t\t\t\tdashArray.lastLength += strokeDashArray.length;\n\t\t\t\t\tdashArray.dash.push(strokeDashArray.dash);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dashArray.dash.length) {\n\t\t\t// if not last x tick, then should draw rest of path that is not drawn yet\n\t\t\t!isLastX && dashArray.dash.push(getLength(tempNode, path));\n\n\t\t\ttempNode.remove();\n\t\t\ttarget.attr(\"stroke-dasharray\", dashArray.dash.join(\" \"));\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tisWithinRegions(withinX, withinRegions): boolean {\n\t\tfor (let i = 0, reg; (reg = withinRegions[i]); i++) {\n\t\t\tif (reg.start < withinX && withinX <= reg.end) {\n\t\t\t\treturn reg.style;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tisWithinStep(that, y: number): boolean {\n\t\treturn Math.abs(y - getPointer(this.state.event, that)[1]) < 30;\n\t},\n\n\tshouldDrawPointsForLine(d): boolean {\n\t\tconst linePoint = this.config.line_point;\n\n\t\treturn linePoint === true ||\n\t\t\t(isArray(linePoint) && linePoint.indexOf(d.id) !== -1);\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport type {d3Selection} from \"../../../types/types\";\nimport {$CIRCLE, $COMMON, $SELECT} from \"../../config/classes\";\nimport {\n\tgetBBox,\n\tgetBoundingRect,\n\tgetPointer,\n\tgetRandom,\n\tisFunction,\n\tisObject,\n\tisUndefined,\n\tisValue\n} from \"../../module/util\";\nimport type {IDataPoint, IDataRow} from \"../data/IData\";\n\nconst getTransitionName = () => getRandom();\n\nexport default {\n\tinitialOpacityForCircle(d): string | number | null {\n\t\tconst {config, state: {withoutFadeIn}} = this;\n\t\tlet opacity = config.point_opacity;\n\n\t\tif (isUndefined(opacity)) {\n\t\t\topacity = this.getBaseValue(d) !== null &&\n\t\t\t\t\twithoutFadeIn[d.id] ?\n\t\t\t\tthis.opacityForCircle(d) :\n\t\t\t\t\"0\";\n\t\t}\n\n\t\treturn opacity;\n\t},\n\n\topacityForCircle(d): string | number | null {\n\t\tconst {config} = this;\n\t\tlet opacity = config.point_opacity;\n\n\t\tif (isUndefined(opacity)) {\n\t\t\topacity = config.point_show && !this.isPointFocusOnly?.() ? null : \"0\";\n\n\t\t\topacity = isValue(this.getBaseValue(d)) ?\n\t\t\t\t(this.isBubbleType(d) || this.isScatterType(d) ? \"0.5\" : opacity) :\n\t\t\t\t\"0\";\n\t\t}\n\n\t\treturn opacity;\n\t},\n\n\tinitCircle(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {main}} = $$;\n\n\t\t!$$.point && ($$.point = $$.generatePoint());\n\n\t\tif (\n\t\t\t($$.hasType(\"bubble\") || $$.hasType(\"scatter\")) &&\n\t\t\tmain.select(`.${$COMMON.chart} > .${$CIRCLE.chartCircles}`).empty()\n\t\t) {\n\t\t\tmain.select(`.${$COMMON.chart}`)\n\t\t\t\t.append(\"g\")\n\t\t\t\t.attr(\"class\", $CIRCLE.chartCircles);\n\t\t}\n\t},\n\n\tupdateTargetForCircle(targetsValue, enterNodeValue): void {\n\t\tconst $$ = this;\n\t\tconst {config, data, $el} = $$;\n\t\tconst selectionEnabled = config.interaction_enabled && config.data_selection_enabled;\n\t\tconst isSelectable = selectionEnabled && config.data_selection_isselectable;\n\t\tconst classCircles = $$.getClass(\"circles\", true);\n\n\t\tif (!config.point_show) {\n\t\t\treturn;\n\t\t}\n\n\t\t$$.initCircle();\n\n\t\tlet targets = targetsValue;\n\t\tlet enterNode = enterNodeValue;\n\n\t\t// only for scatter & bubble type should generate seprate <g> node\n\t\tif (!targets) {\n\t\t\ttargets = $$.filterNullish(data.targets)\n\t\t\t\t.filter(d => this.isScatterType(d) || this.isBubbleType(d));\n\n\t\t\tconst mainCircle = $el.main.select(`.${$CIRCLE.chartCircles}`)\n\t\t\t\t.style(\"pointer-events\", \"none\")\n\t\t\t\t.selectAll(`.${$CIRCLE.circles}`)\n\t\t\t\t.data(targets);\n\n\t\t\tmainCircle.exit().remove();\n\t\t\tenterNode = mainCircle.enter();\n\t\t}\n\n\t\t// Circles for each data point on lines\n\t\tselectionEnabled && enterNode.append(\"g\")\n\t\t\t.attr(\"class\", d => $$.generateClass($SELECT.selectedCircles, d.id));\n\n\t\tenterNode.append(\"g\")\n\t\t\t.attr(\"class\", classCircles)\n\t\t\t.call(selection => {\n\t\t\t\t$$.setCssRule(true, `.${$CIRCLE.circles}`, [\"cursor:pointer\"], isSelectable)(\n\t\t\t\t\tselection\n\t\t\t\t);\n\t\t\t\t$$.setCssRule(true, ` .${$CIRCLE.circle}`, [\"fill\", \"stroke\"], $$.color)(selection);\n\t\t\t})\n\t\t\t.style(\"opacity\", function() {\n\t\t\t\tconst parent = d3Select(this.parentNode);\n\n\t\t\t\t// if the parent node is .bb-chart-circles (bubble, scatter), initialize <g bb-circles> with opacity \"0\"\n\t\t\t\treturn parent.attr(\"class\").indexOf($CIRCLE.chartCircles) > -1 ? \"0\" : null;\n\t\t\t});\n\n\t\t// Update date for selected circles\n\t\tselectionEnabled && targets.forEach(t => {\n\t\t\t$el.main.selectAll(`.${$SELECT.selectedCircles}${$$.getTargetSelectorSuffix(t.id)}`)\n\t\t\t\t.selectAll(`${$SELECT.selectedCircle}`)\n\t\t\t\t.each(d => {\n\t\t\t\t\td.value = t.values[d.index].value;\n\t\t\t\t});\n\t\t});\n\t},\n\n\tupdateCircle(isSub = false): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el} = $$;\n\t\tconst focusOnly = $$.isPointFocusOnly();\n\t\tconst $root = isSub ? $el.subchart : $el;\n\n\t\tif (config.point_show && !state.toggling) {\n\t\t\tconfig.point_radialGradient && $$.updateLinearGradient();\n\n\t\t\tconst circles = $root.main.selectAll(`.${$CIRCLE.circles}`)\n\t\t\t\t.selectAll(`.${$CIRCLE.circle}`)\n\t\t\t\t.data(d => {\n\t\t\t\t\tconst data = ($$.isLineType(d) && $$.shouldDrawPointsForLine(d)) ||\n\t\t\t\t\t\t\t$$.isBubbleType(d) || $$.isRadarType(d) || $$.isScatterType(d) ?\n\t\t\t\t\t\t(focusOnly ? [d.values[0]] : d.values) :\n\t\t\t\t\t\t[];\n\n\t\t\t\t\t// return data;\n\t\t\t\t\treturn $$.filterNullish(data);\n\t\t\t\t});\n\n\t\t\tcircles.exit().remove();\n\n\t\t\tcircles.enter()\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.append(\n\t\t\t\t\t$$.point(\"create\", this, $$.pointR.bind($$), $$.updateCircleColor.bind($$))\n\t\t\t\t);\n\n\t\t\t$root.circle = $root.main.selectAll(`.${$CIRCLE.circles} .${$CIRCLE.circle}`)\n\t\t\t\t.style(\"stroke\", $$.getStylePropValue($$.color))\n\t\t\t\t.style(\"opacity\", $$.initialOpacityForCircle.bind($$));\n\t\t}\n\t},\n\n\t/**\n\t * Update circle color\n\t * @param {object} d Data object\n\t * @returns {string} Color string\n\t * @private\n\t */\n\tupdateCircleColor(d: IDataRow): string | null {\n\t\tconst $$ = this;\n\t\tconst fn = $$.getStylePropValue($$.color);\n\n\t\treturn $$.config.point_radialGradient ? $$.getGradienColortUrl(d.id) : (fn ? fn(d) : null);\n\t},\n\n\tredrawCircle(cx: Function, cy: Function, withTransition: boolean, flow, isSub = false) {\n\t\tconst $$ = this;\n\t\tconst {state: {rendered}, $el, $T} = $$;\n\t\tconst $root = isSub ? $el.subchart : $el;\n\t\tconst selectedCircles = $root.main.selectAll(`.${$SELECT.selectedCircle}`);\n\n\t\tif (!$$.config.point_show) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst fn = $$.point(\"update\", $$, cx, cy, $$.updateCircleColor.bind($$), withTransition,\n\t\t\tflow, selectedCircles);\n\t\tconst posAttr = $$.isCirclePoint() ? \"c\" : \"\";\n\n\t\tconst t = getRandom();\n\t\tconst opacityStyleFn = $$.opacityForCircle.bind($$);\n\t\tconst mainCircles: any[] = [];\n\n\t\t$root.circle.each(function(d) {\n\t\t\tlet result: d3Selection | any = fn.bind(this)(d);\n\n\t\t\tresult = $T(result, withTransition || !rendered, t)\n\t\t\t\t.style(\"opacity\", opacityStyleFn);\n\n\t\t\tmainCircles.push(result);\n\t\t});\n\n\t\treturn [\n\t\t\tmainCircles,\n\t\t\t$T(selectedCircles, withTransition)\n\t\t\t\t.attr(`${posAttr}x`, cx)\n\t\t\t\t.attr(`${posAttr}y`, cy)\n\t\t];\n\t},\n\n\t/**\n\t * Show focused data point circle\n\t * @param {object} d Selected data\n\t * @private\n\t */\n\tshowCircleFocus(d?: IDataRow[]): void {\n\t\tconst $$ = this;\n\t\tconst {state: {hasRadar, resizing, toggling, transiting}, $el} = $$;\n\t\tlet {circle} = $el;\n\n\t\tif (transiting === false && circle && $$.isPointFocusOnly()) {\n\t\t\tconst cx = (hasRadar ? $$.radarCircleX : $$.circleX).bind($$);\n\t\t\tconst cy = (hasRadar ? $$.radarCircleY : $$.circleY).bind($$);\n\t\t\tconst withTransition = toggling || isUndefined(d);\n\t\t\tconst fn = $$.point(\"update\", $$, cx, cy, $$.getStylePropValue($$.color),\n\t\t\t\tresizing ? false : withTransition);\n\n\t\t\tif (d) {\n\t\t\t\tcircle = circle\n\t\t\t\t\t.filter(function(t) {\n\t\t\t\t\t\tconst data = d.filter?.(v => v.id === t.id);\n\n\t\t\t\t\t\treturn data.length ? d3Select(this).datum(data[0]) : false;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tcircle\n\t\t\t\t.attr(\"class\", this.updatePointClass.bind(this))\n\t\t\t\t.style(\"opacity\", null)\n\t\t\t\t.each(function(d) {\n\t\t\t\t\tconst {id, index, value} = d;\n\t\t\t\t\tlet visibility = \"hidden\";\n\n\t\t\t\t\tif (isValue(value)) {\n\t\t\t\t\t\tfn.bind(this)(d);\n\t\t\t\t\t\t$$.expandCircles(index, id);\n\t\t\t\t\t\tvisibility = \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.style.visibility = visibility;\n\t\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Hide focused data point circle\n\t * @private\n\t */\n\thideCircleFocus(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {circle}} = $$;\n\n\t\tif ($$.isPointFocusOnly() && circle) {\n\t\t\t$$.unexpandCircles();\n\t\t\tcircle.style(\"visibility\", \"hidden\");\n\t\t}\n\t},\n\n\tcircleX(d): number | null {\n\t\treturn this.xx(d);\n\t},\n\n\tupdateCircleY(isSub = false): Function {\n\t\tconst $$ = this;\n\t\tconst getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), isSub);\n\n\t\treturn (d, i) => {\n\t\t\tconst id = d.id;\n\n\t\t\treturn $$.isGrouped(id) ?\n\t\t\t\tgetPoints(d, i)[0][1] :\n\t\t\t\t$$.getYScaleById(id, isSub)($$.getBaseValue(d));\n\t\t};\n\t},\n\n\texpandCircles(i: number, id: string, reset?: boolean): void {\n\t\tconst $$ = this;\n\t\tconst r = $$.pointExpandedR.bind($$);\n\n\t\treset && $$.unexpandCircles();\n\n\t\tconst circles = $$.getShapeByIndex(\"circle\", i, id).classed($COMMON.EXPANDED, true);\n\t\tconst scale = r(circles) / $$.config.point_r;\n\t\tconst ratio = 1 - scale;\n\n\t\tif ($$.isCirclePoint()) {\n\t\t\tcircles.attr(\"r\", r);\n\t\t} else {\n\t\t\t// transform must be applied to each node individually\n\t\t\tcircles.each(function() {\n\t\t\t\tconst point = d3Select(this);\n\n\t\t\t\tif (this.tagName === \"circle\") {\n\t\t\t\t\tpoint.attr(\"r\", r);\n\t\t\t\t} else {\n\t\t\t\t\tconst {width, height} = getBBox(this);\n\t\t\t\t\tconst x = ratio * (+point.attr(\"x\") + width / 2);\n\t\t\t\t\tconst y = ratio * (+point.attr(\"y\") + height / 2);\n\n\t\t\t\t\tpoint.attr(\"transform\", `translate(${x} ${y}) scale(${scale})`);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\tunexpandCircles(i): void {\n\t\tconst $$ = this;\n\t\tconst r = $$.pointR.bind($$);\n\n\t\tconst circles = $$.getShapeByIndex(\"circle\", i)\n\t\t\t.filter(function() {\n\t\t\t\treturn d3Select(this).classed($COMMON.EXPANDED);\n\t\t\t})\n\t\t\t.classed($COMMON.EXPANDED, false);\n\n\t\tcircles.attr(\"r\", r);\n\n\t\tif (!$$.isCirclePoint()) {\n\t\t\tconst scale = r(circles) / $$.config.point_r;\n\n\t\t\tcircles.attr(\"transform\", scale !== 1 ? `scale(${scale})` : null);\n\t\t}\n\t},\n\n\tpointR(d): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst pointR = config.point_r;\n\t\tlet r = pointR;\n\n\t\tif ($$.isBubbleType(d)) {\n\t\t\tr = $$.getBubbleR(d);\n\t\t} else if (isFunction(pointR)) {\n\t\t\tr = pointR.bind($$.api)(d);\n\t\t}\n\n\t\td.r = r;\n\n\t\treturn r;\n\t},\n\n\tpointExpandedR(d): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst scale = $$.isBubbleType(d) ? 1.15 : 1.75;\n\n\t\treturn config.point_focus_expand_enabled ?\n\t\t\t(config.point_focus_expand_r || $$.pointR(d) * scale) :\n\t\t\t$$.pointR(d);\n\t},\n\n\tpointSelectR(d): number {\n\t\tconst $$ = this;\n\t\tconst selectR = $$.config.point_select_r;\n\n\t\treturn isFunction(selectR) ? selectR(d) : (selectR || $$.pointR(d) * 4);\n\t},\n\n\t/**\n\t * Check if point.focus.only option can be applied.\n\t * @returns {boolean}\n\t * @private\n\t */\n\tisPointFocusOnly(): boolean {\n\t\tconst $$ = this;\n\n\t\treturn $$.config.point_focus_only &&\n\t\t\t!$$.hasType(\"bubble\") && !$$.hasType(\"scatter\") && !$$.hasArcType(null, [\"radar\"]);\n\t},\n\n\tisWithinCircle(node: SVGElement, r?: number): boolean {\n\t\tconst {state} = this;\n\t\tconst mouse = getPointer(state.event, node);\n\t\tconst element = d3Select(node);\n\t\tconst prefix = this.isCirclePoint(node) ? \"c\" : \"\";\n\t\tconst pointSensitivity = this.getPointSensitivity(element?.datum());\n\n\t\tlet cx = +element.attr(`${prefix}x`);\n\t\tlet cy = +element.attr(`${prefix}y`);\n\n\t\t// if node don't have cx/y or x/y attribute value\n\t\tif (!(cx || cy) && node.nodeType === 1) {\n\t\t\tconst {x, y} = getBoundingRect(node);\n\n\t\t\tcx = x;\n\t\t\tcy = y;\n\t\t}\n\n\t\treturn Math.sqrt(\n\t\t\tMath.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)\n\t\t) < (r || pointSensitivity);\n\t},\n\n\t/**\n\t * Get data point sensitivity radius\n\t * @param {object} d Data point object\n\t * @returns {number} return the sensitivity value\n\t */\n\tgetPointSensitivity(d: IDataPoint) {\n\t\tconst $$ = this;\n\t\tlet sensitivity = $$.config.point_sensitivity;\n\n\t\tif (!d) {\n\t\t\treturn sensitivity;\n\t\t} else if (isFunction(sensitivity)) {\n\t\t\tsensitivity = sensitivity.call($$.api, d);\n\t\t} else if (sensitivity === \"radius\") {\n\t\t\tsensitivity = d.r;\n\t\t}\n\n\t\treturn sensitivity;\n\t},\n\n\tupdatePointClass(d) {\n\t\tconst $$ = this;\n\t\tconst {circle} = $$.$el;\n\t\tlet pointClass = false;\n\n\t\tif (isObject(d) || circle) {\n\t\t\tpointClass = d === true ?\n\t\t\t\tcircle.each(function(d) {\n\t\t\t\t\tlet className = $$.getClass(\"circle\", true)(d);\n\n\t\t\t\t\tif (this.getAttribute(\"class\").indexOf($COMMON.EXPANDED) > -1) {\n\t\t\t\t\t\tclassName += ` ${$COMMON.EXPANDED}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setAttribute(\"class\", className);\n\t\t\t\t}) :\n\t\t\t\t$$.getClass(\"circle\", true)(d);\n\t\t}\n\n\t\treturn pointClass;\n\t},\n\n\tgenerateGetLinePoints(lineIndices, isSub?: boolean): Function { // partial duplication of generateGetBarPoints\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst x = $$.getShapeX(0, lineIndices, isSub);\n\t\tconst y = $$.getShapeY(isSub);\n\t\tconst lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub);\n\t\tconst yScale = $$.getYScaleById.bind($$);\n\n\t\treturn (d, i) => {\n\t\t\tconst y0 = yScale.call($$, d.id, isSub)($$.getShapeYMin(d.id));\n\t\t\tconst offset = lineOffset(d, i) || y0; // offset is for stacked area chart\n\t\t\tconst posX = x(d);\n\t\t\tlet posY = y(d);\n\n\t\t\t// fix posY not to overflow opposite quadrant\n\t\t\tif (\n\t\t\t\tconfig.axis_rotated && (\n\t\t\t\t\t(d.value > 0 && posY < y0) || (d.value < 0 && y0 < posY)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tposY = y0;\n\t\t\t}\n\n\t\t\t// 1 point that marks the line position\n\t\t\tconst point = [posX, posY - (y0 - offset)];\n\n\t\t\treturn [\n\t\t\t\tpoint,\n\t\t\t\tpoint, // from here and below, needed for compatibility\n\t\t\t\tpoint,\n\t\t\t\tpoint\n\t\t\t];\n\t\t};\n\t},\n\n\tcustom: {\n\t\tcreate(element, id, fillStyleFn) {\n\t\t\treturn element.append(\"use\")\n\t\t\t\t.attr(\"xlink:href\", `#${id}`)\n\t\t\t\t.attr(\"class\", this.updatePointClass.bind(this))\n\t\t\t\t.style(\"fill\", fillStyleFn)\n\t\t\t\t.node();\n\t\t},\n\n\t\tupdate(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {\n\t\t\tconst $$ = this;\n\t\t\tconst {width, height} = getBBox(element.node());\n\n\t\t\tconst xPosFn2 = d => (isValue(d.value) ? xPosFn(d) - width / 2 : 0);\n\t\t\tconst yPosFn2 = d => (isValue(d.value) ? yPosFn(d) - height / 2 : 0);\n\t\t\tlet mainCircles = element;\n\n\t\t\tif (withTransition) {\n\t\t\t\tflow && mainCircles.attr(\"x\", xPosFn2);\n\n\t\t\t\tmainCircles = $$.$T(mainCircles, withTransition, getTransitionName());\n\t\t\t\tselectedCircles && $$.$T(selectedCircles, withTransition, getTransitionName());\n\t\t\t}\n\n\t\t\treturn mainCircles\n\t\t\t\t.attr(\"x\", xPosFn2)\n\t\t\t\t.attr(\"y\", yPosFn2)\n\t\t\t\t.style(\"fill\", fillStyleFn);\n\t\t}\n\t},\n\n\t// 'circle' data point\n\tcircle: {\n\t\tcreate(element, sizeFn, fillStyleFn) {\n\t\t\treturn element.append(\"circle\")\n\t\t\t\t.attr(\"class\", this.updatePointClass.bind(this))\n\t\t\t\t.attr(\"r\", sizeFn)\n\t\t\t\t.style(\"fill\", fillStyleFn)\n\t\t\t\t.node();\n\t\t},\n\n\t\tupdate(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {\n\t\t\tconst $$ = this;\n\t\t\tlet mainCircles = element;\n\n\t\t\t// when '.load()' called, bubble size should be updated\n\t\t\tif ($$.hasType(\"bubble\")) {\n\t\t\t\tmainCircles.attr(\"r\", $$.pointR.bind($$));\n\t\t\t}\n\n\t\t\tif (withTransition) {\n\t\t\t\tflow && mainCircles.attr(\"cx\", xPosFn);\n\n\t\t\t\tif (mainCircles.attr(\"cx\")) {\n\t\t\t\t\tmainCircles = $$.$T(mainCircles, withTransition, getTransitionName());\n\t\t\t\t}\n\n\t\t\t\tselectedCircles && $$.$T(mainCircles, withTransition, getTransitionName());\n\t\t\t}\n\n\t\t\treturn mainCircles\n\t\t\t\t.attr(\"cx\", xPosFn)\n\t\t\t\t.attr(\"cy\", yPosFn)\n\t\t\t\t.style(\"fill\", fillStyleFn);\n\t\t}\n\t},\n\n\t// 'rectangle' data point\n\trectangle: {\n\t\tcreate(element, sizeFn, fillStyleFn) {\n\t\t\tconst rectSizeFn = d => sizeFn(d) * 2.0;\n\n\t\t\treturn element.append(\"rect\")\n\t\t\t\t.attr(\"class\", this.updatePointClass.bind(this))\n\t\t\t\t.attr(\"width\", rectSizeFn)\n\t\t\t\t.attr(\"height\", rectSizeFn)\n\t\t\t\t.style(\"fill\", fillStyleFn)\n\t\t\t\t.node();\n\t\t},\n\n\t\tupdate(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {\n\t\t\tconst $$ = this;\n\t\t\tconst r = $$.config.point_r;\n\t\t\tconst rectXPosFn = d => xPosFn(d) - r;\n\t\t\tconst rectYPosFn = d => yPosFn(d) - r;\n\n\t\t\tlet mainCircles = element;\n\n\t\t\tif (withTransition) {\n\t\t\t\tflow && mainCircles.attr(\"x\", rectXPosFn);\n\n\t\t\t\tmainCircles = $$.$T(mainCircles, withTransition, getTransitionName());\n\t\t\t\tselectedCircles && $$.$T(selectedCircles, withTransition, getTransitionName());\n\t\t\t}\n\n\t\t\treturn mainCircles\n\t\t\t\t.attr(\"x\", rectXPosFn)\n\t\t\t\t.attr(\"y\", rectYPosFn)\n\t\t\t\t.style(\"fill\", fillStyleFn);\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {namespaces as d3Namespaces, select as d3Select} from \"d3-selection\";\nimport {document} from \"../../module/browser\";\nimport {isFunction, isObjectType, notEmpty, toArray} from \"../../module/util\";\n\n/**\n * Check if point draw methods are valid\n * @param {string} point point type\n * @returns {boolean}\n * @private\n */\nfunction hasValidPointDrawMethods(point: string): boolean {\n\treturn isObjectType(point) &&\n\t\tisFunction(point.create) && isFunction(point.update);\n}\n\n/**\n * Insert point info defs element\n * @param {string} point Point element\n * @param {string} id Point id\n * @private\n */\nfunction insertPointInfoDefs(point: string, id: string): void {\n\tconst $$ = this;\n\tconst copyAttr = (from, target) => {\n\t\tconst attribs = from.attributes;\n\n\t\tfor (let i = 0, name; (name = attribs[i]); i++) {\n\t\t\tname = name.name;\n\t\t\ttarget.setAttribute(name, from.getAttribute(name));\n\t\t}\n\t};\n\n\tconst doc = new DOMParser().parseFromString(point, \"image/svg+xml\");\n\tconst node = doc.documentElement;\n\tconst clone = document.createElementNS(d3Namespaces.svg, node.nodeName.toLowerCase());\n\n\tclone.id = id;\n\tclone.style.fill = \"inherit\";\n\tclone.style.stroke = \"inherit\";\n\n\tcopyAttr(node, clone);\n\n\tif (node.childNodes?.length) {\n\t\tconst parent = d3Select(clone);\n\n\t\tif (\"innerHTML\" in clone) {\n\t\t\tparent.html(node.innerHTML);\n\t\t} else {\n\t\t\ttoArray(node.childNodes).forEach(v => {\n\t\t\t\tcopyAttr(v, parent.append(v.tagName).node());\n\t\t\t});\n\t\t}\n\t}\n\n\t$$.$el.defs.node().appendChild(clone);\n}\n\nexport default {\n\t/**\n\t * Check if point type option is valid\n\t * @param {string} type point type\n\t * @returns {boolean}\n\t * @private\n\t */\n\thasValidPointType(type?: string): boolean {\n\t\treturn /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);\n\t},\n\n\t/**\n\t * Check if pattern point is set to be used on legend\n\t * @returns {boolean}\n\t * @private\n\t */\n\thasLegendDefsPoint(): boolean {\n\t\tconst {config} = this;\n\n\t\treturn config.legend_show && config.point_pattern?.length && config.legend_usePoint;\n\t},\n\n\tgetDefsPointId(id: string): string {\n\t\tconst {state: {datetimeId}} = this;\n\n\t\treturn `${datetimeId}-point${id}`;\n\t},\n\n\t/**\n\t * Get generate point function\n\t * @returns {Function}\n\t * @private\n\t */\n\tgeneratePoint(): Function {\n\t\tconst $$ = this;\n\t\tconst {$el, config} = $$;\n\t\tconst ids: string[] = [];\n\t\tconst pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];\n\n\t\treturn function(method, context, ...args) {\n\t\t\treturn function(d) {\n\t\t\t\tconst id: string = $$.getTargetSelectorSuffix(d.id || d.data?.id || d);\n\t\t\t\tconst element = d3Select(this);\n\n\t\t\t\tids.indexOf(id) < 0 && ids.push(id);\n\n\t\t\t\tlet point = pattern[ids.indexOf(id) % pattern.length];\n\n\t\t\t\tif ($$.hasValidPointType(point)) {\n\t\t\t\t\tpoint = $$[point];\n\t\t\t\t} else if (!hasValidPointDrawMethods(point || config.point_type)) {\n\t\t\t\t\tconst pointId = $$.getDefsPointId(id);\n\t\t\t\t\tconst defsPoint = $el.defs.select(`#${pointId}`);\n\n\t\t\t\t\tif (defsPoint.size() < 1) {\n\t\t\t\t\t\tinsertPointInfoDefs.bind($$)(point, pointId);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (method === \"create\") {\n\t\t\t\t\t\treturn $$.custom?.create.bind(context)(element, pointId, ...args);\n\t\t\t\t\t} else if (method === \"update\") {\n\t\t\t\t\t\treturn $$.custom?.update.bind(context)(element, ...args);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn point[method]?.bind(context)(element, ...args);\n\t\t\t};\n\t\t};\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {$LEVEL} from \"../../config/classes\";\nimport {getRange} from \"../../module/util\";\nimport type {IArcData, IData} from \"../data/IData\";\n\n/**\n * Get data max value\n * @param {object} $$ ChartInternal instance\n * @returns {number} max value\n * @private\n */\nfunction getDataMax($$): number {\n\tconst levelMax = $$.config.polar_level_max;\n\tlet dataMax = $$.getMinMaxData().max[0].value;\n\n\t// Apply level max only when is greater than the data max value\n\tif (levelMax && levelMax > dataMax) {\n\t\tdataMax = levelMax;\n\t}\n\n\treturn dataMax;\n}\n\nexport default {\n\t/**\n\t * Initialize polar\n\t * @private\n\t */\n\tinitPolar(): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {arcs}, config} = $$;\n\t\tconst levelTextShow: boolean = config.polar_level_text_show;\n\t\tconst levelTextBgColor: string = config.polar_level_text_backgroundColor;\n\n\t\t// append <g> for level\n\t\tarcs.levels = arcs.append(\"g\")\n\t\t\t.attr(\"class\", $LEVEL.levels);\n\n\t\t// set level text background color\n\t\tif (levelTextShow && levelTextBgColor) {\n\t\t\t$$.generateTextBGColorFilter(levelTextBgColor);\n\t\t}\n\t},\n\n\t/**\n\t * Get polar outer radius according to the data value\n\t * @param {object} d Data object\n\t * @param {numbet} outerRadius Outer radius\n\t * @returns {number} outer radius\n\t * @private\n\t */\n\tgetPolarOuterRadius(d: IArcData, outerRadius: number): number {\n\t\tconst dataMax = getDataMax(this);\n\n\t\treturn ((d?.data.values[0].value ?? 0) / dataMax) * outerRadius;\n\t},\n\n\t/**\n\t * Update polar based on given data array\n\t * @param {object} targets Data object\n\t * @private\n\t */\n\tupdateTargetsForPolar(targets: IData[]): void {\n\t\t// borrow from Arc\n\t\tthis.updateTargetsForArc(targets);\n\t},\n\n\t/**\n\t * Called whenever redraw happens\n\t * @private\n\t */\n\tredrawPolar(): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tconfig.polar_level_show && $$.updatePolarLevel();\n\t},\n\n\t/**\n\t * Update polar level circle\n\t * @private\n\t */\n\tupdatePolarLevel(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {arcs: {levels}}} = $$;\n\n\t\tconst depth: number = config.polar_level_depth;\n\t\tconst dataMax = getDataMax($$);\n\t\tconst levelData = getRange(0, depth);\n\t\tconst outerRadius = state.radius;\n\t\tconst levelRatio = levelData.map(l => outerRadius * ((l + 1) / depth));\n\t\tconst levelTextFormat = (config.polar_level_text_format || function() {}).bind($$.api);\n\n\t\tconst level = levels\n\t\t\t.selectAll(`.${$LEVEL.level}`)\n\t\t\t.data(levelData);\n\n\t\tlevel.exit().remove();\n\n\t\tconst levelEnter = level.enter().append(\"g\")\n\t\t\t.attr(\"class\", (d, i) => `${$LEVEL.level} ${$LEVEL.level}-${i}`);\n\n\t\t// cx, cy, translate: Set center as origin (0,0) so that it can share same center with arcs\n\t\tlevelEnter.append(\"circle\");\n\n\t\tlevelEnter\n\t\t\t.merge(level)\n\t\t\t.selectAll(\"circle\")\n\t\t\t.style(\"visibility\", config.polar_level_show ? null : \"hidden\")\n\t\t\t.attr(\"cx\", 0)\n\t\t\t.attr(\"cy\", 0)\n\t\t\t.attr(\"r\", d => levelRatio[d]);\n\n\t\tif (config.polar_level_text_show) {\n\t\t\tconst levelTextBackgroundColor = config.polar_level_text_backgroundColor;\n\t\t\tconst defsId = `#${state.datetimeId}-labels-bg${\n\t\t\t\t$$.getTargetSelectorSuffix(levelTextBackgroundColor)\n\t\t\t}`;\n\n\t\t\tlevelEnter.append(\"text\")\n\t\t\t\t.style(\"text-anchor\", \"middle\");\n\n\t\t\tlevelEnter\n\t\t\t\t.merge(level)\n\t\t\t\t.selectAll(\"text\")\n\t\t\t\t.attr(\"dy\", d => -levelRatio[d] + 5)\n\t\t\t\t.attr(\"filter\", levelTextBackgroundColor ? `url(${defsId})` : null)\n\t\t\t\t.text(d => levelTextFormat(dataMax / levelData.length * (d + 1)));\n\t\t}\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {select as d3Select} from \"d3-selection\";\nimport {$AXIS, $COMMON, $LEVEL, $RADAR, $SHAPE, $TEXT} from \"../../config/classes\";\nimport {KEY} from \"../../module/Cache\";\nimport {\n\tgetBoundingRect,\n\tgetMinMax,\n\tgetPathBox,\n\tgetRange,\n\tisDefined,\n\tisEmpty,\n\tisNumber,\n\tisUndefined,\n\tsetTextValue,\n\ttoArray\n} from \"../../module/util\";\n\n/**\n * Get the position value\n * @param {boolean} isClockwise If the direction is clockwise\n * @param {string} type Coordinate type 'x' or 'y'\n * @param {number} edge Number of edge\n * @param {number} pos The indexed position\n * @param {number} range Range value\n * @param {number} ratio Ratio value\n * @returns {number}\n * @private\n */\nfunction getPosition(isClockwise: boolean, type: \"x\" | \"y\", edge: number, pos: number,\n\trange: number, ratio: number): number {\n\tconst index = isClockwise && pos > 0 ? edge - pos : pos;\n\tconst r = 2 * Math.PI;\n\tconst func = type === \"x\" ? Math.sin : Math.cos;\n\n\treturn range * (1 - ratio * func(index * r / edge));\n}\n\n// cache key\nconst cacheKeyPoints = KEY.radarPoints;\nconst cacheKeyTextWidth = KEY.radarTextWidth;\n\nexport default {\n\tinitRadar(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state: {current}, $el} = $$;\n\n\t\tif ($$.hasType(\"radar\")) {\n\t\t\t$el.radar = $el.main.select(`.${$COMMON.chart}`).append(\"g\")\n\t\t\t\t.attr(\"class\", $RADAR.chartRadars);\n\n\t\t\t// level\n\t\t\t$el.radar.levels = $el.radar.append(\"g\")\n\t\t\t\t.attr(\"class\", $LEVEL.levels);\n\n\t\t\t// axis\n\t\t\t$el.radar.axes = $el.radar.append(\"g\")\n\t\t\t\t.attr(\"class\", $AXIS.axis);\n\n\t\t\t// shapes\n\t\t\t$el.radar.shapes = $el.radar.append(\"g\")\n\t\t\t\t.attr(\"class\", $SHAPE.shapes);\n\n\t\t\tcurrent.dataMax = config.radar_axis_max || $$.getMinMaxData().max[0].value;\n\n\t\t\tif (config.radar_axis_text_show) {\n\t\t\t\tconfig.interaction_enabled && $$.bindRadarEvent();\n\n\t\t\t\t// it needs to calculate dimension at the initialization\n\t\t\t\t$$.updateRadarLevel();\n\t\t\t\t$$.updateRadarAxes();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetRadarSize(): [number, number] {\n\t\tconst $$ = this;\n\t\tconst {config, state: {arcWidth, arcHeight}} = $$;\n\t\tconst padding = config.axis_x_categories.length < 4 ? -20 : 10;\n\t\tconst size = (Math.min(arcWidth, arcHeight) - padding) / 2;\n\n\t\treturn [size, size];\n\t},\n\n\tupdateTargetsForRadar(targets): void {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\n\t\tif (isEmpty(config.axis_x_categories)) {\n\t\t\tconfig.axis_x_categories = getRange(0, getMinMax(\"max\", targets.map(v =>\n\t\t\t\tv.values.length\n\t\t\t)));\n\t\t}\n\n\t\t$$.generateRadarPoints();\n\t},\n\n\tgetRadarPosition(type, index: number, range, ratio: number): number {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst [width, height] = $$.getRadarSize();\n\t\tconst edge = config.axis_x_categories.length;\n\t\tconst isClockwise = config.radar_direction_clockwise;\n\n\t\tconst pos = toArray(type).map(v =>\n\t\t\tgetPosition(\n\t\t\t\tisClockwise,\n\t\t\t\tv,\n\t\t\t\tedge,\n\t\t\t\tindex,\n\t\t\t\tisDefined(range) ? range : (type === \"x\" ? width : height),\n\t\t\t\tisNumber(ratio) ? ratio : config.radar_size_ratio\n\t\t\t)\n\t\t);\n\n\t\treturn pos.length === 1 ? pos[0] : pos;\n\t},\n\n\t/**\n\t * Generate data points\n\t * @private\n\t */\n\tgenerateRadarPoints(): void {\n\t\tconst $$ = this;\n\t\tconst targets = $$.data.targets;\n\n\t\tconst [width, height] = $$.getRadarSize();\n\t\tconst points = $$.cache.get(cacheKeyPoints) || {};\n\t\tconst size = points._size;\n\n\t\t// recalculate position only when the previous dimension has been changed\n\t\tif (!size || (size.width !== width && size.height !== height)) {\n\t\t\ttargets.forEach(d => {\n\t\t\t\tpoints[d.id] = d.values.map((v, i) => (\n\t\t\t\t\t$$.getRadarPosition([\"x\", \"y\"], i, undefined, $$.getRatio(\"radar\", v))\n\t\t\t\t));\n\t\t\t});\n\n\t\t\tpoints._size = {width, height};\n\t\t\t$$.cache.add(cacheKeyPoints, points);\n\t\t}\n\t},\n\n\tredrawRadar(): void {\n\t\tconst $$ = this;\n\t\tconst {radar, main} = $$.$el;\n\t\tconst translate = $$.getTranslate(\"radar\");\n\n\t\t// Adjust radar, circles and texts' position\n\t\tif (translate) {\n\t\t\tradar.attr(\"transform\", translate);\n\t\t\tmain.select(`.${$TEXT.chartTexts}`).attr(\"transform\", translate);\n\n\t\t\t$$.generateRadarPoints();\n\t\t\t$$.updateRadarLevel();\n\t\t\t$$.updateRadarAxes();\n\t\t\t$$.updateRadarShape();\n\t\t}\n\t},\n\n\tgenerateGetRadarPoints(): Function {\n\t\tconst points = this.cache.get(cacheKeyPoints);\n\n\t\treturn (d, i) => {\n\t\t\tconst point = points[d.id][i];\n\n\t\t\treturn [\n\t\t\t\tpoint,\n\t\t\t\tpoint,\n\t\t\t\tpoint,\n\t\t\t\tpoint\n\t\t\t];\n\t\t};\n\t},\n\n\tupdateRadarLevel(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {radar}} = $$;\n\t\tconst [width, height] = $$.getRadarSize();\n\t\tconst depth = config.radar_level_depth;\n\t\tconst edge = config.axis_x_categories.length;\n\t\tconst showText = config.radar_level_text_show;\n\n\t\tconst radarLevels = radar.levels;\n\t\tconst levelData = getRange(0, depth);\n\n\t\tconst radius = config.radar_size_ratio * Math.min(width, height);\n\t\tconst levelRatio = levelData.map(l => radius * ((l + 1) / depth));\n\t\tconst levelTextFormat = (config.radar_level_text_format || function() {}).bind($$.api);\n\n\t\t// Generate points\n\t\tconst points = levelData.map(v => {\n\t\t\tconst range = levelRatio[v];\n\t\t\tconst pos = getRange(0, edge).map(i =>\n\t\t\t\t(\n\t\t\t\t\t$$.getRadarPosition([\"x\", \"y\"], i, range, 1)\n\t\t\t\t).join(\",\")\n\t\t\t);\n\n\t\t\treturn pos.join(\" \");\n\t\t});\n\n\t\tconst level = radarLevels\n\t\t\t.selectAll(`.${$LEVEL.level}`)\n\t\t\t.data(levelData);\n\n\t\tlevel.exit().remove();\n\n\t\tconst levelEnter = level.enter().append(\"g\")\n\t\t\t.attr(\"class\", (d, i) => `${$LEVEL.level} ${$LEVEL.level}-${i}`);\n\n\t\tlevelEnter.append(\"polygon\")\n\t\t\t.style(\"visibility\", config.radar_level_show ? null : \"hidden\");\n\n\t\tif (showText) {\n\t\t\tif (radarLevels.select(\"text\").empty()) {\n\t\t\t\tradarLevels\n\t\t\t\t\t.append(\"text\")\n\t\t\t\t\t.attr(\"dx\", \"-.5em\")\n\t\t\t\t\t.attr(\"dy\", \"-.7em\")\n\t\t\t\t\t.style(\"text-anchor\", \"end\")\n\t\t\t\t\t.text(() => levelTextFormat(0));\n\t\t\t}\n\n\t\t\tlevelEnter.append(\"text\")\n\t\t\t\t.attr(\"dx\", \"-.5em\")\n\t\t\t\t.style(\"text-anchor\", \"end\")\n\t\t\t\t.text(d =>\n\t\t\t\t\tlevelTextFormat(\n\t\t\t\t\t\tstate.current.dataMax / levelData.length * (d + 1)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\tlevelEnter\n\t\t\t.merge(level)\n\t\t\t.attr(\"transform\",\n\t\t\t\td => `translate(${width - levelRatio[d]}, ${height - levelRatio[d]})`)\n\t\t\t.selectAll(\"polygon\")\n\t\t\t.attr(\"points\", d => points[d]);\n\n\t\t// update level text position\n\t\tif (showText) {\n\t\t\tradarLevels.selectAll(\"text\")\n\t\t\t\t.attr(\"x\", d => (isUndefined(d) ? width : points[d].split(\",\")[0]))\n\t\t\t\t.attr(\"y\", d => (isUndefined(d) ? height : 0));\n\t\t}\n\t},\n\n\tupdateRadarAxes(): void {\n\t\tconst $$ = this;\n\t\tconst {config, $el: {radar}} = $$;\n\t\tconst [width, height] = $$.getRadarSize();\n\t\tconst categories = config.axis_x_categories;\n\n\t\tlet axis = radar.axes.selectAll(\"g\")\n\t\t\t.data(categories);\n\n\t\taxis.exit().remove();\n\n\t\tconst axisEnter = axis.enter().append(\"g\")\n\t\t\t.attr(\"class\", (d, i) => `${$AXIS.axis}-${i}`);\n\n\t\tconfig.radar_axis_line_show && axisEnter.append(\"line\");\n\t\tconfig.radar_axis_text_show && axisEnter.append(\"text\");\n\n\t\taxis = axisEnter.merge(axis);\n\n\t\t// axis line\n\t\tif (config.radar_axis_line_show) {\n\t\t\taxis.select(\"line\")\n\t\t\t\t.attr(\"x1\", width)\n\t\t\t\t.attr(\"y1\", height)\n\t\t\t\t.attr(\"x2\", (d, i) => $$.getRadarPosition(\"x\", i))\n\t\t\t\t.attr(\"y2\", (d, i) => $$.getRadarPosition(\"y\", i));\n\t\t}\n\n\t\t// axis text\n\t\tif (config.radar_axis_text_show) {\n\t\t\tconst {x = 0, y = 0} = config.radar_axis_text_position;\n\t\t\tconst textWidth = $$.cache.get(cacheKeyTextWidth) || 0;\n\n\t\t\taxis.select(\"text\")\n\t\t\t\t.style(\"text-anchor\", \"middle\")\n\t\t\t\t.attr(\"dy\", \".5em\")\n\t\t\t\t.call(selection => {\n\t\t\t\t\tselection.each(function(d) {\n\t\t\t\t\t\tsetTextValue(d3Select(this), String(d), [-0.6, 1.2]);\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.datum((d, i) => ({index: i}))\n\t\t\t\t.attr(\"transform\", function(d) {\n\t\t\t\t\tif (isUndefined(this.width)) {\n\t\t\t\t\t\t// cache evaluated axis text width\n\t\t\t\t\t\tthis.width = getBoundingRect(this, true).width / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet posX = $$.getRadarPosition(\"x\", d.index, undefined, 1);\n\t\t\t\t\tlet posY = Math.round($$.getRadarPosition(\"y\", d.index, undefined, 1));\n\n\t\t\t\t\tif (posX > width) {\n\t\t\t\t\t\tposX += this.width + x;\n\t\t\t\t\t} else if (Math.round(posX) < width) {\n\t\t\t\t\t\tposX -= this.width + x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (posY > height) {\n\t\t\t\t\t\t// update vertical centered edge axis text dy position\n\t\t\t\t\t\tif (posY / 2 === height && this.firstChild.tagName === \"tspan\") {\n\t\t\t\t\t\t\tthis.firstChild.setAttribute(\"dy\", \"0em\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tposY += y;\n\t\t\t\t\t} else if (posY < height) {\n\t\t\t\t\t\tposY -= y;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn `translate(${posX} ${posY})`;\n\t\t\t\t});\n\n\t\t\tif (!textWidth) {\n\t\t\t\tconst widths = [radar.axes, radar.levels].map(v => getPathBox(v.node()).width);\n\n\t\t\t\tif (widths.every(v => v > 0)) {\n\t\t\t\t\t$$.cache.add(cacheKeyTextWidth, widths[0] - widths[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tbindRadarEvent(): void {\n\t\tconst $$ = this;\n\t\tconst {config, state, $el: {radar, svg}} = $$;\n\t\tconst focusOnly = $$.isPointFocusOnly();\n\t\tconst {inputType, transiting} = state;\n\t\tconst isMouse = inputType === \"mouse\";\n\n\t\tconst hide = event => {\n\t\t\tstate.event = event;\n\n\t\t\tif (!config.interaction_onout) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// const index = getIndex(event);\n\n\t\t\tconst index = $$.getDataIndexFromEvent(event);\n\t\t\tconst noIndex = isUndefined(index);\n\n\t\t\tif (isMouse || noIndex) {\n\t\t\t\t$$.hideTooltip();\n\n\t\t\t\tfocusOnly ? $$.hideCircleFocus() : $$.unexpandCircles();\n\n\t\t\t\tif (isMouse) {\n\t\t\t\t\t$$.setOverOut(false, index);\n\t\t\t\t} else if (noIndex) {\n\t\t\t\t\t$$.callOverOutForTouch();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tradar.axes\n\t\t\t.on(isMouse ? \"mouseover \" : \"touchstart\", event => {\n\t\t\t\tif (transiting) { // skip while transiting\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tstate.event = event;\n\t\t\t\tconst index = $$.getDataIndexFromEvent(event);\n\n\t\t\t\t$$.selectRectForSingle(svg.node(), index);\n\t\t\t\tisMouse ? $$.setOverOut(true, index) : $$.callOverOutForTouch(index);\n\t\t\t})\n\t\t\t.on(\"mouseout\", isMouse ? hide : null);\n\n\t\tif (!isMouse) {\n\t\t\tsvg.on(\"touchstart\", hide);\n\t\t}\n\t},\n\n\tupdateRadarShape(): void {\n\t\tconst $$ = this;\n\t\tconst targets = $$.data.targets.filter(d => $$.isRadarType(d));\n\t\tconst points = $$.cache.get(cacheKeyPoints);\n\n\t\tconst areas = $$.$el.radar.shapes\n\t\t\t.selectAll(\"polygon\")\n\t\t\t.data($$.filterNullish(targets));\n\n\t\tconst areasEnter = areas.enter().append(\"g\")\n\t\t\t.attr(\"class\", $$.getChartClass(\"Radar\"));\n\n\t\t$$.$T(areas.exit())\n\t\t\t.remove();\n\n\t\tareasEnter\n\t\t\t.append(\"polygon\")\n\t\t\t.merge(areas)\n\t\t\t.style(\"fill\", $$.color)\n\t\t\t.style(\"stroke\", $$.color)\n\t\t\t.attr(\"points\", d => points[d.id].join(\" \"));\n\n\t\t$$.updateTargetForCircle(targets, areasEnter);\n\t},\n\n\t/**\n\t * Get data point x coordinate\n\t * @param {object} d Data object\n\t * @returns {number}\n\t * @private\n\t */\n\tradarCircleX(d): number {\n\t\treturn this.cache.get(cacheKeyPoints)[d.id][d.index][0];\n\t},\n\n\t/**\n\t * Get data point y coordinate\n\t * @param {object} d Data object\n\t * @returns {number}\n\t * @private\n\t */\n\tradarCircleY(d): number {\n\t\treturn this.cache.get(cacheKeyPoints)[d.id][d.index][1];\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {\n\thierarchy as d3Hierarchy,\n\ttreemap as d3Treemap,\n\ttreemapBinary as d3TreemapBinary,\n\ttreemapDice as d3TreemapDice,\n\ttreemapResquarify as d3TreemapResquarify,\n\ttreemapSlice as d3TreemapSlice,\n\ttreemapSliceDice as d3TreemapSliceDice,\n\ttreemapSquarify as d3TreemapSquarify\n} from \"d3-hierarchy\";\nimport {select as d3Select} from \"d3-selection\";\nimport type {d3Selection} from \"../../../types/types\";\nimport {$COMMON, $TREEMAP} from \"../../config/classes\";\nimport {getRandom, isFunction} from \"../../module/util\";\nimport type {IData, IDataRow, ITreemapData} from \"../data/IData\";\n\n/**\n * Get treemap elements' position\n * @param {d3Selection} group Root selection\n * @param {object} root Root data\n * @private\n */\nfunction position(group, root): void {\n\tconst $$ = this;\n\tconst {scale: {x, y}, state: {width}} = $$;\n\n\tgroup.selectAll(\"g\")\n\t\t.attr(\"transform\", d => (\n\t\t\t`translate(${d === root ? \"0,0\" : `${x(d.x0)},${y(d.y0)}`})`\n\t\t))\n\t\t.select(\"rect\")\n\t\t.attr(\"width\", d => (\n\t\t\td === root ? width : x(d.x1) - x(d.x0)\n\t\t))\n\t\t.attr(\"height\", d => (\n\t\t\td === root ? 0 : y(d.y1) - y(d.y0)\n\t\t));\n}\n\n/**\n * Convert data for treemap hierarchy\n * @param {object} data Data object\n * @returns {Array} Array of data for treemap hierarchy\n * @private\n */\nfunction convertDataToTreemapData(data: IData[]): ITreemapData[] {\n\tconst $$ = this;\n\n\treturn data.map(d => {\n\t\tconst {id, values} = d;\n\t\tconst {value} = values[0];\n\n\t\treturn {\n\t\t\tname: id,\n\t\t\tid, // needed to keep compatibility on whole code logic\n\t\t\tvalue,\n\t\t\tratio: $$.getRatio(\"treemap\", values[0])\n\t\t} as ITreemapData;\n\t});\n}\n\n/**\n * Get hierarchy data\n * @param {object} data Data object\n * @returns {Array} Array of hierarchy data\n * @private\n */\nfunction getHierachyData(data) {\n\tconst $$ = this;\n\tconst hierarchyData = d3Hierarchy(data).sum(d => d.value);\n\tconst sortFn = $$.getSortCompareFn(true);\n\n\treturn [\n\t\t$$.treemap(\n\t\t\tsortFn ? hierarchyData.sort(sortFn) : hierarchyData\n\t\t)\n\t];\n}\n\nexport default {\n\tinitTreemap(): void {\n\t\tconst $$ = this;\n\t\tconst {\n\t\t\t$el,\n\t\t\tstate: {\n\t\t\t\tcurrent: {width, height},\n\t\t\t\tclip,\n\t\t\t\tdatetimeId\n\t\t\t}\n\t\t} = $$;\n\n\t\tclip.id = `${datetimeId}-clip`;\n\n\t\t$$.treemap = d3Treemap()\n\t\t\t.tile($$.getTreemapTile());\n\n\t\t$el.defs\n\t\t\t.append(\"clipPath\")\n\t\t\t.attr(\"id\", clip.id)\n\t\t\t.append(\"rect\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height);\n\n\t\t$el.treemap = $el.main.select(`.${$COMMON.chart}`)\n\t\t\t.attr(\"clip-path\", `url(#${clip.id})`)\n\t\t\t.append(\"g\")\n\t\t\t.classed($TREEMAP.chartTreemaps, true);\n\n\t\t$$.bindTreemapEvent();\n\t},\n\n\t/**\n\t * Bind events\n\t * @private\n\t */\n\tbindTreemapEvent(): void {\n\t\tconst $$ = this;\n\t\tconst {$el, config, state} = $$;\n\t\tconst getTarget = event => {\n\t\t\tconst target = event.isTrusted ? event.target : state.eventReceiver.rect?.node();\n\t\t\tlet data;\n\n\t\t\tif (/^rect$/i.test(target.tagName)) {\n\t\t\t\tstate.event = event;\n\t\t\t\tdata = d3Select(target).datum();\n\t\t\t}\n\n\t\t\treturn data?.data;\n\t\t};\n\n\t\tif (config.interaction_enabled) {\n\t\t\tconst isTouch = state.inputType === \"touch\";\n\n\t\t\t$el.treemap\n\t\t\t\t.on(isTouch ? \"touchstart\" : \"mouseover mousemove\", event => {\n\t\t\t\t\tconst data = getTarget(event);\n\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\t$$.showTooltip([data], event.currentTarget);\n\t\t\t\t\t\t/^(touchstart|mouseover)$/.test(event.type) && $$.setOverOut(true, data);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.on(isTouch ? \"touchend\" : \"mouseout\", event => {\n\t\t\t\t\tconst data = getTarget(event);\n\n\t\t\t\t\tif (config.interaction_onout) {\n\t\t\t\t\t\t$$.hideTooltip();\n\t\t\t\t\t\t$$.setOverOut(false, data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Get tiling function\n\t * @returns {Function}\n\t * @private\n\t */\n\tgetTreemapTile() {\n\t\tconst $$ = this;\n\t\tconst {config, state: {current: {width, height}}} = $$;\n\t\tconst tile = {\n\t\t\tbinary: d3TreemapBinary,\n\t\t\tdice: d3TreemapDice,\n\t\t\tslice: d3TreemapSlice,\n\t\t\tsliceDice: d3TreemapSliceDice,\n\t\t\tsquarify: d3TreemapSquarify,\n\t\t\tresquarify: d3TreemapResquarify\n\t\t}[config.treemap_tile ?? \"binary\"] ?? d3TreemapBinary;\n\n\t\treturn (node, x0, y0, x1, y1) => {\n\t\t\ttile(node, 0, 0, width, height);\n\n\t\t\tfor (const child of node.children) {\n\t\t\t\tchild.x0 = x0 + child.x0 / width * (x1 - x0);\n\t\t\t\tchild.x1 = x0 + child.x1 / width * (x1 - x0);\n\t\t\t\tchild.y0 = y0 + child.y0 / height * (y1 - y0);\n\t\t\t\tchild.y1 = y0 + child.y1 / height * (y1 - y0);\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t * Get treemap hierarchy data\n\t * @param {Array} targets Data targets\n\t * @returns {object}\n\t * @private\n\t */\n\tgetTreemapData(targets: IData[]): ITreemapData {\n\t\tconst $$ = this;\n\n\t\treturn {\n\t\t\tname: \"root\",\n\t\t\tchildren: convertDataToTreemapData.bind($$)(\n\t\t\t\t$$.filterTargetsToShow(targets.filter($$.isTreemapType, $$))\n\t\t\t)\n\t\t};\n\t},\n\n\t/**\n\t * Update treemap data\n\t * @param {Array} targets Data targets\n\t * @private\n\t */\n\tupdateTargetsForTreemap(targets: IData): void {\n\t\tconst $$ = this;\n\t\tconst {$el: {treemap}} = $$;\n\t\tconst treemapData = getHierachyData.call($$, $$.getTreemapData(targets ?? $$.data.targets));\n\n\t\t// using $el.treemap reference can alter data, so select treemap <g> again\n\t\ttreemap.data($$.filterNullish(treemapData));\n\t},\n\n\t/**\n\t * Render treemap\n\t * @param {number} durationForExit Duration for exit transition\n\t * @private\n\t */\n\tupdateTreemap(durationForExit: number): void {\n\t\tconst $$ = this;\n\t\tconst {$el, $T} = $$;\n\t\tconst data = $el.treemap.datum();\n\t\tconst classChartTreemap = $$.getChartClass(\"Treemap\");\n\t\tconst classTreemap = $$.getClass(\"treemap\", true);\n\n\t\tconst treemap = $el.treemap\n\t\t\t.selectAll(\"g\")\n\t\t\t.data(data.children);\n\n\t\t$T(treemap.exit(), durationForExit)\n\t\t\t.style(\"opacity\", \"0\")\n\t\t\t.remove();\n\n\t\ttreemap.enter()\n\t\t\t.append(\"g\")\n\t\t\t.append(\"rect\");\n\n\t\t$el.treemap.selectAll(\"g\")\n\t\t\t.attr(\"class\", classChartTreemap)\n\t\t\t.select(\"rect\")\n\t\t\t.attr(\"class\", classTreemap)\n\t\t\t.attr(\"fill\", d => $$.color(d.data.name));\n\t},\n\n\t/**\n\t * Generate treemap coordinate points data\n\t * @returns {Array} Array of coordinate points\n\t * @private\n\t */\n\tgenerateGetTreemapPoints(): (d: IDataRow) => [number, number][] {\n\t\tconst $$ = this;\n\t\tconst {$el, scale: {x, y}} = $$;\n\t\tconst points = {};\n\n\t\t$el.treemap.selectAll(\"g\").each(d => {\n\t\t\tpoints[d.data.name] = [\n\t\t\t\t[x(d.x0), y(d.y0)],\n\t\t\t\t[x(d.x1), y(d.y1)]\n\t\t\t];\n\t\t});\n\n\t\treturn d => points[d.id];\n\t},\n\n\t/**\n\t * Redraw treemap\n\t * @param {boolean} withTransition With or without transition\n\t * @returns {Array} Selections\n\t * @private\n\t */\n\tredrawTreemap(withTransition?: boolean): d3Selection[] {\n\t\tconst $$ = this;\n\t\tconst {$el, state: {current: {width, height}}} = $$;\n\n\t\t// update defs\n\t\t$el.defs.select(\"rect\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height);\n\n\t\treturn [\n\t\t\t$$.$T($el.treemap, withTransition, getRandom())\n\t\t\t\t.call(position.bind($$), $el.treemap.datum())\n\t\t];\n\t},\n\n\t/**\n\t * Get treemap data label format function\n\t * @param {object} d Data object\n\t * @returns {Function}\n\t * @private\n\t */\n\ttreemapDataLabelFormat(d: IDataRow): Function {\n\t\tconst $$ = this;\n\t\tconst {config} = $$;\n\t\tconst {id, value} = d;\n\t\tconst format = config.treemap_label_format;\n\t\tconst ratio = $$.getRatio(\"treemap\", d);\n\t\tconst percentValue = (ratio * 100).toFixed(2);\n\t\tconst meetLabelThreshold = config.treemap_label_show && $$.meetsLabelThreshold(\n\t\t\t\tratio,\n\t\t\t\t\"treemap\"\n\t\t\t) ?\n\t\t\tnull :\n\t\t\t\"0\";\n\n\t\treturn function(node) {\n\t\t\tnode.style(\"opacity\", meetLabelThreshold);\n\n\t\t\treturn isFunction(format) ?\n\t\t\t\tformat.bind($$.api)(value, ratio, id) :\n\t\t\t\t`${id}\\n${percentValue}%`;\n\t\t};\n\t}\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport {IDataPoint} from \"../../../ChartInternal/data/IData\";\n\n/**\n * point config options\n */\nexport default {\n\t/**\n\t * Set point options\n\t * @name point\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} point Point object\n\t * @property {boolean} [point.show=true] Whether to show each point in line.\n\t * @property {number|Function} [point.r=2.5] The radius size of each point.\n\t *  - **NOTE:** Disabled for 'bubble' type\n\t * @property {boolean|object} [point.radialGradient=false] Set the radial gradient on point.<br><br>\n\t * Or customize by giving below object value:\n\t *  - cx {number}: `cx` value (default: `0.3`)\n\t *  - cy {number}: `cy` value (default: `0.3`)\n\t *  - r {number}: `r` value (default: `0.7`)\n\t *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.\n\t *    - (default: `[[0.1, $DATA_COLOR, 1], [0.9, $DATA_COLOR, 0]]`)\n\t * @property {boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.\n\t * @property {number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.\n\t *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`\n\t * @property {boolean} [point.focus.only=false] Show point only when is focused.\n\t * @property {number|null} [point.opacity=undefined] Set point opacity value.\n\t * - **NOTE:**\n\t * \t- `null` will make to not set inline 'opacity' css prop.\n\t * \t- when no value(or undefined) is set, it defaults to set opacity value according its chart types.\n\t * @property {number|string|Function} [point.sensitivity=10] The senstivity value for interaction boundary.\n\t * - **Available Values:**\n\t *   - {number}: Absolute sensitivity value which is the distance from the data point in pixel.\n\t *   - \"radius\": sensitivity based on point's radius\n\t *   - Function: callback for each point to determine the sensitivity<br>\n\t *    \t```js\n\t *   \tsensitivity: function(d) {\n\t * \t  // ex. of argument d:\n\t * \t  // ==> {x: 2, value: 55, id: 'data3', index: 2, r: 19.820624179302296}\n\t *\n\t * \t  // returning d.r, will make sensitivity same as point's radius value.\n\t *  \t  return d.r;\n\t * \t}\n\t * \t```\n\t * @property {number} [point.select.r=point.r*4] The radius size of each point on selected.\n\t * @property {string} [point.type=\"circle\"] The type of point to be drawn\n\t * - **NOTE:**\n\t *   - If chart has 'bubble' type, only circle can be used.\n\t *   - For IE, non circle point expansions are not supported due to lack of transform support.\n\t * - **Available Values:**\n\t *   - circle\n\t *   - rectangle\n\t * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line\n\t * - **NOTE:**\n\t *   - This is an `experimental` feature and can have some unexpected behaviors.\n\t *   - If chart has 'bubble' type, only circle can be used.\n\t *   - For IE, non circle point expansions are not supported due to lack of transform support.\n\t * - **Available Values:**\n\t *   - circle\n\t *   - rectangle\n\t *   - svg shape tag interpreted as string<br>\n\t *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)\n\t * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)\n\t * @see [Demo: point focus only](https://naver.github.io/billboard.js/demo/#Point.FocusOnly)\n\t * @see [Demo: point radialGradient](https://naver.github.io/billboard.js/demo/#Point.RadialGradientPoint)\n\t * @see [Demo: point sensitivity](https://naver.github.io/billboard.js/demo/#Point.PointSensitivity)\n\t * @example\n\t *  point: {\n\t *      show: false,\n\t *      r: 5,\n\t *\n\t *      // or customize the radius\n\t *      r: function(d) {\n\t *          ...\n\t *          return r;\n\t *      },\n\t *\n\t *      // will generate follwing radialGradient:\n\t *      // for more info: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/radialGradient\n\t *      // <radualGradient cx=\"0.3\" cy=\"0.3\" r=\"0.7\">\n\t *      //    <stop offset=\"0.1\" stop-color=\"$DATA_COLOR\" stop-opacity=\"1\"></stop>\n\t *      //    <stop offset=\"0.9\" stop-color=\"$DATA_COLOR\" stop-opacity=\"0\"></stop>\n\t *      // </radialrGradient>\n\t *      radialGradient: true,\n\t *\n\t *      // Or customized gradient\n\t *      radialGradient: {\n\t *      \tcx: 0.3,  // cx attributes\n\t *      \tcy: 0.5,  // cy attributes\n\t *      \tr: 0.7,  // r attributes\n\t *      \tstops: [\n\t *      \t  // offset, stop-color, stop-opacity\n\t *      \t  [0, \"#7cb5ec\", 1],\n\t *\n\t *      \t  // setting 'null' for stop-color, will set its original data color\n\t *      \t  [0.5, null, 0],\n\t *\n\t *      \t  // setting 'function' for stop-color, will pass data id as argument.\n\t *      \t  // It should return color string or null value\n\t *      \t  [1, function(id) { return id === \"data1\" ? \"red\" : \"blue\"; }, 0],\n\t *      \t]\n\t *      },\n\t *\n\t *      focus: {\n\t *          expand: {\n\t *              enabled: true,\n\t *              r: 1\n\t *          },\n\t *          only: true\n\t *      },\n\t *\n\t *      // do not set inline 'opacity' css prop setting\n\t *      opacity: null,\n\t *\n\t *      // set every data point's opacity value\n\t *      opacity: 0.7,\n\t *\n\t *      select: {\n\t *          r: 3\n\t *      },\n\t *\n\t *      // having lower value, means how closer to be for interaction\n\t *      sensitivity: 3,\n\t *\n\t *      // sensitivity based on point's radius\n\t *      sensitivity: \"radius\",\n\t *\n\t *      // callback for each point to determine the sensitivity\n\t *      sensitivity: function(d) {\n\t * \t// ex. of argument d:\n\t * \t// ==> {x: 2, value: 55, id: 'data3', index: 2, r: 19.820624179302296}\n\t *\n\t * \t// returning d.r, will make sensitivity same as point's radius value.\n\t * \treturn d.r;\n\t *      }\n\t *\n\t *      // valid values are \"circle\" or \"rectangle\"\n\t *      type: \"rectangle\",\n\t *\n\t *      // or indicate as pattern\n\t *      pattern: [\n\t *        \"circle\",\n\t *        \"rectangle\",\n\t *        \"<polygon points='0 6 4 0 -4 0'></polygon>\"\n\t *     ],\n\t *  }\n\t */\n\tpoint_show: true,\n\tpoint_r: 2.5,\n\tpoint_radialGradient: <boolean | {\n\t\tcx?: number,\n\t\tcy?: number,\n\t\tr?: number,\n\t\tstops?: [number, string | null | Function, number]\n\t}>false,\n\tpoint_sensitivity: <number | \"radius\" | ((d: IDataPoint) => number)>10,\n\tpoint_focus_expand_enabled: true,\n\tpoint_focus_expand_r: <number | undefined>undefined,\n\tpoint_focus_only: false,\n\tpoint_opacity: <number | null | undefined>undefined,\n\tpoint_pattern: <string[]>[],\n\tpoint_select_r: <number | undefined>undefined,\n\tpoint_type: \"circle\"\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * area config options\n */\nexport default {\n\t/**\n\t * Set area options\n\t * @name area\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} area Area object\n\t * @property {boolean} [area.above=false] Set background area `above` the data chart line.\n\t * @property {boolean} [area.below=false] Set background area `below` the data chart line.\n\t *  - **NOTE**: Can't be used along with `above` option. When above & below options are set to true, `above` will be prioritized.\n\t * @property {boolean} [area.front=true] Set area node to be positioned over line node.\n\t * @property {boolean|object} [area.linearGradient=false] Set the linear gradient on area.<br><br>\n\t * Or customize by giving below object value:\n\t *  - x {Array}: `x1`, `x2` value (default: `[0, 0]`)\n\t *  - y {Array}: `y1`, `y2` value (default: `[0, 1]`)\n\t *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.\n\t *    - (default: `[[0, $DATA_COLOR, 1], [1, $DATA_COLOR, 0]]`)\n\t * @property {boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.\n\t * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)\n\t * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)\n\t * @see [Demo: below](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Below)\n\t * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)\n\t * @example\n\t *  area: {\n\t *      above: true,\n\t *      below: false,\n\t *      zerobased: false,\n\t *\n\t *      // <g class='bb-areas'> will be positioned behind the line <g class='bb-lines'> in stacking order\n\t *      front: false,\n\t *\n\t *      // will generate follwing linearGradient:\n\t *      // for more info: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient\n\t *      // <linearGradient x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n\t *      //    <stop offset=\"0\" stop-color=\"$DATA_COLOR\" stop-opacity=\"1\"></stop>\n\t *      //    <stop offset=\"1\" stop-color=\"$DATA_COLOR\" stop-opacity=\"0\"></stop>\n\t *      // </linearGradient>\n\t *      linearGradient: true,\n\t *\n\t *      // Or customized gradient\n\t *      linearGradient: {\n\t *      \tx: [0, 0],  // x1, x2 attributes\n\t *      \ty: [0, 0],  // y1, y2 attributes\n\t *      \tstops: [\n\t *      \t  // offset, stop-color, stop-opacity\n\t *      \t  [0, \"#7cb5ec\", 1],\n\t *\n\t *      \t  // setting 'null' for stop-color, will set its original data color\n\t *      \t  [0.5, null, 0],\n\t *\n\t *      \t  // setting 'function' for stop-color, will pass data id as argument.\n\t *      \t  // It should return color string or null value\n\t *      \t  [1, function(id) { return id === \"data1\" ? \"red\" : \"blue\"; }, 0],\n\t *      \t]\n\t *      }\n\t *  }\n\t */\n\tarea_above: false,\n\tarea_below: false,\n\tarea_front: true,\n\tarea_linearGradient: <boolean | {\n\t\tx?: [number, number],\n\t\ty?: [number, number],\n\t\tstops?: [number, string | null | Function, number]\n\t}>false,\n\tarea_zerobased: true\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * bar config options\n */\nexport default {\n\t/**\n\t * Set bar options\n\t * @name bar\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} bar Bar object\n\t * @property {boolean} [bar.front=false] Set 'bar' to be positioned over(on the top) other shapes elements.\n\t * @property {number} [bar.indices.removeNull=false] Remove nullish data on bar indices positions.\n\t * @property {number} [bar.label.threshold=0] Set threshold ratio to show/hide labels.\n\t * @property {boolean|object} [bar.linearGradient=false] Set the linear gradient on bar.<br><br>\n\t * Or customize by giving below object value:\n\t *  - x {Array}: `x1`, `x2` value (default: `[0, 0]`)\n\t *  - y {Array}: `y1`, `y2` value (default: `[0, 1]`)\n\t *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.\n\t *    - (default: `[[0, $DATA_COLOR, 1], [1, $DATA_COLOR, 0]]`)\n\t * @property {boolean} [bar.overlap=false] Bars will be rendered at same position, which will be overlapped each other. (for non-grouped bars only)\n\t * @property {number} [bar.padding=0] The padding pixel value between each bar.\n\t * @property {number} [bar.radius] Set the radius of bar edge in pixel.\n\t * @property {number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.\n\t * @property {number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.\n\t * @property {number|Function|object} [bar.width] Change the width of bar chart.\n\t * @property {number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.\n\t * - **NOTE:** Criteria for ratio.\n\t *   - When x ticks count is same with the data count, the baseline for ratio is the minimum interval value of x ticks.\n\t * \t   - ex. when timeseries x values are: [2024-01-01, 2024-02-01, 2024-03-01], the minimum interval will be `2024-02-01 ~ 2024-03-01`\n\t *     - if the minimum interval is 30px, then ratio=1 means 30px.\n\t *   - When x ticks count is lower than the data count, the baseline will be calculated as `chart width / data count`.\n\t * \t   - ex. when chart width is 500, data count is 5, then ratio=1 means 100px.\n\t * @property {number} [bar.width.max] The maximum width value for ratio.\n\t * @property {number} [bar.width.dataname] Change the width of bar for indicated dataset only.\n\t * @property {number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.\n\t *  - **NOTE:**\n\t *   - Works only for non-stacked bar\n\t * @property {number} [bar.width.dataname.max] The maximum width value for ratio.\n\t * @property {boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.\n\t * @see [Demo: bar front](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarFront)\n\t * @see [Demo: bar indices](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarIndices)\n\t * @see [Demo: bar overlap](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarOverlap)\n\t * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)\n\t * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)\n\t * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)\n\t * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)\n\t * @example\n\t *  bar: {\n\t *      // make bar shape to be positioned over the other shape elements\n\t *      front: true,\n\t *\n\t *      // remove nullish data on bar indices postions\n\t *      indices: {\n\t *          removeNull: true\n\t *      },\n\t *\n\t *      // will generate follwing linearGradient:\n\t *      // for more info: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient\n\t *      // <linearGradient x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n\t *      //    <stop offset=\"0\" stop-color=\"$DATA_COLOR\" stop-opacity=\"1\"></stop>\n\t *      //    <stop offset=\"1\" stop-color=\"$DATA_COLOR\" stop-opacity=\"0\"></stop>\n\t *      // </linearGradient>\n\t *      linearGradient: true,\n\t *\n\t *      // Or customized gradient\n\t *      linearGradient: {\n\t *      \tx: [0, 0],  // x1, x2 attributes\n\t *      \ty: [0, 0],  // y1, y2 attributes\n\t *      \tstops: [\n\t *      \t  // offset, stop-color, stop-opacity\n\t *      \t  [0, \"#7cb5ec\", 1],\n\t *\n\t *      \t  // setting 'null' for stop-color, will set its original data color\n\t *      \t  [0.5, null, 0],\n\t *\n\t *      \t  // setting 'function' for stop-color, will pass data id as argument.\n\t *      \t  // It should return color string or null value\n\t *      \t  [1, function(id) { return id === \"data1\" ? \"red\" : \"blue\"; }, 0],\n\t *      \t]\n\t *      },\n\t *\n\t *      // remove nullish da\n\t *      overlap: true,\n\t *\n\t *      padding: 1,\n\t *\n\t *      // bar radius\n\t *      radius: 10,\n\t *      // or\n\t *      radius: {\n\t *          ratio: 0.5\n\t *      }\n\t *\n\t *      label: {\n\t *          // 0.1(10%) ratio value means, the minimum ratio to show text label relative to the y Axis domain range value.\n\t *          // if data value is below than 0.1, text label will be hidden.\n\t *          threshold: 0.1,\n\t *      },\n\t *\n\t *      // will not have offset between each bar elements for interaction\n\t *      sensitivity: 0,\n\t *\n\t *      width: 10,\n\t *\n\t *      // or specify width callback. The callback will receive width, targetsNum, maxDataCount as arguments.\n\t *      // - width: chart area width\n\t *      // - targetsNum: number of targets\n\t *      // - maxDataCount: maximum data count among targets\n\t *      width: function(width, targetsNum, maxDataCount) {\n\t *            return width / (targetsNum * maxDataCount);\n\t *      }\n\t *\n\t *      // or specify ratio & max\n\t *      width: {\n\t *          ratio: 0.2,\n\t *          max: 20\n\t *      },\n\t *\n\t *      // or specify width per dataset\n\t *      width: {\n\t *          data1: 20,\n\t *          data2: {\n\t *              ratio: 0.2,\n\t *              max: 20\n\t *          }\n\t *      },\n\t *\n\t *      zerobased: false\n\t *  }\n\t */\n\tbar_connectLine: <\"end-end\" | \"end-start\" | \"start-end\" | \"start-start\" | false>false,\n\tbar_front: false,\n\tbar_indices_removeNull: false,\n\tbar_label_threshold: 0,\n\tbar_linearGradient: <boolean | {\n\t\tx?: [number, number],\n\t\ty?: [number, number],\n\t\tstops?: [number, string | null | Function, number]\n\t}>false,\n\tbar_overlap: false,\n\tbar_padding: 0,\n\tbar_radius: <number | {ratio: number} | undefined>undefined,\n\tbar_radius_ratio: <number | undefined>undefined,\n\tbar_sensitivity: 2,\n\tbar_width: <number | ((width: number, targetsNum: number, maxDataCount: number) => number) | {\n\t\tratio?: number,\n\t\tmax?: number\n\t} | undefined>undefined,\n\tbar_width_ratio: 0.6,\n\tbar_width_max: undefined,\n\tbar_zerobased: true\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * bubble config options\n */\nexport default {\n\t/**\n\t * Set bubble options\n\t * @name bubble\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} bubble bubble object\n\t * @property {number|Function} [bubble.maxR=35] Set the max bubble radius value\n\t * @property {boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.\n\t * @example\n\t *  bubble: {\n\t *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.\n\t *      // And the lesser will have radius relatively from tha max value.\n\t *      maxR: 50,\n\t *\n\t *      // or set radius callback\n\t *      maxR: function(d) {\n\t *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: \"data2\", index: 5}\n\t *          ...\n\t *          return Math.sqrt(d.value * 2);\n\t *      },\n\t *      zerobased: false\n\t *  }\n\t */\n\tbubble_maxR: <number | (() => number)>35,\n\tbubble_zerobased: false\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * candlestick config options\n */\nexport default {\n\t/**\n\t * Set candlestick options\n\t * @name candlestick\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} candlestick Candlestick object\n\t * @property {number} [candlestick.width] Change the width.\n\t * @property {number} [candlestick.width.ratio=0.6] Change the width by ratio.\n\t * @property {number} [candlestick.width.max] The maximum width value for ratio.\n\t * @property {number} [candlestick.width.dataname] Change the width for indicated dataset only.\n\t * @property {number} [candlestick.width.dataname.ratio=0.6] Change the width of bar chart by ratio.\n\t * @property {number} [candlestick.width.dataname.max] The maximum width value for ratio.\n\t * @property {object} [candlestick.color] Color setting.\n\t * @property {string|object} [candlestick.color.down] Change down(bearish) value color.\n\t * @property {string} [candlestick.color.down.dataname] Change down value color for indicated dataset only.\n\t *\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/##Chart.CandlestickChart)\n\t * @example\n\t *  candlestick: {\n\t *      width: 10,\n\t *\n\t *      // or\n\t *      width: {\n\t *         \tratio: 0.2,\n\t *         \tmax: 20\n\t *      },\n\t *\n\t *      // or specify width per dataset\n\t *      width: {\n\t *         \tdata1: 20,\n\t *         \tdata2: {\n\t *         \t    ratio: 0.2,\n\t *         \t\tmax: 20\n\t *         \t}\n\t *      },\n\t *      color: {\n\t *  \t  \t// spcify bearish color\n\t *  \t  \tdown: \"red\",\n\t *\n\t *  \t  \t// or specify color per dataset\n\t *  \t  \tdown: {\n\t *  \t  \t\tdata1: \"red\",\n\t *  \t  \t\tdata2: \"blue\",\n\t *  \t  \t}\n\t *      }\n\t *  }\n\t */\n\tcandlestick_width: <number | {ratio?: number, max?: number} | undefined>undefined,\n\tcandlestick_width_ratio: 0.6,\n\tcandlestick_width_max: undefined,\n\tcandlestick_color_down: <string | {[key: string]: string}>\"red\"\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * line config options\n */\nexport default {\n\t/**\n\t * Set line options\n\t * @name line\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} line Line object\n\t * @property {boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>\n\t *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.\n\t * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.\n\t * @property {boolean} [line.step.type=step] Change step type for step chart.<br>\n\t * **Available values:**\n\t * - step\n\t * - step-before\n\t * - step-after\n\t * @property {boolean} [line.step.tooltipMatch=false] Set to `true` for `step-before` and `step-after` types to have cursor/tooltip match to hovered step's point instead of nearest point.\n\t * @property {boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.\n\t * @property {boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.\n\t * @example\n\t *  line: {\n\t *      connectNull: true,\n\t *      classes: [\n\t *          \"line-class1\",\n\t *          \"line-class2\"\n\t *      ],\n\t *      step: {\n\t *          type: \"step-after\",\n\t *\n\t *          // to have cursor/tooltip match to hovered step's point instead of nearest point.\n\t *          tooltipMatch: true\n\t *      },\n\t *\n\t *      // hide all data points ('point.show=false' also has similar effect)\n\t *      point: false,\n\t *\n\t *      // show data points for only indicated datas\n\t *      point: [\n\t *          \"data1\", \"data3\"\n\t *      ],\n\t *\n\t *      zerobased: false\n\t *  }\n\t */\n\tline_connectNull: false,\n\tline_step_type: <\"step\" | \"step-before\" | \"step-after\">\"step\",\n\tline_step_tooltipMatch: false,\n\tline_zerobased: false,\n\tline_classes: <string[] | undefined>undefined,\n\tline_point: <string[] | boolean>true\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * scatter config options\n */\nexport default {\n\t/**\n\t * Set scatter options\n\t * @name scatter\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} [scatter] scatter object\n\t * @property {boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.\n\t * @example\n\t *  scatter: {\n\t *      connectNull: true,\n\t *      step: {\n\t *          type: \"step-after\"\n\t *      },\n\t *\n\t *      // hide all data points ('point.show=false' also has similar effect)\n\t *      point: false,\n\t *\n\t *      // show data points for only indicated datas\n\t *      point: [\n\t *          \"data1\", \"data3\"\n\t *      ],\n\t *\n\t *      zerobased: false\n\t *  }\n\t */\n\tscatter_zerobased: false\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * spline config options\n */\nexport default {\n\t/**\n\t * Set spline options\n\t * - **Available interpolation type values:**\n\t *  - basis (d3.curveBasis)\n\t *  - basis-closed (d3.curveBasisClosed)\n\t *  - basis-open (d3.curveBasisOpen)\n\t *  - bundle (d3.curveBundle)\n\t *  - cardinal (d3.curveCardinal)\n\t *  - cardinal-closed (d3.curveCardinalClosed)\n\t *  - cardinal-open (d3.curveCardinalOpen)\n\t *  - catmull-rom (d3.curveCatmullRom)\n\t *  - catmull-rom-closed (d3.curveCatmullRomClosed)\n\t *  - catmull-rom-open (d3.curveCatmullRomOpen)\n\t *  - monotone-x (d3.curveMonotoneX)\n\t *  - monotone-y (d3.curveMonotoneY)\n\t *  - natural (d3.curveNatural)\n\t *  - linear-closed (d3.curveLinearClosed)\n\t *  - linear (d3.curveLinear)\n\t *  - step (d3.curveStep)\n\t *  - step-after (d3.curveStepAfter)\n\t *  - step-before (d3.curveStepBefore)\n\t * @name spline\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} spline Spline object\n\t * @property {object} spline.interpolation Spline interpolation object\n\t * @property {string} [spline.interpolation.type=\"cardinal\"] Interpolation type\n\t * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)\n\t * @example\n\t *  spline: {\n\t *      interpolation: {\n\t *          type: \"cardinal\"\n\t *      }\n\t *  }\n\t */\n\tspline_interpolation_type: \"cardinal\"\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * arc config options\n */\nexport default {\n\t/**\n\t * Set arc options\n\t * @name arc\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} arc Arc object\n\t * @property {number|Function} [arc.cornerRadius=0] Set corner radius of Arc(donut/gauge/pie/polar) shape.\n\t *  - **NOTE:**\n\t * \t  - Corner radius can't surpass the `(outerRadius - innerRadius) /2` of indicated shape.\n\t * @property {number} [arc.cornerRadius.ratio=0] Set ratio relative of outer radius.\n\t * @property {object} [arc.needle] Set needle options.\n\t * @property {boolean} [arc.needle.show=false] Show or hide needle.\n\t * @property {string} [arc.needle.color] Set needle filled color.\n\t * @property {Function} [arc.needle.path] Set custom needle path function.\n\t *  - **NOTE:**\n\t *   - The path should be starting from 0,0 (which is center) to top center coordinate.\n\t *   - The function will receive, `length`{number} parameter which indicating the needle length in pixel relative to radius.\n\t * @property {number} [arc.needle.value] Set needle value.\n\t *  - **NOTE:**\n\t *   - For single gauge chart, needle will point the data value by default, otherwise will point 0(zero).\n\t * @property {number} [arc.needle.length=100] Set needle length in percentages relative to radius.\n\t * @property {object} [arc.needle.top] Set needle top options.\n\t * @property {number} [arc.needle.top.rx=0] Set needle top [rx radius value](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#elliptical_arc_curve).\n\t * @property {number} [arc.needle.top.ry=0] Set needle top [ry radius value](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#elliptical_arc_curve).\n\t * @property {number} [arc.needle.top.width=0] Set needle top width in pixel.\n\t * @property {object} [arc.needle.bottom] Set needle bottom options.\n\t * @property {number} [arc.needle.bottom.rx=1] Set needle bottom [rx radius value](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#elliptical_arc_curve).\n\t * @property {number} [arc.needle.bottom.ry=1] Set needle bottom [ry radius value](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#elliptical_arc_curve).\n\t * @property {number} [arc.needle.bottom.width=15] Set needle bottom width in pixel.\n\t * @property {number} [arc.needle.bottom.len=0] Set needle bottom length in pixel. Setting this value, will make bottom larger starting from center.\n\t * @property {object} [arc.rangeText] Set rangeText options.\n\t * @property {Array} [arc.rangeText.values] Set range text values to be shown around Arc.\n\t * - When `unit: 'absolute'`: Given values are treated as absolute values.\n\t * - When `unit: '%'`: Given values are treated as percentages.\n\t * @property {string} [arc.rangeText.unit=\"absolute\"] Specify the range text unit.\n\t * - \"absolute\": Show absolute value\n\t * - \"%\": Show percentage value\n\t * @property {boolean} [arc.rangeText.fiexed=false] Set if range text shown will be fixed w/o data toggle update. Only available for gauge chart.\n\t * @property {Function} [arc.rangeText.format] Set format function for the range text.\n\t * @property {number} [arc.rangeText.position] Set position function or object for the range text.\n\t * @see [Demo: Donut corner radius](https://naver.github.io/billboard.js/demo/#DonutChartOptions.DonutCornerRadius)\n\t * @see [Demo: Donut corner radius](https://naver.github.io/billboard.js/demo/#PieChartOptions.CornerRadius)\n\t * @see [Demo: Donut needle](https://naver.github.io/billboard.js/demo/#DonutChartOptions.DonutNeedle)\n\t * @see [Demo: Donut RangeText](https://naver.github.io/billboard.js/demo/#DonutChartOptions.DonutRangeText)\n\t * @see [Demo: Gauge corner radius](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeCornerRadius)\n\t * @see [Demo: Gauge needle](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeNeedle)\n\t * @see [Demo: Gauge RangeText](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeRangeText)\n\t * @example\n\t *  arc: {\n\t *      cornerRadius: 12,\n\t *\n\t *      // can customize corner radius for each data with function callback\n\t *      //\n\t *      // The function will receive:\n\t *      // - id {string}: Data id\n\t *      // - value {number}: Data value\n\t *      // - outerRadius {number}: Outer radius value\n\t *      cornerRadius: function(id, value, outerRadius) {\n\t *          return (id === \"data1\" && value > 10) ?\n\t *          \t50 : outerRadius * 1.2;\n\t *      },\n\t *\n\t *      // set ratio relative of outer radius\n\t *      cornerRadius: {\n\t *          ratio: 0.5\n\t *      },\n\t *\n\t *      needle: {\n\t *       \tshow: true,\n\t *       \tcolor: \"red\", // any valid CSS color\n\t *       \tpath: function(length) {\n\t *       \t  const len = length - 20;\n\t *\n\t *       \t  // will return upper arrow shape path\n\t *       \t  // Note: The path should begun from '0,0' coordinate to top center.\n\t *       \t  const path = `M 0 -${len + 20}\n\t *       \t\tL -12 -${len}\n\t *       \t\tL -5 -${len}\n\t *       \t\tL -5 0\n\t *       \t\tA 1 1 0 0 0 5 0\n\t *       \t\tL 5 -${len}\n\t *       \t\tL 12 -${len} Z`;\n\t *\n\t *       \t  return path;\n\t *       \t},\n\t *       \tvalue: 40,  // will make needle to point value 40.\n\t *       \tlength: 80, // needle length in percentages relative to radius.\n\t *\n\t *       \ttop: {\n\t *       \t  // rx and ry are the two radii of the ellipse;\n\t *       \t  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#elliptical_arc_curve\n\t *       \t  rx: 1,\n\t *       \t  ry: 1,\n\t *       \t  width: 5\n\t *       \t},\n\t *       \tbottom: {\n\t *       \t  // rx and ry are the two radii of the ellipse;\n\t *       \t  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#elliptical_arc_curve\n\t *       \t  rx: 1,\n\t *       \t  ry: 1,\n\t *       \t  width: 10\n\t *       \t  len: 10\n\t *       \t}\n\t *      },\n\t *\n\t *      rangeText: {\n\t *       \tvalues: [15, 30, 50, 75, 95],\n\t *       \tunit: \"%\",\n\t *       \tfixed: false, // only available for gauge chart\n\t *       \tformat: function(v) {\n\t *       \t  return v === 15 ? \"Fifteen\" : v;\n\t *       \t},\n\t *\n\t *       \tposition: function(v) {\n\t *       \t  return v === 15 ? {x: 20, y: 10} : null; // can return one props value also.\n\t *       \t},\n\t *       \tposition: {x: 10, y: 15},\n\t *       \tposition: {x: 10}\n\t *      }\n\t *  }\n\t */\n\tarc_cornerRadius: <number | ((id: string, value: number) => number)>0,\n\tarc_cornerRadius_ratio: 0,\n\tarc_needle_show: false,\n\tarc_needle_color: <string | undefined>undefined,\n\tarc_needle_value: <number | undefined>undefined,\n\tarc_needle_path: undefined,\n\tarc_needle_length: 100,\n\tarc_needle_top_rx: 0,\n\tarc_needle_top_ry: 0,\n\tarc_needle_top_width: 0,\n\tarc_needle_bottom_rx: 1,\n\tarc_needle_bottom_ry: 1,\n\tarc_needle_bottom_width: 15,\n\tarc_needle_bottom_len: 0,\n\tarc_rangeText_values: <number[] | undefined>undefined,\n\tarc_rangeText_unit: <\"absolute\" | \"%\">\"absolute\",\n\tarc_rangeText_fixed: false,\n\tarc_rangeText_format: <((v: number) => number) | undefined>undefined,\n\tarc_rangeText_position: <\n\t\t| ((v: number) => {x?: number, y?: number})\n\t\t| {x?: number, y?: number}\n\t\t| undefined\n\t>undefined\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * donut config options\n */\nexport default {\n\t/**\n\t * Set donut options\n\t * @name donut\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} donut Donut object\n\t * @property {boolean} [donut.label.show=true] Show or hide label on each donut piece.\n\t * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.\n\t * @property {number} [donut.label.threshold=0.05] Set threshold ratio to show/hide labels.\n\t * @property {number|Function} [donut.label.ratio=undefined] Set ratio of labels position.\n\t * @property {boolean} [donut.expand=true] Enable or disable expanding donut pieces.\n\t * @property {number} [donut.expand.rate=0.98] Set expand rate.\n\t * @property {number} [donut.expand.duration=50] Set expand transition time in ms.\n\t * @property {number} [donut.width] Set width of donut chart.\n\t * @property {string} [donut.title=\"\"] Set title of donut chart. Use `\\n` character for line break.\n\t *  - **NOTE:**\n\t *    - When `arc.needle.show=true` is set, special template `{=NEEDLE_VALUE}` can be used inside the title text to show current needle value.\n\t * @property {number} [donut.padAngle=0] Set padding between data.\n\t * @property {number} [donut.startingAngle=0] Set starting angle where data draws.\n\t * @example\n\t *  donut: {\n\t *      label: {\n\t *          show: false,\n\t *          format: function(value, ratio, id) {\n\t *              return d3.format(\"$\")(value);\n\t *\n\t *              // to multiline, return with '\\n' character\n\t *              // return value +\"%\\nLine1\\n2Line2\";\n\t *          },\n\t *\n\t *          // 0.1(10%) ratio value means, the minimum ratio to show text label relative to the total value.\n\t *          // if data value is below than 0.1, text label will be hidden.\n\t *          threshold: 0.1,\n\t *\n\t *          // set ratio callback. Should return ratio value\n\t *          ratio: function(d, radius, h) {\n\t *          \t...\n\t *          \treturn ratio;\n\t *          },\n\t *          // or set ratio number\n\t *          ratio: 0.5\n\t *      },\n\t *\n\t *      // disable expand transition for interaction\n\t *      expand: false,\n\t *\n\t *      expand: {\n\t *      \t// set duration of expand transition to 500ms.\n\t *          duration: 500,\n\t *\n\t *      \t// set expand area rate\n\t *          rate: 1\n\t *      },\n\t *\n\t *      width: 10,\n\t *      padAngle: 0.2,\n\t *      startingAngle: 1,\n\t *      title: \"Donut Title\"\n\t *\n\t *      // when 'arc.needle.show=true' is set, can show current needle value.\n\t *      title: \"Needle value:\\n{=NEEDLE_VALUE}\",\n\t *\n\t *      // title with line break\n\t *      title: \"Title1\\nTitle2\"\n\t *  }\n\t */\n\tdonut_label_show: true,\n\tdonut_label_format: <(() => number | string) | undefined>undefined,\n\tdonut_label_threshold: 0.05,\n\tdonut_label_ratio: <number | (() => number) | undefined>undefined,\n\tdonut_width: <number | undefined>undefined,\n\tdonut_title: \"\",\n\tdonut_expand: <boolean | {rate?: number, duration?: number}>{},\n\tdonut_expand_rate: 0.98,\n\tdonut_expand_duration: 50,\n\tdonut_padAngle: 0,\n\tdonut_startingAngle: 0\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * funnel config options\n */\nexport default {\n\t/**\n\t * Set funnel options\n\t * @name funnel\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} funnel Funnel object\n\t * @property {number} [funnel.neck.width=0] Set funnel neck width.\n\t * @property {number} [funnel.neck.height=0] Set funnel neck height.\n\t * @property {number} [funnel.neck.width.ratio] Set funnel neck width in ratio.\n\t * @property {number} [funnel.neck.height.ratio] Set funnel neck height in ratio.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.PolarChart)\n\t * @example\n\t *  funnel: {\n\t *      neck: {\n\t *          width: 200,\n\t *          height: 100,\n\t *\n\t *          // or specify as ratio value (relative to the chart size)\n\t *          width: {\n\t *            ratio: 0.5\n\t *          },\n\t *          height: {\n\t *            ratio: 0.5\n\t *          }\n\t *      }\n\t *  }\n\t */\n\tfunnel_neck_width: <number | {ratio: number}>0,\n\tfunnel_neck_height: <number | {ratio: number}>0\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * gauge config options\n */\nexport default {\n\t/**\n\t * Set gauge options\n\t * @name gauge\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} gauge Gauge object\n\t * @property {boolean} [gauge.background=\"\"] Set background color. (The `.bb-chart-arcs-background` element)\n\t * @property {boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.\n\t * @property {boolean} [gauge.label.show=true] Show or hide label on gauge.\n\t * @property {Function} [gauge.label.extents] Set customized min/max label text.\n\t * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\\n` character.<br>\n\t * Will pass following arguments to the given function:\n\t * - value {number}: absolute value\n\t * - ratio {number}: value's ratio\n\t * - id {string}: data's id value\n\t * @property {number|Function} [gauge.label.ratio=undefined] Set ratio of labels position.\n\t * @property {number} [gauge.label.threshold=0] Set threshold ratio to show/hide labels.\n\t * @property {boolean} [gauge.expand=true] Enable or disable expanding gauge.\n\t * @property {number} [gauge.expand.rate=0.98] Set expand rate.\n\t * @property {number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.\n\t * @property {boolean} [gauge.enforceMinMax=false] Enforce to given min/max value.\n\t * - **Note:** Only works for single data series.\n\t * \t- When `gauge.min=50` and given value is `30`, gauge will render as empty value.\n\t * \t- When `gauge.max=100` and given value is `120`, gauge will render till 100, not surpassing max value.\n\t * @property {number} [gauge.min=0] Set min value of the gauge.\n\t * @property {number} [gauge.max=100] Set max value of the gauge.\n\t * @property {number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.\n\t *\n\t * **Limitations:**\n\t * - when `gauge.fullCircle=false`:\n\t *   - -1 * Math.PI / 2 <= startingAngle <= Math.PI / 2\n\t *   - `startingAngle <= -1 * Math.PI / 2` defaults to `-1 * Math.PI / 2`\n\t *   - `startingAngle >= Math.PI / 2` defaults to `Math.PI / 2`\n\t * - when `gauge.fullCircle=true`:\n\t *   - -1 * Math.PI < startingAngle < Math.PI\n\t *   - `startingAngle < -1 * Math.PI` defaults to `Math.PI`\n\t *   - `startingAngle >  Math.PI` defaults to `Math.PI`\n\t * @property {number} [gauge.arcLength=100] Set the length of the arc to be drawn in percent from -100 to 100.<br>\n\t * Negative value will draw the arc **counterclockwise**. Need to be used in conjunction with `gauge.fullCircle=true`.\n\t *\n\t * **Limitations:**\n\t * - -100 <= arcLength (in percent) <= 100\n\t * - 'arcLength < -100' defaults to -100\n\t * - 'arcLength > 100' defaults to 100\n\t * @property {string} [gauge.title=\"\"] Set title of gauge chart. Use `\\n` character for line break.\n\t *  - **NOTE:**\n\t *    - When `arc.needle.show=true` is set, special template `{=NEEDLE_VALUE}` can be used inside the title text to show current needle value.\n\t * @property {string} [gauge.units] Set units of the gauge.\n\t * @property {number} [gauge.width] Set width of gauge chart.\n\t * @property {string} [gauge.type=\"single\"] Set type of gauge to be displayed.<br><br>\n\t * **Available Values:**\n\t * - single\n\t * - multi\n\t * @property {number} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.\n\t * @see [Demo: enforceMinMax, min/max](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeMinMax)\n\t * @see [Demo: archLength](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeArcLength)\n\t * @see [Demo: startingAngle](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeStartingAngle)\n\t * @see [Demo: labelRatio](https://naver.github.io/billboard.js/demo/#GaugeChartOptions.GaugeLabelRatio)\n\t * @example\n\t *  gauge: {\n\t *      background: \"#eee\", // will set 'fill' css prop for '.bb-chart-arcs-background' classed element.\n\t *      fullCircle: false,\n\t *      label: {\n\t *          show: false,\n\t *          format: function(value, ratio, id) {\n\t *              return value;\n\t *\n\t *              // to multiline, return with '\\n' character\n\t *              // return value +\"%\\nLine1\\n2Line2\";\n\t *          },\n\t *\n\t *           extents: function(value, isMax) {\n\t *              return (isMax ? \"Max:\" : \"Min:\") + value;\n\t *          },\n\t *\n\t *          // 0.1(10%) ratio value means, the minimum ratio to show text label relative to the total value.\n\t *          // if data value is below than 0.1, text label will be hidden.\n\t *          threshold: 0.1,\n\t *\n\t *          // set ratio callback. Should return ratio value\n\t *          ratio: function(d, radius, h) {\n\t *              ...\n\t *              return ratio;\n\t *          },\n\t *          // or set ratio number\n\t *          ratio: 0.5\n\t *      },\n\t *\n\t *      // disable expand transition for interaction\n\t *      expand: false,\n\t *\n\t *      expand: {\n\t *      \t// set duration of expand transition to 500ms.\n\t *          duration: 500,\n\t *\n\t *      \t// set expand area rate\n\t *          rate: 1\n\t *      },\n\t *\n\t *      // enforce min/max value.\n\t * \t\t// when given value < min, will render as empty value.\n\t * \t\t// when value > max, will render to given max value not surpassing it.\n\t *      enforceMinMax: true,\n\t *\n\t *      min: -100,\n\t *      max: 200,\n\t *      type: \"single\"  // or 'multi'\n\t *      title: \"Title Text\",\n\t *\n\t *      // when 'arc.needle.show=true' is set, can show current needle value.\n\t *      title: \"Needle value:\\n{=NEEDLE_VALUE}\",\n\t *\n\t *      units: \"%\",\n\t *      width: 10,\n\t *      startingAngle: -1 * Math.PI / 2,\n\t *      arcLength: 100,\n\t *      arcs: {\n\t *          minWidth: 5\n\t *      }\n\t *  }\n\t */\n\tgauge_background: \"\",\n\tgauge_fullCircle: false,\n\tgauge_label_show: true,\n\tgauge_label_extents: <(() => string) | undefined>undefined,\n\tgauge_label_format: <(() => string) | undefined>undefined,\n\tgauge_label_ratio: <(() => number) | undefined>undefined,\n\tgauge_label_threshold: 0,\n\tgauge_enforceMinMax: false,\n\tgauge_min: 0,\n\tgauge_max: 100,\n\tgauge_type: \"single\",\n\tgauge_startingAngle: -1 * Math.PI / 2,\n\tgauge_arcLength: 100,\n\tgauge_title: \"\",\n\tgauge_units: <string | undefined>undefined,\n\tgauge_width: <number | undefined>undefined,\n\tgauge_arcs_minWidth: 5,\n\tgauge_expand: <boolean | {duration: number}>{},\n\tgauge_expand_rate: 0.98,\n\tgauge_expand_duration: 50\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * pie config options\n */\nexport default {\n\t/**\n\t * Set pie options\n\t * @name pie\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} pie Pie object\n\t * @property {boolean} [pie.label.show=true] Show or hide label on each pie piece.\n\t * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.\n\t * @property {number|Function} [pie.label.ratio=undefined] Set ratio of labels position.\n\t * @property {number} [pie.label.threshold=0.05] Set threshold ratio to show/hide labels.\n\t * @property {boolean|object} [pie.expand=true] Enable or disable expanding pie pieces.\n\t * @property {number} [pie.expand.rate=0.98] Set expand rate.\n\t * @property {number} [pie.expand.duration=50] Set expand transition time in ms.\n\t * @property {number|object} [pie.innerRadius=0] Sets the inner radius of pie arc.\n\t * @property {number|object|undefined} [pie.outerRadius=undefined] Sets the outer radius of pie arc.\n\t * @property {number} [pie.padAngle=0] Set padding between data.\n\t * @property {number} [pie.padding=0] Sets the gap between pie arcs.\n\t * @property {number} [pie.startingAngle=0] Set starting angle where data draws.\n\t * @see [Demo: expand.rate](https://naver.github.io/billboard.js/demo/#PieChartOptions.ExpandRate)\n\t * @see [Demo: innerRadius](https://naver.github.io/billboard.js/demo/#PieChartOptions.InnerRadius)\n\t * @see [Demo: outerRadius](https://naver.github.io/billboard.js/demo/#PieChartOptions.OuterRadius)\n\t * @see [Demo: startingAngle](https://naver.github.io/billboard.js/demo/#PieChartOptions.StartingAngle)\n\t * @example\n\t *  pie: {\n\t *      label: {\n\t *          show: false,\n\t *          format: function(value, ratio, id) {\n\t *              return d3.format(\"$\")(value);\n\t *\n\t *              // to multiline, return with '\\n' character\n\t *              // return value +\"%\\nLine1\\n2Line2\";\n\t *          },\n\t *\n\t *          // 0.1(10%) ratio value means, the minimum ratio to show text label relative to the total value.\n\t *          // if data value is below than 0.1, text label will be hidden.\n\t *          threshold: 0.1,\n\t *\n\t *          // set ratio callback. Should return ratio value\n\t *          ratio: function(d, radius, h) {\n\t *              ...\n\t *              return ratio;\n\t *          },\n\t *          // or set ratio number\n\t *          ratio: 0.5\n\t *      },\n\t *\n\t *      // disable expand transition for interaction\n\t *      expand: false,\n\t *\n\t *      expand: {\n\t *      \t// set duration of expand transition to 500ms.\n\t *          duration: 500,\n\t *\n\t *      \t// set expand area rate\n\t *          rate: 1\n\t *      },\n\t *\n\t *      innerRadius: 0,\n\t *\n\t *      // set different innerRadius for each data\n\t *      innerRadius: {\n\t *      \tdata1: 10,\n\t *      \tdata2: 0\n\t *      },\n\t *\n\t *      outerRadius: 100,\n\t *\n\t *      // set different outerRadius for each data\n\t *      outerRadius: {\n\t *      \tdata1: 50,\n\t *      \tdata2: 100\n\t *      }\n\t *\n\t *      padAngle: 0.1,\n\t *      padding: 0,\n\t *      startingAngle: 1\n\t *  }\n\t */\n\tpie_label_show: true,\n\tpie_label_format: <(() => number | string) | undefined>undefined,\n\tpie_label_ratio: <(() => number) | undefined>undefined,\n\tpie_label_threshold: 0.05,\n\tpie_expand: <boolean | {rate?: number, duration?: number}>{},\n\tpie_expand_rate: 0.98,\n\tpie_expand_duration: 50,\n\tpie_innerRadius: <number | {[key: string]: number}>0,\n\tpie_outerRadius: <number | {[key: string]: number} | undefined>undefined,\n\tpie_padAngle: 0,\n\tpie_padding: 0,\n\tpie_startingAngle: 0\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * polar config options\n */\nexport default {\n\t/**\n\t * Set polar options\n\t * @name polar\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} polar Polar object\n\t * @property {boolean} [polar.label.show=true] Show or hide label on each polar piece.\n\t * @property {Function} [polar.label.format] Set formatter for the label on each polar piece.\n\t * @property {number} [polar.label.threshold=0.05] Set threshold ratio to show/hide labels.\n\t * @property {number|Function} [polar.label.ratio=undefined] Set ratio of labels position.\n\t * @property {number} [polar.level.depth=3] Set the level depth.\n\t * @property {boolean} [polar.level.show=true] Show or hide level.\n\t * @property {string} [polar.level.text.backgroundColor=\"#fff\"] Set label text's background color.\n\t * @property {Function} [polar.level.text.format] Set format function for the level value.<br>- Default value: `(x) => x % 1 === 0 ? x : x.toFixed(2)`\n\t * @property {boolean} [polar.level.text.show=true] Show or hide level text.\n\t * @property {number} [polar.padAngle=0] Set padding between data.\n\t * @property {number} [polar.padding=0] Sets the gap between pie arcs.\n\t * @property {number} [polar.startingAngle=0] Set starting angle where data draws.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.PolarChart)\n\t * @example\n\t *  polar: {\n\t *      label: {\n\t *          show: false,\n\t *          format: function(value, ratio, id) {\n\t *              return d3.format(\"$\")(value);\n\t *\n\t *              // to multiline, return with '\\n' character\n\t *              // return value +\"%\\nLine1\\n2Line2\";\n\t *          },\n\t *\n\t *          // 0.1(10%) ratio value means, the minimum ratio to show text label relative to the total value.\n\t *          // if data value is below than 0.1, text label will be hidden.\n\t *          threshold: 0.1,\n\t *\n\t *          // set ratio callback. Should return ratio value\n\t *          ratio: function(d, radius, h) {\n\t *              ...\n\t *              return ratio;\n\t *          },\n\t *          // or set ratio number\n\t *          ratio: 0.5\n\t *      },\n\t *      level: {\n\t *          depth: 3,\n\t *          max: 500,\n\t *          show: true,\n\t *          text: {\n\t *              format: function(x) {\n\t *                  return x + \"%\";\n\t *              },\n\t *              show: true,\n\t *              backgroundColor: \"red\"\n\t *          }\n\t *      },\n\t *      padAngle: 0.1,\n\t *      padding: 0,\n\t *      startingAngle: 1\n\t *  }\n\t */\n\tpolar_label_show: true,\n\tpolar_label_format: <(() => number | string) | undefined>undefined,\n\tpolar_label_threshold: 0.05,\n\tpolar_label_ratio: <(() => number) | undefined>undefined,\n\tpolar_level_depth: 3,\n\tpolar_level_max: <number | undefined>undefined,\n\tpolar_level_show: true,\n\tpolar_level_text_backgroundColor: \"#fff\",\n\tpolar_level_text_format: (x: number) => (x % 1 === 0 ? x : x.toFixed(2)),\n\tpolar_level_text_show: true,\n\tpolar_padAngle: 0,\n\tpolar_padding: 0,\n\tpolar_startingAngle: 0\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * radar config options\n */\nexport default {\n\t/**\n\t * Set radar options\n\t * - **NOTE:**\n\t *  > When x tick text contains `\\n`, it's used as line break.\n\t * @name radar\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} radar Radar object\n\t * @property {number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.\n\t * @property {boolean} [radar.axis.line.show=true] Show or hide axis line.\n\t * @property {number} [radar.axis.text.position.x=0] x coordinate position, relative the original.\n\t * @property {number} [radar.axis.text.position.y=0] y coordinate position, relative the original.\n\t * @property {boolean} [radar.axis.text.show=true] Show or hide axis text.\n\t * @property {boolean} [radar.direction.clockwise=false] Set the direction to be drawn.\n\t * @property {number} [radar.level.depth=3] Set the level depth.\n\t * @property {boolean} [radar.level.show=true] Show or hide level.\n\t * @property {Function} [radar.level.text.format] Set format function for the level value.<br>- Default value: `(x) => x % 1 === 0 ? x : x.toFixed(2)`\n\t * @property {boolean} [radar.level.text.show=true] Show or hide level text.\n\t * @property {number} [radar.size.ratio=0.87] Set size ratio.\n\t * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)\n\t * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)\n\t * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)\n\t * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)\n\t * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)\n\t * @example\n\t *  radar: {\n\t *      axis: {\n\t *          max: 50,\n\t *          line: {\n\t *              show: false\n\t *          },\n\t *          text: {\n\t *              position: {\n\t *              \tx: 0,\n\t *              \ty: 0\n\t *              },\n\t *              show: false\n\t *          }\n\t *      },\n\t *      direction: {\n\t *          clockwise: true\n\t *      },\n\t *      level: {\n\t *          show: false,\n\t *          text: {\n\t *              format: function(x) {\n\t *                  return x + \"%\";\n\t *              },\n\t *              show: true\n\t *          }\n\t *      },\n\t *      size: {\n\t *          ratio: 0.7\n\t *      }\n\t *  }\n\t */\n\tradar_axis_max: <number | undefined>undefined,\n\tradar_axis_line_show: true,\n\tradar_axis_text_show: true,\n\tradar_axis_text_position: <{x?: number, y?: number}>{},\n\tradar_level_depth: 3,\n\tradar_level_show: true,\n\tradar_level_text_format: (x: number) => (x % 1 === 0 ? x : x.toFixed(2)),\n\tradar_level_text_show: true,\n\tradar_size_ratio: 0.87,\n\tradar_direction_clockwise: false\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\n/**\n * treemap config options\n */\nexport default {\n\t/**\n\t * Set treemap options\n\t * @name treemap\n\t * @memberof Options\n\t * @type {object}\n\t * @property {object} treemap Treemap object\n\t * @property {string} [treemap.tile=\"binary\"] Treemap tile type\n\t * - **Available tile type values:**\n\t * \t- binary ([d3.treemapBinary](https://github.com/d3/d3-hierarchy/blob/main/README.md#treemapBinary))\n\t * \t- dice ([d3.treemapDice](https://github.com/d3/d3-hierarchy/blob/main/README.md#treemapDice))\n\t * \t- slice ([d3.treemapSlice](https://github.com/d3/d3-hierarchy/blob/main/README.md#treemapSlice))\n\t * \t- sliceDice ([d3.treemapSliceDice](https://github.com/d3/d3-hierarchy/blob/main/README.md#treemapSliceDice))\n\t * \t- squrify ([d3.treemapSquarify](https://github.com/d3/d3-hierarchy/blob/main/README.md#treemapSquarify))\n\t * \t- resquarify ([d3.treemapResquarify](https://github.com/d3/d3-hierarchy/blob/main/README.md#treemapResquarify))\n\t * @property {Function} [treemap.label.format] Set formatter for the label text.\n\t * @property {number} [treemap.label.threshold=0.05] Set threshold ratio to show/hide labels text.\n\t * @property {number} [treemap.label.show=true] Show or hide label text.\n\t * @see [Demo: treemap](https://naver.github.io/billboard.js/demo/#Chart.TreemapChart)\n\t * @example\n\t *  treemap: {\n\t *      // \"binary\", \"dice\", \"slice\", \"sliceDice\", \"squrify\", \"resquarify\"\n\t *      tile: \"dice\",\n\t *\n\t *      label: {\n\t *          // show or hide label text\n\t *          show: false,\n\t *\n\t *          // set label text formatter\n\t *          format: function(value, ratio, id) {\n\t *              return d3.format(\"$\")(value);\n\t *\n\t *              // to multiline, return with '\\n' character\n\t *              // return value +\"%\\nLine1\\n2Line2\";\n\t *          },\n\t *\n\t *          // set ratio number\n\t *          ratio: 0.05\n\t *      }\n\t *  }\n\t */\n\ttreemap_tile: \"binary\",\n\ttreemap_label_format: <(() => number | string) | undefined>undefined,\n\ttreemap_label_threshold: 0.05,\n\ttreemap_label_show: true\n};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard.js project is licensed under the MIT license\n */\nimport Chart from \"../../Chart/Chart\";\nimport ChartInternal from \"../../ChartInternal/ChartInternal\";\nimport {extend} from \"../../module/util\";\nimport {TYPE} from \"../const\";\nimport Options from \"../Options/Options\";\n\n// Axis\nimport {api as axisAPI, internal as axisInternal, options as axisOptions} from \"./axis\";\n\n// Shape\nimport shapeArc from \"../../ChartInternal/shape/arc\";\nimport shapeArea from \"../../ChartInternal/shape/area\";\nimport shapeBar from \"../../ChartInternal/shape/bar\";\nimport shapeBubble from \"../../ChartInternal/shape/bubble\";\nimport shapeCandlestick from \"../../ChartInternal/shape/candlestick\";\nimport shapeFunnel from \"../../ChartInternal/shape/funnel\";\nimport shapeGauge from \"../../ChartInternal/shape/gauge\";\nimport shapeLine from \"../../ChartInternal/shape/line\";\nimport shapePoint from \"../../ChartInternal/shape/point\";\nimport shapePointCommon from \"../../ChartInternal/shape/point.common\";\nimport shapePolar from \"../../ChartInternal/shape/polar\";\nimport shapeRadar from \"../../ChartInternal/shape/radar\";\nimport shapeTreemap from \"../../ChartInternal/shape/treemap\";\n\n// Options\nimport optPoint from \"../Options/common/point\";\nimport optArea from \"../Options/shape/area\";\nimport optBar from \"../Options/shape/bar\";\nimport optBubble from \"../Options/shape/bubble\";\nimport optCandlestick from \"../Options/shape/candlestick\";\nimport optLine from \"../Options/shape/line\";\nimport optScatter from \"../Options/shape/scatter\";\nimport optSpline from \"../Options/shape/spline\";\n\n// Non-Axis based\nimport optArc from \"../Options/shape/arc\";\nimport optDonut from \"../Options/shape/donut\";\nimport optFunnel from \"../Options/shape/funnel\";\nimport optGauge from \"../Options/shape/gauge\";\nimport optPie from \"../Options/shape/pie\";\nimport optPolar from \"../Options/shape/polar\";\nimport optRadar from \"../Options/shape/radar\";\nimport optTreemap from \"../Options/shape/treemap\";\n\nexport {\n\tarea,\n\tareaLineRange,\n\tareaSpline,\n\tareaSplineRange,\n\tareaStep,\n\tareaStepRange,\n\tbar,\n\tbubble,\n\tcandlestick,\n\tdonut,\n\tfunnel,\n\tgauge,\n\tline,\n\tpie,\n\tpolar,\n\tradar,\n\tscatter,\n\tspline,\n\tstep,\n\ttreemap\n};\n\n/**\n * Extend Axis\n * @param {Array} module Module to be extended\n * @param {Array} option Option object to be extended\n * @private\n */\nfunction extendAxis(module, option?): void {\n\textend(ChartInternal.prototype, Object.values(axisInternal).concat(module));\n\textend(Chart.prototype, axisAPI);\n\tOptions.setOptions(Object.values(axisOptions).concat(option || []));\n}\n\n/**\n * Extend Line type modules\n * @param {object} module Module to be extended\n * @param {Array} option Option object to be extended\n * @private\n */\nfunction extendLine(module?, option?): void {\n\textendAxis([shapePointCommon, shapePoint, shapeLine].concat(module || []));\n\tOptions.setOptions([optPoint, optLine].concat(option || []));\n}\n\n/**\n * Extend Arc type modules\n * @param {Array} module Module to be extended\n * @param {Array} option Option object to be extended\n * @private\n */\nfunction extendArc(module?, option?): void {\n\textend(ChartInternal.prototype, [shapeArc, shapePointCommon].concat(module || []));\n\tOptions.setOptions([optPoint].concat(option || []));\n}\n\n// Area types\nlet area = (): string => (\n\textendLine(shapeArea, [optArea]), (area = () => TYPE.AREA)()\n);\nlet areaLineRange = (): string => (\n\textendLine(shapeArea, [optArea]), (areaLineRange = () => TYPE.AREA_LINE_RANGE)()\n);\nlet areaStepRange = (): string => (\n\textendLine(shapeArea, [optArea]), (areaStepRange = () => TYPE.AREA_STEP_RANGE)()\n);\nlet areaSpline = () => (\n\textendLine(shapeArea, [optArea, optSpline]), (areaSpline = () => TYPE.AREA_SPLINE)()\n);\nlet areaSplineRange = (): string => (\n\textendLine(shapeArea, [optArea, optSpline]), (areaSplineRange = () => TYPE.AREA_SPLINE_RANGE)()\n);\nlet areaStep = (): string => (\n\textendLine(shapeArea, [optArea]), (areaStep = () => TYPE.AREA_STEP)()\n);\n\n// Line types\nlet line = (): string => (extendLine(), (line = () => TYPE.LINE)());\nlet spline = (): string => (extendLine(undefined, [optSpline]), (spline = () => TYPE.SPLINE)());\nlet step = (): string => (extendLine(), (step = () => TYPE.STEP)());\n\n// Arc types\nlet donut = (): string => (\n\textendArc(undefined, [optArc, optDonut]), (donut = () => TYPE.DONUT)()\n);\nlet gauge = (): string => (\n\textendArc([shapeGauge], [optArc, optGauge]), (gauge = () => TYPE.GAUGE)()\n);\nlet pie = (): string => (\n\textendArc(undefined, [optArc, optPie]), (pie = () => TYPE.PIE)()\n);\nlet polar = (): string => (\n\textendArc([shapePolar], [optArc, optPolar]), (polar = () => TYPE.POLAR)()\n);\nlet radar = (): string => (\n\textendArc(\n\t\t[axisInternal.eventrect, shapePoint, shapeRadar],\n\t\t[optPoint, optRadar, {axis_x_categories: axisOptions.optAxis.axis_x_categories}]\n\t), (radar = () => TYPE.RADAR)()\n);\n\n// Axis based types\nlet bar = (): string => (\n\textendAxis([shapeBar, shapePointCommon], [optBar, optPoint]), (bar = () => TYPE.BAR)()\n);\nlet bubble = (): string => (\n\textendAxis(\n\t\t[shapePointCommon, shapePoint, shapeBubble],\n\t\t[optBubble, optPoint]\n\t), (bubble = () => TYPE.BUBBLE)()\n);\nlet candlestick = (): string => (\n\textendAxis(\n\t\t[shapeCandlestick, shapePointCommon],\n\t\t[optCandlestick, optPoint]\n\t), (candlestick = () => TYPE.CANDLESTICK)()\n);\nlet scatter = (): string => (\n\textendAxis(\n\t\t[shapePointCommon, shapePoint],\n\t\t[optPoint, optScatter]\n\t), (scatter = () => TYPE.SCATTER)()\n);\n\n// Non Axis based types\nlet funnel = (): string => (\n\textendArc([shapeFunnel], [optFunnel]), (funnel = () => TYPE.FUNNEL)()\n);\nlet treemap = (): string => (\n\textendAxis([shapeTreemap], [optTreemap]), (treemap = () => TYPE.TREEMAP)()\n);\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard project is licensed under the MIT license\n */\nimport Chart from \"./Chart/Chart\";\nimport {isObject, mergeObj} from \"./module/util\";\n\nlet defaults = Object.create(null);\n\n/**\n * @namespace bb\n * @version 3.17.0-preview\n */\nconst bb = {\n\t/**\n\t * Version information\n\t * @property {string} version version\n\t * @example\n\t *    bb.version;  // \"1.0.0\"\n\t * @memberof bb\n\t */\n\tversion: \"3.17.0-preview\",\n\n\t/**\n\t * Generate chart\n\t * - **NOTE:** Bear in mind for the possiblity of ***throwing an error***, during the generation when:\n\t *   - Unused option value is given.\n\t *     - ex) For `data.type=\"pie\"` option, setting 'axis' option can cause unexpected generation error.\n\t *   - Insufficient value is given for certain option used.\n\t *     - ex) `data: { x: \"x\", columns: [[\"x\"], [\"data1\", 30, 200, 100]] }`\n\t * @param {Options} config chart options\n\t * @memberof bb\n\t * @returns {Chart}\n\t * @see {@link Options} for different generation options\n\t * @see {@link Chart} for different methods API\n\t * @example\n\t *  <!-- chart holder -->\n\t * <div id=\"LineChart\"></div>\n\t * @example\n\t *  // Generate chart with options\n\t *  var chart = bb.generate({\n\t *      \"bindto\": \"#LineChart\"\n\t *      \"data\": {\n\t *          \"columns\": [\n\t *              [\"data1\", 30, 200, 100, 400, 150, 250],\n\t *              [\"data2\", 50, 20, 10, 40, 15, 25]\n\t *           ],\n\t *          \"type\": \"line\"\n\t *      }\n\t *  });\n\t *\n\t *  // call some API\n\t *  // ex) get the data of 'data1'\n\t *  chart.data(\"data1\");\n\t * @example\n\t * // Generate chart by importing ESM\n\t * // Import types to be used only, where this will make smaller bundle size.\n\t * import bb, {\n\t *   area,\n\t *   areaLineRange,\n\t *   areaSpline,\n\t *   areaSplineRange,\n\t *   areaStep,\n\t *   bar,\n\t *   bubble,\n\t *   donut,\n\t *   gauge,\n\t *   line,\n\t *   pie,\n\t *   polar,\n\t *   radar,\n\t *   scatter,\n\t *   spline,\n\t *   step\n\t * }\n\t *\n\t * bb.generate({\n\t *      \"bindto\": \"#LineChart\"\n\t *      \"data\": {\n\t *          \"columns\": [\n\t *              [\"data1\", 30, 200, 100, 400, 150, 250],\n\t *              [\"data2\", 50, 20, 10, 40, 15, 25]\n\t *           ]\n\t *      },\n\t *      type: line(),\n\t *\n\t *      // or\n\t *      types: {\n\t *        data1: bar(),\n\t *        data2: step()\n\t *      }\n\t * });\n\t */\n\tgenerate(config) {\n\t\tconst options = mergeObj(Object.create(null), defaults, config);\n\t\tconst inst = new Chart(options);\n\n\t\tinst.internal.charts = this.instance;\n\t\tthis.instance.push(inst);\n\n\t\treturn inst;\n\t},\n\n\t/**\n\t * Set or get global default options.\n\t * - **NOTE:**\n\t *   - The options values settings are valid within page context only.\n\t *   - If is called multiple times, will override the last value.\n\t * @param {Options} options chart options\n\t * @memberof bb\n\t * @returns {Options}\n\t * @see {@link Options}\n\t * @example\n\t * // Set same option value as for `.generate()`\n\t * bb.defaults({\n\t *   data: {\n\t *     type: \"bar\"\n\t *   }\n\t * });\n\t *\n\t * bb.defaults();  // {data:{type: \"bar\"}}\n\t *\n\t * // data.type defaults to 'bar'\n\t * var chart = bb.generate({ ... });\n\t */\n\tdefaults(options?) {\n\t\tif (isObject(options)) {\n\t\t\tdefaults = options;\n\t\t}\n\n\t\treturn defaults;\n\t},\n\n\t/**\n\t * An array containing instance created\n\t * @property {Array} instance instance array\n\t * @example\n\t *  // generate charts\n\t *  var chart1 = bb.generate(...);\n\t *  var chart2 = bb.generate(...);\n\t *\n\t *  bb.instance;  // [ chart1, chart2, ... ]\n\t * @memberof bb\n\t */\n\tinstance: [],\n\n\t/**\n\t * Namespace for plugins\n\t * @property {object} plugin plugin namespace\n\t * @example\n\t *  // Stanford diagram plugin\n\t *  bb.plugin.stanford;\n\t * @memberof bb\n\t */\n\tplugin: {}\n};\n\nexport {bb, bb as default};\n","/**\n * Copyright (c) 2017 ~ present NAVER Corp.\n * billboard project is licensed under the MIT license\n */\nimport * as interaction from \"./config/resolver/interaction\";\nimport * as shape from \"./config/resolver/shape\";\n\n// extends shape modules\nObject.keys(shape)\n\t.forEach(v => shape[v]());\n\n// extends interaction modules\nObject.keys(interaction)\n\t.forEach(v => interaction[v]());\n\nexport {bb, default} from \"./core\";\n"],"names":[],"sourceRoot":""}